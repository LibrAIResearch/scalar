{
  "title": "Determine-Then-Ensemble: Necessity of Top-k Union for Large Language Model Ensembling",
  "abstract": "Large language models (LLMs) exhibit varying strengths and weaknesses across\ndifferent tasks, prompting recent studies to explore the benefits of ensembling\nmodels to leverage their complementary advantages. However, existing LLM\nensembling methods often overlook model compatibility and struggle with\ninefficient alignment of probabilities across the entire vocabulary. In this\nstudy, we empirically investigate the factors influencing ensemble performance,\nidentifying model performance, vocabulary size, and response style as key\ndeterminants, revealing that compatibility among models is essential for\neffective ensembling. This analysis leads to the development of a simple yet\neffective model selection strategy that identifies compatible models.\nAdditionally, we introduce the \\textsc{Uni}on \\textsc{T}op-$k$\n\\textsc{E}nsembling (\\textsc{UniTE}), a novel approach that efficiently\ncombines models by focusing on the union of the top-k tokens from each model,\nthereby avoiding the need for full vocabulary alignment and reducing\ncomputational overhead. Extensive evaluations across multiple benchmarks\ndemonstrate that \\textsc{UniTE} significantly enhances performance compared to\nexisting methods, offering a more efficient framework for LLM ensembling.",
  "paper_id": "http://arxiv.org/abs/2410.03777v1",
  "markdown_content": "# Determine-Then-Ensemble: Necessity of Top-k Union for Large Language Model Ensembling\n\nYuxuan Yao1, Han Wu2‚Ä†, Mingyang Liu1, Sichun Luo1, Xiongwei Han2, Jie Liu3\n\nZhijiang Guo2, Linqi Song1‚Ä†\n\n1Department of Computer Science, City University of Hong Kong\n\n2Huawei Noah‚Äôs Ark Lab\n\n3North China University of Technology\n\nyuxuanyao3-c@my.cityu.edu.hk\n\nwu.han1@huawei.com\n\nlinqi.song@cityu.edu.hk\n\n###### Abstract\n\nLarge language models (LLMs) exhibit varying strengths and weaknesses across different tasks, prompting recent studies to explore the benefits of ensembling models to leverage their complementary advantages. However, existing LLM ensembling methods often overlook model compatibility and struggle with inefficient alignment of probabilities across the entire vocabulary. In this study, we empirically investigate the factors influencing ensemble performance, identifying model performance, vocabulary size, and response style as key determinants, revealing that compatibility among models is essential for effective ensembling. This analysis leads to the development of a simple yet effective model selection strategy that identifies compatible models. Additionally, we introduce the Union Top-kùëòkEnsembling (UniTE), a novel approach that efficiently combines models by focusing on the union of the top-k tokens from each model, thereby avoiding the need for full vocabulary alignment and reducing computational overhead. Extensive evaluations across multiple benchmarks demonstrate that UniTE significantly enhances performance compared to existing methods, offering a more efficient framework for LLM ensembling.\n\n## 1 Introduction\n\n‚Ä†‚Ä†footnotetext: ‚Ä†‚Ä†\\\\dagger Corresponding authors.\n\nLarge language models (LLMs) have demonstrated remarkable performance across a wide range of tasks and have shown promising results in real-world applications (OpenAI, [2023](https://ar5iv.org/html/2410.03777#bib.bib21 \"\"); Yang et al., [2024](https://ar5iv.org/html/2410.03777#bib.bib29 \"\"); Dubey et al., [2024](https://ar5iv.org/html/2410.03777#bib.bib8 \"\")). Given the diversity in data sources, model architectures, and training methods, LLMs exhibit varying strengths and weaknesses depending on the task at hand. Consequently, rather than relying solely on training an LLM from scratch, an alternative approach is to create an ensemble of LLMs. This method allows for leveraging the complementary advantages of different LLMs (Jiang et al., [2023b](https://ar5iv.org/html/2410.03777#bib.bib14 \"\"); Lu et al., [2024](https://ar5iv.org/html/2410.03777#bib.bib20 \"\"); Yu et al., [2024b](https://ar5iv.org/html/2410.03777#bib.bib32 \"\")).\n\nExisting model ensembling methods can be broadly categorized into three types: output-level, probability-level, and training-level approaches. Output-level methods (Jiang et al., [2023b](https://ar5iv.org/html/2410.03777#bib.bib14 \"\"); Lu et al., [2024](https://ar5iv.org/html/2410.03777#bib.bib20 \"\"); Shnitzer et al., [2023](https://ar5iv.org/html/2410.03777#bib.bib22 \"\")) aggregate the complete outputs of multiple candidate models. Probability-level methods (Huang et al., [2024](https://ar5iv.org/html/2410.03777#bib.bib11 \"\"); Yu et al., [2024b](https://ar5iv.org/html/2410.03777#bib.bib32 \"\")), integrate outputs based on probability distributions at each generation step through the intersection or union of the vocabulary. Training-level methods (Wan et al., [2024a](https://ar5iv.org/html/2410.03777#bib.bib24 \"\"); Xu et al., [2024](https://ar5iv.org/html/2410.03777#bib.bib28 \"\")) utilize output probability vectors as labels for richer information extraction during training. While output-level methods are constrained by the limitations of existing outputs, and training-level methods introduce additional computational overhead, probability-level methods have garnered particular attention.\n\nExisting methods for ensembling LLMs, such as DeePen(Huang et al., [2024](https://ar5iv.org/html/2410.03777#bib.bib11 \"\")) and GaC(Yu et al., [2024b](https://ar5iv.org/html/2410.03777#bib.bib32 \"\")), grapple with two significant challenges. First, these approaches concentrate solely on the ensembling technique, sidestepping the crucial discussion of which types of models can be effectively combined. This oversight is critical because LLMs with substantial differences in architecture, size, and tokenizer may be inherently incompatible, leading to potential incompatibilities that undermine the benefits of ensembling(Dong et al., [2023](https://ar5iv.org/html/2410.03777#bib.bib7 \"\"); Lee et al., [2023](https://ar5iv.org/html/2410.03777#bib.bib17 \"\")). Second, these methods tend to align the probabilities across the entire vocabulary at each generation step. Such a strategy introduces substantial computational overhead during inference, which hinders performance and efficiency.\n\nTo address these challenges, we conduct a thorough investigation into the factors that truly influence ensembling performance. Our empirical analysis identifies three key factors: model performance, vocabulary size, and response process. We evaluate multiple widely recognized LLMs across various benchmarks to explore ensembling from these perspectives. Our findings reveal several important insights: 1) Variations in performance levels among base LLMs significantly affect their compatibility for ensembling; 2) The impact of vocabulary size is marginal; and 3) Even when performance and vocabulary size are aligned across LLMs, substantial differences in the reasoning process in the response can hinder successful ensembling.\n\nBuilding on this analysis, we adopt a determine-then-ensemble strategy by starting with the best-performing LLM for target tasks, then iteratively selecting the next best-performing LLMs that meets ensembling criteria until the maximum number of models is reached or no further suitable candidates exist. Additionally, we seek to improve the efficiency and performance of ensembling. Instead of aligning the entire vocabulary of different LLMs, we propose the Union Top-kùëòkEnsembling (UniTE). UniTE constructs a union of the top-k tokens from each model and expands this set using each model‚Äôs tokenizer. This is followed by probability aggregation to determine the next token. UniTE avoids the need for auxiliary mapping matrices and full vocabulary alignment, respecting the unique tokenization of each base LLM. Extensive experiments demonstrate the effectiveness of UniTE across various tasks, consistently outperforming state-of-the-art LLM ensemble methods.\n\nOverall, our key contributions are: 1) We conduct an extensive analysis of existing model ensembling approaches and derive three significant insights. Building on these findings, we introduce a general model selection strategy for model ensembling;\n2) We propose a well-motivated model ensembling method that efficiently operates on the top-k candidate tokens rather than the entire vocabulary.\n3) Experiments demonstrate significant performance improvements, reduced operational tokens to less than 0.04% of current methods, and minimized latency to only 10 ms longer than the individual model, validating the effectiveness of our proposed approach.\n\n## 2 Related Works\n\nBased on the sequence of inference and fusion processes, multiple model collaboration methods can be broadly classified into two categories: model ensembling (Jiang et al., [2023b](https://ar5iv.org/html/2410.03777#bib.bib14 \"\"); Yu et al., [2024b](https://ar5iv.org/html/2410.03777#bib.bib32 \"\")) and model merging (Yu et al., [2024a](https://ar5iv.org/html/2410.03777#bib.bib31 \"\"); Akiba et al., [2024](https://ar5iv.org/html/2410.03777#bib.bib1 \"\")). Model ensembling follows an inference-then-fusion approach, aiming to integrate the outputs of various models to achieve a more refined response. Conversely, model merging adopts a fusion-then-inference strategy, wherein different models are combined into a single model before inference. While model merging is typically applicable only to homologous models, our focus in this study is on the more general approach, namely model ensembling. We discuss different model ensembling methods as follows:\n\nOutput-Level Model Ensembling methods involve selecting multiple candidate models and utilizing their complete outputs for aggregation. For instance, Jiang et al. ( [2023b](https://ar5iv.org/html/2410.03777#bib.bib14 \"\")) developed PairRanker, an additional ranking model, to evaluate and select the best candidate output. Similarly, Lu et al. ( [2024](https://ar5iv.org/html/2410.03777#bib.bib20 \"\")) and Shnitzer et al. ( [2023](https://ar5iv.org/html/2410.03777#bib.bib22 \"\")) designed a router that determines the most appropriate candidate model based on the given question. However, these approaches are restricted by the existing outputs and become ineffective if all options are incorrect. Some studies have addressed this by training fusion models to combine outputs (Jiang et al., [2023b](https://ar5iv.org/html/2410.03777#bib.bib14 \"\"); Wang et al., [2024b](https://ar5iv.org/html/2410.03777#bib.bib27 \"\")), which alleviates the limitation of relying solely on available candidates and often yields improved results. Nevertheless, achieving generalization with fusion models remains a significant challenge, as they may not fully utilize the probability information generated at each step.\n\nProbability-Level Model Ensembling methods focus on integrating outputs from different models by utilizing the probability distribution at each generation step. Cool-Fusion(Liu et al., [2024](https://ar5iv.org/html/2410.03777#bib.bib19 \"\")) let each source LLM generate tokens until reaching common word boundaries, then jointly reranks the segments.\nHowever, this method relies on common word boundaries, limiting generation flexibility and diversity. Additionally, managing multiple source models can increase complexity. DeePen(Huang et al., [2024](https://ar5iv.org/html/2410.03777#bib.bib11 \"\")), based on the principles of relative representation theory, transforms each model‚Äôs probability distribution from its individual space into a common relative space for aggregation, which is determined through the intersection of the models‚Äô vocabularies. On the other hand, GaC(Yu et al., [2024b](https://ar5iv.org/html/2410.03777#bib.bib32 \"\")) constructs a mapping matrix that projects the probability vectors of multiple LLMs into the dimensional space of their union vocabulary, aggregating outputs to select the next token at each generation step. It is worth noting that all of these existing approaches operate on the entire vocabulary at every single step, resulting in significant computational overhead. In this work, we focus on the probability-level model ensembling without the need for additional training.\n\nTraining-Level Model Ensembling methods exemplified by FuseLLM(Wan et al., [2024a](https://ar5iv.org/html/2410.03777#bib.bib24 \"\")), leverage output probability vectors from various models during the training process, using these vectors as labels instead of one-hot representations. This technique serves as a unique form of distillation, enabling the trained model to extract richer information from the probability outputs of the ensemble of teacher models. FuseCHAT(Wan et al., [2024b](https://ar5iv.org/html/2410.03777#bib.bib25 \"\")) extends the framework of FuseLLM to fuse multiple chat LLMs with diverse architectures and scales. However, distillation is predominantly aimed at enhancing smaller models, which limits its effectiveness in further advancing larger models. On the other hand, EVA(Xu et al., [2024](https://ar5iv.org/html/2410.03777#bib.bib28 \"\")) addresses vocabulary discrepancies by learning token alignment across different vocabularies, utilizing overlapping tokens for assistance. However, vocabulary alignment should involve both output embedding alignment and weight alignment, EVA achieves vocabulary alignment solely by solving the mapping matrix of output embeddings.\n\n![Refer to caption](https://ar5iv.org/html/2410.03777/assets/Figs/performance_datasets.png)Figure 1: The impact of performance disparity among models on ensemble effectiveness across different datasets and methods is examined. We compare these methods to the individual performances of LLaMA2 and Mistral, indicated by dashed lines.\n\n## 3 Understanding Model Ensembling from Model Capacity, Vocabulary Size and Task\n\nExisting model ensembling approaches (Huang et al., [2024](https://ar5iv.org/html/2410.03777#bib.bib11 \"\"); Yu et al., [2024b](https://ar5iv.org/html/2410.03777#bib.bib32 \"\")) only focus on designing the model ensembling method, offering limited discussion on the selection of base models for ensembling.\nHowever, insights from prior research (Dong et al., [2023](https://ar5iv.org/html/2410.03777#bib.bib7 \"\"); Lee et al., [2023](https://ar5iv.org/html/2410.03777#bib.bib17 \"\")), indicate that not all model pairs are compatible to be combined, particularly when there are significant differences in size, vocabulary, and performance.\nIn our preliminary experiments, we explored various factors that might affect the performance of model ensembling, including model size (e.g., 3B/7B/8B/13B/70B), model architecture (dense/sparse), performance discrepancies, tokenization strategies (BPE/WordPiece), vocabulary size (e.g., 102K/64K/32K) and tasks variations (e.g., text generation/QA/multiple choices).\nFinally, we identified three representative factors for further analyses, including performance discrepancy, vocabulary size, and tasks variations.\n\n### 3.1 Impact of Model Performance Discrepancy\n\nTo investigate the impact of performance disparity on model ensembling, we select LLaMA2-13B-Chat and Mistral-7B-Instruct-v0.3 as base models, which show a significant performance gap across various tasks. We evaluated the GSM8K (Cobbe et al., [2021](https://ar5iv.org/html/2410.03777#bib.bib6 \"\")), PIQA (Bisk et al., [2020](https://ar5iv.org/html/2410.03777#bib.bib4 \"\")), ARC-C (Clark et al., [2018](https://ar5iv.org/html/2410.03777#bib.bib5 \"\")), and NQ (Kwiatkowski et al., [2019](https://ar5iv.org/html/2410.03777#bib.bib16 \"\")) datasets with three comparative methods.\n\nAs shown in Fig. [1](https://ar5iv.org/html/2410.03777#S2.F1 \"Figure 1 ‚Ä£ 2 Related Works ‚Ä£ Determine-Then-Ensemble: Necessity of Top-k Union for Large Language Model Ensembling\"), we found that when there is a significant performance disparity between models, LLM-Blender, which selects the optimal response from model candidates, is not suitable for model ensembling.\nSimilarly, for methods like DeePen and GaC, which are achieved through token probability averaging, a substantial performance gap also leads to certain performance drops. This observation is straightforward and easily understood, as lower-performing models may introduce noise and bias, adversely affecting overall effectiveness.\nNonetheless, it has been observed that DeePen and GaC consistently enhance the performance of less effective models when combined with a superior model. Although the resultant performance does not surpass that of the superior model, these methods can also serve as an alternative way for training-free knowledge distillation.\n\nTo further figure out how performance discrepancy impacts the ensembling, we then identify model pairs based on the GSM8K dataset with performance gaps of approximately 40% (LLaMA2-7B-Chat and Mistral-7B-Instruct-v0.3), 25% (LLaMA2-13b-Chat and Mistral-7B-Instruct-v0.3), 15% (OpenChat-3.5 and Mistral-7B-Instruct-v0.3), and less than 10% (LLaMA3-8B-Instruct and Qwen2-7B-Instruct).\nFig. [2](https://ar5iv.org/html/2410.03777#S3.F2 \"Figure 2 ‚Ä£ 3.1 Impact of Model Performance Discrepancy ‚Ä£ 3 Understanding Model Ensembling from Model Capacity, Vocabulary Size and Task ‚Ä£ Determine-Then-Ensemble: Necessity of Top-k Union for Large Language Model Ensembling\") shows that as the performance gap increases, the improvement from ensembling inferior models becomes more pronounced. In contrast, for superior models, the ensembling effect consistently falls below the baseline performance. When the performance difference is within 10%, ensembling may yield better results.\n\n![Refer to caption](https://ar5iv.org/html/2410.03777/assets/Figs/performance_disparity.png)Figure 2: The impact of performance differences on model ensembling effectiveness on GSM8K dataset. OOM represents out of memory issue.\n\nMoreover, it was observed that with the increase in vocabulary size, as exemplified by models such as LLaMA3 and Qwen2, whose vocabulary size exceeds 120K, approaches like DeePen, which depend on high-dimensional matrix operations, encounter heavy memory limitations that diminish their effectiveness.\n\nTakeaway I: Smaller performance gaps lead to greater gains from model ensembling.\n\n| Methods | Dataset |\n| GSM | PIQA |\n| DeepSeek-7B(102K) | 59.67 | 72.66 |\n| Mistral-7B(32K) | 56.48 | 80.63 |\n| LLM-Blender | 61.16 | 76.54 |\n| (+1.49) | (-4.09) |\n| DeePen(DeepSeek-7B) | 55.00 | 77.65 |\n| (-4.67) | (+4.99) |\n| DeePen(Mistral-7B) | 61.28 | 76.32 |\n| (+4.80) | (-4.31) |\n| \\\\cdashline1-3<br>Ours(DeepSeek-7B) | 62.77 | 81.81 |\n| (+3.10) | (+9.15) |\n| Ours(Mistral-7B) | 58.88 | 81.81 |\n| (+2.40) | (+1.18) |\n\n| Methods | Dataset |\n| MMLU | ARC-C |\n| DeepSeek-7B(102K) | 46.97 | 58.73 |\n| LLaMA2-13B(32K) | 49.61 | 51.53 |\n| LLM-Blender | 48.86 | 57.84 |\n| (-0.75) | (-0.89) |\n| DeePen(DeepSeek-7B) | 52.81 | 60.00 |\n| (+5.84) | (+1.27) |\n| DeePen(LLaMA2-13B) | 54.09 | 62.39 |\n| (+4.48) | (+10.86) |\n| \\\\cdashline1-3<br>Ours(DeepSeek-7B) | 48.90 | 60.16 |\n| (+1.93) | (+1.43) |\n| Ours(Mistral-7B) | 48.90 | 60.16 |\n| (-0.71) | (+8.63) |\n\n| Methods | Dataset |\n| NQ | ARC-C |\n| Mistral-7B(32K) | 24.25 | 74.49 |\n| Yi-6B(64K) | 22.55 | 73.21 |\n| LLM-Blender | 22.97 | 72.48 |\n| (-1.28) | (-2.01) |\n| DeePen(Mistral-7B) | 25.26 | 76.50 |\n| (+1.01) | (+1.01) |\n| DeePen(Yi-6B) | 22.80 | 77.86 |\n| (+0.25) | (+4.65) |\n| \\\\cdashline1-3<br>Ours(Mistral-7B) | 24.76 | 76.54 |\n| (+0.51) | (+2.05) |\n| Ours(Yi-6B) | 23.28 | 76.54 |\n| (+0.73) | (+3.33) |\n\nTable 1: The influence of vocabulary size on model ensembling effectiveness\n\n### 3.2 Influence of Vocabulary Size\n\nYu et al. ( [2024b](https://ar5iv.org/html/2410.03777#bib.bib32 \"\")) found that large models employing different tokenization methods, such as BPE and BBPE, exhibit over 90% overlap in tokenizing Oxford 5000 common words. This indicates that tokenization methods have a marginal impact on model ensembling, leading us to focus on the effect of vocabulary size on ensemble performance.\nTo this end, we selected four models with varying vocabulary sizes that exhibit similar performance on certain datasets, namely LLaMA2-13B-Chat (vocabulary size: 32,000), Mistral-7B-Instruct-v0.3 (vocabulary size: 32,768), Yi-6B (vocabulary size: 64,000), and DeepSeek-LLM-7B-Chat (vocabulary size: 102,400).\n\n![Refer to caption](https://ar5iv.org/html/2410.03777/assets/Figs/token_distribution.png)Figure 3: Token distribution of different models. We extract the top 15 words from the vocabulary of each model and apply a softmax processing to their corresponding logits.\n\nAs presented in Table [1](https://ar5iv.org/html/2410.03777#S3.T1 \"Table 1 ‚Ä£ 3.1 Impact of Model Performance Discrepancy ‚Ä£ 3 Understanding Model Ensembling from Model Capacity, Vocabulary Size and Task ‚Ä£ Determine-Then-Ensemble: Necessity of Top-k Union for Large Language Model Ensembling\"), existing methods demonstrate consistent performance irrespective of the gap in vocabulary size, thereby indicating that vocabulary size does not significantly influence the efficacy of model ensembling.\nTo elucidate the underlying causes, we conducted a manual analysis of 100 responses generated by various LLMs. Our investigation revealed that approximately 80% of the words in the responses were common words while the tokenization of these common words exhibited no discernible differences across the different LLMs. Therefore, the vocabulary size, as well as the tokenization strategy, exerts minimal influence on the performance of model ensembling.\nNotably, despite significant variations in vocabulary size, the ensembling results of models with similar performance suggest that when the performance gap between base models is within 10%, model ensembling may achieve better results than the baseline model, which is aligned with findings in Section [3.1](https://ar5iv.org/html/2410.03777#S3.SS1 \"3.1 Impact of Model Performance Discrepancy ‚Ä£ 3 Understanding Model Ensembling from Model Capacity, Vocabulary Size and Task ‚Ä£ Determine-Then-Ensemble: Necessity of Top-k Union for Large Language Model Ensembling\").\nMore interestingly, results of evaluating DeepPen on the ARC-C dataset indicate that when model performances are comparable, ensembling inferior models can even outperform superior ones. This might imply that when performance differences are minimal, the selection of main base models does not necessarily need to prioritize those with superior performance.\nBesides, it is important to note that these findings related to the vocabulary and tokenization consistently apply to LLM-Blender, DeePen and our method, with the exception of GAC.\nWe will detail the reason in Section [4.2](https://ar5iv.org/html/2410.03777#S4.SS2 \"4.2 Union top-ùëò ensembling ‚Ä£ 4 Methodology ‚Ä£ Determine-Then-Ensemble: Necessity of Top-k Union for Large Language Model Ensembling\").\n\nTakeaway II: The influence of vocabulary size for model ensembling is marginal.\n\n| Question | who wrote he ain‚Äôt heavy he‚Äôs my brother lyrics |\n| who was the ruler of england in 1616 |\n| Gold answer | Bob Russell |\n| James I |\n| LLaMA3 response | Bob Russell \\\\usym2713 |\n| James I \\\\usym2713 |\n| Qwen2 response | |     |\n| --- |\n| He Ain‚Äôt Heavy, He‚Äôs My Brother was written by Mike D‚ÄôAbo. \\\\usym2717 |\n| The song was originally recorded by the British singer-songwriter and released as a single in 1969. |\n| It became a hit and has since been covered by numerous artists. |\n| ‚ãØ‚ãØ\\\\cdots | |\n| \\\\cdashline2-2 | |     |\n| --- |\n| The ruler of England in 1616 was King James I. \\\\usym2713 |\n| He was the first monarch of the Stuart dynasty and reigned from March 24, 1603, until his death on July 19, 1625. |\n| ‚ãØ‚ãØ\\\\cdots | |\n| LLM-Blender response | |     |\n| --- |\n| He Ain‚Äôt Heavy, He‚Äôs My Brother was written by Mike D‚ÄôAbo. \\\\usym2717 |\n| The song was originally recorded by the British singer-songwriter and released as a single in 1969. |\n| It became a hit and has since been covered by numerous artists. |\n| ‚ãØ‚ãØ\\\\cdots | |\n| \\\\cdashline2-2 | |     |\n| --- |\n| The ruler of England in 1616 was King James I. \\\\usym2713 |\n| He was the first monarch of the Stuart dynasty and reigned from March 24, 1603, until his death on July 19, 1625. |\n| ‚ãØ‚ãØ\\\\cdots | |\n\nTable 2: Responses of different methods on NQ dataset.\n\n### 3.3 Task-Specific Challenges in Model Ensembling\n\nIn the aforementioned experiments, we identified an interesting phenomenon:\nEven when performance and vocabulary size are aligned across models, substantial differences in the response style can also hinder successful ensembling on specific tasks.\nFor example, LLaMA3-8B and Qwen2-7B exhibit comparable performance across various tasks. Existing ensembling approaches such as LLM-Blender have been shown to enhance outcomes on GSM8K and PIQA tasks when utilizing these two base models. However, ensembling these models to address the questions in TriviaQA and NQ datasets proves to be impractical due to the significant discrepancies in their response styles.\n\nAs shown in Table [2](https://ar5iv.org/html/2410.03777#S3.T2 \"Table 2 ‚Ä£ 3.2 Influence of Vocabulary Size ‚Ä£ 3 Understanding Model Ensembling from Model Capacity, Vocabulary Size and Task ‚Ä£ Determine-Then-Ensemble: Necessity of Top-k Union for Large Language Model Ensembling\"), under identical prompting conditions, LLaMA3 tends to directly return the answers, whereas Qwen2 is inclined to conduct analysis. In voting-based LLM-Blender, response length significantly influences judgments, with PairRanker consistently favoring longer responses. For instance, in our analysis of 100 randomly selected NQ and TriviaQA responses, the PairRanker favored the longer response as the answer in approximately 80% and 70% of cases accordingly, possibly due to its training data characteristics. More detailed analysis of TriviaQA and more experimental results are in appendix [A](https://ar5iv.org/html/2410.03777#A1 \"Appendix A Appendix ‚Ä£ Determine-Then-Ensemble: Necessity of Top-k Union for Large Language Model Ensembling\"). Similarly, probability-based ensembling methods like DeePen and GaC are also affected by the differences in the reasoning process, leading to significant deviations in vocabulary probability distributions. Figure [3](https://ar5iv.org/html/2410.03777#S3.F3 \"Figure 3 ‚Ä£ 3.2 Influence of Vocabulary Size ‚Ä£ 3 Understanding Model Ensembling from Model Capacity, Vocabulary Size and Task ‚Ä£ Determine-Then-Ensemble: Necessity of Top-k Union for Large Language Model Ensembling\") reveals a significant disparity in top token distributions between LLaMA3 and Qwen2 for the first two tokens. Averaging the probabilities directly could result in an excessively smoothed distribution, which is inappropriate.\nThe underlying reason for this phenomenon may be the differences in LLMs‚Äô training data. Therefore, caution is warranted in specific tasks to avoid substantial disparities, despite effective ensembling in most other tasks.\n\nTakeaway III: Even though the performance and vocabulary size are aligned across models, substantial differences in response style could also hinder successful ensembling.\n\n## 4 Methodology\n\n### 4.1 Model selection strategy\n\nGiven the aforementioned insights, we present a strategy to assess the compatibility of two models for ensembling and offer guidance for selecting base models from the candidate model pool.\n\nWhen ensembling two models, we begin by comparing their performance on the target tasks. An overall performance gap within 10% is desirable, as it indicates the potential compatibility for successful ensembling.\nIf the performance gap falls within this range, it is crucial to compare the response styles of different models. This comparison is relatively subjective, with differences often identifiable through superficial features such as text length and BLEU score.\n\nIn this work, we use text length as a guiding metric by constraining the length of longer responses to not exceed twice the length of the shorter ones. When the response manner is also consistent across models, it is highly probable that these two models can be successfully ensembled to produce a superior response.\nWe exclude discrepancies in vocabulary size from consideration, as prior analyses have demonstrated its insignificance in affecting ensembling outcomes.\n\nTo select base models from the pool, we recommend initially choosing the best-performing model for the target tasks. Subsequently, select the next best-performing model that satisfies the criteria for successful ensembling with the first chosen model, continuing this process iteratively until the maximum number of base models is reached or no further suitable models can be found.\n\n### 4.2 Union top-kùëòk ensembling\n\nApart from the model selection strategy, we also endeavor to improve the efficiency and performance of model ensembling. Existing probability-level model ensembling methods, e.g. DeePen and GaC, attempt to combine the models through full vocabulary alignment. We argue this approach is sub-optimal since the candidate next token typically resides within the top-k tokens. Conversely, incorporating tokens of lower probability may introduce unnecessary noise, thereby diminishing the overall accuracy and effectiveness of the ensemble. Motivated by this, we propose the Union Top-k Ensembling (UniTE), a novel and efficient ensembling approach that only aligns the top-k tokens in each decoding step.\n\nGiven the base models for ensembling, denoted as LLMi with their respective tokenizer TisuperscriptùëáùëñT^{i} and vocabulary VisuperscriptùëâùëñV^{i}, we feed the input text prompt into LLMi and obtain the probability distribution.\nInstead of aligning the probability distributions across different models, we only focus on the subset of top-kùëòk tokens since the candidate next token is highly likely to be within the subset. The selected top-kùëòk tokens of LLMi is presented as TopKi = (t1isubscriptsuperscriptùë°ùëñ1t^{i}\\_{1}, t2isubscriptsuperscriptùë°ùëñ2t^{i}\\_{2}, ‚Ä¶, tkisubscriptsuperscriptùë°ùëñùëòt^{i}\\_{k}) with corresponding probability distribution PisuperscriptùëÉùëñP^{i} = (p1isubscriptsuperscriptùëùùëñ1p^{i}\\_{1}, p2isubscriptsuperscriptùëùùëñ2p^{i}\\_{2}, ‚Ä¶, pkisubscriptsuperscriptùëùùëñùëòp^{i}\\_{k}).\n\nAlgorithm 1 Union top-kùëòk ensembling\n\n1:LLMi, Vocabulary Vi, Tokenizer Ti, Demonstration p‚Äãr‚Äão‚Äãm‚Äãp‚Äãtùëùùëüùëúùëöùëùùë°prompt, Stop condition s‚Äãt‚Äão‚Äãp‚Äã(\\*)ùë†ùë°ùëúùëù\\*stop(\\\\text{\\*})\n\n2:while not s‚Äãt‚Äão‚Äãp‚Äã(\\*)ùë†ùë°ùëúùëù\\*stop(\\\\text{\\*})do‚ñ∑‚ñ∑\\\\triangleright Stopping criteria\n\n3:     TopKi, PisuperscriptùëÉùëñP^{i}‚Üê‚Üê\\\\leftarrow LLMi(prompt)\n‚ñ∑‚ñ∑\\\\triangleright Generate top-kùëòk tokens and their probabilities\n\n4:for each model do\n\n5:if token wùë§w‚àà\\\\inVusuperscriptùëâùë¢V^{u} and wùë§w‚àà\\\\in TopKithen\n\n6:P{w}isubscriptsuperscriptùëÉùëñùë§P^{i}\\_{\\\\{w\\\\}} and TopKi remains unchanged.\n\n7:elseif token wùë§w‚àà\\\\inVusuperscriptùëâùë¢V^{u} and wùë§w‚àà\\\\inVisuperscriptùëâùëñV^{i} and wùë§w‚àâ\\\\notin TopKithen\n\n8:TopK^^ùêæ\\\\hat{K}i‚Üê‚Üê\\\\leftarrowwùë§w, P^isuperscript^ùëÉùëñ\\\\hat{P}^{i}‚Üê‚Üê\\\\leftarrowpwisubscriptsuperscriptùëùùëñùë§p^{i}\\_{w}\n\n9:elseif token wùë§w‚àà\\\\inVusuperscriptùëâùë¢V^{u} and wùë§w‚àâ\\\\notinVisuperscriptùëâùëñV^{i}then\n\n10:w1,‚Ä¶,wmsuperscriptùë§1‚Ä¶superscriptùë§ùëöw^{1},\\\\ldots,w^{m}‚Üê‚Üê\\\\leftarrowTi‚Äã(w)superscriptùëáùëñùë§T^{i}(w)\n\n11:TopK^^ùêæ\\\\hat{K}i‚Üê‚Üê\\\\leftarroww1superscriptùë§1w^{1}, P^isuperscript^ùëÉùëñ\\\\hat{P}^{i}‚Üê‚Üê\\\\leftarrowpw1isubscriptsuperscriptùëùùëñsuperscriptùë§1p^{i}\\_{w^{1}}\n\n12:endif\n\n13:endfor\n\n14:P^n‚Äão‚Äãr‚Äãmi=softmax‚Å°(P^i)subscriptsuperscript^ùëÉùëñùëõùëúùëüùëösoftmaxsuperscript^ùëÉùëñ\\\\hat{P}^{i}\\_{norm}=\\\\operatorname{softmax}(\\\\hat{P}^{i}), P^a‚Äãv‚Äãg=1n‚Äã‚àëi=1nP^n‚Äão‚Äãr‚Äãmisubscript^ùëÉùëéùë£ùëî1ùëõsuperscriptsubscriptùëñ1ùëõsubscriptsuperscript^ùëÉùëñùëõùëúùëüùëö\\\\hat{P}\\_{avg}=\\\\frac{1}{n}\\\\sum\\_{i=1}^{n}\\\\hat{P}^{i}\\_{norm}\n\n15:w=argmaxw‚ààT‚Äão‚Äãp‚ÄãK^i‚Äã(P^a‚Äãv‚Äãg)ùë§ùë§ùëáùëúùëùsubscript^ùêæùëñargmaxsubscript^ùëÉùëéùë£ùëîw=\\\\underset{w\\\\in Top{\\\\hat{K}}\\_{i}}{\\\\operatorname{argmax}}(\\\\hat{P}\\_{avg})‚ñ∑‚ñ∑\\\\triangleright Predict the next token\n\n16:prompt‚Üê‚Üê\\\\leftarrowprompt ++wùë§w‚ñ∑‚ñ∑\\\\triangleright Update input sequence\n\n17:endwhile\n\nNext, we aim to construct the union set Vusuperscriptùëâùë¢V^{u} of TopKi across the base models. The most straightforward solution to obtain the union set is to directly remove the duplicate tokens and retain all other distinct tokens. For the token in Vusuperscriptùëâùë¢V^{u} but not in VisuperscriptùëâùëñV^{i}, the probability of this token in LLMi is assigned to 0. This strategy is adopted by GAC(Yu et al., [2024b](https://ar5iv.org/html/2410.03777#bib.bib32 \"\")). However, we contend that this strategy is not entirely reasonable since it is heavily influenced by the tokenizer and vocabulary.\nFor example, the candidate token ‚ÄúJames‚Äù is within the top-kùëòk subset of LLM1 but not in V2superscriptùëâ2V^{2} while the token ‚ÄúJam‚Äù appears in TopK2. The word ‚ÄúJames‚Äù can be tokenized into ‚ÄúJam‚Äù and ‚Äúes‚Äù by LLM2. If the token probabilities p{J‚Äãa‚Äãm}1subscriptsuperscriptùëù1ùêΩùëéùëöp^{1}\\_{\\\\{Jam\\\\}} and p{J‚Äãa‚Äãm‚Äãe‚Äãs}2subscriptsuperscriptùëù2ùêΩùëéùëöùëíùë†p^{2}\\_{\\\\{James\\\\}} are set to 0, the overall probability of generating the word ‚ÄúJames‚Äù should be inherently reduced, even if both base models exhibit a preference for this word. Therefore, we present a new token probability alignment strategy on the union set. Firstly, we obtain the top-kùëòk union vocabulary Vusuperscriptùëâùë¢V^{u} by directly merging the TopKi subsets. Then, the token distribution PisuperscriptùëÉùëñP^{i} and TopKi are updated according to following criteria:\n\n1. 1.\n\n\nIf the token wùë§w appears in both Vusuperscriptùëâùë¢V^{u} and TopKi, P{w}isubscriptsuperscriptùëÉùëñùë§P^{i}\\_{\\\\{w\\\\}} and TopKi remains unchanged.\n\n2. 2.\n\n\nIf the token wùë§w in Vusuperscriptùëâùë¢V^{u} is absent in TopKi but present in VisuperscriptùëâùëñV^{i}, it will be appended to TopKi. PisuperscriptùëÉùëñP^{i} also updates accordingly.\n\n3. 3.\n\n\nIf the token wùë§w in Vusuperscriptùëâùë¢V^{u} does not exist in VisuperscriptùëâùëñV^{i}, it should be tokenized by TisuperscriptùëáùëñT^{i}. The first token of the result along with its token probability is then updated to TopKi and PisuperscriptùëÉùëñP^{i}.\n\n\nUp to now, we can obtain the aligned top tokens TopK^^ùêæ\\\\hat{K}i and the token distributions P^isuperscript^ùëÉùëñ\\\\hat{P}^{i} of based models. Consequently, we normalize P^isuperscript^ùëÉùëñ\\\\hat{P}^{i} as: P^n‚Äão‚Äãr‚Äãmi=softmax‚Å°(P^i)subscriptsuperscript^ùëÉùëñùëõùëúùëüùëösoftmaxsuperscript^ùëÉùëñ\\\\hat{P}^{i}\\_{norm}=\\\\operatorname{softmax}(\\\\hat{P}^{i}).\n\nSince our method eliminates the need for full vocabulary alignment, it is essential to designate one model as the primary base model. As discussed in Section [3.2](https://ar5iv.org/html/2410.03777#S3.SS2 \"3.2 Influence of Vocabulary Size ‚Ä£ 3 Understanding Model Ensembling from Model Capacity, Vocabulary Size and Task ‚Ä£ Determine-Then-Ensemble: Necessity of Top-k Union for Large Language Model Ensembling\"), the selection of primary base model is flexible when the candidate models exhibit comparable performance. To simplify the process, we directly employ the best-performing model as the primary base model. Then, the primary base model employs the average token probability P^a‚Äãv‚Äãgsubscript^ùëÉùëéùë£ùëî\\\\hat{P}\\_{avg} to predict the next token, where P^a‚Äãv‚Äãg=1n‚Äã‚àëi=1nP^n‚Äão‚Äãr‚Äãmisubscript^ùëÉùëéùë£ùëî1ùëõsuperscriptsubscriptùëñ1ùëõsubscriptsuperscript^ùëÉùëñùëõùëúùëüùëö\\\\hat{P}\\_{avg}=\\\\frac{1}{n}\\\\sum\\_{i=1}^{n}\\\\hat{P}^{i}\\_{norm}.\n\nThe next token is determined using the maximization-based greedy strategy (Li et al., [2016](https://ar5iv.org/html/2410.03777#bib.bib18 \"\")). The chosen token will be appended to the input text. This process is iteratively repeated until the predetermined stopping criterion is met, such as generating an end-of-sentence token or reaching the maximum length.\n\n## 5 Experiments\n\n### 5.1 Setup\n\n#### Models\n\nAll of our experiments are conducted with the following commonly used models, including LLaMA2-7B-Chat (Touvron et al., [2023](https://ar5iv.org/html/2410.03777#bib.bib23 \"\")), LLaMA2-13B-Chat (Touvron et al., [2023](https://ar5iv.org/html/2410.03777#bib.bib23 \"\")), LLaMA3-8B-Instruct (Dubey et al., [2024](https://ar5iv.org/html/2410.03777#bib.bib8 \"\")), LLaMA3.1-8B-Instruct (Dubey et al., [2024](https://ar5iv.org/html/2410.03777#bib.bib8 \"\")), Mistral-7B-Instruct-v0.3 (Jiang et al., [2023a](https://ar5iv.org/html/2410.03777#bib.bib12 \"\")), DeepSeek-LLM-7B-Chat (Bi et al., [2024](https://ar5iv.org/html/2410.03777#bib.bib3 \"\")), Yi-6B (Young et al., [2024](https://ar5iv.org/html/2410.03777#bib.bib30 \"\")), OpenChat-3.5 (Wang et al., [2024a](https://ar5iv.org/html/2410.03777#bib.bib26 \"\")), Qwen2-7B-Instruct (Yang et al., [2024](https://ar5iv.org/html/2410.03777#bib.bib29 \"\")), Mixtral-8√ó7B (Jiang et al., [2024](https://ar5iv.org/html/2410.03777#bib.bib13 \"\")) and Qwen1.5-72B (Bai et al., [2023](https://ar5iv.org/html/2410.03777#bib.bib2 \"\")).\n\n#### Baselines\n\nWe selected three typical model ensembling methods for further analyses.\n1) LLM-Blender(Jiang et al., [2023b](https://ar5iv.org/html/2410.03777#bib.bib14 \"\")) includes a reward model, PairRanker, to evaluate LLM responses, and a fusion model, GenFuser, to combine them. We only use PairRanker due to significant over-generation issues with GenFuser.\n2) DeePen(Huang et al., [2024](https://ar5iv.org/html/2410.03777#bib.bib11 \"\")) employs relative representation theory to map each model‚Äôs probability distribution to a universal space for aggregation, computed through the intersection of model vocabularies.\n3) GaC(Yu et al., [2024b](https://ar5iv.org/html/2410.03777#bib.bib32 \"\")) projects multiple LLMs‚Äô probability vectors into a unified vocabulary dimension using a mapping matrix and aggregates outputs at each generation step to select the next token. Although GaC suggests the importance of identifying keywords to improve latency, we still exclude it owing to its hindrance on the ensembling performance.\n\n| Method | Dataset | Avg. |\n| GSM8K | PIQA | MMLU | ARC-C | TriviaQA | NQ |\n| Mistral | 56.48 | 80.63 | 59.28 | 74.49 | 64.30 | 24.25 | 59.91 |\n| DeepSeek | 59.67 | 72.66 | 46.97 | 58.73 | 47.63 | 11.37 | 49.51 |\n| OpenChat | 73.46 | 87.10 | 60.80 | 78.05 | 61.77 | 31.08 | 65.38 |\n| LLM-Blender | 70.79(-2.67) | 83.28(-3.82) | 60.10(-0.70) | 76.29(-1.76) | 56.35(-5.42) | 25.57(-5.51) | 62.06(-3.32) |\n| DeePen | 73.06(-0.40) | 76.04(-11.06) | 61.91(+1.11) | 72.14(-5.91) | 67.24(+5.47) | 28.26(-2.82) | 63.11(-2.27) |\n| GaC | 62.85(-10.61) | 67.85(-19.25) | 55.15(-5.65) | 73.04(-5.01) | 62.22(+0.45) | 20.72(-10.36) | 56.97(-8.41) |\n| UniTE | 73.31(-0.15) | 87.50(+0.40) | 62.13(+1.33) | 78.70(+0.65) | 65.80(+4.03) | 31.78(+0.70) | 66.54(+1.16) |\n\nTable 3: Results of ensembling on Mistral, DeepSeek, OpenChat. OpenChat is chosen as primary model for these experiments.\n\n| Method | Dataset | Avg. |\n| GSM8K | PIQA | ARC-C | MMLU |\n| LLaMA3 | 78.77 | 79.08 | 79.01 | 64.58 | 75.36 |\n| LLaMA3.1 | 80.83 | 82.86 | 79.49 | 66.69 | 77.47 |\n| Qwen2 | 80.78 | 84.57 | 84.92 | 64.96 | 78.81 |\n| Two-model ensembling (LLaMA3+Qwen2) |\n| LLM-Blender | 82.69 (+1.91) | 82.53 (-2.04) | 82.98 (-1.94) | 62.07 (-2.89) | 77.57 (-1.24) |\n| DeePen | \\- OOM - |\n| GaC | 80.67 (-0.11) | 80.96 (-3.61) | 84.93 (+0.01) | 67.05 (+2.09) | 78.40 (-0.41) |\n| UniTE | 84.17(+3.39) | 85.53(+0.96) | 85.07(+0.15) | 69.78(+4.82) | 81.14(+2.33) |\n| Three-model ensembling |\n| LLM-Blender | 83.30(+2.52) | 83.47(-1.10) | 83.48(-1.44) | 62.55(-2.41) | 78.20(-0.61) |\n| DeePen | \\- OOM - |\n| UniTE | 84.99(+4.21) | 84.98(+0.41) | 85.39(+0.47) | 69.12(+4.16) | 81.12(+2.31) |\n\nTable 4: Results of ensembling on LLaMA3, LLaMA3.1, Qwen2. Qwen2 is chosen as primary model for these experiments.\n\n#### Benchmarks\n\nWe evaluate six benchmarks, which can be categorized into three main groups. 1) Comprehensive Examination: MMLU (5-shot) (Hendrycks et al., [2021](https://ar5iv.org/html/2410.03777#bib.bib10 \"\")), covering 57 subjects that humans typically learn; ARC-C (0-shot) (Clark et al., [2018](https://ar5iv.org/html/2410.03777#bib.bib5 \"\")), collected from standardized natural science tests. 2) Reasoning Capabilities: GSM8K (Cobbe et al., [2021](https://ar5iv.org/html/2410.03777#bib.bib6 \"\")) (4-shot), a dataset of high-quality problems at the grade school math level; PIQA (Bisk et al., [2020](https://ar5iv.org/html/2410.03777#bib.bib4 \"\")) (0-shot), a commonsense reasoning dataset. 3) Knowledge Capacities: TriviaQA (5-shot) (Joshi et al., [2017](https://ar5iv.org/html/2410.03777#bib.bib15 \"\")), compiled by Trivia enthusiasts; NaturalQuestion (NQ) (5-shot) (Kwiatkowski et al., [2019](https://ar5iv.org/html/2410.03777#bib.bib16 \"\")), a question-answering corpus consisting of queries issued to the Google search engine.\n\nFor a comprehensive evaluation, we conduct two- and multi-model ensembling experiments on the aforementioned benchmarks. We select base models following the strategy presented in Section [4.1](https://ar5iv.org/html/2410.03777#S4.SS1 \"4.1 Model selection strategy ‚Ä£ 4 Methodology ‚Ä£ Determine-Then-Ensemble: Necessity of Top-k Union for Large Language Model Ensembling\"). We choose two pairs from Mistral, Deepseek, and OpenChat for the two-model experiments. For the closely performing LLaMA3, LLaMA3.1, and Qwen2, we select LLaMA3 and Qwen2 for the two-model ensemble based on their release dates and subsequently employ all three models for the multi-model ensembling evaluations. The hyper-parameter kùëòk is set to 10 in this work. All experiments are conducted on 46G NVIDIA L40 GPUs.\n\n### 5.2 Main Results\n\nAs shown in Table [3](https://ar5iv.org/html/2410.03777#S5.T3 \"Table 3 ‚Ä£ Baselines ‚Ä£ 5.1 Setup ‚Ä£ 5 Experiments ‚Ä£ Determine-Then-Ensemble: Necessity of Top-k Union for Large Language Model Ensembling\") and Table [4](https://ar5iv.org/html/2410.03777#S5.T4 \"Table 4 ‚Ä£ Baselines ‚Ä£ 5.1 Setup ‚Ä£ 5 Experiments ‚Ä£ Determine-Then-Ensemble: Necessity of Top-k Union for Large Language Model Ensembling\"), we have following observations:\n\n(1) UniTE enhances individual model performance when the base models exhibit similar performance levels. As demonstrated, the ensemble of models such as OpenChat achieved an average improvement of approximately 1.2% across five benchmark tasks, including ARC-C and MMLU. However, in the GSM8K task, a 15% performance gap between DeepSeek and OpenChat led to a slight decline in overall performance, reinforcing our observation in Section [3.1](https://ar5iv.org/html/2410.03777#S3.SS1 \"3.1 Impact of Model Performance Discrepancy ‚Ä£ 3 Understanding Model Ensembling from Model Capacity, Vocabulary Size and Task ‚Ä£ Determine-Then-Ensemble: Necessity of Top-k Union for Large Language Model Ensembling\") that ensemble methods are most effective when model performances are closely aligned. Furthermore, experiments with LLaMA3 and Qwen2 validated our approach, resulting in performance increases of 3.39% and 4.82% on the GSM8K and MMLU tasks, respectively.\n\n(2) UniTE demonstrates greater robustness and generality. Ensembling experiments with LLaMA3 and Qwen2 indicate that while LLM-Blender improves performance on the GSM8K dataset, it significantly underperforms compared to baseline models in the PIQA, ARC-C, and MMLU benchmarks. Specifically, Blender demonstrates a decline of 2.89% in the MMLU task, and this issue is exacerbated in ensembles with the baseline models OpenChat and Mistral, which exhibit relatively low baseline performance, leading to an average performance drop of 3.32%. Additionally, GaC fails to improve the performance of individual models across most tasks and exhibits a significant decline of over 10% when combined with Mistral and OpenChat. Furthermore, due to its intersection limitations, DeePen is ill-suited for ensembling with the LLaMA3 model, which requires handling a large vocabulary. In contrast, across tasks with comparable performance levels, UniTE achieves the highest improvements and overall performance across the board, with the exception of a slight under-performance relative to DeePen on TriviaQA. This outcome underscores the effectiveness and robustness of UniTE.\n\n(3) Collaborating with comparable LLMs does not necessarily yield better results. The ensembling experiments conducted with three models, following the integration of LLaMA3.1, demonstrate improved performance on the GSM8K and ARC-C benchmarks compared to the ensemble of LLaMA3 and Qwen2. However, this approach results in suboptimal outcomes on PIQA and MMLU. This observation is justified, as the analysis in Section [3.2](https://ar5iv.org/html/2410.03777#S3.SS2 \"3.2 Influence of Vocabulary Size ‚Ä£ 3 Understanding Model Ensembling from Model Capacity, Vocabulary Size and Task ‚Ä£ Determine-Then-Ensemble: Necessity of Top-k Union for Large Language Model Ensembling\") indicates that while combining models with similar performance may enhance overall efficacy, such improvement is not guaranteed.\n\n![Refer to caption](https://ar5iv.org/html/2410.03777/assets/Figs/impact_of_k.png)Figure 4: Impact of the choice of hyperparameter kùëòk.\n\n![Refer to caption](https://ar5iv.org/html/2410.03777/assets/Figs/latency.png)Figure 5: Latency comparison of different methods. The darker the color, the greater the latency.\n\n### 5.3 Ablation study\n\n#### Effect of hyperparameter kùëòk selection\n\nTo investigate the impact of the hyperparameter kùëòk, we conducted experiments using the Mistral and OpenChat models on the TriviaQA and ARC-C datasets. As illustrated in Fig. [5](https://ar5iv.org/html/2410.03777#S5.F5 \"Figure 5 ‚Ä£ 5.2 Main Results ‚Ä£ 5 Experiments ‚Ä£ Determine-Then-Ensemble: Necessity of Top-k Union for Large Language Model Ensembling\"), increasing kùëòk from 5 to 10 enhances ensemble performance. However, further increasing kùëòk beyond 10 leads to either a slight decline or no change in performance. This finding supports our assertion that, in probability-level ensembling, aligning the entire vocabulary is unnecessary for predicting the next token.\n\n#### Effect of the next token selection strategy\n\nWe also explored the impact of deterministic decoding and top-kùëòk sampling (Fan et al., [2018](https://ar5iv.org/html/2410.03777#bib.bib9 \"\")) on the next token emission. It is important to clarify that our UniTE focuses on the fact that, when predicting the next token, we only need to ensemble a subset of tokens rather than the entire vocabulary. In contrast, greedy decoding and top-kùëòk sampling emphasize how to determine the next token‚Äôs ID after the ensemble process is complete. To investigate this, we conducted experiments using LLaMA3.1 and Mistral on the PIQA and ARC-C datasets correspondingly. As shown in Figure [6](https://ar5iv.org/html/2410.03777#S5.F6 \"Figure 6 ‚Ä£ Effect of the next token selection strategy ‚Ä£ 5.3 Ablation study ‚Ä£ 5 Experiments ‚Ä£ Determine-Then-Ensemble: Necessity of Top-k Union for Large Language Model Ensembling\"), for these deterministic tasks, the maximization-based greedy method outperforms the random sampling approach, which aligns with intuition.\n\n![Refer to caption](https://ar5iv.org/html/2410.03777/assets/Figs/ablation.png)Figure 6: Comparison among different decoding methods.\n\n### 5.4 Further Analysis\n\n#### Latency analysis\n\nFollowing the settings detailed in GaC(Yu et al., [2024b](https://ar5iv.org/html/2410.03777#bib.bib32 \"\")), we recorded the latency (ms/token) of different methods. The data presented in Fig. [5](https://ar5iv.org/html/2410.03777#S5.F5 \"Figure 5 ‚Ä£ 5.2 Main Results ‚Ä£ 5 Experiments ‚Ä£ Determine-Then-Ensemble: Necessity of Top-k Union for Large Language Model Ensembling\") reveals significant differences in latency among the various methods. Notably, the latency of UniTE is 87.78 ms/token, which is substantially lower than that of DeePen and GaC, and only about 10 ms longer than that of the individual models.\n\n#### Tokens manipulated each step\n\nTable [6](https://ar5iv.org/html/2410.03777#S5.T6 \"Table 6 ‚Ä£ Tokens manipulated each step ‚Ä£ 5.4 Further Analysis ‚Ä£ 5 Experiments ‚Ä£ Determine-Then-Ensemble: Necessity of Top-k Union for Large Language Model Ensembling\") presents tokens manipulated at each step. Compared to DeePen and GaC, UniTE significantly reduces the number of tokens manipulated at each step, indicating its efficiency. As the vocabulary of the base model expands, the number of manipulated tokens of DeePen and GaC increases significantly, which not only increases the computational burden but may also lead to performance bottlenecks. Contrastly, UniTE is minimally affected, maintaining its effectiveness.\n\n| Base Model | Method | Tokens Manipulated Each Step |\n| --- | --- | --- |\n| Mistral(32678)+OpenChat(32002) | DeePen | 32000 |\n| GaC | 32770 |\n| UniTE | 14.46 |\n| LLaMA3(128256)+Qwen2(151646) | DeePen | 109566 |\n| GaC | 170336 |\n| UniTE | 14.43 |\n\nTable 5: Tokens manipulated at each step. It‚Äôs noteworthy that DeePen encountered out-of-memory issues when conducting LLaMA3 and Qwen2 ensembling.\n\n| Model | ARC-C | PIQA |\n| --- | --- | --- |\n| Qwen1.5-72B(Dense) | 69.03 | 73.83 |\n| Mixtral-8x7B(Sparse) | 73.98 | 74.59 |\n| UniTE | 78.84 | 81.88 |\n| (+4.86) | (+7.29) |\n\nTable 6: Ensemble learning of the dense LLM Qwen1.5-72B and the sparse MOE model Mixtral-8x7B.\n\n#### Ensemble of the dense model and the sparse model\n\nWe evaluate our method on the ensemble learning of the dense model and the sparse MoE model for reasoning and comprehensive examination tasks. Specifically, we utilize the widely-used large-scale dense model Qwen1.5-72B (Bai et al., [2023](https://ar5iv.org/html/2410.03777#bib.bib2 \"\")) alongside the popular sparse MoE model Mixtral-8√ó7B (Jiang et al., [2024](https://ar5iv.org/html/2410.03777#bib.bib13 \"\")) as our base models. As shown in Tabel [6](https://ar5iv.org/html/2410.03777#S5.T6 \"Table 6 ‚Ä£ Tokens manipulated each step ‚Ä£ 5.4 Further Analysis ‚Ä£ 5 Experiments ‚Ä£ Determine-Then-Ensemble: Necessity of Top-k Union for Large Language Model Ensembling\"), our UniTE achieves +4.86% and +7.29% performance on the ARC-C and PIQA datasets respectively, despite the base models already exhibiting high levels of performance.\n\n## 6 Conclusion\n\nIn conclusion, our research highlights the effectiveness of ensemble methods in enhancing the performance of LLMs. By examining existing techniques, we identified key factors influencing ensembling success, such as model performance and response processes, while finding that vocabulary size has a minimal impact. In addition, the issue of vocabulary redundancy exposed by existing methods during ensembling lead us to propose UniTE, which efficiently aggregates a bunch of tokens from multiple LLMs without the computational overhead. Through extensive experimentation, UniTE consistently outperformed state-of-the-art ensemble methods, demonstrating its effectiveness in leveraging the strengths of diverse LLMs. Our contributions not only advance the understanding of model ensembling but also provide a practical framework for selecting and integrating LLMs to achieve superior performance.\n\n## References\n\n- Akiba et al. (2024)\nTakuya Akiba, Makoto Shing, Yujin Tang, Qi Sun, and David Ha.\n\nEvolutionary optimization of model merging recipes.\n\n_CoRR_, abs/2403.13187, 2024.\n\ndoi: 10.48550/ARXIV.2403.13187.\n\nURL [https://doi.org/10.48550/arXiv.2403.13187](https://doi.org/10.48550/arXiv.2403.13187 \"\").\n\n- Bai et al. (2023)\nJinze Bai, Shuai Bai, Yunfei Chu, Zeyu Cui, Kai Dang, Xiaodong Deng, Yang Fan, Wenbin Ge, Yu Han, Fei Huang, Binyuan Hui, Luo Ji, Mei Li, Junyang Lin, Runji Lin, Dayiheng Liu, Gao Liu, Chengqiang Lu, Keming Lu, Jianxin Ma, Rui Men, Xingzhang Ren, Xuancheng Ren, Chuanqi Tan, Sinan Tan, Jianhong Tu, Peng Wang, Shijie Wang, Wei Wang, Shengguang Wu, Benfeng Xu, Jin Xu, An Yang, Hao Yang, Jian Yang, Shusheng Yang, Yang Yao, Bowen Yu, Hongyi Yuan, Zheng Yuan, Jianwei Zhang, Xingxuan Zhang, Yichang Zhang, Zhenru Zhang, Chang Zhou, Jingren Zhou, Xiaohuan Zhou, and Tianhang Zhu.\n\nQwen technical report.\n\n_arXiv preprint arXiv:2309.16609_, 2023.\n\n- Bi et al. (2024)\nXiao Bi, Deli Chen, Guanting Chen, Shanhuang Chen, Damai Dai, Chengqi Deng, Honghui Ding, Kai Dong, Qiushi Du, Zhe Fu, Huazuo Gao, Kaige Gao, Wenjun Gao, Ruiqi Ge, Kang Guan, Daya Guo, Jianzhong Guo, Guangbo Hao, Zhewen Hao, Ying He, Wenjie Hu, Panpan Huang, Erhang Li, Guowei Li, Jiashi Li, Yao Li, Y. K. Li, Wenfeng Liang, Fangyun Lin, Alex X. Liu, Bo Liu, Wen Liu, Xiaodong Liu, Xin Liu, Yiyuan Liu, Haoyu Lu, Shanghao Lu, Fuli Luo, Shirong Ma, Xiaotao Nie, Tian Pei, Yishi Piao, Junjie Qiu, Hui Qu, Tongzheng Ren, Zehui Ren, Chong Ruan, Zhangli Sha, Zhihong Shao, Junxiao Song, Xuecheng Su, Jingxiang Sun, Yaofeng Sun, Minghui Tang, Bingxuan Wang, Peiyi Wang, Shiyu Wang, Yaohui Wang, Yongji Wang, Tong Wu, Y. Wu, Xin Xie, Zhenda Xie, Ziwei Xie, Yiliang Xiong, Hanwei Xu, R. X. Xu, Yanhong Xu, Dejian Yang, Yuxiang You, Shuiping Yu, Xingkai Yu, B. Zhang, Haowei Zhang, Lecong Zhang, Liyue Zhang, Mingchuan Zhang, Minghua Zhang, Wentao Zhang, Yichao Zhang, Chenggang Zhao, Yao Zhao, Shangyan Zhou, Shunfeng Zhou, Qihao\nZhu, and Yuheng Zou.\n\nDeepseek LLM: scaling open-source language models with longtermism.\n\n_CoRR_, abs/2401.02954, 2024.\n\ndoi: 10.48550/ARXIV.2401.02954.\n\nURL [https://doi.org/10.48550/arXiv.2401.02954](https://doi.org/10.48550/arXiv.2401.02954 \"\").\n\n- Bisk et al. (2020)\nYonatan Bisk, Rowan Zellers, Ronan Le Bras, Jianfeng Gao, and Yejin Choi.\n\nPIQA: reasoning about physical commonsense in natural language.\n\nIn _The Thirty-Fourth AAAI Conference on Artificial Intelligence, AAAI 2020, The Thirty-Second Innovative Applications of Artificial Intelligence Conference, IAAI 2020, The Tenth AAAI Symposium on Educational Advances in Artificial Intelligence, EAAI 2020, New York, NY, USA, February 7-12, 2020_, pp.  7432‚Äì7439. AAAI Press, 2020.\n\ndoi: 10.1609/AAAI.V34I05.6239.\n\nURL [https://doi.org/10.1609/aaai.v34i05.6239](https://doi.org/10.1609/aaai.v34i05.6239 \"\").\n\n- Clark et al. (2018)\nPeter Clark, Isaac Cowhey, Oren Etzioni, Tushar Khot, Ashish Sabharwal, Carissa Schoenick, and Oyvind Tafjord.\n\nThink you have solved question answering? try arc, the AI2 reasoning challenge.\n\n_CoRR_, abs/1803.05457, 2018.\n\nURL [http://arxiv.org/abs/1803.05457](http://arxiv.org/abs/1803.05457 \"\").\n\n- Cobbe et al. (2021)\nKarl Cobbe, Vineet Kosaraju, Mohammad Bavarian, Mark Chen, Heewoo Jun, Lukasz Kaiser, Matthias Plappert, Jerry Tworek, Jacob Hilton, Reiichiro Nakano, Christopher Hesse, and John Schulman.\n\nTraining verifiers to solve math word problems.\n\n_CoRR_, abs/2110.14168, 2021.\n\nURL [https://arxiv.org/abs/2110.14168](https://arxiv.org/abs/2110.14168 \"\").\n\n- Dong et al. (2023)\nPeijie Dong, Lujun Li, and Zimian Wei.\n\nDiswot: Student architecture search for distillation without training.\n\nIn _IEEE/CVF Conference on Computer Vision and Pattern Recognition, CVPR 2023, Vancouver, BC, Canada, June 17-24, 2023_, pp.  11898‚Äì11908. IEEE, 2023.\n\ndoi: 10.1109/CVPR52729.2023.01145.\n\nURL [https://doi.org/10.1109/CVPR52729.2023.01145](https://doi.org/10.1109/CVPR52729.2023.01145 \"\").\n\n- Dubey et al. (2024)\nAbhimanyu Dubey, Abhinav Jauhri, Abhinav Pandey, Abhishek Kadian, Ahmad Al-Dahle, Aiesha Letman, Akhil Mathur, Alan Schelten, Amy Yang, Angela Fan, Anirudh Goyal, Anthony Hartshorn, Aobo Yang, Archi Mitra, Archie Sravankumar, Artem Korenev, Arthur Hinsvark, Arun Rao, Aston Zhang, Aur√©lien Rodriguez, Austen Gregerson, Ava Spataru, Baptiste Rozi√®re, Bethany Biron, Binh Tang, Bobbie Chern, Charlotte Caucheteux, Chaya Nayak, Chloe Bi, Chris Marra, Chris McConnell, Christian Keller, Christophe Touret, Chunyang Wu, Corinne Wong, Cristian Canton Ferrer, Cyrus Nikolaidis, Damien Allonsius, Daniel Song, Danielle Pintz, Danny Livshits, David Esiobu, Dhruv Choudhary, Dhruv Mahajan, Diego Garcia-Olano, Diego Perino, Dieuwke Hupkes, Egor Lakomkin, Ehab AlBadawy, Elina Lobanova, Emily Dinan, Eric Michael Smith, Filip Radenovic, Frank Zhang, Gabriel Synnaeve, Gabrielle Lee, Georgia Lewis Anderson, Graeme Nail, Gr√©goire Mialon, Guan Pang, Guillem Cucurell, Hailey Nguyen, Hannah Korevaar, Hu Xu, Hugo\nTouvron, Iliyan Zarov, Imanol Arrieta Ibarra, Isabel M. Kloumann, Ishan Misra, Ivan Evtimov, Jade Copet, Jaewon Lee, Jan Geffert, Jana Vranes, Jason Park, Jay Mahadeokar, Jeet Shah, Jelmer van der Linde, Jennifer Billock, Jenny Hong, Jenya Lee, Jeremy Fu, Jianfeng Chi, Jianyu Huang, Jiawen Liu, Jie Wang, Jiecao Yu, Joanna Bitton, Joe Spisak, Jongsoo Park, Joseph Rocca, Joshua Johnstun, Joshua Saxe, Junteng Jia, Kalyan Vasuden Alwala, Kartikeya Upasani, Kate Plawiak, Ke Li, Kenneth Heafield, Kevin Stone, and et al.\n\nThe llama 3 herd of models.\n\n_CoRR_, abs/2407.21783, 2024.\n\ndoi: 10.48550/ARXIV.2407.21783.\n\nURL [https://doi.org/10.48550/arXiv.2407.21783](https://doi.org/10.48550/arXiv.2407.21783 \"\").\n\n- Fan et al. (2018)\nAngela Fan, Mike Lewis, and Yann N. Dauphin.\n\nHierarchical neural story generation.\n\nIn Iryna Gurevych and Yusuke Miyao (eds.), _Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics, ACL 2018, Melbourne, Australia, July 15-20, 2018, Volume 1: Long Papers_, pp.  889‚Äì898. Association for Computational Linguistics, 2018.\n\ndoi: 10.18653/V1/P18-1082.\n\nURL [https://aclanthology.org/P18-1082/](https://aclanthology.org/P18-1082/ \"\").\n\n- Hendrycks et al. (2021)\nDan Hendrycks, Collin Burns, Steven Basart, Andy Zou, Mantas Mazeika, Dawn Song, and Jacob Steinhardt.\n\nMeasuring massive multitask language understanding.\n\nIn _9th International Conference on Learning Representations, ICLR 2021, Virtual Event, Austria, May 3-7, 2021_. OpenReview.net, 2021.\n\nURL [https://openreview.net/forum?id=d7KBjmI3GmQ](https://openreview.net/forum?id=d7KBjmI3GmQ \"\").\n\n- Huang et al. (2024)\nYichong Huang, Xiaocheng Feng, Baohang Li, Yang Xiang, Hui Wang, Bing Qin, and Ting Liu.\n\nEnabling ensemble learning for heterogeneous large language models with deep parallel collaboration.\n\n_CoRR_, abs/2404.12715, 2024.\n\ndoi: 10.48550/ARXIV.2404.12715.\n\nURL [https://doi.org/10.48550/arXiv.2404.12715](https://doi.org/10.48550/arXiv.2404.12715 \"\").\n\n- Jiang et al. (2023a)\nAlbert Q. Jiang, Alexandre Sablayrolles, Arthur Mensch, Chris Bamford, Devendra Singh Chaplot, Diego de Las Casas, Florian Bressand, Gianna Lengyel, Guillaume Lample, Lucile Saulnier, L√©lio Renard Lavaud, Marie-Anne Lachaux, Pierre Stock, Teven Le Scao, Thibaut Lavril, Thomas Wang, Timoth√©e Lacroix, and William El Sayed.\n\nMistral 7b.\n\n_CoRR_, abs/2310.06825, 2023a.\n\ndoi: 10.48550/ARXIV.2310.06825.\n\nURL [https://doi.org/10.48550/arXiv.2310.06825](https://doi.org/10.48550/arXiv.2310.06825 \"\").\n\n- Jiang et al. (2024)\nAlbert Q. Jiang, Alexandre Sablayrolles, Antoine Roux, Arthur Mensch, Blanche Savary, Chris Bamford, Devendra Singh Chaplot, Diego de Las Casas, Emma Bou Hanna, Florian Bressand, Gianna Lengyel, Guillaume Bour, Guillaume Lample, L√©lio Renard Lavaud, Lucile Saulnier, Marie-Anne Lachaux, Pierre Stock, Sandeep Subramanian, Sophia Yang, Szymon Antoniak, Teven Le Scao, Th√©ophile Gervet, Thibaut Lavril, Thomas Wang, Timoth√©e Lacroix, and William El Sayed.\n\nMixtral of experts.\n\n_CoRR_, abs/2401.04088, 2024.\n\ndoi: 10.48550/ARXIV.2401.04088.\n\nURL [https://doi.org/10.48550/arXiv.2401.04088](https://doi.org/10.48550/arXiv.2401.04088 \"\").\n\n- Jiang et al. (2023b)\nDongfu Jiang, Xiang Ren, and Bill Yuchen Lin.\n\nLlm-blender: Ensembling large language models with pairwise ranking and generative fusion.\n\nIn Anna Rogers, Jordan L. Boyd-Graber, and Naoaki Okazaki (eds.), _Proceedings of the 61st Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), ACL 2023, Toronto, Canada, July 9-14, 2023_, pp.  14165‚Äì14178. Association for Computational Linguistics, 2023b.\n\ndoi: 10.18653/V1/2023.ACL-LONG.792.\n\nURL [https://doi.org/10.18653/v1/2023.acl-long.792](https://doi.org/10.18653/v1/2023.acl-long.792 \"\").\n\n- Joshi et al. (2017)\nMandar Joshi, Eunsol Choi, Daniel S. Weld, and Luke Zettlemoyer.\n\nTriviaqa: A large scale distantly supervised challenge dataset for reading comprehension.\n\nIn Regina Barzilay and Min-Yen Kan (eds.), _Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics, ACL 2017, Vancouver, Canada, July 30 - August 4, Volume 1: Long Papers_, pp.  1601‚Äì1611. Association for Computational Linguistics, 2017.\n\ndoi: 10.18653/V1/P17-1147.\n\nURL [https://doi.org/10.18653/v1/P17-1147](https://doi.org/10.18653/v1/P17-1147 \"\").\n\n- Kwiatkowski et al. (2019)\nTom Kwiatkowski, Jennimaria Palomaki, Olivia Redfield, Michael Collins, Ankur P. Parikh, Chris Alberti, Danielle Epstein, Illia Polosukhin, Jacob Devlin, Kenton Lee, Kristina Toutanova, Llion Jones, Matthew Kelcey, Ming-Wei Chang, Andrew M. Dai, Jakob Uszkoreit, Quoc Le, and Slav Petrov.\n\nNatural questions: a benchmark for question answering research.\n\n_Trans. Assoc. Comput. Linguistics_, 7:452‚Äì466, 2019.\n\ndoi: 10.1162/TACL‚ÄúÀôA‚ÄúÀô00276.\n\nURL [https://doi.org/10.1162/tacl\\_a\\_00276](https://doi.org/10.1162/tacl_a_00276 \"\").\n\n- Lee et al. (2023)\nHayeon Lee, Rui Hou, Jongpil Kim, Davis Liang, Sung Ju Hwang, and Alexander Min.\n\nA study on knowledge distillation from weak teacher for scaling up pre-trained language models.\n\nIn Anna Rogers, Jordan L. Boyd-Graber, and Naoaki Okazaki (eds.), _Findings of the Association for Computational Linguistics: ACL 2023, Toronto, Canada, July 9-14, 2023_, pp.  11239‚Äì11246. Association for Computational Linguistics, 2023.\n\ndoi: 10.18653/V1/2023.FINDINGS-ACL.714.\n\nURL [https://doi.org/10.18653/v1/2023.findings-acl.714](https://doi.org/10.18653/v1/2023.findings-acl.714 \"\").\n\n- Li et al. (2016)\nJiwei Li, Will Monroe, Alan Ritter, Dan Jurafsky, Michel Galley, and Jianfeng Gao.\n\nDeep reinforcement learning for dialogue generation.\n\nIn Jian Su, Xavier Carreras, and Kevin Duh (eds.), _Proceedings of the 2016 Conference on Empirical Methods in Natural Language Processing, EMNLP 2016, Austin, Texas, USA, November 1-4, 2016_, pp.  1192‚Äì1202. The Association for Computational Linguistics, 2016.\n\ndoi: 10.18653/V1/D16-1127.\n\nURL [https://doi.org/10.18653/v1/d16-1127](https://doi.org/10.18653/v1/d16-1127 \"\").\n\n- Liu et al. (2024)\nCong Liu, Xiaojun Quan, Yan Pan, Liang Li, Weigang Wu, and Xu Chen.\n\nCool-fusion: Fuse large language models without training.\n\n_CoRR_, abs/2407.19807, 2024.\n\ndoi: 10.48550/ARXIV.2407.19807.\n\nURL [https://doi.org/10.48550/arXiv.2407.19807](https://doi.org/10.48550/arXiv.2407.19807 \"\").\n\n- Lu et al. (2024)\nKeming Lu, Hongyi Yuan, Runji Lin, Junyang Lin, Zheng Yuan, Chang Zhou, and Jingren Zhou.\n\nRouting to the expert: Efficient reward-guided ensemble of large language models.\n\nIn Kevin Duh, Helena G√≥mez-Adorno, and Steven Bethard (eds.), _Proceedings of the 2024 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies (Volume 1: Long Papers), NAACL 2024, Mexico City, Mexico, June 16-21, 2024_, pp.  1964‚Äì1974. Association for Computational Linguistics, 2024.\n\ndoi: 10.18653/V1/2024.NAACL-LONG.109.\n\nURL [https://doi.org/10.18653/v1/2024.naacl-long.109](https://doi.org/10.18653/v1/2024.naacl-long.109 \"\").\n\n- OpenAI (2023)\nOpenAI.\n\nGPT-4 technical report.\n\n_CoRR_, abs/2303.08774, 2023.\n\ndoi: 10.48550/ARXIV.2303.08774.\n\nURL [https://doi.org/10.48550/arXiv.2303.08774](https://doi.org/10.48550/arXiv.2303.08774 \"\").\n\n- Shnitzer et al. (2023)\nTal Shnitzer, Anthony Ou, M√≠rian Silva, Kate Soule, Yuekai Sun, Justin Solomon, Neil Thompson, and Mikhail Yurochkin.\n\nLarge language model routing with benchmark datasets.\n\n_CoRR_, abs/2309.15789, 2023.\n\ndoi: 10.48550/ARXIV.2309.15789.\n\nURL [https://doi.org/10.48550/arXiv.2309.15789](https://doi.org/10.48550/arXiv.2309.15789 \"\").\n\n- Touvron et al. (2023)\nHugo Touvron, Louis Martin, Kevin Stone, Peter Albert, Amjad Almahairi, Yasmine Babaei, Nikolay Bashlykov, Soumya Batra, Prajjwal Bhargava, Shruti Bhosale, et al.\n\nLlama 2: Open foundation and fine-tuned chat models.\n\n_arXiv preprint arXiv:2307.09288_, 2023.\n\n- Wan et al. (2024a)\nFanqi Wan, Xinting Huang, Deng Cai, Xiaojun Quan, Wei Bi, and Shuming Shi.\n\nKnowledge fusion of large language models.\n\nIn _The Twelfth International Conference on Learning Representations, ICLR 2024, Vienna, Austria, May 7-11, 2024_. OpenReview.net, 2024a.\n\nURL [https://openreview.net/forum?id=jiDsk12qcz](https://openreview.net/forum?id=jiDsk12qcz \"\").\n\n- Wan et al. (2024b)\nFanqi Wan, Ziyi Yang, Longguang Zhong, Xiaojun Quan, Xinting Huang, and Wei Bi.\n\nFusechat: Knowledge fusion of chat models.\n\n_CoRR_, abs/2402.16107, 2024b.\n\ndoi: 10.48550/ARXIV.2402.16107.\n\nURL [https://doi.org/10.48550/arXiv.2402.16107](https://doi.org/10.48550/arXiv.2402.16107 \"\").\n\n- Wang et al. (2024a)\nGuan Wang, Sijie Cheng, Xianyuan Zhan, Xiangang Li, Sen Song, and Yang Liu.\n\nOpenchat: Advancing open-source language models with mixed-quality data.\n\nIn _The Twelfth International Conference on Learning Representations, ICLR 2024, Vienna, Austria, May 7-11, 2024_. OpenReview.net, 2024a.\n\nURL [https://openreview.net/forum?id=AOJyfhWYHf](https://openreview.net/forum?id=AOJyfhWYHf \"\").\n\n- Wang et al. (2024b)\nHongyi Wang, Felipe Maia Polo, Yuekai Sun, Souvik Kundu, Eric P. Xing, and Mikhail Yurochkin.\n\nFusing models with complementary expertise.\n\nIn _The Twelfth International Conference on Learning Representations, ICLR 2024, Vienna, Austria, May 7-11, 2024_. OpenReview.net, 2024b.\n\nURL [https://openreview.net/forum?id=PhMrGCMIRL](https://openreview.net/forum?id=PhMrGCMIRL \"\").\n\n- Xu et al. (2024)\nYangyifan Xu, Jinliang Lu, and Jiajun Zhang.\n\nBridging the gap between different vocabularies for LLM ensemble.\n\nIn Kevin Duh, Helena G√≥mez-Adorno, and Steven Bethard (eds.), _Proceedings of the 2024 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies (Volume 1: Long Papers), NAACL 2024, Mexico City, Mexico, June 16-21, 2024_, pp.  7140‚Äì7152. Association for Computational Linguistics, 2024.\n\ndoi: 10.18653/V1/2024.NAACL-LONG.395.\n\nURL [https://doi.org/10.18653/v1/2024.naacl-long.395](https://doi.org/10.18653/v1/2024.naacl-long.395 \"\").\n\n- Yang et al. (2024)\nAn Yang, Baosong Yang, Binyuan Hui, Bo Zheng, Bowen Yu, Chang Zhou, Chengpeng Li, Chengyuan Li, Dayiheng Liu, Fei Huang, Guanting Dong, Haoran Wei, Huan Lin, Jialong Tang, Jialin Wang, Jian Yang, Jianhong Tu, Jianwei Zhang, Jianxin Ma, Jianxin Yang, Jin Xu, Jingren Zhou, Jinze Bai, Jinzheng He, Junyang Lin, Kai Dang, Keming Lu, Keqin Chen, Kexin Yang, Mei Li, Mingfeng Xue, Na Ni, Pei Zhang, Peng Wang, Ru Peng, Rui Men, Ruize Gao, Runji Lin, Shijie Wang, Shuai Bai, Sinan Tan, Tianhang Zhu, Tianhao Li, Tianyu Liu, Wenbin Ge, Xiaodong Deng, Xiaohuan Zhou, Xingzhang Ren, Xinyu Zhang, Xipin Wei, Xuancheng Ren, Xuejing Liu, Yang Fan, Yang Yao, Yichang Zhang, Yu Wan, Yunfei Chu, Yuqiong Liu, Zeyu Cui, Zhenru Zhang, Zhifang Guo, and Zhihao Fan.\n\nQwen2 technical report.\n\n_CoRR_, abs/2407.10671, 2024.\n\ndoi: 10.48550/ARXIV.2407.10671.\n\nURL [https://doi.org/10.48550/arXiv.2407.10671](https://doi.org/10.48550/arXiv.2407.10671 \"\").\n\n- Young et al. (2024)\nAlex Young, Bei Chen, Chao Li, Chengen Huang, Ge Zhang, Guanwei Zhang, Heng Li, Jiangcheng Zhu, Jianqun Chen, Jing Chang, Kaidong Yu, Peng Liu, Qiang Liu, Shawn Yue, Senbin Yang, Shiming Yang, Tao Yu, Wen Xie, Wenhao Huang, Xiaohui Hu, Xiaoyi Ren, Xinyao Niu, Pengcheng Nie, Yuchi Xu, Yudong Liu, Yue Wang, Yuxuan Cai, Zhenyu Gu, Zhiyuan Liu, and Zonghong Dai.\n\nYi: Open foundation models by 01.ai.\n\n_CoRR_, abs/2403.04652, 2024.\n\ndoi: 10.48550/ARXIV.2403.04652.\n\nURL [https://doi.org/10.48550/arXiv.2403.04652](https://doi.org/10.48550/arXiv.2403.04652 \"\").\n\n- Yu et al. (2024a)\nLe Yu, Bowen Yu, Haiyang Yu, Fei Huang, and Yongbin Li.\n\nLanguage models are super mario: Absorbing abilities from homologous models as a free lunch.\n\nIn _Forty-first International Conference on Machine Learning, ICML 2024, Vienna, Austria, July 21-27, 2024_. OpenReview.net, 2024a.\n\nURL [https://openreview.net/forum?id=fq0NaiU8Ex](https://openreview.net/forum?id=fq0NaiU8Ex \"\").\n\n- Yu et al. (2024b)\nYao-Ching Yu, Chun-Chih Kuo, Ziqi Ye, Yu-Cheng Chang, and Yueh-Se Li.\n\nBreaking the ceiling of the LLM community by treating token generation as a classification for ensembling.\n\n_CoRR_, abs/2406.12585, 2024b.\n\ndoi: 10.48550/ARXIV.2406.12585.\n\nURL [https://doi.org/10.48550/arXiv.2406.12585](https://doi.org/10.48550/arXiv.2406.12585 \"\").\n\n\n## Appendix A Appendix\n\n### A.1 Task challenges analysis on TriviaQA\n\nTable [7](https://ar5iv.org/html/2410.03777#A1.T7 \"Table 7 ‚Ä£ A.2 Case Study of UniTE ‚Ä£ Appendix A Appendix ‚Ä£ Determine-Then-Ensemble: Necessity of Top-k Union for Large Language Model Ensembling\") provides a detailed comparison of the differences in response styles between LLaMA3 and Qwen2 on the TriviaQA dataset. It is easily observable that, regardless of correctness, LLM-Blender consistently tends to choose longer responses as answers.\n\n### A.2 Case Study of UniTE\n\nTable [8](https://ar5iv.org/html/2410.03777#A1.T8 \"Table 8 ‚Ä£ A.2 Case Study of UniTE ‚Ä£ Appendix A Appendix ‚Ä£ Determine-Then-Ensemble: Necessity of Top-k Union for Large Language Model Ensembling\") presents the specific cases of UniTE and other ensembling approaches, showcasing the validity and stability of our method.\n\n| Question | Who had a 70s No 1 hit with Kiss You All Over? |\n| The flag of Libya is a plain rectangle of which color? |\n| Gold answer | Sir Henry Campbell Bannerman |\n| Green |\n| LLaMA3 response | Henry Campbell-Bannerman \\\\usym2713 |\n| Green \\\\usym2713 |\n| Qwen2 Response | |     |\n| --- |\n| The hit song KÃàiss You All Over·∫Öas performed by the band Arrows, featuring vocalist Jim McCarty. \\\\usym2717 |\n| The song reached number one on the UK Singles Chart in 1976. |\n| The song was written by Arrows‚Äô lead singer Jim McCarty, along with the band‚Äôs guitarist, Steve PÃàig·∏¶arrison. |\n| It was produced by Tony Visconti, who had previously worked with David Bowie and T. Rex. |\n| KÃàiss You All Over·∫Öas released as a single from the band‚Äôs debut album, √Ñrrows,·∫Öhich was also released in 1976. |\n| The song‚Äôs catchy chorus and upbeat tempo made it a popular hit of the 1970s, |\n| and it remains a well-known and beloved track from that era. |\n| The song‚Äôs success helped to establish Arrows as a popular band of the time, |\n| and it continues to be played on classic rock and oldies radio stations today. | |\n| \\\\cdashline2-2 | |     |\n| --- |\n| The flag of Libya is a plain rectangle of green color. \\\\usym2713 |\n| It was adopted in 1977 and features a green color field with no other symbols or designs. |\n| The color green is significant in the country‚Äôs history and culture, |\n| representing hope, fertility, and the country‚Äôs rich agricultural heritage. |\n| The flag is rectangular in shape and is often flown vertically. |\n| It is an important symbol of the Libyan state and is used in various official and ceremonial contexts. | |\n| LLM-Blender response | |     |\n| --- |\n| The hit song KÃàiss You All Over·∫Öas performed by the band Arrows, featuring vocalist Jim McCarty. \\\\usym2717 |\n| The song reached number one on the UK Singles Chart in 1976. |\n| The song was written by Arrows‚Äô lead singer Jim McCarty, along with the band‚Äôs guitarist, Steve PÃàig·∏¶arrison. |\n| It was produced by Tony Visconti, who had previously worked with David Bowie and T. Rex. |\n| KÃàiss You All Over·∫Öas released as a single from the band‚Äôs debut album, √Ñrrows,·∫Öhich was also released in 1976. |\n| The song‚Äôs catchy chorus and upbeat tempo made it a popular hit of the 1970s, |\n| and it remains a well-known and beloved track from that era. |\n| The song‚Äôs success helped to establish Arrows as a popular band of the time, |\n| and it continues to be played on classic rock and oldies radio stations today. | |\n| \\\\cdashline2-2 | |     |\n| --- |\n| The flag of Libya is a plain rectangle of green color. \\\\usym2713 |\n| It was adopted in 1977 and features a green color field with no other symbols or designs. |\n| The color green is significant in the country‚Äôs history and culture, |\n| representing hope, fertility, and the country‚Äôs rich agricultural heritage. |\n| The flag is rectangular in shape and is often flown vertically. |\n| It is an important symbol of the Libyan state and is used in various official and ceremonial contexts. | |\n\nTable 7: Responses of different methods on TriviaQA dataset\n\n|     |     |     |\n| --- | --- | --- |\n| Question | |     |\n| --- |\n| Tom plants 10 trees a year. Every year he also chops down 2 trees a year. |\n| He starts with 50 trees. After 10 years 30% of the trees die. |\n| How many trees does he have left? | |\n| Gold Answer | |     |\n| --- |\n| He gets 10‚àí2=<<10‚àí2=8>>810-2=<<10-2=8>>8 new trees a year. |\n| After 10 years he has 8‚àó10=<<8‚àó10=80>>808\\*10=<<8\\*10=80>>80 new trees |\n| so he had 80+50=<<80+50=130>>13080+50=<<80+50=130>>130 trees |\n| He lost 130‚àó.3=<<130‚àó.3=39>>39130\\*.3=<<130\\*.3=39>>39 trees |\n| That means he had 130‚àí39=<<130‚àí39=91>>91130-39=<<130-39=91>>\\\\hbox{\\\\pagecolor{lightgreen}91} trees | |\n| LLaMA3 Response | |     |\n| --- |\n| Tom starts with 50 trees. |\n| He plants 10 trees a year, so after 10 years he has 50+10\\*10= 150 trees. |\n| However, he chops down 2 trees a year, so after 10 years he has 150-2\\*10= 140 trees. |\n| 30% of the trees die, which means 30/100\\*140= 42 trees die. |\n| Tom is left with 140-42= 98 trees. |\n| The answer is boxed{98} | |\n| LLaMA3.1 Response | |     |\n| --- |\n| Tom starts with 50 trees and plants 10 trees a year, so after 10 years he will have 50+10\\*10= 150 trees. |\n| However, he also chops down 2 trees a year, so after 10 years he will have 150-2\\*10= 140 trees. |\n| After 10 years, 30% of the trees die, so 30% of 140 is 0.3\\*140= 42 trees die. |\n| The number of trees Tom has left is 140-42= 98 trees. |\n| The answer is boxed{98} | |\n| Qwen2 Response | |     |\n| --- |\n| Tom starts with 50 trees and plants 10 trees a year, so after 10 years he will have 50+10\\*10= 150 trees. |\n| However, he also chops down 2 trees a year, so after 10 years he will have 150-2\\*10= 140 trees. |\n| After 10 years, 30% of the trees die, so 30% of 140 is 0.3\\*140= 42 trees die. |\n| The number of trees Tom has left is 140-42= 98 trees. |\n| The answer is boxed{98} | |\n| 2-models | LLM-Blender | |     |\n| --- |\n| Tom starts with 50 trees and plants 10 trees a year, so after 10 years he will have 50+10\\*10= 150 trees. |\n| However, he also chops down 2 trees a year, so after 10 years he will have 150-2\\*10= 140 trees. |\n| After 10 years, 30% of the trees die, so 30% of 140 is 0.3\\*140= 42 trees die. |\n| The number of trees Tom has left is 140-42= 98 trees. |\n| The answer is boxed{98} | |\n| GaC | |     |\n| --- |\n| Tom plants 10 trees a year and chops down 2 trees a year, |\n| so the net increase in trees each year is 10 - 2 = 8 trees. |\n| After 10 years, the total number of trees planted is 10 \\* 10 = 100 trees. |\n| The total number of trees chopped down is 2 \\* 10 = 20 trees. |\n| So the total number of trees after 10 years is 50 + 100 - 20 = 130 trees. |\n| If 30% of the trees die, then the number of trees that die is 30/100 \\* 130 = 39 trees. |\n| The number of trees left is 130 - 39 = 91 trees. |\n| The answer is boxed{91} | |\n| UniTE | |     |\n| --- |\n| Tom plants 10 trees a year, so in 10 years he plants 10\\*10 = 100 trees. |\n| He starts with 50 trees, so after planting 100 trees, he has 50+100 = 150 trees. |\n| Every year he chops down 2 trees, |\n| so in 10 years he chops down 2\\*10 = 20 trees. |\n| So, after 10 years, he has 150-20 = 130 trees. |\n| 30% of the trees die, so 30% of 130 trees is 0.3\\*130 = 39 trees. |\n| Therefore, after 30% of the trees die, he has 130-39 = 91 trees left. |\n| The answer is boxed{91} | |\n| 3-models | LLM-Blender | |     |\n| --- |\n| Tom starts with 50 trees and plants 10 trees a year, so after 10 years he will have 50+10\\*10= 150 trees. |\n| However, he also chops down 2 trees a year, so after 10 years he will have 150-2\\*10= 140 trees. |\n| After 10 years, 30% of the trees die, so 30% of 140 is 0.3\\*140= 42 trees die. |\n| The number of trees Tom has left is 140-42= 98 trees. |\n| The answer is boxed{98} | |\n| UniTE | |     |\n| --- |\n| Tom plants 10 trees a year and chops down 2 trees a year, |\n| so he has 10-2=8 more trees each year. |\n| After 10 years, he will have 8\\*10=80 more trees. |\n| He starts with 50 trees, so he will have 50+80=130 trees after 10 years. |\n| After 10 years, 30% of the trees die, so 30% of 130 trees die, which is 0.3\\*130=39 trees. |\n| Therefore, he will have 130-39=91 trees left. |\n| The answer is boxed{91} | |\n\nTable 8: Case study of UniTE and other ensembling methods on GSM8K\n\n[‚óÑ](https://ar5iv.org/html/2410.03776) [![ar5iv homepage](https://ar5iv.org/assets/ar5iv.png)](https://ar5iv.org/) [Feeling\\\\\n\\\\\nlucky?](https://ar5iv.org/feeling_lucky) [Conversion\\\\\n\\\\\nreport](https://ar5iv.org/log/2410.03777) [Report\\\\\n\\\\\nan issue](https://github.com/dginev/ar5iv/issues/new?template=improve-article--arxiv-id-.md&title=Improve+article+2410.03777) [View original\\\\\n\\\\\non arXiv](https://arxiv.org/abs/2410.03777) [‚ñ∫](https://ar5iv.org/html/2410.03778)",
  "sections": {
    "1 Introduction": {
      "content": "‚Ä†‚Ä†footnotetext: ‚Ä†‚Ä†\\\\dagger Corresponding authors.\n\nLarge language models (LLMs) have demonstrated remarkable performance across a wide range of tasks and have shown promising results in real-world applications (OpenAI, [2023]; Yang et al., [2024]; Dubey et al., [2024]). Given the diversity in data sources, model architectures, and training methods, LLMs exhibit varying strengths and weaknesses depending on the task at hand. Consequently, rather than relying solely on training an LLM from scratch, an alternative approach is to create an ensemble of LLMs. This method allows for leveraging the complementary advantages of different LLMs (Jiang et al., [2023b]; Lu et al., [2024]; Yu et al., [2024b]).\n\nExisting model ensembling methods can be broadly categorized into three types: output-level, probability-level, and training-level approaches. Output-level methods (Jiang et al., [2023b]; Lu et al., [2024]; Shnitzer et al., [2023]) aggregate the complete outputs of multiple candidate models. Probability-level methods (Huang et al., [2024]; Yu et al., [2024b]), integrate outputs based on probability distributions at each generation step through the intersection or union of the vocabulary. Training-level methods (Wan et al., [2024a]; Xu et al., [2024]) utilize output probability vectors as labels for richer information extraction during training. While output-level methods are constrained by the limitations of existing outputs, and training-level methods introduce additional computational overhead, probability-level methods have garnered particular attention.\n\nExisting methods for ensembling LLMs, such as DeePen(Huang et al., [2024]) and GaC(Yu et al., [2024b]), grapple with two significant challenges. First, these approaches concentrate solely on the ensembling technique, sidestepping the crucial discussion of which types of models can be effectively combined. This oversight is critical because LLMs with substantial differences in architecture, size, and tokenizer may be inherently incompatible, leading to potential incompatibilities that undermine the benefits of ensembling(Dong et al., [2023]; Lee et al., [2023]). Second, these methods tend to align the probabilities across the entire vocabulary at each generation step. Such a strategy introduces substantial computational overhead during inference, which hinders performance and efficiency.\n\nTo address these challenges, we conduct a thorough investigation into the factors that truly influence ensembling performance. Our empirical analysis identifies three key factors: model performance, vocabulary size, and response process. We evaluate multiple widely recognized LLMs across various benchmarks to explore ensembling from these perspectives. Our findings reveal several important insights: 1) Variations in performance levels among base LLMs significantly affect their compatibility for ensembling; 2) The impact of vocabulary size is marginal; and 3) Even when performance and vocabulary size are aligned across LLMs, substantial differences in the reasoning process in the response can hinder successful ensembling.\n\nBuilding on this analysis, we adopt a determine-then-ensemble strategy by starting with the best-performing LLM for target tasks, then iteratively selecting the next best-performing LLMs that meets ensembling criteria until the maximum number of models is reached or no further suitable candidates exist. Additionally, we seek to improve the efficiency and performance of ensembling. Instead of aligning the entire vocabulary of different LLMs, we propose the Union Top-kùëòkEnsembling (UniTE). UniTE constructs a union of the top-k tokens from each model and expands this set using each model‚Äôs tokenizer. This is followed by probability aggregation to determine the next token. UniTE avoids the need for auxiliary mapping matrices and full vocabulary alignment, respecting the unique tokenization of each base LLM. Extensive experiments demonstrate the effectiveness of UniTE across various tasks, consistently outperforming state-of-the-art LLM ensemble methods.\n\nOverall, our key contributions are: 1) We conduct an extensive analysis of existing model ensembling approaches and derive three significant insights. Building on these findings, we introduce a general model selection strategy for model ensembling;\n2) We propose a well-motivated model ensembling method that efficiently operates on the top-k candidate tokens rather than the entire vocabulary.\n3) Experiments demonstrate significant performance improvements, reduced operational tokens to less than 0.04% of current methods, and minimized latency to only 10 ms longer than the individual model, validating the effectiveness of our proposed approach.",
      "citations": [
        {
          "start_pos": 211,
          "end_pos": 225,
          "text": "OpenAI, [2023]",
          "paper_id": "bib.bib21",
          "single_citation": false,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 227,
          "end_pos": 246,
          "text": "Yang et al., [2024]",
          "paper_id": "bib.bib29",
          "single_citation": false,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 248,
          "end_pos": 268,
          "text": "Dubey et al., [2024]",
          "paper_id": "bib.bib8",
          "single_citation": false,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 642,
          "end_pos": 663,
          "text": "Jiang et al., [2023b]",
          "paper_id": "bib.bib14",
          "single_citation": false,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 665,
          "end_pos": 682,
          "text": "Lu et al., [2024]",
          "paper_id": "bib.bib20",
          "single_citation": false,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 684,
          "end_pos": 702,
          "text": "Yu et al., [2024b]",
          "paper_id": "bib.bib32",
          "single_citation": false,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 871,
          "end_pos": 892,
          "text": "Jiang et al., [2023b]",
          "paper_id": "bib.bib14",
          "single_citation": false,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 894,
          "end_pos": 911,
          "text": "Lu et al., [2024]",
          "paper_id": "bib.bib20",
          "single_citation": false,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 913,
          "end_pos": 936,
          "text": "Shnitzer et al., [2023]",
          "paper_id": "bib.bib22",
          "single_citation": false,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1026,
          "end_pos": 1046,
          "text": "Huang et al., [2024]",
          "paper_id": "bib.bib11",
          "single_citation": false,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1048,
          "end_pos": 1066,
          "text": "Yu et al., [2024b]",
          "paper_id": "bib.bib32",
          "single_citation": false,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1223,
          "end_pos": 1242,
          "text": "Wan et al., [2024a]",
          "paper_id": "bib.bib24",
          "single_citation": false,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1244,
          "end_pos": 1261,
          "text": "Xu et al., [2024]",
          "paper_id": "bib.bib28",
          "single_citation": false,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1630,
          "end_pos": 1650,
          "text": "Huang et al., [2024]",
          "paper_id": "bib.bib11",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        },
        {
          "start_pos": 1660,
          "end_pos": 1678,
          "text": "Yu et al., [2024b]",
          "paper_id": "bib.bib32",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        },
        {
          "start_pos": 2103,
          "end_pos": 2122,
          "text": "Dong et al., [2023]",
          "paper_id": "bib.bib7",
          "single_citation": false,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 2124,
          "end_pos": 2142,
          "text": "Lee et al., [2023]",
          "paper_id": "bib.bib17",
          "single_citation": false,
          "citation_type": null,
          "nearest_citations": null
        }
      ]
    },
    "2 Related Works": {
      "content": "Based on the sequence of inference and fusion processes, multiple model collaboration methods can be broadly classified into two categories: model ensembling (Jiang et al., [2023b]; Yu et al., [2024b]) and model merging (Yu et al., [2024a]; Akiba et al., [2024]). Model ensembling follows an inference-then-fusion approach, aiming to integrate the outputs of various models to achieve a more refined response. Conversely, model merging adopts a fusion-then-inference strategy, wherein different models are combined into a single model before inference. While model merging is typically applicable only to homologous models, our focus in this study is on the more general approach, namely model ensembling. We discuss different model ensembling methods as follows:\n\nOutput-Level Model Ensembling methods involve selecting multiple candidate models and utilizing their complete outputs for aggregation. For instance, Jiang et al. ( [2023b]) developed PairRanker, an additional ranking model, to evaluate and select the best candidate output. Similarly, Lu et al. ( [2024]) and Shnitzer et al. ( [2023]) designed a router that determines the most appropriate candidate model based on the given question. However, these approaches are restricted by the existing outputs and become ineffective if all options are incorrect. Some studies have addressed this by training fusion models to combine outputs (Jiang et al., [2023b]; Wang et al., [2024b]), which alleviates the limitation of relying solely on available candidates and often yields improved results. Nevertheless, achieving generalization with fusion models remains a significant challenge, as they may not fully utilize the probability information generated at each step.\n\nProbability-Level Model Ensembling methods focus on integrating outputs from different models by utilizing the probability distribution at each generation step. Cool-Fusion(Liu et al., [2024]) let each source LLM generate tokens until reaching common word boundaries, then jointly reranks the segments.\nHowever, this method relies on common word boundaries, limiting generation flexibility and diversity. Additionally, managing multiple source models can increase complexity. DeePen(Huang et al., [2024]), based on the principles of relative representation theory, transforms each model‚Äôs probability distribution from its individual space into a common relative space for aggregation, which is determined through the intersection of the models‚Äô vocabularies. On the other hand, GaC(Yu et al., [2024b]) constructs a mapping matrix that projects the probability vectors of multiple LLMs into the dimensional space of their union vocabulary, aggregating outputs to select the next token at each generation step. It is worth noting that all of these existing approaches operate on the entire vocabulary at every single step, resulting in significant computational overhead. In this work, we focus on the probability-level model ensembling without the need for additional training.\n\nTraining-Level Model Ensembling methods exemplified by FuseLLM(Wan et al., [2024a]), leverage output probability vectors from various models during the training process, using these vectors as labels instead of one-hot representations. This technique serves as a unique form of distillation, enabling the trained model to extract richer information from the probability outputs of the ensemble of teacher models. FuseCHAT(Wan et al., [2024b]) extends the framework of FuseLLM to fuse multiple chat LLMs with diverse architectures and scales. However, distillation is predominantly aimed at enhancing smaller models, which limits its effectiveness in further advancing larger models. On the other hand, EVA(Xu et al., [2024]) addresses vocabulary discrepancies by learning token alignment across different vocabularies, utilizing overlapping tokens for assistance. However, vocabulary alignment should involve both output embedding alignment and weight alignment, EVA achieves vocabulary alignment solely by solving the mapping matrix of output embeddings.\n\n![Refer to caption]Figure 1: The impact of performance disparity among models on ensemble effectiveness across different datasets and methods is examined. We compare these methods to the individual performances of LLaMA2 and Mistral, indicated by dashed lines.",
      "citations": [
        {
          "start_pos": 159,
          "end_pos": 180,
          "text": "Jiang et al., [2023b]",
          "paper_id": "bib.bib14",
          "single_citation": false,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 182,
          "end_pos": 200,
          "text": "Yu et al., [2024b]",
          "paper_id": "bib.bib32",
          "single_citation": false,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 221,
          "end_pos": 239,
          "text": "Yu et al., [2024a]",
          "paper_id": "bib.bib31",
          "single_citation": false,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 241,
          "end_pos": 261,
          "text": "Akiba et al., [2024]",
          "paper_id": "bib.bib1",
          "single_citation": false,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 915,
          "end_pos": 937,
          "text": "Jiang et al. ( [2023b]",
          "paper_id": "bib.bib14",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        },
        {
          "start_pos": 1051,
          "end_pos": 1069,
          "text": "Lu et al. ( [2024]",
          "paper_id": "bib.bib20",
          "single_citation": true,
          "citation_type": "others",
          "nearest_citations": null
        },
        {
          "start_pos": 1075,
          "end_pos": 1099,
          "text": "Shnitzer et al. ( [2023]",
          "paper_id": "bib.bib22",
          "single_citation": true,
          "citation_type": "others",
          "nearest_citations": null
        },
        {
          "start_pos": 1398,
          "end_pos": 1419,
          "text": "Jiang et al., [2023b]",
          "paper_id": "bib.bib14",
          "single_citation": false,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1421,
          "end_pos": 1441,
          "text": "Wang et al., [2024b]",
          "paper_id": "bib.bib27",
          "single_citation": false,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1900,
          "end_pos": 1918,
          "text": "Liu et al., [2024]",
          "paper_id": "bib.bib19",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        },
        {
          "start_pos": 2210,
          "end_pos": 2230,
          "text": "Huang et al., [2024]",
          "paper_id": "bib.bib11",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        },
        {
          "start_pos": 2510,
          "end_pos": 2528,
          "text": "Yu et al., [2024b]",
          "paper_id": "bib.bib32",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        },
        {
          "start_pos": 3069,
          "end_pos": 3088,
          "text": "Wan et al., [2024a]",
          "paper_id": "bib.bib24",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        },
        {
          "start_pos": 3428,
          "end_pos": 3447,
          "text": "Wan et al., [2024b]",
          "paper_id": "bib.bib25",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        },
        {
          "start_pos": 3712,
          "end_pos": 3729,
          "text": "Xu et al., [2024]",
          "paper_id": "bib.bib28",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        }
      ]
    },
    "3 Understanding Model Ensembling from Model Capacity, Vocabulary Size and Task": {
      "content": "Existing model ensembling approaches (Huang et al., [2024]; Yu et al., [2024b]) only focus on designing the model ensembling method, offering limited discussion on the selection of base models for ensembling.\nHowever, insights from prior research (Dong et al., [2023]; Lee et al., [2023]), indicate that not all model pairs are compatible to be combined, particularly when there are significant differences in size, vocabulary, and performance.\nIn our preliminary experiments, we explored various factors that might affect the performance of model ensembling, including model size (e.g., 3B/7B/8B/13B/70B), model architecture (dense/sparse), performance discrepancies, tokenization strategies (BPE/WordPiece), vocabulary size (e.g., 102K/64K/32K) and tasks variations (e.g., text generation/QA/multiple choices).\nFinally, we identified three representative factors for further analyses, including performance discrepancy, vocabulary size, and tasks variations.\n\n### 3.1 Impact of Model Performance Discrepancy\n\nTo investigate the impact of performance disparity on model ensembling, we select LLaMA2-13B-Chat and Mistral-7B-Instruct-v0.3 as base models, which show a significant performance gap across various tasks. We evaluated the GSM8K (Cobbe et al., [2021]), PIQA (Bisk et al., [2020]), ARC-C (Clark et al., [2018]), and NQ (Kwiatkowski et al., [2019]) datasets with three comparative methods.\n\nAs shown in Fig. [1]Figure 1 ‚Ä£ 2 Related Works ‚Ä£ Determine-Then-Ensemble: Necessity of Top-k Union for Large Language Model Ensembling\"), we found that when there is a significant performance disparity between models, LLM-Blender, which selects the optimal response from model candidates, is not suitable for model ensembling.\nSimilarly, for methods like DeePen and GaC, which are achieved through token probability averaging, a substantial performance gap also leads to certain performance drops. This observation is straightforward and easily understood, as lower-performing models may introduce noise and bias, adversely affecting overall effectiveness.\nNonetheless, it has been observed that DeePen and GaC consistently enhance the performance of less effective models when combined with a superior model. Although the resultant performance does not surpass that of the superior model, these methods can also serve as an alternative way for training-free knowledge distillation.\n\nTo further figure out how performance discrepancy impacts the ensembling, we then identify model pairs based on the GSM8K dataset with performance gaps of approximately 40% (LLaMA2-7B-Chat and Mistral-7B-Instruct-v0.3), 25% (LLaMA2-13b-Chat and Mistral-7B-Instruct-v0.3), 15% (OpenChat-3.5 and Mistral-7B-Instruct-v0.3), and less than 10% (LLaMA3-8B-Instruct and Qwen2-7B-Instruct).\nFig. [2]Figure 2 ‚Ä£ 3.1 Impact of Model Performance Discrepancy ‚Ä£ 3 Understanding Model Ensembling from Model Capacity, Vocabulary Size and Task ‚Ä£ Determine-Then-Ensemble: Necessity of Top-k Union for Large Language Model Ensembling\") shows that as the performance gap increases, the improvement from ensembling inferior models becomes more pronounced. In contrast, for superior models, the ensembling effect consistently falls below the baseline performance. When the performance difference is within 10%, ensembling may yield better results.\n\n![Refer to caption]Figure 2: The impact of performance differences on model ensembling effectiveness on GSM8K dataset. OOM represents out of memory issue.\n\nMoreover, it was observed that with the increase in vocabulary size, as exemplified by models such as LLaMA3 and Qwen2, whose vocabulary size exceeds 120K, approaches like DeePen, which depend on high-dimensional matrix operations, encounter heavy memory limitations that diminish their effectiveness.\n\nTakeaway I: Smaller performance gaps lead to greater gains from model ensembling.\n\n| Methods | Dataset |\n| GSM | PIQA |\n| DeepSeek-7B(102K) | 59.67 | 72.66 |\n| Mistral-7B(32K) | 56.48 | 80.63 |\n| LLM-Blender | 61.16 | 76.54 |\n| (+1.49) | (-4.09) |\n| DeePen(DeepSeek-7B) | 55.00 | 77.65 |\n| (-4.67) | (+4.99) |\n| DeePen(Mistral-7B) | 61.28 | 76.32 |\n| (+4.80) | (-4.31) |\n| \\\\cdashline1-3<br>Ours(DeepSeek-7B) | 62.77 | 81.81 |\n| (+3.10) | (+9.15) |\n| Ours(Mistral-7B) | 58.88 | 81.81 |\n| (+2.40) | (+1.18) |\n\n| Methods | Dataset |\n| MMLU | ARC-C |\n| DeepSeek-7B(102K) | 46.97 | 58.73 |\n| LLaMA2-13B(32K) | 49.61 | 51.53 |\n| LLM-Blender | 48.86 | 57.84 |\n| (-0.75) | (-0.89) |\n| DeePen(DeepSeek-7B) | 52.81 | 60.00 |\n| (+5.84) | (+1.27) |\n| DeePen(LLaMA2-13B) | 54.09 | 62.39 |\n| (+4.48) | (+10.86) |\n| \\\\cdashline1-3<br>Ours(DeepSeek-7B) | 48.90 | 60.16 |\n| (+1.93) | (+1.43) |\n| Ours(Mistral-7B) | 48.90 | 60.16 |\n| (-0.71) | (+8.63) |\n\n| Methods | Dataset |\n| NQ | ARC-C |\n| Mistral-7B(32K) | 24.25 | 74.49 |\n| Yi-6B(64K) | 22.55 | 73.21 |\n| LLM-Blender | 22.97 | 72.48 |\n| (-1.28) | (-2.01) |\n| DeePen(Mistral-7B) | 25.26 | 76.50 |\n| (+1.01) | (+1.01) |\n| DeePen(Yi-6B) | 22.80 | 77.86 |\n| (+0.25) | (+4.65) |\n| \\\\cdashline1-3<br>Ours(Mistral-7B) | 24.76 | 76.54 |\n| (+0.51) | (+2.05) |\n| Ours(Yi-6B) | 23.28 | 76.54 |\n| (+0.73) | (+3.33) |\n\nTable 1: The influence of vocabulary size on model ensembling effectiveness\n\n### 3.2 Influence of Vocabulary Size\n\nYu et al. ( [2024b]) found that large models employing different tokenization methods, such as BPE and BBPE, exhibit over 90% overlap in tokenizing Oxford 5000 common words. This indicates that tokenization methods have a marginal impact on model ensembling, leading us to focus on the effect of vocabulary size on ensemble performance.\nTo this end, we selected four models with varying vocabulary sizes that exhibit similar performance on certain datasets, namely LLaMA2-13B-Chat (vocabulary size: 32,000), Mistral-7B-Instruct-v0.3 (vocabulary size: 32,768), Yi-6B (vocabulary size: 64,000), and DeepSeek-LLM-7B-Chat (vocabulary size: 102,400).\n\n![Refer to caption]Figure 3: Token distribution of different models. We extract the top 15 words from the vocabulary of each model and apply a softmax processing to their corresponding logits.\n\nAs presented in Table [1]Table 1 ‚Ä£ 3.1 Impact of Model Performance Discrepancy ‚Ä£ 3 Understanding Model Ensembling from Model Capacity, Vocabulary Size and Task ‚Ä£ Determine-Then-Ensemble: Necessity of Top-k Union for Large Language Model Ensembling\"), existing methods demonstrate consistent performance irrespective of the gap in vocabulary size, thereby indicating that vocabulary size does not significantly influence the efficacy of model ensembling.\nTo elucidate the underlying causes, we conducted a manual analysis of 100 responses generated by various LLMs. Our investigation revealed that approximately 80% of the words in the responses were common words while the tokenization of these common words exhibited no discernible differences across the different LLMs. Therefore, the vocabulary size, as well as the tokenization strategy, exerts minimal influence on the performance of model ensembling.\nNotably, despite significant variations in vocabulary size, the ensembling results of models with similar performance suggest that when the performance gap between base models is within 10%, model ensembling may achieve better results than the baseline model, which is aligned with findings in Section [3.1]Impact of Model Performance Discrepancy ‚Ä£ 3 Understanding Model Ensembling from Model Capacity, Vocabulary Size and Task ‚Ä£ Determine-Then-Ensemble: Necessity of Top-k Union for Large Language Model Ensembling\").\nMore interestingly, results of evaluating DeepPen on the ARC-C dataset indicate that when model performances are comparable, ensembling inferior models can even outperform superior ones. This might imply that when performance differences are minimal, the selection of main base models does not necessarily need to prioritize those with superior performance.\nBesides, it is important to note that these findings related to the vocabulary and tokenization consistently apply to LLM-Blender, DeePen and our method, with the exception of GAC.\nWe will detail the reason in Section [4.2]Union top-ùëò ensembling ‚Ä£ 4 Methodology ‚Ä£ Determine-Then-Ensemble: Necessity of Top-k Union for Large Language Model Ensembling\").\n\nTakeaway II: The influence of vocabulary size for model ensembling is marginal.\n\n| Question | who wrote he ain‚Äôt heavy he‚Äôs my brother lyrics |\n| who was the ruler of england in 1616 |\n| Gold answer | Bob Russell |\n| James I |\n| LLaMA3 response | Bob Russell \\\\usym2713 |\n| James I \\\\usym2713 |\n| Qwen2 response | |     |\n| --- |\n| He Ain‚Äôt Heavy, He‚Äôs My Brother was written by Mike D‚ÄôAbo. \\\\usym2717 |\n| The song was originally recorded by the British singer-songwriter and released as a single in 1969. |\n| It became a hit and has since been covered by numerous artists. |\n| ‚ãØ‚ãØ\\\\cdots | |\n| \\\\cdashline2-2 | |     |\n| --- |\n| The ruler of England in 1616 was King James I. \\\\usym2713 |\n| He was the first monarch of the Stuart dynasty and reigned from March 24, 1603, until his death on July 19, 1625. |\n| ‚ãØ‚ãØ\\\\cdots | |\n| LLM-Blender response | |     |\n| --- |\n| He Ain‚Äôt Heavy, He‚Äôs My Brother was written by Mike D‚ÄôAbo. \\\\usym2717 |\n| The song was originally recorded by the British singer-songwriter and released as a single in 1969. |\n| It became a hit and has since been covered by numerous artists. |\n| ‚ãØ‚ãØ\\\\cdots | |\n| \\\\cdashline2-2 | |     |\n| --- |\n| The ruler of England in 1616 was King James I. \\\\usym2713 |\n| He was the first monarch of the Stuart dynasty and reigned from March 24, 1603, until his death on July 19, 1625. |\n| ‚ãØ‚ãØ\\\\cdots | |\n\nTable 2: Responses of different methods on NQ dataset.\n\n### 3.3 Task-Specific Challenges in Model Ensembling\n\nIn the aforementioned experiments, we identified an interesting phenomenon:\nEven when performance and vocabulary size are aligned across models, substantial differences in the response style can also hinder successful ensembling on specific tasks.\nFor example, LLaMA3-8B and Qwen2-7B exhibit comparable performance across various tasks. Existing ensembling approaches such as LLM-Blender have been shown to enhance outcomes on GSM8K and PIQA tasks when utilizing these two base models. However, ensembling these models to address the questions in TriviaQA and NQ datasets proves to be impractical due to the significant discrepancies in their response styles.\n\nAs shown in Table [2]Table 2 ‚Ä£ 3.2 Influence of Vocabulary Size ‚Ä£ 3 Understanding Model Ensembling from Model Capacity, Vocabulary Size and Task ‚Ä£ Determine-Then-Ensemble: Necessity of Top-k Union for Large Language Model Ensembling\"), under identical prompting conditions, LLaMA3 tends to directly return the answers, whereas Qwen2 is inclined to conduct analysis. In voting-based LLM-Blender, response length significantly influences judgments, with PairRanker consistently favoring longer responses. For instance, in our analysis of 100 randomly selected NQ and TriviaQA responses, the PairRanker favored the longer response as the answer in approximately 80% and 70% of cases accordingly, possibly due to its training data characteristics. More detailed analysis of TriviaQA and more experimental results are in appendix [A]Appendix A Appendix ‚Ä£ Determine-Then-Ensemble: Necessity of Top-k Union for Large Language Model Ensembling\"). Similarly, probability-based ensembling methods like DeePen and GaC are also affected by the differences in the reasoning process, leading to significant deviations in vocabulary probability distributions. Figure [3]Figure 3 ‚Ä£ 3.2 Influence of Vocabulary Size ‚Ä£ 3 Understanding Model Ensembling from Model Capacity, Vocabulary Size and Task ‚Ä£ Determine-Then-Ensemble: Necessity of Top-k Union for Large Language Model Ensembling\") reveals a significant disparity in top token distributions between LLaMA3 and Qwen2 for the first two tokens. Averaging the probabilities directly could result in an excessively smoothed distribution, which is inappropriate.\nThe underlying reason for this phenomenon may be the differences in LLMs‚Äô training data. Therefore, caution is warranted in specific tasks to avoid substantial disparities, despite effective ensembling in most other tasks.\n\nTakeaway III: Even though the performance and vocabulary size are aligned across models, substantial differences in response style could also hinder successful ensembling.",
      "citations": [
        {
          "start_pos": 38,
          "end_pos": 58,
          "text": "Huang et al., [2024]",
          "paper_id": "bib.bib11",
          "single_citation": false,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 60,
          "end_pos": 78,
          "text": "Yu et al., [2024b]",
          "paper_id": "bib.bib32",
          "single_citation": false,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 248,
          "end_pos": 267,
          "text": "Dong et al., [2023]",
          "paper_id": "bib.bib7",
          "single_citation": false,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 269,
          "end_pos": 287,
          "text": "Lee et al., [2023]",
          "paper_id": "bib.bib17",
          "single_citation": false,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1241,
          "end_pos": 1261,
          "text": "Cobbe et al., [2021]",
          "paper_id": "bib.bib6",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": [
            "bib.bib5",
            "bib.bib2"
          ]
        },
        {
          "start_pos": 1270,
          "end_pos": 1289,
          "text": "Bisk et al., [2020]",
          "paper_id": "bib.bib4",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        },
        {
          "start_pos": 1299,
          "end_pos": 1319,
          "text": "Clark et al., [2018]",
          "paper_id": "bib.bib5",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": [
            "bib.bib6",
            "bib.bib2"
          ]
        },
        {
          "start_pos": 1330,
          "end_pos": 1356,
          "text": "Kwiatkowski et al., [2019]",
          "paper_id": "bib.bib16",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        },
        {
          "start_pos": 5230,
          "end_pos": 5249,
          "text": "Yu et al. ( [2024b]",
          "paper_id": "bib.bib32",
          "single_citation": true,
          "citation_type": "others",
          "nearest_citations": null
        }
      ]
    },
    "4 Methodology": {
      "content": "### 4.1 Model selection strategy\n\nGiven the aforementioned insights, we present a strategy to assess the compatibility of two models for ensembling and offer guidance for selecting base models from the candidate model pool.\n\nWhen ensembling two models, we begin by comparing their performance on the target tasks. An overall performance gap within 10% is desirable, as it indicates the potential compatibility for successful ensembling.\nIf the performance gap falls within this range, it is crucial to compare the response styles of different models. This comparison is relatively subjective, with differences often identifiable through superficial features such as text length and BLEU score.\n\nIn this work, we use text length as a guiding metric by constraining the length of longer responses to not exceed twice the length of the shorter ones. When the response manner is also consistent across models, it is highly probable that these two models can be successfully ensembled to produce a superior response.\nWe exclude discrepancies in vocabulary size from consideration, as prior analyses have demonstrated its insignificance in affecting ensembling outcomes.\n\nTo select base models from the pool, we recommend initially choosing the best-performing model for the target tasks. Subsequently, select the next best-performing model that satisfies the criteria for successful ensembling with the first chosen model, continuing this process iteratively until the maximum number of base models is reached or no further suitable models can be found.\n\n### 4.2 Union top-kùëòk ensembling\n\nApart from the model selection strategy, we also endeavor to improve the efficiency and performance of model ensembling. Existing probability-level model ensembling methods, e.g. DeePen and GaC, attempt to combine the models through full vocabulary alignment. We argue this approach is sub-optimal since the candidate next token typically resides within the top-k tokens. Conversely, incorporating tokens of lower probability may introduce unnecessary noise, thereby diminishing the overall accuracy and effectiveness of the ensemble. Motivated by this, we propose the Union Top-k Ensembling (UniTE), a novel and efficient ensembling approach that only aligns the top-k tokens in each decoding step.\n\nGiven the base models for ensembling, denoted as LLMi with their respective tokenizer TisuperscriptùëáùëñT^{i} and vocabulary VisuperscriptùëâùëñV^{i}, we feed the input text prompt into LLMi and obtain the probability distribution.\nInstead of aligning the probability distributions across different models, we only focus on the subset of top-kùëòk tokens since the candidate next token is highly likely to be within the subset. The selected top-kùëòk tokens of LLMi is presented as TopKi = (t1isubscriptsuperscriptùë°ùëñ1t^{i}\\_{1}, t2isubscriptsuperscriptùë°ùëñ2t^{i}\\_{2}, ‚Ä¶, tkisubscriptsuperscriptùë°ùëñùëòt^{i}\\_{k}) with corresponding probability distribution PisuperscriptùëÉùëñP^{i} = (p1isubscriptsuperscriptùëùùëñ1p^{i}\\_{1}, p2isubscriptsuperscriptùëùùëñ2p^{i}\\_{2}, ‚Ä¶, pkisubscriptsuperscriptùëùùëñùëòp^{i}\\_{k}).\n\nAlgorithm 1 Union top-kùëòk ensembling\n\n1:LLMi, Vocabulary Vi, Tokenizer Ti, Demonstration p‚Äãr‚Äão‚Äãm‚Äãp‚Äãtùëùùëüùëúùëöùëùùë°prompt, Stop condition s‚Äãt‚Äão‚Äãp‚Äã(\\*)ùë†ùë°ùëúùëù\\*stop(\\\\text{\\*})\n\n2:while not s‚Äãt‚Äão‚Äãp‚Äã(\\*)ùë†ùë°ùëúùëù\\*stop(\\\\text{\\*})do‚ñ∑‚ñ∑\\\\triangleright Stopping criteria\n\n3:     TopKi, PisuperscriptùëÉùëñP^{i}‚Üê‚Üê\\\\leftarrow LLMi(prompt)\n‚ñ∑‚ñ∑\\\\triangleright Generate top-kùëòk tokens and their probabilities\n\n4:for each model do\n\n5:if token wùë§w‚àà\\\\inVusuperscriptùëâùë¢V^{u} and wùë§w‚àà\\\\in TopKithen\n\n6:P{w}isubscriptsuperscriptùëÉùëñùë§P^{i}\\_{\\\\{w\\\\}} and TopKi remains unchanged.\n\n7:elseif token wùë§w‚àà\\\\inVusuperscriptùëâùë¢V^{u} and wùë§w‚àà\\\\inVisuperscriptùëâùëñV^{i} and wùë§w‚àâ\\\\notin TopKithen\n\n8:TopK^^ùêæ\\\\hat{K}i‚Üê‚Üê\\\\leftarrowwùë§w, P^isuperscript^ùëÉùëñ\\\\hat{P}^{i}‚Üê‚Üê\\\\leftarrowpwisubscriptsuperscriptùëùùëñùë§p^{i}\\_{w}\n\n9:elseif token wùë§w‚àà\\\\inVusuperscriptùëâùë¢V^{u} and wùë§w‚àâ\\\\notinVisuperscriptùëâùëñV^{i}then\n\n10:w1,‚Ä¶,wmsuperscriptùë§1‚Ä¶superscriptùë§ùëöw^{1},\\\\ldots,w^{m}‚Üê‚Üê\\\\leftarrowTi‚Äã(w)superscriptùëáùëñùë§T^{i}(w)\n\n11:TopK^^ùêæ\\\\hat{K}i‚Üê‚Üê\\\\leftarroww1superscriptùë§1w^{1}, P^isuperscript^ùëÉùëñ\\\\hat{P}^{i}‚Üê‚Üê\\\\leftarrowpw1isubscriptsuperscriptùëùùëñsuperscriptùë§1p^{i}\\_{w^{1}}\n\n12:endif\n\n13:endfor\n\n14:P^n‚Äão‚Äãr‚Äãmi=softmax‚Å°(P^i)subscriptsuperscript^ùëÉùëñùëõùëúùëüùëösoftmaxsuperscript^ùëÉùëñ\\\\hat{P}^{i}\\_{norm}=\\\\operatorname{softmax}(\\\\hat{P}^{i}), P^a‚Äãv‚Äãg=1n‚Äã‚àëi=1nP^n‚Äão‚Äãr‚Äãmisubscript^ùëÉùëéùë£ùëî1ùëõsuperscriptsubscriptùëñ1ùëõsubscriptsuperscript^ùëÉùëñùëõùëúùëüùëö\\\\hat{P}\\_{avg}=\\\\frac{1}{n}\\\\sum\\_{i=1}^{n}\\\\hat{P}^{i}\\_{norm}\n\n15:w=argmaxw‚ààT‚Äão‚Äãp‚ÄãK^i‚Äã(P^a‚Äãv‚Äãg)ùë§ùë§ùëáùëúùëùsubscript^ùêæùëñargmaxsubscript^ùëÉùëéùë£ùëîw=\\\\underset{w\\\\in Top{\\\\hat{K}}\\_{i}}{\\\\operatorname{argmax}}(\\\\hat{P}\\_{avg})‚ñ∑‚ñ∑\\\\triangleright Predict the next token\n\n16:prompt‚Üê‚Üê\\\\leftarrowprompt ++wùë§w‚ñ∑‚ñ∑\\\\triangleright Update input sequence\n\n17:endwhile\n\nNext, we aim to construct the union set Vusuperscriptùëâùë¢V^{u} of TopKi across the base models. The most straightforward solution to obtain the union set is to directly remove the duplicate tokens and retain all other distinct tokens. For the token in Vusuperscriptùëâùë¢V^{u} but not in VisuperscriptùëâùëñV^{i}, the probability of this token in LLMi is assigned to 0. This strategy is adopted by GAC(Yu et al., [2024b]). However, we contend that this strategy is not entirely reasonable since it is heavily influenced by the tokenizer and vocabulary.\nFor example, the candidate token ‚ÄúJames‚Äù is within the top-kùëòk subset of LLM1 but not in V2superscriptùëâ2V^{2} while the token ‚ÄúJam‚Äù appears in TopK2. The word ‚ÄúJames‚Äù can be tokenized into ‚ÄúJam‚Äù and ‚Äúes‚Äù by LLM2. If the token probabilities p{J‚Äãa‚Äãm}1subscriptsuperscriptùëù1ùêΩùëéùëöp^{1}\\_{\\\\{Jam\\\\}} and p{J‚Äãa‚Äãm‚Äãe‚Äãs}2subscriptsuperscriptùëù2ùêΩùëéùëöùëíùë†p^{2}\\_{\\\\{James\\\\}} are set to 0, the overall probability of generating the word ‚ÄúJames‚Äù should be inherently reduced, even if both base models exhibit a preference for this word. Therefore, we present a new token probability alignment strategy on the union set. Firstly, we obtain the top-kùëòk union vocabulary Vusuperscriptùëâùë¢V^{u} by directly merging the TopKi subsets. Then, the token distribution PisuperscriptùëÉùëñP^{i} and TopKi are updated according to following criteria:\n\n1. 1.\n\n\nIf the token wùë§w appears in both Vusuperscriptùëâùë¢V^{u} and TopKi, P{w}isubscriptsuperscriptùëÉùëñùë§P^{i}\\_{\\\\{w\\\\}} and TopKi remains unchanged.\n\n2. 2.\n\n\nIf the token wùë§w in Vusuperscriptùëâùë¢V^{u} is absent in TopKi but present in VisuperscriptùëâùëñV^{i}, it will be appended to TopKi. PisuperscriptùëÉùëñP^{i} also updates accordingly.\n\n3. 3.\n\n\nIf the token wùë§w in Vusuperscriptùëâùë¢V^{u} does not exist in VisuperscriptùëâùëñV^{i}, it should be tokenized by TisuperscriptùëáùëñT^{i}. The first token of the result along with its token probability is then updated to TopKi and PisuperscriptùëÉùëñP^{i}.\n\n\nUp to now, we can obtain the aligned top tokens TopK^^ùêæ\\\\hat{K}i and the token distributions P^isuperscript^ùëÉùëñ\\\\hat{P}^{i} of based models. Consequently, we normalize P^isuperscript^ùëÉùëñ\\\\hat{P}^{i} as: P^n‚Äão‚Äãr‚Äãmi=softmax‚Å°(P^i)subscriptsuperscript^ùëÉùëñùëõùëúùëüùëösoftmaxsuperscript^ùëÉùëñ\\\\hat{P}^{i}\\_{norm}=\\\\operatorname{softmax}(\\\\hat{P}^{i}).\n\nSince our method eliminates the need for full vocabulary alignment, it is essential to designate one model as the primary base model. As discussed in Section [3.2]Influence of Vocabulary Size ‚Ä£ 3 Understanding Model Ensembling from Model Capacity, Vocabulary Size and Task ‚Ä£ Determine-Then-Ensemble: Necessity of Top-k Union for Large Language Model Ensembling\"), the selection of primary base model is flexible when the candidate models exhibit comparable performance. To simplify the process, we directly employ the best-performing model as the primary base model. Then, the primary base model employs the average token probability P^a‚Äãv‚Äãgsubscript^ùëÉùëéùë£ùëî\\\\hat{P}\\_{avg} to predict the next token, where P^a‚Äãv‚Äãg=1n‚Äã‚àëi=1nP^n‚Äão‚Äãr‚Äãmisubscript^ùëÉùëéùë£ùëî1ùëõsuperscriptsubscriptùëñ1ùëõsubscriptsuperscript^ùëÉùëñùëõùëúùëüùëö\\\\hat{P}\\_{avg}=\\\\frac{1}{n}\\\\sum\\_{i=1}^{n}\\\\hat{P}^{i}\\_{norm}.\n\nThe next token is determined using the maximization-based greedy strategy (Li et al., [2016]). The chosen token will be appended to the input text. This process is iteratively repeated until the predetermined stopping criterion is met, such as generating an end-of-sentence token or reaching the maximum length.",
      "citations": [
        {
          "start_pos": 5148,
          "end_pos": 5166,
          "text": "Yu et al., [2024b]",
          "paper_id": "bib.bib32",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        },
        {
          "start_pos": 7970,
          "end_pos": 7987,
          "text": "Li et al., [2016]",
          "paper_id": "bib.bib18",
          "single_citation": true,
          "citation_type": "others",
          "nearest_citations": null
        }
      ]
    },
    "5 Experiments": {
      "content": "### 5.1 Setup\n\n#### Models\n\nAll of our experiments are conducted with the following commonly used models, including LLaMA2-7B-Chat (Touvron et al., [2023]), LLaMA2-13B-Chat (Touvron et al., [2023]), LLaMA3-8B-Instruct (Dubey et al., [2024]), LLaMA3.1-8B-Instruct (Dubey et al., [2024]), Mistral-7B-Instruct-v0.3 (Jiang et al., [2023a]), DeepSeek-LLM-7B-Chat (Bi et al., [2024]), Yi-6B (Young et al., [2024]), OpenChat-3.5 (Wang et al., [2024a]), Qwen2-7B-Instruct (Yang et al., [2024]), Mixtral-8√ó7B (Jiang et al., [2024]) and Qwen1.5-72B (Bai et al., [2023]).\n\n#### Baselines\n\nWe selected three typical model ensembling methods for further analyses.\n1) LLM-Blender(Jiang et al., [2023b]) includes a reward model, PairRanker, to evaluate LLM responses, and a fusion model, GenFuser, to combine them. We only use PairRanker due to significant over-generation issues with GenFuser.\n2) DeePen(Huang et al., [2024]) employs relative representation theory to map each model‚Äôs probability distribution to a universal space for aggregation, computed through the intersection of model vocabularies.\n3) GaC(Yu et al., [2024b]) projects multiple LLMs‚Äô probability vectors into a unified vocabulary dimension using a mapping matrix and aggregates outputs at each generation step to select the next token. Although GaC suggests the importance of identifying keywords to improve latency, we still exclude it owing to its hindrance on the ensembling performance.\n\n| Method | Dataset | Avg. |\n| GSM8K | PIQA | MMLU | ARC-C | TriviaQA | NQ |\n| Mistral | 56.48 | 80.63 | 59.28 | 74.49 | 64.30 | 24.25 | 59.91 |\n| DeepSeek | 59.67 | 72.66 | 46.97 | 58.73 | 47.63 | 11.37 | 49.51 |\n| OpenChat | 73.46 | 87.10 | 60.80 | 78.05 | 61.77 | 31.08 | 65.38 |\n| LLM-Blender | 70.79(-2.67) | 83.28(-3.82) | 60.10(-0.70) | 76.29(-1.76) | 56.35(-5.42) | 25.57(-5.51) | 62.06(-3.32) |\n| DeePen | 73.06(-0.40) | 76.04(-11.06) | 61.91(+1.11) | 72.14(-5.91) | 67.24(+5.47) | 28.26(-2.82) | 63.11(-2.27) |\n| GaC | 62.85(-10.61) | 67.85(-19.25) | 55.15(-5.65) | 73.04(-5.01) | 62.22(+0.45) | 20.72(-10.36) | 56.97(-8.41) |\n| UniTE | 73.31(-0.15) | 87.50(+0.40) | 62.13(+1.33) | 78.70(+0.65) | 65.80(+4.03) | 31.78(+0.70) | 66.54(+1.16) |\n\nTable 3: Results of ensembling on Mistral, DeepSeek, OpenChat. OpenChat is chosen as primary model for these experiments.\n\n| Method | Dataset | Avg. |\n| GSM8K | PIQA | ARC-C | MMLU |\n| LLaMA3 | 78.77 | 79.08 | 79.01 | 64.58 | 75.36 |\n| LLaMA3.1 | 80.83 | 82.86 | 79.49 | 66.69 | 77.47 |\n| Qwen2 | 80.78 | 84.57 | 84.92 | 64.96 | 78.81 |\n| Two-model ensembling (LLaMA3+Qwen2) |\n| LLM-Blender | 82.69 (+1.91) | 82.53 (-2.04) | 82.98 (-1.94) | 62.07 (-2.89) | 77.57 (-1.24) |\n| DeePen | \\- OOM - |\n| GaC | 80.67 (-0.11) | 80.96 (-3.61) | 84.93 (+0.01) | 67.05 (+2.09) | 78.40 (-0.41) |\n| UniTE | 84.17(+3.39) | 85.53(+0.96) | 85.07(+0.15) | 69.78(+4.82) | 81.14(+2.33) |\n| Three-model ensembling |\n| LLM-Blender | 83.30(+2.52) | 83.47(-1.10) | 83.48(-1.44) | 62.55(-2.41) | 78.20(-0.61) |\n| DeePen | \\- OOM - |\n| UniTE | 84.99(+4.21) | 84.98(+0.41) | 85.39(+0.47) | 69.12(+4.16) | 81.12(+2.31) |\n\nTable 4: Results of ensembling on LLaMA3, LLaMA3.1, Qwen2. Qwen2 is chosen as primary model for these experiments.\n\n#### Benchmarks\n\nWe evaluate six benchmarks, which can be categorized into three main groups. 1) Comprehensive Examination: MMLU (5-shot) (Hendrycks et al., [2021]), covering 57 subjects that humans typically learn; ARC-C (0-shot) (Clark et al., [2018]), collected from standardized natural science tests. 2) Reasoning Capabilities: GSM8K (Cobbe et al., [2021]) (4-shot), a dataset of high-quality problems at the grade school math level; PIQA (Bisk et al., [2020]) (0-shot), a commonsense reasoning dataset. 3) Knowledge Capacities: TriviaQA (5-shot) (Joshi et al., [2017]), compiled by Trivia enthusiasts; NaturalQuestion (NQ) (5-shot) (Kwiatkowski et al., [2019]), a question-answering corpus consisting of queries issued to the Google search engine.\n\nFor a comprehensive evaluation, we conduct two- and multi-model ensembling experiments on the aforementioned benchmarks. We select base models following the strategy presented in Section [4.1]Model selection strategy ‚Ä£ 4 Methodology ‚Ä£ Determine-Then-Ensemble: Necessity of Top-k Union for Large Language Model Ensembling\"). We choose two pairs from Mistral, Deepseek, and OpenChat for the two-model experiments. For the closely performing LLaMA3, LLaMA3.1, and Qwen2, we select LLaMA3 and Qwen2 for the two-model ensemble based on their release dates and subsequently employ all three models for the multi-model ensembling evaluations. The hyper-parameter kùëòk is set to 10 in this work. All experiments are conducted on 46G NVIDIA L40 GPUs.\n\n### 5.2 Main Results\n\nAs shown in Table [3]Table 3 ‚Ä£ Baselines ‚Ä£ 5.1 Setup ‚Ä£ 5 Experiments ‚Ä£ Determine-Then-Ensemble: Necessity of Top-k Union for Large Language Model Ensembling\") and Table [4]Table 4 ‚Ä£ Baselines ‚Ä£ 5.1 Setup ‚Ä£ 5 Experiments ‚Ä£ Determine-Then-Ensemble: Necessity of Top-k Union for Large Language Model Ensembling\"), we have following observations:\n\n(1) UniTE enhances individual model performance when the base models exhibit similar performance levels. As demonstrated, the ensemble of models such as OpenChat achieved an average improvement of approximately 1.2% across five benchmark tasks, including ARC-C and MMLU. However, in the GSM8K task, a 15% performance gap between DeepSeek and OpenChat led to a slight decline in overall performance, reinforcing our observation in Section [3.1]Impact of Model Performance Discrepancy ‚Ä£ 3 Understanding Model Ensembling from Model Capacity, Vocabulary Size and Task ‚Ä£ Determine-Then-Ensemble: Necessity of Top-k Union for Large Language Model Ensembling\") that ensemble methods are most effective when model performances are closely aligned. Furthermore, experiments with LLaMA3 and Qwen2 validated our approach, resulting in performance increases of 3.39% and 4.82% on the GSM8K and MMLU tasks, respectively.\n\n(2) UniTE demonstrates greater robustness and generality. Ensembling experiments with LLaMA3 and Qwen2 indicate that while LLM-Blender improves performance on the GSM8K dataset, it significantly underperforms compared to baseline models in the PIQA, ARC-C, and MMLU benchmarks. Specifically, Blender demonstrates a decline of 2.89% in the MMLU task, and this issue is exacerbated in ensembles with the baseline models OpenChat and Mistral, which exhibit relatively low baseline performance, leading to an average performance drop of 3.32%. Additionally, GaC fails to improve the performance of individual models across most tasks and exhibits a significant decline of over 10% when combined with Mistral and OpenChat. Furthermore, due to its intersection limitations, DeePen is ill-suited for ensembling with the LLaMA3 model, which requires handling a large vocabulary. In contrast, across tasks with comparable performance levels, UniTE achieves the highest improvements and overall performance across the board, with the exception of a slight under-performance relative to DeePen on TriviaQA. This outcome underscores the effectiveness and robustness of UniTE.\n\n(3) Collaborating with comparable LLMs does not necessarily yield better results. The ensembling experiments conducted with three models, following the integration of LLaMA3.1, demonstrate improved performance on the GSM8K and ARC-C benchmarks compared to the ensemble of LLaMA3 and Qwen2. However, this approach results in suboptimal outcomes on PIQA and MMLU. This observation is justified, as the analysis in Section [3.2]Influence of Vocabulary Size ‚Ä£ 3 Understanding Model Ensembling from Model Capacity, Vocabulary Size and Task ‚Ä£ Determine-Then-Ensemble: Necessity of Top-k Union for Large Language Model Ensembling\") indicates that while combining models with similar performance may enhance overall efficacy, such improvement is not guaranteed.\n\n![Refer to caption]Figure 4: Impact of the choice of hyperparameter kùëòk.\n\n![Refer to caption]Figure 5: Latency comparison of different methods. The darker the color, the greater the latency.\n\n### 5.3 Ablation study\n\n#### Effect of hyperparameter kùëòk selection\n\nTo investigate the impact of the hyperparameter kùëòk, we conducted experiments using the Mistral and OpenChat models on the TriviaQA and ARC-C datasets. As illustrated in Fig. [5]Figure 5 ‚Ä£ 5.2 Main Results ‚Ä£ 5 Experiments ‚Ä£ Determine-Then-Ensemble: Necessity of Top-k Union for Large Language Model Ensembling\"), increasing kùëòk from 5 to 10 enhances ensemble performance. However, further increasing kùëòk beyond 10 leads to either a slight decline or no change in performance. This finding supports our assertion that, in probability-level ensembling, aligning the entire vocabulary is unnecessary for predicting the next token.\n\n#### Effect of the next token selection strategy\n\nWe also explored the impact of deterministic decoding and top-kùëòk sampling (Fan et al., [2018]) on the next token emission. It is important to clarify that our UniTE focuses on the fact that, when predicting the next token, we only need to ensemble a subset of tokens rather than the entire vocabulary. In contrast, greedy decoding and top-kùëòk sampling emphasize how to determine the next token‚Äôs ID after the ensemble process is complete. To investigate this, we conducted experiments using LLaMA3.1 and Mistral on the PIQA and ARC-C datasets correspondingly. As shown in Figure [6]Figure 6 ‚Ä£ Effect of the next token selection strategy ‚Ä£ 5.3 Ablation study ‚Ä£ 5 Experiments ‚Ä£ Determine-Then-Ensemble: Necessity of Top-k Union for Large Language Model Ensembling\"), for these deterministic tasks, the maximization-based greedy method outperforms the random sampling approach, which aligns with intuition.\n\n![Refer to caption]Figure 6: Comparison among different decoding methods.\n\n### 5.4 Further Analysis\n\n#### Latency analysis\n\nFollowing the settings detailed in GaC(Yu et al., [2024b]), we recorded the latency (ms/token) of different methods. The data presented in Fig. [5]Figure 5 ‚Ä£ 5.2 Main Results ‚Ä£ 5 Experiments ‚Ä£ Determine-Then-Ensemble: Necessity of Top-k Union for Large Language Model Ensembling\") reveals significant differences in latency among the various methods. Notably, the latency of UniTE is 87.78 ms/token, which is substantially lower than that of DeePen and GaC, and only about 10 ms longer than that of the individual models.\n\n#### Tokens manipulated each step\n\nTable [6]Table 6 ‚Ä£ Tokens manipulated each step ‚Ä£ 5.4 Further Analysis ‚Ä£ 5 Experiments ‚Ä£ Determine-Then-Ensemble: Necessity of Top-k Union for Large Language Model Ensembling\") presents tokens manipulated at each step. Compared to DeePen and GaC, UniTE significantly reduces the number of tokens manipulated at each step, indicating its efficiency. As the vocabulary of the base model expands, the number of manipulated tokens of DeePen and GaC increases significantly, which not only increases the computational burden but may also lead to performance bottlenecks. Contrastly, UniTE is minimally affected, maintaining its effectiveness.\n\n| Base Model | Method | Tokens Manipulated Each Step |\n| --- | --- | --- |\n| Mistral(32678)+OpenChat(32002) | DeePen | 32000 |\n| GaC | 32770 |\n| UniTE | 14.46 |\n| LLaMA3(128256)+Qwen2(151646) | DeePen | 109566 |\n| GaC | 170336 |\n| UniTE | 14.43 |\n\nTable 5: Tokens manipulated at each step. It‚Äôs noteworthy that DeePen encountered out-of-memory issues when conducting LLaMA3 and Qwen2 ensembling.\n\n| Model | ARC-C | PIQA |\n| --- | --- | --- |\n| Qwen1.5-72B(Dense) | 69.03 | 73.83 |\n| Mixtral-8x7B(Sparse) | 73.98 | 74.59 |\n| UniTE | 78.84 | 81.88 |\n| (+4.86) | (+7.29) |\n\nTable 6: Ensemble learning of the dense LLM Qwen1.5-72B and the sparse MOE model Mixtral-8x7B.\n\n#### Ensemble of the dense model and the sparse model\n\nWe evaluate our method on the ensemble learning of the dense model and the sparse MoE model for reasoning and comprehensive examination tasks. Specifically, we utilize the widely-used large-scale dense model Qwen1.5-72B (Bai et al., [2023]) alongside the popular sparse MoE model Mixtral-8√ó7B (Jiang et al., [2024]) as our base models. As shown in Tabel [6]Table 6 ‚Ä£ Tokens manipulated each step ‚Ä£ 5.4 Further Analysis ‚Ä£ 5 Experiments ‚Ä£ Determine-Then-Ensemble: Necessity of Top-k Union for Large Language Model Ensembling\"), our UniTE achieves +4.86% and +7.29% performance on the ARC-C and PIQA datasets respectively, despite the base models already exhibiting high levels of performance.",
      "citations": [
        {
          "start_pos": 132,
          "end_pos": 154,
          "text": "Touvron et al., [2023]",
          "paper_id": "bib.bib23",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        },
        {
          "start_pos": 174,
          "end_pos": 196,
          "text": "Touvron et al., [2023]",
          "paper_id": "bib.bib23",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        },
        {
          "start_pos": 219,
          "end_pos": 239,
          "text": "Dubey et al., [2024]",
          "paper_id": "bib.bib8",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        },
        {
          "start_pos": 264,
          "end_pos": 284,
          "text": "Dubey et al., [2024]",
          "paper_id": "bib.bib8",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        },
        {
          "start_pos": 313,
          "end_pos": 334,
          "text": "Jiang et al., [2023a]",
          "paper_id": "bib.bib12",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        },
        {
          "start_pos": 359,
          "end_pos": 376,
          "text": "Bi et al., [2024]",
          "paper_id": "bib.bib3",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        },
        {
          "start_pos": 386,
          "end_pos": 406,
          "text": "Young et al., [2024]",
          "paper_id": "bib.bib30",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        },
        {
          "start_pos": 423,
          "end_pos": 443,
          "text": "Wang et al., [2024a]",
          "paper_id": "bib.bib26",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        },
        {
          "start_pos": 465,
          "end_pos": 484,
          "text": "Yang et al., [2024]",
          "paper_id": "bib.bib29",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        },
        {
          "start_pos": 501,
          "end_pos": 521,
          "text": "Jiang et al., [2024]",
          "paper_id": "bib.bib13",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        },
        {
          "start_pos": 540,
          "end_pos": 558,
          "text": "Bai et al., [2023]",
          "paper_id": "bib.bib2",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": [
            "bib.bib5",
            "bib.bib6"
          ]
        },
        {
          "start_pos": 666,
          "end_pos": 687,
          "text": "Jiang et al., [2023b]",
          "paper_id": "bib.bib14",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        },
        {
          "start_pos": 890,
          "end_pos": 910,
          "text": "Huang et al., [2024]",
          "paper_id": "bib.bib11",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        },
        {
          "start_pos": 1098,
          "end_pos": 1116,
          "text": "Yu et al., [2024b]",
          "paper_id": "bib.bib32",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        },
        {
          "start_pos": 3351,
          "end_pos": 3375,
          "text": "Hendrycks et al., [2021]",
          "paper_id": "bib.bib10",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        },
        {
          "start_pos": 3444,
          "end_pos": 3464,
          "text": "Clark et al., [2018]",
          "paper_id": "bib.bib5",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": [
            "bib.bib6",
            "bib.bib2"
          ]
        },
        {
          "start_pos": 3552,
          "end_pos": 3572,
          "text": "Cobbe et al., [2021]",
          "paper_id": "bib.bib6",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": [
            "bib.bib5",
            "bib.bib2"
          ]
        },
        {
          "start_pos": 3657,
          "end_pos": 3676,
          "text": "Bisk et al., [2020]",
          "paper_id": "bib.bib4",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        },
        {
          "start_pos": 3765,
          "end_pos": 3785,
          "text": "Joshi et al., [2017]",
          "paper_id": "bib.bib15",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        },
        {
          "start_pos": 3851,
          "end_pos": 3877,
          "text": "Kwiatkowski et al., [2019]",
          "paper_id": "bib.bib16",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        },
        {
          "start_pos": 8920,
          "end_pos": 8938,
          "text": "Fan et al., [2018]",
          "paper_id": "bib.bib9",
          "single_citation": true,
          "citation_type": "others",
          "nearest_citations": null
        },
        {
          "start_pos": 9913,
          "end_pos": 9931,
          "text": "Yu et al., [2024b]",
          "paper_id": "bib.bib32",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        },
        {
          "start_pos": 12014,
          "end_pos": 12032,
          "text": "Bai et al., [2023]",
          "paper_id": "bib.bib2",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": [
            "bib.bib6",
            "bib.bib5"
          ]
        },
        {
          "start_pos": 12087,
          "end_pos": 12107,
          "text": "Jiang et al., [2024]",
          "paper_id": "bib.bib13",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        }
      ]
    },
    "6 Conclusion": {
      "content": "In conclusion, our research highlights the effectiveness of ensemble methods in enhancing the performance of LLMs. By examining existing techniques, we identified key factors influencing ensembling success, such as model performance and response processes, while finding that vocabulary size has a minimal impact. In addition, the issue of vocabulary redundancy exposed by existing methods during ensembling lead us to propose UniTE, which efficiently aggregates a bunch of tokens from multiple LLMs without the computational overhead. Through extensive experimentation, UniTE consistently outperformed state-of-the-art ensemble methods, demonstrating its effectiveness in leveraging the strengths of diverse LLMs. Our contributions not only advance the understanding of model ensembling but also provide a practical framework for selecting and integrating LLMs to achieve superior performance.",
      "citations": []
    }
  },
  "references": {
    "data": {
      "bib.bib2": {
        "id": "bib.bib2",
        "citation": "Bai et al. (2023)",
        "authors": "",
        "year": "",
        "title": "Qwen technical report.",
        "venue": "arXiv preprint arXiv:2309.16609",
        "pages": "",
        "url": "",
        "arxiv_id": "2309.16609",
        "doi": null,
        "sections": {},
        "abstract": "Large language models (LLMs) have revolutionized the field of artificial\nintelligence, enabling natural language processing tasks that were previously\nthought to be exclusive to humans. In this work, we introduce Qwen, the first\ninstallment of our large language model series. Qwen is a comprehensive\nlanguage model series that encompasses distinct models with varying parameter\ncounts. It includes Qwen, the base pretrained language models, and Qwen-Chat,\nthe chat models finetuned with human alignment techniques. The base language\nmodels consistently demonstrate superior performance across a multitude of\ndownstream tasks, and the chat models, particularly those trained using\nReinforcement Learning from Human Feedback (RLHF), are highly competitive. The\nchat models possess advanced tool-use and planning capabilities for creating\nagent applications, showcasing impressive performance even when compared to\nbigger models on complex tasks like utilizing a code interpreter. Furthermore,\nwe have developed coding-specialized models, Code-Qwen and Code-Qwen-Chat, as\nwell as mathematics-focused models, Math-Qwen-Chat, which are built upon base\nlanguage models. These models demonstrate significantly improved performance in\ncomparison with open-source models, and slightly fall behind the proprietary\nmodels."
      },
      "bib.bib5": {
        "id": "bib.bib5",
        "citation": "Clark et al. (2018)",
        "authors": "",
        "year": "",
        "title": "Think you have solved question answering? try arc, the AI2 reasoning challenge.",
        "venue": "CoRR",
        "pages": "",
        "url": "http://arxiv.org/abs/1803.05457",
        "arxiv_id": "1803.05457",
        "doi": null,
        "sections": {},
        "abstract": "We present a new question set, text corpus, and baselines assembled to\nencourage AI research in advanced question answering. Together, these\nconstitute the AI2 Reasoning Challenge (ARC), which requires far more powerful\nknowledge and reasoning than previous challenges such as SQuAD or SNLI. The ARC\nquestion set is partitioned into a Challenge Set and an Easy Set, where the\nChallenge Set contains only questions answered incorrectly by both a\nretrieval-based algorithm and a word co-occurence algorithm. The dataset\ncontains only natural, grade-school science questions (authored for human\ntests), and is the largest public-domain set of this kind (7,787 questions). We\ntest several baselines on the Challenge Set, including leading neural models\nfrom the SQuAD and SNLI tasks, and find that none are able to significantly\noutperform a random baseline, reflecting the difficult nature of this task. We\nare also releasing the ARC Corpus, a corpus of 14M science sentences relevant\nto the task, and implementations of the three neural baseline models tested.\nCan your model perform better? We pose ARC as a challenge to the community."
      },
      "bib.bib6": {
        "id": "bib.bib6",
        "citation": "Cobbe et al. (2021)",
        "authors": "",
        "year": "",
        "title": "Training verifiers to solve math word problems.",
        "venue": "CoRR",
        "pages": "",
        "url": "https://arxiv.org/abs/2110.14168",
        "arxiv_id": "2110.14168",
        "doi": null,
        "sections": {
          "1 Introduction": {
            "content": "In recent years, large language models have demonstrated impressive skills across many diverse tasks (Wang et al., [2019]), Brown et al., [2020])). Kaplan et al.( [2020])) describe the consistent benefits of increasing model size, characterizing scaling trends that hold across many orders of magnitude. However, even the largest models falter when required to perform multi-step mathematical reasoning (Hendrycks et al., [2021])). Model samples frequently contain catastrophic mistakes, even after the model has been appropriately finetuned. Mathematical reasoning thus reveals a critical weakness in modern language models.\n\nOne significant challenge in mathematical reasoning is the high sensitivity to individual mistakes (Shen et al., [2021a])). When generating a solution, autoregressive models have no mechanism to correct their own errors. Solutions that veer off-course quickly become unrecoverable. If we rely purely on generative methods and extrapolate from current trends, we will require an exorbitant parameter count to achieve even moderate performance on distributions as challenging as the MATH dataset (Hendrycks et al., [2021])). This evidence strongly motivates the search for methods with more favorable scaling laws.\n\nWe propose training verifiers to evaluate the correctness of model generated solutions, similar to concurrent work by Shen et al.( [2021a])). At test time, we sample a fixed number of candidate solutions and select the solution ranked highest by the verifier. Verifiers benefit both from their inherent optionality and from verification being a simpler task than generation in general.\n\nTo facilitate research, we are releasing GSM8K, a dataset of 8.5K high quality problems at the grade school math level. We designed this dataset to have high linguistic diversity while relying on relatively simple grade school math concepts. State-of-the-art language models struggle to achieve high performance on this dataset, primarily due to the high diversity among problems. At the same time, GSM8K solutions depend only on elementary concepts, so achieving high test performance is a tractable goal.\n\n![Refer to caption]Figure 1: Three example problems from GSM8K. Calculation annotations are highlighted in red.\n\nOur main contributions are as follows:\n\n1. 1.\n\n\nWe present a curated dataset of 8.5K grade school math questions and natural language solutions, useful for probing the informal reasoning ability of large language models.\n\n2. 2.\n\n\nWe show that, compared to a finetuning baseline, the use of verifiers results in approximately the same performance boost as a 30x model size increase, and that verifiers scale significantly better with increased data.\n\n3. 3.\n\n\nWe show that dropout acts as a strong regularizer, significantly improving performance for both finetuning and verification.",
            "citations": null
          },
          "2 Dataset": {
            "content": "GSM8K consists of 8.5K high quality grade school math problems created by human problem writers. We segmented these into 7.5K training problems and 1K test problems. These problems take between 2 and 8 steps to solve, and solutions primarily involve performing a sequence of elementary calculations using basic arithmetic operations (+‚Å£‚àí‚Å£√ó‚Å£√∑+-\\\\times\\\\div) to reach the final answer. A bright middle school student should be able to solve every problem.\n\nWe created GSM8K based on the following design principles.\n\n- ‚Ä¢\n\n\nHigh Quality We avoid error-prone scraping procedures and instead rely on human workers to create problems. After performing extensive quality control based on workers‚Äô answer agreement, we estimate that less than 2 percent of problems contain breaking errors.\n\n- ‚Ä¢\n\n\nHigh Diversity We strive for high diversity among problems. We actively avoid designing problems that are drawn from the same linguistic template or differ only in superficial details, an issue that is prevalent among many other datasets. By creating each individual problem to be relatively unique, held-out test performance becomes a far more relevant metric.\n\n- ‚Ä¢\n\n\nModerate Difficulty We choose a problem distribution that is challenging for large state-of-the-art language models, without being completely intractable. GSM8K will help us better understand the data scaling trends of different models and methods in this difficulty sweet spot. Problems require no concepts beyond the level of early Algebra, and the vast majority of problems can be solved without explicitly defining a variable.\n\n- ‚Ä¢\n\n\nNatural Language Solutions We collect solutions in natural language rather than as pure math expressions. We believe this is the most generally useful data format, and we expect it to shed light on the properties of large language models‚Äô internal monologues. We instructed problem writers to explain their work as much as possible, but we allowed them to write solutions in their own diverse linguistic styles.\n\n\nThe full GSM8K dataset can be found at [https://github.com/openai/grade-school-math]. Example problems are shown in [Figure1]In 1 Introduction ‚Ä£ Training Verifiers to Solve Math Word Problems\"), and we discuss additional dataset details in [AppendixA]Appendix A Dataset Details ‚Ä£ Training Verifiers to Solve Math Word Problems\").",
            "citations": null
          },
          "3 Related Work": {
            "content": "### 3.1 Related Datasets\n\nEarly math word problem datasets (Kushman et al., [2014]), Roy and Roth, [2015])) are relatively small and are not well suited for testing the limits of modern language models. Dolphin18K (Huang et al., [2016])) is a larger dataset containing 18K problems, but solutions are provided only in the form of equations or final answers. AQuA-RAT (Ling et al., [2017])) contains 100K problems, but this dataset unfortunately suffers from both a high degree of problem templatization and poor quality control of the natural language solutions. MathQA is a recently released subset of AQuA-RAT focused on correcting these mistakes (Amini et al., [2019])), but even the corrected dataset has data quality issues, with around 30% of the data having inconsistencies (Miao et al., [2021])). Ape210K (Zhao et al., [2020])) is the largest publicly available dataset, consisting of 210K Chinese elementary school-level math problems. However, due to the language barrier and the lack of natural language solutions, we‚Äôre unable to evaluate our methods on this dataset.\n\nThe recently developed ASDiv dataset (Miao et al., [2021])), which contains 2.3K math word problems, addresses common flaws in prior datasets by ensuring problems have both high diversity and high quality. We share those design principles in the creation of GSM8K. However, we note that GSM8K is larger, provides natural language solutions, and consists of problems that on average require more steps to solve. The MATH dataset (Hendrycks et al., [2021])) is larger and significantly more complex than GSM8K, but the high difficulty makes it challenging to accurately measure progress given the current capabilities of state-of-the-art language models.\n\nOther recent reasoning-related datasets have focused on mathematical reasoning on symbolic math (Lample and Charton, [2019])), reading comprehension (LogiQA) (Liu et al., [2020])), and commonsense question answering (CommonsenseQA) (Talmor et al., [2018])). Similar to CommonsenseQA, GSM8K includes questions that require basic background knowledge, like the number of days in a week. Similar to LogiQA, which requires a mix of reading comprehension and logical reasoning, GSM8K‚Äôs main difficulty lies in both properly interpreting a question and reasoning through the steps to solve it.\n\n### 3.2 Related Methods\n\nPrevious work has attempted to solve classic math word problem benchmarks with recurrent seq2seq models (Sutskever et al., [2014])) and closely related variants (Wang et al., [2017]), Huang et al., [2018])). More recent work has improved performance by designing specialized encoder-decoder architectures (Amini et al., [2019]), Chiang and Chen, [2018]), Xie and Sun, [2019]), Chen et al., [2020]), Li et al., [2020])), with the strongest results often relying on large pretrained encoders from the BERT family (Chen et al., [2019]), Kim et al., [2020]), Liang et al., [2021])).\n\nOther recent work has recommended additional pretraining tasks to further improve the math reasoning skills of large transformer-based models. Hendrycks et al.( [2021])) propose pretraining models on a new AMPS corpus, derived from Khan Academy problems and Mathematica scripts. Similarly, Shen et al.( [2021b])) propose a pretrained a corpus of pre-K to college level curricula extracted from the internet, and Peng et al.( [2021])) propose pretraining by predicting masked subexpressions from expression trees.\n\nSimilar to verification, other methods have finetuned a language model to select among many model completions. Nichols et al.( [2020])) proposed a sample-and-rank approach to improve the collaborative storytelling ability of large language models, with the training signal coming from the preferences of human workers. In concurrent work closely related to our own, Shen et al.( [2021a])) applied a similar approach to solving math word problems, jointly training a model to both generate and rank solutions. Our work shares many fundamental similarities with their approach, though we differ in several key respects. First, we focus attention on the space of natural language solutions, as this is a richer and more general solution format than pure mathematical expressions. Moreover, this choice enables our models to develop verbal analytical skills and to produce solutions that are more readily interpretable by humans. Second, we provide evidence that verifiers scale far more favorably with additional data than baseline methods. Finally, we use separate generator and verifier networks, in order to prevent the generator from overfitting.",
            "citations": null
          },
          "4 Methods": {
            "content": "![Refer to caption]\n\n![Refer to caption]\n\nFigure 2: Final test performance for various GPT-3 model sizes after finetuning on training sets of different sizes. Mean and standard deviation is shown across 3 runs.\n\nWe investigate two methods to solve problems in GSM8K: finetuning and verification. Finetuning, our baseline method, uses the same language modeling objective as the generative pretraining in GPT-3 (Brown et al., [2020])). At test time, we judge performance by autoregressively sampling a single low temperature solution and checking whether the final answer is correct. In contrast, verification consists of sampling multiple high temperature solutions, assigning each solution a score, and outputting the highest ranked solution. Verifiers are trained to judge the correctness of solutions, with the training signal determined solely by whether or not the solution reached the correct final answer.\n\nFor both methods, we use models from the GPT-3 family as our initialization, primarily focusing on the 175B and 6B model sizes. The 175B model is the largest and produces the most impressive results, while the 6B model is significantly more convenient for research purposes. We discuss hyperparameter choices in [AppendixB]Appendix B Hyperparameters ‚Ä£ Training Verifiers to Solve Math Word Problems\").\n\nOur models frequently fail to accurately perform calculations. Although larger models make fewer arithmetic mistakes than smaller models, this remains a common source of errors. To mitigate this issue, we train all models to use a calculator by injecting calculation annotations into the training set. At test time, a calculator will override sampling when the model chooses to use these annotations. Details can be found in [AppendixC]Appendix C Calculator Annotations ‚Ä£ Training Verifiers to Solve Math Word Problems\").\n\n![Refer to caption]\n\n![Refer to caption]\n\nFigure 3: Test solve rate after finetuning a 6B model on the full GSM8K training set, when the model is allowed to make 1 guess (left) or 100 guesses (right).\n\n### 4.1 Finetuning\n\nWe perform finetuning by updating model parameters to minimize the cross-entropy loss over all training tokens. [Figure2]In 4 Methods ‚Ä£ Training Verifiers to Solve Math Word Problems\") shows test performance after finetuning on training sets of varying sizes for 20 epochs. We visualize the same data both as a function of training set size and as a function of model size. Test performance is determined by a single low temperature (T=0ùëá0T=0) sample for each test problem. Unsurprisingly, we see that the 175B model significantly outperforms the smaller models. Assuming a log-linear trend, we can naively extrapolate these results to estimate that a model with 1016superscript101610^{16} parameters would be required to reach an 80%percent8080\\\\% solve rate, when using the full GSM8K training set. It is even harder to extrapolate along the data dimension, since performance does not appear to follow a log-linear trend. Nevertheless, it appears likely that the 175B model would require at least two additional orders of magnitude of training data to reach an 80%percent8080\\\\% solve rate.\n\nIn [Figure3]In 4 Methods ‚Ä£ Training Verifiers to Solve Math Word Problems\"), we show how 6B test performance varies over the course of 100 training epochs. We use test@N to denote the percentage of problems solved correctly at least once when allowing the model to make N separate guesses for each problem. We use a low temperature (T=0ùëá0T=0) to generate test@1 samples and we use a higher temperature (T=0.7ùëá0.7T=0.7) to generate test@100 samples. Both temperature values were chosen empirically to produce the best results. Test@1 performance improves approximately monotonically, even though we quickly begin overfitting on test loss. Unfortunately, test@100 performance degrades much more sharply than test@1 as we increase the number of epochs. This is to be expected: as the model repeatedly encounters the same data, it becomes increasingly uncalibrated and overconfident in its predictions. At test time, this overconfidence leads to poor coverage of the solution space, an effect which only becomes noticeable when we are considering multiple samples at test time.\n\nChoosing a model with good coverage is critical to successfully train verifiers. Empirically, we see that test@100 performance peaks within the first few epochs. For this reason, we use models trained for 2 epochs to generate samples for training verifiers. We provide several example solutions from 6B and 175B models in [AppendixD]Appendix D Example Model Solutions ‚Ä£ Training Verifiers to Solve Math Word Problems\"). We also note that it is important to allow the model to generate the full natural language solution before outputting a final answer. If we instead finetune a 6B model to directly output the final answer without any intermediate steps, performance drops drastically from 20.6% to 5.2%.\n\n![Refer to caption]Figure 4: A diagram of the verification training pipeline.\n\n### 4.2 Verification\n\nTo improve upon the finetuning baseline, we train verifiers to judge the correctness of model-generated solutions and search against these verifiers at test time. Conditioned on the problem and a candidate solution, the verifier outputs the probability that the solution is correct. Training solutions are labeled as correct or incorrect based solely on whether they reach the correct final answer. In practice, some solutions will reach the correct final answer using flawed reasoning, leading to false positives.\n\nAs shown in [Figure4]In 4.1 Finetuning ‚Ä£ 4 Methods ‚Ä£ Training Verifiers to Solve Math Word Problems\"), we train the verifier as follows:\n\n1. 1.\n\n\nFinetune a model (the ‚Äúgenerator‚Äù) for 2 epochs on the training set.\n\n2. 2.\n\n\nSample 100 completions from the generator for each training problem and label each solution as correct or incorrect.\n\n3. 3.\n\n\nTrain a verifier for a single epoch on this dataset.\n\n\nTraining for 2 epochs is enough for the generator to learn basic skills in this domain. We choose not to train for longer, since the diversity of generated solutions begins to collapse after this point, as shown in [Figure3]In 4 Methods ‚Ä£ Training Verifiers to Solve Math Word Problems\"). We train separate generator and verifier models to limit the generator‚Äôs training and prevent overfitting, but in principle, it should be possible to combine these models. Unless otherwise specified, we use the same model size for the generator and the verifier. In addition to predicting solution correctness, we also train the verifier with the same language modeling objective as the generator. This serves as a valuable auxiliary objective for the verifier. We discuss additional verifier training details in [AppendixE]Appendix E Verifier Details ‚Ä£ Training Verifiers to Solve Math Word Problems\").\n\n![Refer to caption]\n\n![Refer to caption]\n\nFigure 5: A comparison between finetuning and verification using 6B and 175B model sizes. Verification considers 100 solutions per problem. Mean and standard deviation is shown across 3 runs, except for 175B verification which shows only a single run.\n\nAt test time, we sample 100 completions to each test problem, rank them with the verifier, and then return the one with the highest verifier score. A comparison between verification and finetuning is shown in [Figure5]In 4.2 Verification ‚Ä£ 4 Methods ‚Ä£ Training Verifiers to Solve Math Word Problems\") for both the 6B and 175B model sizes. We find that it is not beneficial to use verification at low dataset sizes. We believe this is due to the pressure to overfit to the correct answer: with small datasets, overfitting to the correct answer happens faster than learning more generalizable properties of correct reasoning. However, once we use a sufficiently large dataset, we see a strong boost from verifiers. It‚Äôs interesting to note that the 175B verifiers ‚Äútake off‚Äù earlier than the 6B verifiers, requiring fewer training problems to surpass the finetuning baseline. See [AppendixD]Appendix D Example Model Solutions ‚Ä£ Training Verifiers to Solve Math Word Problems\") for example solutions found by verifiers and [AppendixF]Appendix F Verifier Visualization ‚Ä£ Training Verifiers to Solve Math Word Problems\") for a visualization of verifier confidence.\n\n![Refer to caption](a) Comparison between a verifier trained to predict correctness after every token (token-level) and one trained to predict correctness after only the final token (solution-level)\n\n![Refer to caption](b) Comparison between a verifier trained jointly to predict correctness and perform language modeling (joint) and one trained only to predict correctness (verification-only)\n\n![Refer to caption](c) Performance when varying the size of the generator and the verifier in isolation. Increasing the size of the generator has a larger impact than increasing the size of the verifier.\n\nFigure 6: Verification ablations\n\n### 4.3 Verification Ablations\n\nWe can either train verifiers to make a single scalar prediction conditioned on the entire generated solution, or to make a scalar prediction after each token in the solution. By default, we choose the latter, training verifiers to make predictions after each token. This can be viewed as a token-level value function. We compare these two methods in [Figure6(a)]In Figure 6 ‚Ä£ 4.2 Verification ‚Ä£ 4 Methods ‚Ä£ Training Verifiers to Solve Math Word Problems\"), respectively labeled ‚Äúsolution-level‚Äù and ‚Äútoken-level‚Äù.\n\nPredicting the value function at every token is a more challenging and noisier task than judging only the full completion. However, despite the initially slower training, the token-level verifier ultimately outperforms the solution-level verifier. Moreover, the token-level verifier is still improving late in training, whereas the solution-level verifier quickly shows signs of overfitting. We hypothesize that the full value function provides a useful auxiliary signal that encourages the model to judge the reasoning throughout solutions, rather than merely memorizing the correct final answer.\n\nIn [Figure6(b)]In Figure 6 ‚Ä£ 4.2 Verification ‚Ä£ 4 Methods ‚Ä£ Training Verifiers to Solve Math Word Problems\"), we ablate the objective used when training verifiers. As discussed in [Section4.2]Verification ‚Ä£ 4 Methods ‚Ä£ Training Verifiers to Solve Math Word Problems\"), we can optionally include a language modeling objective alongside the verification objective. We compare using both objectives to using only the verification objective. Although both are reasonable choices, including the language modeling objective is a strict improvement. This makes intuitive sense: better understanding this language distribution should only aid the verifier in discriminating between samples.\n\nIn [Figure6(c)]In Figure 6 ‚Ä£ 4.2 Verification ‚Ä£ 4 Methods ‚Ä£ Training Verifiers to Solve Math Word Problems\"), we separately ablate the model size of the generator and the verifier. We find that using a large generator with a small verifier performs significantly better than using a small generator with a large verifier. Verification is still remarkably effective, even when the verifier is much smaller than the generator. This suggests that the verifier may often be relying on relatively coarse heuristics to discriminate between solutions from a given generator, rather than attempting a more thorough form of verification.\n\n![Refer to caption](a) 6B verification test performance when given varying numbers of completions per problem to rank.\n\n![Refer to caption](b) 6B verification test performance when varying the number of top ranked samples allowed to vote on the answer.\n\nFigure 7: Performance as the amount of test time compute varies.",
            "citations": null
          },
          "5 Additional Experiments": {
            "content": "### 5.1 Test Time Compute\n\nAt test time, we can choose to generate arbitrarily many solutions to be judged by the verifier before selecting the highest ranked completion. [Figure7(a)]In Figure 7 ‚Ä£ 4.3 Verification Ablations ‚Ä£ 4 Methods ‚Ä£ Training Verifiers to Solve Math Word Problems\") shows how 6B verifier performance varies with the number of completions per test problem. At this scale, performance improves as we increase the number of completions up to 400. Beyond this point, performance start to decrease. This suggests that the benefits of search are eventually outweighed by the risk of finding adversarial solutions that fool the verifier. In general, we evaluate verifier test performance using 100 completions, since this captures most of the benefits of verification with a relatively modest compute cost.\n\nTo further increase performance, we can take a majority vote among the top verifier-ranked solutions instead of selecting only the single top solution. This voting process considers only the final answer reached by the individual solutions: the final answer selected is the one with the most votes. [Figure7(b)]In Figure 7 ‚Ä£ 4.3 Verification Ablations ‚Ä£ 4 Methods ‚Ä£ Training Verifiers to Solve Math Word Problems\") shows how performance varies as we allow a greater number of top samples to cast a vote. Unsurprisingly, when starting with a greater number of samples, we can afford to allow a greater number of samples to cast a vote. When we have only 100 samples, it is optimal to allow only the top 3-5 samples to cast a vote. When we have 3200 samples, it is approximately optimal to allow the top 30 to cast a vote.\n\n### 5.2 Regularization\n\n![Refer to caption](a) Finetuning\n\n![Refer to caption](b) Solution-level verifiers\n\n![Refer to caption](c) Token-level verifiers\n\nFigure 8: 6B finetuning and verification dropout ablations.\n\nWe find that both finetuning and verification strongly benefit from the use of dropout as a regularizer. Specifically, we apply residual dropout (Vaswani et al., [2017])) along the residual paths of each layer in the network. We use 20% dropout for all dropout experiments, chosen based on the results of a hyperparameters sweep. We note that GPT-3 models are not pretrained with dropout. For experiments involving dropout, we therefore perform additional pretraining with dropout before subsequently finetuning the models. This mitigates the distribution shift the model experiences during finetuning.\n\nWe first investigate the effect of dropout on finetuning across various training set sizes. [Figure8(a)]In Figure 8 ‚Ä£ 5.2 Regularization ‚Ä£ 5 Additional Experiments ‚Ä£ Training Verifiers to Solve Math Word Problems\") shows that dropout leads to a significant improvement over baseline. We next investigate the effect of dropout on verifiers, considering both the solution-level and token-level variants. In [Figure8(b)]In Figure 8 ‚Ä£ 5.2 Regularization ‚Ä£ 5 Additional Experiments ‚Ä£ Training Verifiers to Solve Math Word Problems\"), we see that dropout significantly improves solution-level verifiers, mitigating the overfitting that occurs in the unregularized baseline. Notably, using dropout with solution-level verifiers reaches a similar level of performance as token-level verifiers. In [Figure8(c)]In Figure 8 ‚Ä£ 5.2 Regularization ‚Ä£ 5 Additional Experiments ‚Ä£ Training Verifiers to Solve Math Word Problems\"), we apply dropout to token-level verifiers. Since token-level verifiers are already less susceptible to overfitting, it is no surprise that the impact of dropout is less significant. Nevertheless, we do still see a slight gain from training token-level verifiers with dropout. Note that we increase the batch size for token-level verifiers by a factor of 4, to better handle the more difficult objective and the noise from dropout.",
            "citations": null
          },
          "6 Conclusion": {
            "content": "We have seen that verification provides a significant performance boost relative to a finetuning baseline. On the full dataset, 6B verification slightly outperforms a finetuned 175B model, thereby offering a boost approximately equivalent to a 30x model size increase. We have also seen that token-level verifiers are less prone to overfitting than solution-level verifiers, and that all methods benefit from regularization with residual dropout. We expect verification to scale well to problem distributions that require more complex mathematical reasoning, and we hope GSM8K supports the development of new methods that scale even better.",
            "citations": null
          }
        },
        "abstract": "State-of-the-art language models can match human performance on many tasks,\nbut they still struggle to robustly perform multi-step mathematical reasoning.\nTo diagnose the failures of current models and support research, we introduce\nGSM8K, a dataset of 8.5K high quality linguistically diverse grade school math\nword problems. We find that even the largest transformer models fail to achieve\nhigh test performance, despite the conceptual simplicity of this problem\ndistribution. To increase performance, we propose training verifiers to judge\nthe correctness of model completions. At test time, we generate many candidate\nsolutions and select the one ranked highest by the verifier. We demonstrate\nthat verification significantly improves performance on GSM8K, and we provide\nstrong empirical evidence that verification scales more effectively with\nincreased data than a finetuning baseline."
      }
    },
    "key_map": {
      "2309.16609": "bib.bib2",
      "1803.05457": "bib.bib5",
      "2110.14168": "bib.bib6"
    }
  }
}