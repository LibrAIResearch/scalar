{
  "title": "Multi-Robot Motion Planning with Diffusion Models",
  "abstract": "Diffusion models have recently been successfully applied to a wide range of\nrobotics applications for learning complex multi-modal behaviors from data.\nHowever, prior works have mostly been confined to single-robot and small-scale\nenvironments due to the high sample complexity of learning multi-robot\ndiffusion models. In this paper, we propose a method for generating\ncollision-free multi-robot trajectories that conform to underlying data\ndistributions while using only single-robot data. Our algorithm, Multi-robot\nMulti-model planning Diffusion (MMD), does so by combining learned diffusion\nmodels with classical search-based techniques -- generating data-driven motions\nunder collision constraints. Scaling further, we show how to compose multiple\ndiffusion models to plan in large environments where a single diffusion model\nfails to generalize well. We demonstrate the effectiveness of our approach in\nplanning for dozens of robots in a variety of simulated scenarios motivated by\nlogistics environments. View video demonstrations in our supplementary\nmaterial, and our code at: https://github.com/yoraish/mmd.",
  "paper_id": "http://arxiv.org/abs/2410.03072v1",
  "markdown_content": "# Multi-Robot Motion Planning with Diffusion Models\n\nYorai Shaoul,  Itamar Mishani11footnotemark: 1,  Shivam Vats11footnotemark: 1,  Jiaoyang Li & Maxim Likhachev.\n\nRobotics Institute, School of Computer Science,\nCarnegie Mellon University.\n\n{yshaoul,imishani,svats,jiaoyanl,maxim}@cs.cmu.edu\n\nEqual contribution.\n\n###### Abstract\n\nDiffusion models have recently been successfully applied to a wide range of robotics applications for learning complex multi-modal behaviors from data. However, prior works have mostly been confined to single-robot and small-scale environments due to the high sample complexity of learning multi-robot diffusion models. In this paper, we propose a method for generating collision-free multi-robot trajectories that conform to underlying data distributions while using only single-robot data.\nOur algorithm, Multi-robot Multi-model planning Diffusion (MMD), does so by combining learned diffusion models with classical search-based techniques—generating data-driven motions under collision constraints.\nScaling further, we show how to compose multiple diffusion models to plan in large environments where a single diffusion model fails to generalize well. We demonstrate the effectiveness of our approach in planning for dozens of robots in a variety of simulated scenarios motivated by logistics environments. View video demonstrations in our supplementary material, and our code at:\n[https://github.com/yoraish/mmd](https://github.com/yoraish/mmd \"\").\n\n![[Uncaptioned image]](https://ar5iv.org/html/2410.03072/assets/figures/front_fig.png)\n\n## 1 Introduction\n\nMulti-robot motion planning (MRMP) is a fundamental challenge in many real-world applications where teams of robots have to work in close proximity to each other to complete their tasks.\nIn automated warehouses, for example, hundreds of mobile robots and robotic manipulators need to coordinate with each other to transport and exchange items while avoiding collisions. Learning motions from demonstrations can oftentimes allow robots to complete tasks they couldn’t otherwise, like navigating a region in a pattern frequently followed by human workers; however, it is unclear how to best incorporate demonstrations in MRMP. In fact, MRMP at its simplest form, where robots are only concerned with finding short trajectories between start and goal configurations, is already known to be computationally intractable (Hopcroft & Wilfong, [1986](https://ar5iv.org/html/2410.03072#bib.bib11 \"\"))—significantly harder than single-agent motion planning due to the complexity of mutual interactions between robots.\nAttempting to simplify the problem, various approximate formulations have been proposed in the literature. For example, a popular approach is to formulate the problem as a multi-agent path finding problem (MAPF) (Stern et al., [2019](https://ar5iv.org/html/2410.03072#bib.bib34 \"\")) by discretizing space and time. While the latest MAPF planners (Li et al., [2021](https://ar5iv.org/html/2410.03072#bib.bib18 \"\"); Okumura, [2024](https://ar5iv.org/html/2410.03072#bib.bib22 \"\")) can compute near-optimal plans and scale to hundreds of agents, they make strong assumptions, such as constant velocities and rectilinear movements that limit their real-world application and reduce their ability to generate complex behaviors learned from demonstrations.\n\nIn single-agent motion planning, methods that learn to plan from data (Xiao et al., [2022](https://ar5iv.org/html/2410.03072#bib.bib38 \"\")) have been widely used to circumvent similar limitations resulting from inaccurate models (Vemula et al., [2021](https://ar5iv.org/html/2410.03072#bib.bib37 \"\")), partial observability (Choudhury et al., [2018](https://ar5iv.org/html/2410.03072#bib.bib6 \"\")) and slow planning (Sohn et al., [2015](https://ar5iv.org/html/2410.03072#bib.bib30 \"\"); Qureshi et al., [2020](https://ar5iv.org/html/2410.03072#bib.bib24 \"\")).\nMore recently, diffusion models (DM) have emerged as the generative model of choice for learning visuomotor manipulation policies from demonstrations (Chi et al., [2024](https://ar5iv.org/html/2410.03072#bib.bib5 \"\")), motion planning (Carvalho et al., [2023](https://ar5iv.org/html/2410.03072#bib.bib3 \"\")), and reinforcement learning (Janner et al., [2022](https://ar5iv.org/html/2410.03072#bib.bib12 \"\")). However, there has been relatively little work on extending these ideas to multi-robot motion planning. This is due to the twin challenges of generating high quality multi-agent data and the _curse of dimensionality_, i.e., significantly higher sample complexity of learning multi-robot models.\n\nIn this paper, we propose a data-efficient and scalable multi-robot diffusion planning algorithm, Multi-robot Multi-model planning Diffusion (MMD), that addresses both these challenges by combining constraint-based MAPF planners with diffusion models.\nImportantly, our approach calls for learning only _single-robot diffusion models_, which does away with the difficulty of obtaining multi-robot interaction data and breaks the curse of dimensionality. MMD generates collision-free trajectories by _constraining_ single-robot diffusion models using our\nnovel spatio-temporal guiding functions and choosing constraint placement via strategies inspired by MAPF algorithms.\nOur contributions in this paper are threefold:\n\n- •\n\n\nWe propose a data-efficient framework for multi-robot diffusion planning inspired by constraint-based search algorithms.\n\n- •\n\n\nWe provide a comparative analysis of the performance of five MMD algorithms, each based on a different MAPF algorithm, shedding light on their applicability to coordinating robots leveraging diffusion models for planning.\n\n- •\n\n\nWe show that we can scale our approach to arbitrarily large and diverse maps by learning and composing multiple diffusion models for each robot.\n\n\nOur experimental results from varied motion planning problems in simulated scenarios motivated by logistics environments suggest that our approach scales favorably with both the number of agents and the size of the environment when compared to alternatives.\n\n## 2 Preliminary\n\nIn this section we define the MRMP problem and provide relevant background on constraint-based MAPF algorithms and on planning with diffusion models. Sec. [3](https://ar5iv.org/html/2410.03072#S3 \"3 Method ‣ Multi-Robot Motion Planning with Diffusion Models\") elaborates on how we combine these concepts to coordinate numerous robots that plan with diffusion models.\n\n### 2.1 Multi-Robot Motion Planning (MRMP)\n\nGiven n𝑛n robots ℛisubscriptℛ𝑖\\\\mathcal{R}\\_{i}, MRMP seeks a set of collision-free trajectories, one for each robot, that optimize a given objective function.\nLet 𝒮isuperscript𝒮𝑖\\\\mathcal{S}^{i} be the state space of a single robot and a state be 𝐬i:=\\[𝐪i,𝐪˙i\\]⊺∈𝒮iassignsuperscript𝐬𝑖superscriptsuperscript𝐪𝑖superscript˙𝐪𝑖⊺superscript𝒮𝑖\\\\mathbf{s}^{i}:=\\[\\\\mathbf{q}^{i},\\\\dot{\\\\mathbf{q}}^{i}\\]^{\\\\intercal}\\\\in\\\\mathcal{S}^{i} where 𝐪isuperscript𝐪𝑖\\\\mathbf{q}^{i} and 𝐪˙isuperscript˙𝐪𝑖\\\\dot{\\\\mathbf{q}}^{i} are the configuration and velocity of the robot.\nEach robot has an assigned start state 𝐬starti∈𝒮isubscriptsuperscript𝐬𝑖startsuperscript𝒮𝑖\\\\mathbf{s}^{i}\\_{\\\\text{start}}\\\\in\\\\mathcal{S}^{i} and binary termination (goal) condition 𝒯i:𝒮i→{0,1}:superscript𝒯𝑖→superscript𝒮𝑖01\\\\mathcal{T}^{i}:\\\\mathcal{S}^{i}\\\\to\\\\{0,1\\\\}.\nAn MRMP solution is a multi-robot trajectory 𝝉={𝝉1,⋯​𝝉n}𝝉superscript𝝉1⋯superscript𝝉𝑛\\\\boldsymbol{\\\\tau}=\\\\{\\\\boldsymbol{\\\\tau}^{1},\\\\cdots\\\\boldsymbol{\\\\tau}^{n}\\\\}, where 𝝉i:\\[0,Ti\\]→𝒮i:superscript𝝉𝑖→0superscript𝑇𝑖superscript𝒮𝑖\\\\boldsymbol{\\\\tau}^{i}:\\[0,T^{i}\\]\\\\to\\\\mathcal{S}^{i} represents the trajectory of robot ℛisubscriptℛ𝑖\\\\mathcal{R}\\_{i} over the time interval \\[0,Ti\\]0superscript𝑇𝑖\\[0,T^{i}\\], with Tisuperscript𝑇𝑖T^{i} being the terminal time. In practice, we uniformly discretize the time horizon into H𝐻H time steps and optimize over a sequence of states 𝝉i={𝐬1i,𝐬2i,…,𝐬Hi}superscript𝝉𝑖subscriptsuperscript𝐬𝑖1subscriptsuperscript𝐬𝑖2…subscriptsuperscript𝐬𝑖𝐻\\\\boldsymbol{\\\\tau}^{i}=\\\\{\\\\mathbf{s}^{i}\\_{1},\\\\mathbf{s}^{i}\\_{2},...,\\\\mathbf{s}^{i}\\_{H}\\\\}.\nSubscripts, e.g., 𝝉tisubscriptsuperscript𝝉𝑖𝑡\\\\boldsymbol{\\\\tau}^{i}\\_{t}, indicate indexing into a trajectory.\nEach trajectory 𝝉isuperscript𝝉𝑖\\\\boldsymbol{\\\\tau}^{i} must avoid collisions between robots and with obstacles in the environment.\nIn MRMP, robots share a workspace 𝒲𝒲\\\\mathcal{W} (i.e., 𝒲⊆ℝ3𝒲superscriptℝ3\\\\mathcal{W}\\\\subseteq\\\\mathbb{R}^{3} for general robots and 𝒲⊆ℝ2𝒲superscriptℝ2\\\\mathcal{W}\\\\subseteq\\\\mathbb{R}^{2} for robots on the plane) and occupy some volume or area within 𝒲𝒲\\\\mathcal{W}, which we denote as ℛi​(𝐪i)⊆𝒲subscriptℛ𝑖superscript𝐪𝑖𝒲\\\\mathcal{R}\\_{i}(\\\\mathbf{q}^{i})\\\\subseteq\\\\mathcal{W} for robot ℛisubscriptℛ𝑖\\\\mathcal{R}\\_{i} in configuration 𝐪isuperscript𝐪𝑖\\\\mathbf{q}^{i}.\n\nThe usual MRMP objective is to minimize the sum of the single-robot costs (e.g., the cumulative motion) across all robots.\nGeneral cost functions can be defined on the trajectories, and the objective then becomes 𝒥​(𝝉)=1n​∑i=1ncost​(𝝉i)𝒥𝝉1𝑛superscriptsubscript𝑖1𝑛costsuperscript𝝉𝑖\\\\mathcal{J}(\\\\boldsymbol{\\\\tau})=\\\\frac{1}{n}\\\\sum\\_{i=1}^{n}\\\\text{cost}(\\\\boldsymbol{\\\\tau}^{i}). When learning from data, we are interested in _data adherence_, i.e., the trajectories should match the underlying trajectory distribution. We define costdata​(𝝉)=1n​∑i=1ncostdata​(𝝉i)subscriptcostdata𝝉1𝑛superscriptsubscript𝑖1𝑛subscriptcostdatasuperscript𝝉𝑖\\\\text{cost}\\_{\\\\text{data}}(\\\\boldsymbol{\\\\tau})=\\\\frac{1}{n}\\\\sum\\_{i=1}^{n}\\\\text{cost}\\_{\\\\text{data}}(\\\\boldsymbol{\\\\tau}^{i}) to quantify how well, on average, trajectories in 𝝉𝝉\\\\boldsymbol{\\\\tau} follow their underlying data distribution. This metric is task-specific; we provide some examples in Sec. [4](https://ar5iv.org/html/2410.03072#S4 \"4 Experimental Analysis ‣ Multi-Robot Motion Planning with Diffusion Models\").\n\n### 2.2 Multi-Agent Path Finding (MAPF)\n\nThe MAPF problem, a simpler form of MRMP, seeks the shortest collision-free pathsΠ={𝝅1,𝝅2,⋯​𝝅n}Πsuperscript𝝅1superscript𝝅2⋯superscript𝝅𝑛\\\\Pi=\\\\{\\\\boldsymbol{\\\\pi}^{1},\\\\boldsymbol{\\\\pi}^{2},\\\\cdots\\\\boldsymbol{\\\\pi}^{n}\\\\} for n𝑛n agents on a graph. This graph approximates their configuration space, with vertices corresponding to configurations and edges to transitions. Each path𝝅i={𝐪1i,⋯​𝐪Hi}superscript𝝅𝑖subscriptsuperscript𝐪𝑖1⋯subscriptsuperscript𝐪𝑖𝐻\\\\boldsymbol{\\\\pi}^{i}=\\\\{\\\\mathbf{q}^{i}\\_{1},\\\\cdots\\\\mathbf{q}^{i}\\_{H}\\\\} is a trajectory without velocity that need not be dynamically feasible.\nIn MAPF studies, constraint-based algorithms have become popular due to their simplicity and scalability. These algorithms are effective, in part, because they avoid the complexity of the multi-agent configuration space by delegating planning to single-agent planners and avoid collision via constraints. For instance, if a configuration 𝐪isuperscript𝐪𝑖\\\\mathbf{q}^{i} for ℛisubscriptℛ𝑖\\\\mathcal{R}\\_{i} leads to a collision at time (or interval) t𝑡t, this can be prevented by applying the constraint set C={⟨ℛi,𝐪i,t⟩}𝐶subscriptℛ𝑖superscript𝐪𝑖𝑡C=\\\\{\\\\langle\\\\mathcal{R}\\_{i},\\\\mathbf{q}^{i},t\\\\rangle\\\\} to the path 𝝅isuperscript𝝅𝑖\\\\boldsymbol{\\\\pi}^{i}, thereby preventing the configuration from being used at that time.\nSeveral MAPF algorithms, including Prioritized Planning (PP) (Erdmann & Lozano-Perez, [1987](https://ar5iv.org/html/2410.03072#bib.bib8 \"\")) and Conflict-Based Search (CBS) (Sharon et al., [2015](https://ar5iv.org/html/2410.03072#bib.bib28 \"\")), use this mechanism to force single-agent planning queries to avoid states that would lead to collisions. We detail these methods in Sec. [3](https://ar5iv.org/html/2410.03072#S3 \"3 Method ‣ Multi-Robot Motion Planning with Diffusion Models\") and explain how, despite traditionally being used for MAPF, their principles can be applied to coordinating robots in continuous space that generate data-driven trajectories via diffusion models.\n\n### 2.3 Planning with Diffusion Models\n\nMotion planning diffusion models are generative models that learn a denoising process to recover a dynamically-feasible trajectory from noise (Carvalho et al., [2023](https://ar5iv.org/html/2410.03072#bib.bib3 \"\"); Janner et al., [2022](https://ar5iv.org/html/2410.03072#bib.bib12 \"\")). Given a dataset of multi-modal trajectories, diffusion models aim to generate new trajectories that follow the underlying distribution of the data. Additionally, these trajectories may be conditioned on a task objective 𝒪𝒪\\\\mathcal{O}, for example, goal condition and collision avoidance. Specifically, given a task objective 𝒪𝒪\\\\mathcal{O}, motion planning diffusion models aim to sample from the posterior distribution of trajectories:\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n|  |  | arg​max𝝉i⁡log⁡p​(𝝉i\\|𝒪)=arg​max𝝉i⁡(log⁡p​(𝒪\\|𝝉i)+log⁡p​(𝝉i))subscriptargmaxsuperscript𝝉𝑖𝑝conditionalsuperscript𝝉𝑖𝒪subscriptargmaxsuperscript𝝉𝑖𝑝conditional𝒪superscript𝝉𝑖𝑝superscript𝝉𝑖\\\\displaystyle\\\\operatorname\\*{arg\\\\,max}\\_{\\\\boldsymbol{\\\\tau}^{i}}\\\\log p(\\\\boldsymbol{\\\\tau}^{i}\\|\\\\mathcal{O})=\\\\operatorname\\*{arg\\\\,max}\\_{\\\\boldsymbol{\\\\tau}^{i}}\\\\left(\\\\log p(\\\\mathcal{O}\\|\\\\boldsymbol{\\\\tau}^{i})+\\\\log p(\\\\boldsymbol{\\\\tau}^{i})\\\\right) |  | (1) |\n|  |  | =arg​min𝝉i⁡(−log⁡p​(𝒪\\|𝝉i)−log⁡p​(𝝉i))=arg​min𝝉i⁡(𝒥​(𝝉i)−log⁡p​(𝝉i))absentsubscriptargminsuperscript𝝉𝑖𝑝conditional𝒪superscript𝝉𝑖𝑝superscript𝝉𝑖subscriptargminsuperscript𝝉𝑖𝒥superscript𝝉𝑖𝑝superscript𝝉𝑖\\\\displaystyle=\\\\operatorname\\*{arg\\\\,min}\\_{\\\\boldsymbol{\\\\tau}^{i}}\\\\left(-\\\\log p(\\\\mathcal{O}\\|\\\\boldsymbol{\\\\tau}^{i})-\\\\log p(\\\\boldsymbol{\\\\tau}^{i})\\\\right)=\\\\operatorname\\*{arg\\\\,min}\\_{\\\\boldsymbol{\\\\tau}^{i}}\\\\left(\\\\mathcal{J}(\\\\boldsymbol{\\\\tau}^{i})-\\\\log p(\\\\boldsymbol{\\\\tau}^{i})\\\\right) |  |\n\nThe first term of the objective, 𝒥​(𝝉i)𝒥superscript𝝉𝑖\\\\mathcal{J}(\\\\boldsymbol{\\\\tau}^{i}), can be interpreted as a standard motion planning objective (Carvalho et al., [2023](https://ar5iv.org/html/2410.03072#bib.bib3 \"\")), in which we try to minimize a cost function (or, equivalently, maximize a reward function). The second term, log⁡p​(𝝉i)𝑝superscript𝝉𝑖\\\\log p(\\\\boldsymbol{\\\\tau}^{i}), is the prior corresponding to the data adherence discussed in Sec. [2.1](https://ar5iv.org/html/2410.03072#S2.SS1 \"2.1 Multi-Robot Motion Planning (MRMP) ‣ 2 Preliminary ‣ Multi-Robot Motion Planning with Diffusion Models\").\n\nDiffusion models are a type of score-based model (Song et al., [2021](https://ar5iv.org/html/2410.03072#bib.bib33 \"\")), where the focus is on learning the score function (the gradient of the data distribution’s log-probability) rather than learning the probability distribution directly.\nThe score function is learned using denoising score matching, a technique for learning to estimate the score by gradually denoising noisy samples.\nThe diffusion inference process consists of a K𝐾K-step denoising process that takes a noisy trajectory 𝝉iKsuperscriptsuperscript𝝉𝑖𝐾{}^{K}\\\\boldsymbol{\\\\tau}^{i} and recovers a feasible trajectory 𝝉i0superscriptsuperscript𝝉𝑖0{}^{0}\\\\boldsymbol{\\\\tau}^{i}, which also follows the data distribution. We use the notation 𝝉i0,1𝝉i,⋯,K𝝉i{}^{0}\\\\boldsymbol{\\\\tau}^{i},^{1}\\\\boldsymbol{\\\\tau}^{i},\\\\cdots,^{K}\\\\boldsymbol{\\\\tau}^{i} to denote the evolution of the trajectory in the diffusion process.\nTo generate a trajectory 𝝉i0superscriptsuperscript𝝉𝑖0{}^{0}\\\\boldsymbol{\\\\tau}^{i} from a noise trajectory 𝝉iK∼𝒩​(𝟎,𝐈)similar-tosuperscriptsuperscript𝝉𝑖𝐾𝒩0𝐈{}^{K}\\\\boldsymbol{\\\\tau}^{i}\\\\sim\\\\mathcal{N}(\\\\mathbf{0},\\\\mathbf{I}), we use Langevin dynamics sampling (Ho et al., [2020](https://ar5iv.org/html/2410.03072#bib.bib9 \"\")), an iterative process that is a type of Markov Chain Monte Carlo method. At each denoising step k∈{K,…,1}𝑘𝐾…1k\\\\in\\\\{K,\\\\dots,1\\\\}, a trajectory-space mean μk−1isubscriptsuperscript𝜇𝑖𝑘1\\\\mu^{i}\\_{k-1} is sampled from the network μθsubscript𝜇𝜃\\\\mu\\_{\\\\theta}:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | μk−1i=μθ(k𝝉i)\\\\mu^{i}\\_{k-1}=\\\\mu\\_{\\\\theta}(^{k}\\\\boldsymbol{\\\\tau}^{i}) |  | (2) |\n\nNow, with the variance prescribed by a deterministic schedule {βk∣k∈{K,⋯,1}}conditional-setsubscript𝛽𝑘𝑘𝐾⋯1\\\\{\\\\beta\\_{k}\\\\mid k\\\\in\\\\{K,\\\\cdots,1\\\\}\\\\}, the next trajectory in the denoising sequence is sampled from the following distribution:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | 𝝉ik−1∼𝒩​(μk−1i+η​βk−1​∇𝝉𝒥​(μk−1i)⏟Guidance,βk−1)similar-tosuperscriptsuperscript𝝉𝑖𝑘1𝒩subscriptsuperscript𝜇𝑖𝑘1subscript⏟𝜂subscript𝛽𝑘1subscript∇𝝉𝒥superscriptsubscript𝜇𝑘1𝑖Guidancesubscript𝛽𝑘1{}^{k-1}\\\\boldsymbol{\\\\tau}^{i}\\\\sim\\\\mathcal{N}\\\\big{(}\\\\mu^{i}\\_{k-1}+\\\\underbrace{\\\\eta\\\\beta\\_{k-1}\\\\nabla\\_{\\\\boldsymbol{\\\\tau}}\\\\mathcal{J}(\\\\mu\\_{k-1}^{i})}\\_{\\\\text{Guidance}},\\\\beta\\_{k-1}\\\\big{)} |  | (3) |\n\nThe term ∇𝝉𝒥​(μk−1i)subscript∇𝝉𝒥superscriptsubscript𝜇𝑘1𝑖\\\\nabla\\_{\\\\boldsymbol{\\\\tau}}\\\\mathcal{J}(\\\\mu\\_{k-1}^{i}) is the gradient of additional trajectory-space objectives (described in Eq. [1](https://ar5iv.org/html/2410.03072#S2.E1 \"In 2.3 Planning with Diffusion Models ‣ 2 Preliminary ‣ Multi-Robot Motion Planning with Diffusion Models\")) imposed on the generation process. This term, also called _guidance_, can include multiple weighted cost components, each optimizing for a different objective. For instance, we can have 𝒥=λobj​𝒥obj+λsmooth​𝒥smooth𝒥subscript𝜆objsubscript𝒥objsubscript𝜆smoothsubscript𝒥smooth\\\\mathcal{J}=\\\\lambda\\_{\\\\text{obj}}\\\\mathcal{J}\\_{\\\\text{obj}}+\\\\lambda\\_{\\\\text{smooth}}\\\\mathcal{J}\\_{\\\\text{smooth}} to penalize trajectories in collision with objects via 𝒥objsubscript𝒥obj\\\\mathcal{J}\\_{\\\\text{obj}} and to encourage the trajectory to be dynamically feasible via 𝒥smoothsubscript𝒥smooth\\\\mathcal{J}\\_{\\\\text{smooth}}. We denote the trajectory generation process queried with a start state 𝐬startisubscriptsuperscript𝐬𝑖start\\\\mathbf{s}^{i}\\_{\\\\text{start}}, goal condition 𝒯isuperscript𝒯𝑖\\\\mathcal{T}^{i}, and costraint set C𝐶C (Sec. [3.1](https://ar5iv.org/html/2410.03072#S3.SS1 \"3.1 Constraints in Diffusion Models ‣ 3 Method ‣ Multi-Robot Motion Planning with Diffusion Models\")) as fθi​(𝐬starti,𝒯i,C)superscriptsubscript𝑓𝜃𝑖subscriptsuperscript𝐬𝑖startsuperscript𝒯𝑖𝐶f\\_{\\\\theta}^{i}(\\\\mathbf{s}^{i}\\_{\\\\text{start}},\\\\mathcal{T}^{i},C).\n\nInput:Starts, goal conditions, and single-robot diffusion models {𝐬starti,𝒯i,fθi}i=1nsubscriptsuperscriptsubscriptsuperscript𝐬𝑖startsuperscript𝒯𝑖subscriptsuperscript𝑓𝑖𝜃𝑛𝑖1\\\\left\\\\{\\\\mathbf{s}^{i}\\_{\\\\text{start}},\\\\mathcal{T}^{i},f^{i}\\_{\\\\theta}\\\\right\\\\}^{n}\\_{i=1}\n\nOutput:Trajectories 𝝉={𝝉i}i=1n𝝉subscriptsuperscriptsuperscript𝝉𝑖𝑛𝑖1\\\\boldsymbol{\\\\tau}=\\\\left\\\\{\\\\boldsymbol{\\\\tau}^{i}\\\\right\\\\}^{n}\\_{i=1}\n\nNroot←←subscript𝑁rootabsentN\\_{\\\\text{root}}\\\\leftarrow new CT node; Nroot.Ci←∅​∀i∈{1,⋯​n}formulae-sequencesubscript𝑁root←superscript𝐶𝑖for-all𝑖1⋯𝑛N\\_{\\\\text{root}}.C^{i}\\\\leftarrow\\\\emptyset\\\\;\\\\forall i\\\\in\\\\{1,\\\\cdots n\\\\}\n\nfor _i∈{1,⋯,n}𝑖1⋯𝑛i\\\\in\\\\left\\\\{1,\\\\cdots,n\\\\right\\\\}_ do\n\nCstrongi,Cweaki←∅,∅formulae-sequence←subscriptsuperscript𝐶𝑖strongsubscriptsuperscript𝐶𝑖weakC^{i}\\_{\\\\text{strong}},C^{i}\\_{\\\\text{weak}}\\\\leftarrow\\\\emptyset,\\\\emptyset// Empty constraints set.\n\nCstrongi←{⟨ℛi,Nroot.𝝉⟩}C^{i}\\_{\\\\text{strong}}\\\\leftarrow\\\\{\\\\langle\\\\mathcal{R}\\_{i},N\\_{\\\\text{root}}.\\\\boldsymbol{\\\\tau}\\\\rangle\\\\}// Avoid other robots.\n\nCweaki←{⟨ℛi,Nroot.𝝉⟩}C^{i}\\_{\\\\text{weak}}\\\\leftarrow\\\\{\\\\langle\\\\mathcal{R}\\_{i},N\\_{\\\\text{root}}.\\\\boldsymbol{\\\\tau}\\\\rangle\\\\}// Penalize collisions.\n\nNroot.𝝉i←fθi​(𝐬starti,𝒯i,Cstrongi∪Cweaki)formulae-sequencesubscript𝑁root←superscript𝝉𝑖subscriptsuperscript𝑓𝑖𝜃subscriptsuperscript𝐬𝑖startsuperscript𝒯𝑖subscriptsuperscript𝐶𝑖strongsubscriptsuperscript𝐶𝑖weakN\\_{\\\\text{root}}.\\\\boldsymbol{\\\\tau}^{i}\\\\leftarrow f^{i}\\_{\\\\theta}(\\\\mathbf{s}^{i}\\_{\\\\text{start}},\\\\mathcal{T}^{i},C^{i}\\_{\\\\text{strong}}\\\\cup C^{i}\\_{\\\\text{weak}})\n\nend for\n\nreturnNroot.𝝉formulae-sequencesubscript𝑁root𝝉N\\_{\\\\text{root}}.\\\\boldsymbol{\\\\tau}\n\nCT ←{Nroot}←absentsubscript𝑁root\\\\leftarrow\\\\left\\\\{N\\_{\\\\text{root}}\\\\right\\\\}// Initialize CT.\n\nwhile _CT ≠∅absent\\\\neq\\\\emptyset_ do\n\nN←arg​minN′∈CTnumConflicts(N′.𝝉)N\\\\leftarrow\\\\operatorname\\*{arg\\\\,min}\\\\limits\\_{N^{\\\\prime}\\\\in\\\\text{CT}}\\\\textnormal{{numConflicts}}(N^{\\\\prime}.\\\\boldsymbol{\\\\tau})\n\nRemove N𝑁N from CT\n\nif _N.𝛕formulae-sequence𝑁𝛕N.\\\\boldsymbol{\\\\tau} conflict-free_ then\n\nreturnN.𝝉formulae-sequence𝑁𝝉N.\\\\boldsymbol{\\\\tau}// Return if collision free.\n\n    end if\n\np,t,ℛi,ℛj←getOneConflict(N.𝝉)p,t,\\\\mathcal{R}\\_{i},\\\\mathcal{R}\\_{j}\\\\leftarrow\\\\textnormal{{getOneConflict}}(N.\\\\boldsymbol{\\\\tau})\n\nfor _k∈{i,j}𝑘𝑖𝑗k\\\\in\\\\{i,j\\\\}// Split N𝑁N; constrain conflicting robots._ do\n\nN′←N.copyformulae-sequence←superscript𝑁′𝑁copyN^{\\\\prime}\\\\leftarrow N.\\\\text{copy}\n\nN′.Ck←Ck∪{⟨ℛk,Sr​(p),𝐭⟩}formulae-sequencesuperscript𝑁′←superscript𝐶𝑘superscript𝐶𝑘subscriptℛ𝑘subscript𝑆𝑟𝑝𝐭N^{\\\\prime}.C^{k}\\\\leftarrow C^{k}\\\\cup\\\\{\\\\langle\\\\mathcal{R}\\_{k},S\\_{r}(p),\\\\mathbf{t}\\\\rangle\\\\}\n\nCweakk←{ℛk,⟨N′.𝝉⟩}C^{k}\\_{\\\\text{weak}}\\\\leftarrow\\\\{\\\\mathcal{R}\\_{k},\\\\langle N^{\\\\prime}.\\\\boldsymbol{\\\\tau}\\\\rangle\\\\}// Penalize collisions.\n\nN′.𝝉k←fθk(𝐬startk,𝒯k,N′.Ck∪Cweakk)N^{\\\\prime}.\\\\boldsymbol{\\\\tau}^{k}\\\\leftarrow f^{k}\\_{\\\\theta}(\\\\mathbf{s}^{k}\\_{\\\\text{start}},\\\\mathcal{T}^{k},N^{\\\\prime}.C^{k}{\\\\color\\[rgb\\]{0.5,0.5,0}\\\\cup C^{k}\\_{\\\\text{weak}}})\n\nCT ←←\\\\leftarrow CT ∪{N′}superscript𝑁′\\\\cup\\\\{N^{\\\\prime}\\\\}\n\n    end for\n\nend while\n\nAlgorithm 1MMD-CBS sketch. Colored lines are only in  MMD-PP,  MMD-ECBS\n\n![Refer to caption](https://ar5iv.org/html/2410.03072/assets/figures/mmd_figure/mmd_fig_colliding_paths.png)(a) Two robots aim to switch positions. Blindly generated single-robot trajectories collide.\n\n![Refer to caption](https://ar5iv.org/html/2410.03072/assets/figures/mmd_figure/mmd_fig_iter1_paths.png)\n\n![Refer to caption](https://ar5iv.org/html/2410.03072/assets/figures/mmd_figure/mmd_fig_itermiddle_paths.png)\n\n![Refer to caption](https://ar5iv.org/html/2410.03072/assets/figures/mmd_figure/mmd_fig_iterfinal_paths.png)\n\n(b) The diffusion denoising process for the left robot in (a), under a temporally-activated constraint (in red), yields multi-modal trajectories.\n\n![Refer to caption](https://ar5iv.org/html/2410.03072/assets/figures/mmd_figure/mmd_fig_iterfinal_paths_with_tails.png)(c) Collision-free solution.\n\nFigure 1: An illustration of how MMD-CBS generates collision-free trajectories with constrained diffusion models.\n\n## 3 Method\n\nWe present Multi-robot Multi-model planning Diffusion (MMD), an algorithm for flexibly scaling diffusion planning to multiple robots and long horizons using only single-robot data.\nMMD imposes constraints on diffusion models to generate collision-free trajectories, addressing three main questions: how, when, and where to impose them. First, we discuss integrating spatio-temporal constraints into the diffusion denoising process through guiding functions. Next, we introduce five MMD algorithms, each inspired by a MAPF algorithm regarding constraint placement and timing. Finally, we demonstrate how to sequence multiple models for long-horizon planning.\n\n### 3.1 Constraints in Diffusion Models\n\nAn intuitive and effective constraint for multi-robot motion planning in robotics is the sphere constraint111The sphere constraint generalizes the MAPF vertex constraint, as it constrains robots from visiting the point of collision itself instead of a single colliding configuration corresponding to a vertex in a graph. In MAPF, the point of collision and the graph vertex coincide.(Li et al., [2019](https://ar5iv.org/html/2410.03072#bib.bib17 \"\"); Shaoul et al., [2024b](https://ar5iv.org/html/2410.03072#bib.bib27 \"\")).\nIt is defined by a point p∈𝒲𝑝𝒲p\\\\in\\\\mathcal{W} and restricts robots from being closer to p𝑝p than a radius r∈ℝ𝑟ℝr\\\\in\\\\mathbb{R} at a certain time range 𝐭:=\\[t−Δ​t,t+Δ​t\\]assign𝐭𝑡Δ𝑡𝑡Δ𝑡\\\\mathbf{t}:=\\[t-\\\\Delta t,t+\\\\Delta t\\].\nThe sphere constraint can be imposed as a soft-constraint on a diffusion model by incorporating it in its guiding function 𝒥​(⋅)𝒥⋅\\\\mathcal{J}(\\\\cdot). This can be done by adding a cost term 𝒥csubscript𝒥c\\\\mathcal{J}\\_{\\\\text{c}} that repels the robots from the sphere’s center point p𝑝p. Let 𝝉iksuperscriptsuperscript𝝉𝑖𝑘{}^{k}\\\\boldsymbol{\\\\tau}^{i} be the generated trajectory for ℛisubscriptℛ𝑖\\\\mathcal{R}\\_{i} at step k𝑘k of the diffusion denoising process, and ⟨ℛi,Sr​(p),𝐭⟩subscriptℛ𝑖subscript𝑆𝑟𝑝𝐭\\\\langle\\\\mathcal{R}\\_{i},S\\_{r}(p),\\\\mathbf{t}\\\\rangle be a sphere constraint centered at p𝑝p with radius r𝑟r over time interval 𝐭𝐭\\\\mathbf{t}. The guidance cost term for ℛisubscriptℛ𝑖\\\\mathcal{R}\\_{i} can be defined as:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | 𝒥c(k𝝉ti):=∑t∈𝐭max(ϵ⋅r−d(ℛi(k𝝉ti),p), 0)\\\\mathcal{J}\\_{\\\\text{c}}(^{k}\\\\boldsymbol{\\\\tau}^{i}\\_{t}):=\\\\sum\\_{t\\\\in\\\\mathbf{t}}\\\\max\\\\left(\\\\epsilon\\\\cdot r-d\\\\left({\\\\mathcal{R}\\_{i}(^{k}\\\\boldsymbol{\\\\tau}^{i}\\_{t}),p}\\\\right),\\\\;0\\\\right) |  | (4) |\n\nwith d(ℛi(k𝝉ti),p)d\\\\left({\\\\mathcal{R}\\_{i}(^{k}\\\\boldsymbol{\\\\tau}^{i}\\_{t}),p}\\\\right) as the distance from point p𝑝p to ℛisubscriptℛ𝑖\\\\mathcal{R}\\_{i} at 𝝉tiksuperscriptsubscriptsuperscript𝝉𝑖𝑡𝑘{}^{k}\\\\boldsymbol{\\\\tau}^{i}\\_{t}, and ϵ≥1italic-ϵ1\\\\epsilon\\\\geq 1 a padding factor.\n\n### 3.2 Constraining Strategies\n\nTo determine _when_ and _where_ to apply constraints on diffusion models, MMD draws on MAPF strategies like CBS and PP. We propose five MMD variants, each inspired by a state-of-the-art search algorithm. Alg. [1](https://ar5iv.org/html/2410.03072#alg1 \"In Figure 1 ‣ 2.3 Planning with Diffusion Models ‣ 2 Preliminary ‣ Multi-Robot Motion Planning with Diffusion Models\") provides a summary of these methods and we elaborate upon them here.\n\nMMD-PP.\nPrioritized Planning sequentially plans paths for robots ℛi​∀i∈{1,…​n}subscriptℛ𝑖for-all𝑖1…𝑛\\\\mathcal{R}\\_{i}\\\\;\\\\forall\\\\;i\\\\in\\\\{1,\\\\dots n\\\\}. This ordering of robots is treated as a priority ordering in that, on each call, robot ℛisubscriptℛ𝑖\\\\mathcal{R}\\_{i} must generate a path 𝝅isuperscript𝝅𝑖\\\\boldsymbol{\\\\pi}^{i} that avoids all ℛjsubscriptℛ𝑗\\\\mathcal{R}\\_{j} that previously planned. Robot ℛisubscriptℛ𝑖\\\\mathcal{R}\\_{i} does so by respecting the constraints C:={⟨ℛi,𝐪i,t⟩∣ℛi​(𝐪i)∩ℛj​(𝝅tj)≠∅​∀t}assign𝐶conditional-setsubscriptℛ𝑖superscript𝐪𝑖𝑡subscriptℛ𝑖superscript𝐪𝑖subscriptℛ𝑗subscriptsuperscript𝝅𝑗𝑡for-all𝑡C:=\\\\{\\\\langle\\\\mathcal{R}\\_{i},\\\\mathbf{q}^{i},t\\\\rangle\\\\mid\\\\mathcal{R}\\_{i}(\\\\mathbf{q}^{i})\\\\cap\\\\mathcal{R}\\_{j}(\\\\boldsymbol{\\\\pi}^{j}\\_{t})\\\\neq\\\\emptyset\\\\;\\\\forall t\\\\}.\nTo translate this approach to trajectory generation with diffusion models, _MMD-PP_ represents robot volumes using spheres, as is common in robotics, and uses the sphere representation of higher-priority robots as sphere soft-constraints for lower-priority robots.\nSpecifically, let a high-priority robot ℛjsubscriptℛ𝑗\\\\mathcal{R}\\_{j} be modeled with Mjsubscript𝑀𝑗M\\_{j} spheres and pmjsubscriptsuperscript𝑝𝑗𝑚p^{j}\\_{m} and rmjsubscriptsuperscript𝑟𝑗𝑚r^{j}\\_{m} be the position and radius of the mthsuperscript𝑚thm^{\\\\text{th}} sphere at time t𝑡t. Then, lower-priority robot ℛisubscriptℛ𝑖\\\\mathcal{R}\\_{i} generates a trajectory under the constraint set {⟨ℛi,Srmj​(pmj),t⟩∣m∈{1,⋯​Mj},j≺i}conditional-setsubscriptℛ𝑖subscript𝑆subscriptsuperscript𝑟𝑗𝑚subscriptsuperscript𝑝𝑗𝑚𝑡formulae-sequence𝑚1⋯subscript𝑀𝑗precedes𝑗𝑖\\\\{\\\\langle\\\\mathcal{R}\\_{i},S\\_{r^{j}\\_{m}}(p^{j}\\_{m}),t\\\\rangle\\\\mid m\\\\in\\\\{1,\\\\cdots M\\_{j}\\\\},j\\\\prec i\\\\}, where ≺precedes\\\\prec indicates priority precedence. In Alg. [1](https://ar5iv.org/html/2410.03072#alg1 \"In Figure 1 ‣ 2.3 Planning with Diffusion Models ‣ 2 Preliminary ‣ Multi-Robot Motion Planning with Diffusion Models\"), ⟨ℛi,𝝉⟩subscriptℛ𝑖𝝉\\\\langle\\\\mathcal{R}\\_{i},\\\\boldsymbol{\\\\tau}\\\\rangle means that all trajectories of ℛj≠isubscriptℛ𝑗𝑖\\\\mathcal{R}\\_{j\\\\neq i} in 𝝉𝝉\\\\boldsymbol{\\\\tau} must be similarly avoided.\n\nMMD-CBS. CBS is a popular MAPF solver that combines “low-level” planners for individual agents with a “high-level” constraint tree (CT) to resolve conflicts (i.e., collisions). The algorithm initiates by creating the root node Nrootsubscript𝑁rootN\\_{\\\\text{root}} in the CT, planning paths for each agent independently, and storing these paths in Nroot.Πformulae-sequencesubscript𝑁rootΠN\\_{\\\\text{root}}.\\\\Pi.\nCBS repeatedly extracts nodes N𝑁N from the CT and inspects N.Πformulae-sequence𝑁ΠN.\\\\Pi for conflicts. If no conflicts exist, the algorithm terminates, returning N.Πformulae-sequence𝑁ΠN.\\\\Pi. Otherwise, CBS selects a conflict time t𝑡t where agents ℛisubscriptℛ𝑖\\\\mathcal{R}\\_{i} and ℛjsubscriptℛ𝑗\\\\mathcal{R}\\_{j} collide at positions 𝐪i=𝝅tisuperscript𝐪𝑖subscriptsuperscript𝝅𝑖𝑡\\\\mathbf{q}^{i}=\\\\boldsymbol{\\\\pi}^{i}\\_{t} and 𝐪j=𝝅tjsuperscript𝐪𝑗subscriptsuperscript𝝅𝑗𝑡\\\\mathbf{q}^{j}=\\\\boldsymbol{\\\\pi}^{j}\\_{t} in N.Πformulae-sequence𝑁ΠN.\\\\Pi.\nCBS then splits node N𝑁N into two new CT nodes, Nisubscript𝑁𝑖N\\_{i} and Njsubscript𝑁𝑗N\\_{j}, each inheriting the (initially empty) constraint set N.Cformulae-sequence𝑁𝐶N.C and paths N.Πformulae-sequence𝑁ΠN.\\\\Pi from N𝑁N, and incorporating a new constraint for preventing the respective agent from occupying the conflict position at time t𝑡t. For example, Ni.C←N.C∪{⟨ℛi,𝐪i,t⟩}formulae-sequencesubscript𝑁𝑖←𝐶𝑁𝐶subscriptℛ𝑖superscript𝐪𝑖𝑡N\\_{i}.C\\\\leftarrow N.C\\\\cup\\\\{\\\\langle\\\\mathcal{R}\\_{i},\\\\mathbf{q}^{i},t\\\\rangle\\\\} for ℛisubscriptℛ𝑖\\\\mathcal{R}\\_{i}.\nPaths for ℛisubscriptℛ𝑖\\\\mathcal{R}\\_{i} and ℛjsubscriptℛ𝑗\\\\mathcal{R}\\_{j} are then replanned using low-level planners under the updated constraints in Ni.Cformulae-sequencesubscript𝑁𝑖𝐶N\\_{i}.C and Nj.Cformulae-sequencesubscript𝑁𝑗𝐶N\\_{j}.C. The new CT nodes, with updated paths in Ni.Πformulae-sequencesubscript𝑁𝑖ΠN\\_{i}.\\\\Pi and Nj.Πformulae-sequencesubscript𝑁𝑗ΠN\\_{j}.\\\\Pi, are added to the CT.\n_MMD-CBS_ follows the general CBS structure. It keeps a CT of nodes N𝑁N, each with trajectories N.𝝉formulae-sequence𝑁𝝉N.\\\\boldsymbol{\\\\tau}, and uses motion planning diffusion models as low-level planners. The algorithm identifies a collision pointp𝑝p for each conflict and resolves it by imposing sphere soft-constraints centered at p𝑝p on affected robots (see Fig. [1](https://ar5iv.org/html/2410.03072#S2.F1 \"Figure 1 ‣ 2.3 Planning with Diffusion Models ‣ 2 Preliminary ‣ Multi-Robot Motion Planning with Diffusion Models\") for an illustration and Sec. [A.4](https://ar5iv.org/html/2410.03072#A1.SS4 \"A.4 Implementation Details ‣ Appendix A Appendix ‣ Multi-Robot Motion Planning with Diffusion Models\") for parameter values).\n\nMMD-ECBS. Enhanced-CBS (ECBS) (Barer et al., [2014](https://ar5iv.org/html/2410.03072#bib.bib2 \"\")) informs CBS low-level planners of the paths of other robots in the same CT node and steers the search towards solutions that are more likely to be collision-free.\nTo emulate this in diffusion-based trajectory generation, MMD-ECBS imposes two types of soft constraints: “weak” and “strong.” For each robot ℛjsubscriptℛ𝑗\\\\mathcal{R}\\_{j} with a trajectory in the CT node N𝑁N, a weak soft-constraint that forbids ℛisubscriptℛ𝑖\\\\mathcal{R}\\_{i} from colliding with any other ℛjsubscriptℛ𝑗\\\\mathcal{R}\\_{j} with 𝝉j∈N.𝝉formulae-sequencesuperscript𝝉𝑗𝑁𝝉\\\\boldsymbol{\\\\tau}^{j}\\\\in N.\\\\boldsymbol{\\\\tau} is imposed. This is done in a similar way to MMD-PP but with a lower penalty value (Sec. [A.4](https://ar5iv.org/html/2410.03072#A1.SS4 \"A.4 Implementation Details ‣ Appendix A Appendix ‣ Multi-Robot Motion Planning with Diffusion Models\")). The strong constraints are the same as those in MMD-CBS, resolving previously observed conflicts.\n\nReusing Experience in CBS.\nRecent studies indicate that leveraging previous single-robot solutions to guide replanning enhances the efficiency of CBS (Shaoul et al., [2024a](https://ar5iv.org/html/2410.03072#bib.bib26 \"\")). This is primarily because the motion planning problem between a CT node and its successors is nearly identical, with the only difference being a single constraint, making planning from scratch wasteful. This can be utilized in MMD replanning by initially adding noise to the stored trajectory for a limited number of steps (333 in our experiments; regular inference uses 252525 steps) and then denoising with the new soft-constraints. This approach, in the context of single-robot planning, was first proposed in Janner et al. ( [2022](https://ar5iv.org/html/2410.03072#bib.bib12 \"\")) and further refined in Zhou et al. ( [2024](https://ar5iv.org/html/2410.03072#bib.bib39 \"\")).\nAdding this functionality to MMD-CBS and MMD-ECBS yields our two final MMD algorithms, MMD-xCBS and MMD-xECBS, respectively. Both reuse previous solutions to inform replanning and are otherwise unchanged.\n\n### 3.3 Sequencing Diffusion Models for Long Horizon Planning\n\nDiffusion models have shown notable success in learning trajectory distributions within specific contexts. However, they face challenges in modeling complex trajectory distributions and generalizing to diverse contexts (e.g., significantly different obstacle layouts). To tackle this issue, we propose utilizing an ensemble of local diffusion models rather than a single model for a single robot. Each local model is trained to capture the trajectory distribution of a particular motion pattern within a local map segment, and we combine multiple models sequentially for long-horizon single-robot planning.\nThis approach offers three advantages: (1) Easier learning with simple, demonstrable motion patterns. (2) Better generalization across different contexts. (3) Effective scaling for large maps, aiding long-term planning.\n\nDuring online planning, given a specific single-robot task 𝒪isuperscript𝒪𝑖\\\\mathcal{O}^{i} (which includes the start state and the termination condition), we can query the task-relevant local diffusion models to generate a full-horizon motion plan. Motivated by Mishra et al. ( [2023](https://ar5iv.org/html/2410.03072#bib.bib20 \"\")), this is done by sampling from the local models in parallel, while incorporating a cross-conditioning term that constrains the local trajectories to connect seamlessly.\nLet 𝝉i,lsuperscript𝝉𝑖𝑙\\\\boldsymbol{\\\\tau}^{i,l} be a local trajectory sampled from a local probability distribution plsuperscript𝑝𝑙p^{l}. The goal of the single-robot planner is to sample from the posterior distribution of trajectories:\n\n|     |     |     |     |     |     |\n| --- | --- | --- | --- | --- | --- |\n|  |\n|  | arg​max𝝉isubscriptargmaxsuperscript𝝉𝑖\\\\displaystyle\\\\operatorname\\*{arg\\\\,max}\\_{\\\\boldsymbol{\\\\tau}^{i}} |  | log⁡p​(𝝉i\\|𝒪)=arg​max𝝉i,1,…,𝝉i,L⁡log⁡p​(𝝉i,1,…,𝝉i,L\\|𝒪)𝑝conditionalsuperscript𝝉𝑖𝒪subscriptargmaxsuperscript𝝉𝑖1…superscript𝝉𝑖𝐿𝑝superscript𝝉𝑖1…conditionalsuperscript𝝉𝑖𝐿𝒪\\\\displaystyle\\\\log p(\\\\boldsymbol{\\\\tau}^{i}\\|\\\\mathcal{O})=\\\\operatorname\\*{arg\\\\,max}\\_{\\\\boldsymbol{\\\\tau}^{i,1},\\\\dots,\\\\boldsymbol{\\\\tau}^{i,L}}\\\\log p(\\\\boldsymbol{\\\\tau}^{i,1},\\\\dots,\\\\boldsymbol{\\\\tau}^{i,L}\\|\\\\mathcal{O}) |  | (5a) |\n|  | subject to |  | 𝝉1i,l=𝝉Hl−1i,l−1,∀l=1,…,Lformulae-sequencesubscriptsuperscript𝝉𝑖𝑙1subscriptsuperscript𝝉𝑖𝑙1subscript𝐻𝑙1for-all𝑙1…𝐿\\\\displaystyle\\\\boldsymbol{\\\\tau}^{i,l}\\_{1}=\\\\boldsymbol{\\\\tau}^{i,l-1}\\_{H\\_{l-1}},\\\\forall l=1,\\\\dots,L |  | (5b) |\n\nFollowing Eq. [1](https://ar5iv.org/html/2410.03072#S2.E1 \"In 2.3 Planning with Diffusion Models ‣ 2 Preliminary ‣ Multi-Robot Motion Planning with Diffusion Models\"), the new objective becomes:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | arg​min𝝉i,1,…,𝝉i,L⁡(𝒥​(𝝉i,1,…,𝝉i,L)−∑l=1Llog⁡p​(𝝉i,l))subscriptargminsuperscript𝝉𝑖1…superscript𝝉𝑖𝐿𝒥superscript𝝉𝑖1…superscript𝝉𝑖𝐿superscriptsubscript𝑙1𝐿𝑝superscript𝝉𝑖𝑙\\\\displaystyle\\\\operatorname\\*{arg\\\\,min}\\_{\\\\boldsymbol{\\\\tau}^{i,1},\\\\dots,\\\\boldsymbol{\\\\tau}^{i,L}}\\\\left(\\\\mathcal{J}(\\\\boldsymbol{\\\\tau}^{i,1},\\\\dots,\\\\boldsymbol{\\\\tau}^{i,L})-\\\\sum\\_{l=1}^{L}\\\\log p(\\\\boldsymbol{\\\\tau}^{i,l})\\\\right) |  | (6) |\n\nIn practice, MMD ensures proper sequencing of the L𝐿L local diffusion models by introducing constraints requiring the last state of the trajectory from model l𝑙l to be equal to the first state from model l+1𝑙1l+1 (see Eq. [5b](https://ar5iv.org/html/2410.03072#S3.E5.2 \"In 5 ‣ 3.3 Sequencing Diffusion Models for Long Horizon Planning ‣ 3 Method ‣ Multi-Robot Motion Planning with Diffusion Models\")) and treating generation of local trajectories as inpainting (Lugmayr et al., [2022](https://ar5iv.org/html/2410.03072#bib.bib19 \"\")).\n222Another option is to add a guidance term penalizing discontinuity. This approach is more flexible as it can optimize for connection points that are learned as well (e.g., via classifier guidance on the connection itself).\n\n![Refer to caption](https://ar5iv.org/html/2410.03072/assets/figures/envs/empty_isaac_env.png)(a) Empty map.\n\n![Refer to caption](https://ar5iv.org/html/2410.03072/assets/figures/composite_exp/agents_empty_avg_data_adherence_comparison_plot.png)(b) Data adherence in the Empty map.\n\n![Refer to caption](https://ar5iv.org/html/2410.03072/assets/figures/envs/highways_isaac_3.png)(c) Highways map.\n\n![Refer to caption](https://ar5iv.org/html/2410.03072/assets/figures/composite_exp/agents_highways_avg_data_adherence_comparison_plot.png)(d) Data adherence in the Highways map.\n\nFigure 2: A comparison between MMD and “composite” diffusion models that generate trajectories for all agents at once.\nWe observed consistent performance from MMD but a sharp decrease for the baseline, unable to produce valid solutions for 999 agents (denoted as zero adherence score). Since MMD uses the same single-agent model for all robots in these experiments, it is straightforward to keep increasing the number of agents without needing any retraining or new datasets.\n\n## 4 Experimental Analysis\n\nWe tested MMD’s efficacy in learning multi-robot trajectories on increasingly complex maps with varying numbers of holonomic ground robots in a simulated warehouse, modeling robots as 2D disks. Our goals were to (i) compare our approach with common methods for integrating data into multi-robot trajectory generation, (ii) identify the most effective constraining strategies with MMD, and (iii) evaluate MMD’s scalability.\nEach experiment with n𝑛n robots begins by randomly picking start and goal states on a map for various algorithms to compute valid trajectories 𝝉𝝉\\\\boldsymbol{\\\\tau} (or MAPF paths ΠΠ\\\\Pi) between. We evaluated the methods by  success rate, the percentage of problems solved with no collision within a time limit, and data adherence, the average alignment of 𝝉i∈𝝉superscript𝝉𝑖𝝉\\\\boldsymbol{\\\\tau}^{i}\\\\in\\\\boldsymbol{\\\\tau} with the dataset motion patterns. Data adherence uses a map-specific function costdata​(𝝉i)subscriptcostdatasuperscript𝝉𝑖\\\\text{cost}\\_{\\\\text{data}}(\\\\boldsymbol{\\\\tau}^{i}), scoring 111 for perfect conformity and lower otherwise. Our evaluation maps, datasets, and adherence functions are summarized here with simple illustrations and more details are in the appendix.\n\n![[Uncaptioned image]](https://ar5iv.org/html/2410.03072/assets/figures/envs/drop_region_env.png)\n\nDrop-Region map (Fig. [3(i)](https://ar5iv.org/html/2410.03072#S4.F3.sf9 \"In Figure 3 ‣ 4 Experimental Analysis ‣ Multi-Robot Motion Planning with Diffusion Models\")) simulates package drop-off chutes. Motion demonstrations are trajectories between random states that include a pause at one of sixteen drop-off regions—next to any chute edge midpoint. Adherence is met for 𝝉isuperscript𝝉𝑖\\\\boldsymbol{\\\\tau}^{i}, i.e., costdata​(𝝉i)=1subscriptcostdatasuperscript𝝉𝑖1\\\\text{cost}\\_{\\\\text{data}}(\\\\boldsymbol{\\\\tau}^{i})=1, if it includes such a pause. Otherwise, it is zero.\n\n![[Uncaptioned image]](https://ar5iv.org/html/2410.03072/assets/figures/envs/conveyor_env.png)\n\nConveyor map (Fig. [3(e)](https://ar5iv.org/html/2410.03072#S4.F3.sf5 \"In Figure 3 ‣ 4 Experimental Analysis ‣ Multi-Robot Motion Planning with Diffusion Models\")) features narrow passages with directional motion requirements. Demonstrations connect random states with trajectories that pass along the top corridor to the left, or through the bottom corridor to the right. Trajectory 𝝉isuperscript𝝉𝑖\\\\boldsymbol{\\\\tau}^{i} adheres to data if it similarly passes through either corridor before reaching its goal.\n\n![[Uncaptioned image]](https://ar5iv.org/html/2410.03072/assets/figures/envs/highways_env.png)\n\nHighways map (Fig. [3(a)](https://ar5iv.org/html/2410.03072#S4.F3.sf1 \"In Figure 3 ‣ 4 Experimental Analysis ‣ Multi-Robot Motion Planning with Diffusion Models\")), requires counter-clockwise movement around a central obstacle—a pattern shown in its associated data. This map can be seen as a modular building block for larger multi-robot environments with its required motion pattern promoting easier coordination. Adherence is met for 𝝉isuperscript𝝉𝑖\\\\boldsymbol{\\\\tau}^{i} if its cumulative motion within the map is counter-clockwise.\n\n![[Uncaptioned image]](https://ar5iv.org/html/2410.03072/assets/figures/envs/empty_env.png)\n\nEmpty map (Fig. [2(a)](https://ar5iv.org/html/2410.03072#S3.F2.sf1 \"In Figure 2 ‣ 3.3 Sequencing Diffusion Models for Long Horizon Planning ‣ 3 Method ‣ Multi-Robot Motion Planning with Diffusion Models\")) is our simplest. Robots are scored highly if they move in straight lines and gradually worse the more they deviate. Demonstrations are of straight line motions.\n\n![[Uncaptioned image]](https://ar5iv.org/html/2410.03072/assets/figures/envs/multitile_3x3_env.png)\n\nLarger Maps (Fig. [5(f)](https://ar5iv.org/html/2410.03072#S4.F5.sf6 \"In Figure 5 ‣ 4.2 MMD Outperforms MAPF with Learned Cost Maps ‣ 4 Experimental Analysis ‣ Multi-Robot Motion Planning with Diffusion Models\")). In our larger scale experiments (Sec. [4.3](https://ar5iv.org/html/2410.03072#S4.SS3 \"4.3 Sequenced Diffusion Models for Long-Horizon Planning ‣ 4 Experimental Analysis ‣ Multi-Robot Motion Planning with Diffusion Models\")) trajectories are computed within 2×2222\\\\times 2 and 3×3333\\\\times 3 maps composed of smaller, local maps. Required motions are dictated by spanned local maps, and the overall adherence is the average adherence per local map.\n\n![Refer to caption](https://ar5iv.org/html/2410.03072/assets/figures/envs/highways_isaac_env.png)(a) Highways map.\n\n(b) \\*(c) \\*(d) \\*\n\n\\[0.12\\]![[Uncaptioned image]](https://ar5iv.org/html/2410.03072/assets/figures/mapf_exp/comparison_legend.png)\n\n\\[0.32\\]![[Uncaptioned image]](https://ar5iv.org/html/2410.03072/assets/figures/mapf_exp/agents_highways_success_rate_comparison_plot.png)\n\n\\[0.32\\]![[Uncaptioned image]](https://ar5iv.org/html/2410.03072/assets/figures/mapf_exp/agents_highways_avg_data_adherence_comparison_plot.png)\n\n![Refer to caption](https://ar5iv.org/html/2410.03072/assets/figures/envs/conveyor_isaac_env.png)(e) Conveyor map.\n\n(f) \\*(g) \\*(h) \\*\n\n\\[0.12\\]![[Uncaptioned image]](https://ar5iv.org/html/2410.03072/assets/figures/mapf_exp/comparison_legend.png)\n\n\\[0.32\\]![[Uncaptioned image]](https://ar5iv.org/html/2410.03072/assets/figures/mapf_exp/agents_conveyor_success_rate_comparison_plot.png)\n\n\\[0.32\\]![[Uncaptioned image]](https://ar5iv.org/html/2410.03072/assets/figures/mapf_exp/agents_conveyor_avg_data_adherence_comparison_plot.png)\n\n![Refer to caption](https://ar5iv.org/html/2410.03072/assets/figures/envs/drop_region_isaac_env.png)(i) Drop-Region map.\n\n(j) \\*(k) \\*(l) \\*Figure 3: Analysis of success rates and data adherence scores in randomly generated planning queries.\nWe report on all five MMD instantiations, each influenced by a constraint-based search algorithm, and a MAPF method with and without a learned cost map. The left column shows our test maps, the middle column compares success rates across 101010 trials per robot count, and the right column presents the average data adherence scores. Sec. [4](https://ar5iv.org/html/2410.03072#S4 \"4 Experimental Analysis ‣ Multi-Robot Motion Planning with Diffusion Models\") discusses the experiments and results.\n\n\\[0.12\\]![[Uncaptioned image]](https://ar5iv.org/html/2410.03072/assets/figures/mapf_exp/comparison_legend.png)\n\n\\[0.32\\]![[Uncaptioned image]](https://ar5iv.org/html/2410.03072/assets/figures/mapf_exp/agents_drop_region_success_rate_comparison_plot.png)\n\n\\[0.32\\]![[Uncaptioned image]](https://ar5iv.org/html/2410.03072/assets/figures/mapf_exp/agents_drop_region_avg_data_adherence_comparison_plot.png)\n\n### 4.1 Decoupling Scales Multi-Robot Diffusion Planning\n\nAn appealing approach for learning multi-robot trajectory generation is by obtaining multi-robot trajectory datasets and training a single model to jointly generate trajectories for all robots. To test this approach, we evaluated MPD-Composite, a state-of-the-art motion planning diffusion model (MPD) (Carvalho et al., [2023](https://ar5iv.org/html/2410.03072#bib.bib3 \"\")) that we trained on multi-robot data we collected in two maps: Empty and Highways. We created three models: for 333, 666, and 999 robots. Each model was also given an additional guidance term that penalized collisions between robots.\nAcross 300300300 tests, 505050 for each map and group size, we compared MPD-Composite to MMD-xECBS (referred to as MMD). See Fig. [2](https://ar5iv.org/html/2410.03072#S3.F2 \"Figure 2 ‣ 3.3 Sequencing Diffusion Models for Long Horizon Planning ‣ 3 Method ‣ Multi-Robot Motion Planning with Diffusion Models\") for results. The composite model achieved perfect success rates and high data adherence scores with 3 robots but struggled as the number of robots increased to 666. No valid trajectories were generated in any test with 999 agents using MPD-Composite in either map. In contrast, MMD solved all 300 problems successfully and further scaled to 40 agents in additional random tests, also producing trajectories with high data adherence scores and no collisions.\n\n### 4.2 MMD Outperforms MAPF with Learned Cost Maps\n\nFrom a search-based planning viewpoint, a compelling way to integrate motion data into multi-agent planning is by reducing MRMP to MAPF and forming cost maps to direct algorithms like ECBS (Cohen et al., [2016](https://ar5iv.org/html/2410.03072#bib.bib7 \"\")). This sacrifices dynamic feasibility, limiting solutions to a fixed graph, but can still offer a desirable homotopy class and be assessed for data compliance.\nOur second experiment set evaluates this method’s potential to produce data-compliant motions (see Fig. [3(j)](https://ar5iv.org/html/2410.03072#S4.F3.sf10 \"In Figure 3 ‣ 4 Experimental Analysis ‣ Multi-Robot Motion Planning with Diffusion Models\")). We created 180 motion planning problems, 10 per group size across three maps, and assessed two search-based methods: A\\*Data-ECBS and A\\*-ECBS. The former plans single-robot paths with A\\* using map-specific statistical cost maps, where edges have lower costs if those are visited more frequently by the map’s dataset trajectories (discretized to map cells). The latter uses uniform costs (i.e., has no knowledge of the data) and is reported only to provide context for A\\*Data-ECBS’s performance.\n\nWe find that integrating motion data into statistical cost maps yields mixed outcomes: it enhances adherence in the Highways map by around 35%percent3535\\\\% compared to A\\*-ECBS but decreases success rates. In other maps, this approach finds collision-free paths, but falls short in managing complex motion distributions.\nIn contrast, our results for running MMD methods for the same planning problems show that those can solve complex trajectory generation tasks with high data adherence scores across all methods, and for some, with high success rates too.\n\n![Refer to caption](https://ar5iv.org/html/2410.03072/assets/figures/envs/empty_circle15_env.png)(a) _Circle_ setup.\n\n(b) \\*(c) \\*(d) \\*\n\n\\[0.12\\]![[Uncaptioned image]](https://ar5iv.org/html/2410.03072/assets/figures/mapf_freespace_exp/comparison_legend.png)\n\n\\[0.32\\]![[Uncaptioned image]](https://ar5iv.org/html/2410.03072/assets/figures/mapf_freespace_exp/agents_circle_env_avg_path_length_per_agent_comparison_plot.png)\n\n\\[0.32\\]![[Uncaptioned image]](https://ar5iv.org/html/2410.03072/assets/figures/mapf_freespace_exp/agents_circle_env_avg_planning_time_comparison_plot.png)\n\n![Refer to caption](https://ar5iv.org/html/2410.03072/assets/figures/envs/empty_boundary20_env.png)(e) _Weave_ setup.\n\n(f) \\*(g) \\*(h) \\*Figure 4: Scalability tests for our five MMD methods in free-space MRMP. Starts and goals were chosen to induce robot collisions. The top row shows the _circle_ setup, where robots swap positions between opposite points on the perimeter. The _weave_ setup results are below, with robots exchanging positions along uniformly spaced boundary points. Length is zero for failed problems (in MMD-PP, caused by yielding invalid solutions, and in the rest, by computing for longer than 240 seconds).\n\n\\[0.12\\]![[Uncaptioned image]](https://ar5iv.org/html/2410.03072/assets/figures/mapf_freespace_exp/comparison_legend.png)\n\n\\[0.32\\]![[Uncaptioned image]](https://ar5iv.org/html/2410.03072/assets/figures/mapf_freespace_exp/agents_weave_env_avg_path_length_per_agent_comparison_plot.png)\n\n\\[0.32\\]![[Uncaptioned image]](https://ar5iv.org/html/2410.03072/assets/figures/mapf_freespace_exp/agents_weave_env_avg_planning_time_comparison_plot.png)\n\nAnalyzing MMD Constraining Strategies.\nFurther analysis reveals a trend familiar from the MAPF literature. MMD-CBS struggles with scalability, reaching the time limit with more than 999 robots. MMD-ECBS significantly outperforms MMD-CBS, and accelerated versions further improve performance.\nMMD-PP finds efficiency in requiring only one inference pass per robot, however, because the constraints on diffusion models are soft, trajectory generation queries are not guaranteed to completely avoid higher-priority robots, and as such MMD-PP may fail to produce collision-free solutions. This is reflected in lower success rates in congested maps. In contrast, CBS-based MMD methods only failed by exceeding our 60-second runtime limit. MMD-xECBS outperformd other MMD algorithms in success rates and matched MMD-ECBS in data adherence.\n\nTo test MMD’s MRMP solving ability without regard to data adherence, we created two free-space experiments focusing on robot interactions (Fig. [4(f)](https://ar5iv.org/html/2410.03072#S4.F4.sf6 \"In Figure 4 ‣ 4.2 MMD Outperforms MAPF with Learned Cost Maps ‣ 4 Experimental Analysis ‣ Multi-Robot Motion Planning with Diffusion Models\")). In the _circle_ setup, robots move between opposite points on a circle, likely colliding at the center. In the _weave_ setup (inspired by Tajbakhsh et al. ( [2024](https://ar5iv.org/html/2410.03072#bib.bib35 \"\"))), robots begin on opposite points of a square, aiming to switch places.\nCBS-based methods were challenged in _circle_ since incrementally constraining the center region is time consuming. MMD-PP’s stronger constraints navigated around congestion and solved more problems, however, occasionally failed to produce valid solutions. In _weave_, where navigating around congestion is more difficult, CBS-based methods generated collision-free trajectories more effectively.\n\n![Refer to caption](https://ar5iv.org/html/2410.03072/assets/figures/envs/multitile_2x2_env.png)(a) 2×2222\\\\times 2 map.\n\n(b) \\*(c) \\*(d) \\*\n\n\\[0.12\\]![[Uncaptioned image]](https://ar5iv.org/html/2410.03072/assets/figures/multi_tile_exp/comparison_legend.png)\n\n\\[0.32\\]![[Uncaptioned image]](https://ar5iv.org/html/2410.03072/assets/figures/multi_tile_exp/agents_multitile2x2_success_rate_comparison_plot.png)\n\n\\[0.32\\]![[Uncaptioned image]](https://ar5iv.org/html/2410.03072/assets/figures/multi_tile_exp/agents_multitile2x2_avg_data_adherence_comparison_plot.png)\n\n![Refer to caption](https://ar5iv.org/html/2410.03072/assets/figures/envs/multitile_3x3_env.png)(e) 3×3333\\\\times 3 map.\n\n(f) \\*(g) \\*(h) \\*Figure 5: Experimental setup and results for scaling MMD to larger environments and longer planning horizons. MMD still relies on single agent data in small, local maps and does not require training of new networks for this scale-up. We evaluate three MMD variants across two large maps made of tiled local maps to cover a significantly larger area.\n\n\\[0.12\\]![[Uncaptioned image]](https://ar5iv.org/html/2410.03072/assets/figures/multi_tile_exp/comparison_legend.png)\n\n\\[0.32\\]![[Uncaptioned image]](https://ar5iv.org/html/2410.03072/assets/figures/multi_tile_exp/agents_multitile3x3_success_rate_comparison_plot.png)\n\n\\[0.32\\]![[Uncaptioned image]](https://ar5iv.org/html/2410.03072/assets/figures/multi_tile_exp/agents_multitile3x3_avg_data_adherence_comparison_plot.png)\n\n### 4.3 Sequenced Diffusion Models for Long-Horizon Planning\n\nWe present a feasibility study on expanding MMD algorithms to larger maps using the sequencing method described in Sec. [3.3](https://ar5iv.org/html/2410.03072#S3.SS3 \"3.3 Sequencing Diffusion Models for Long Horizon Planning ‣ 3 Method ‣ Multi-Robot Motion Planning with Diffusion Models\"). This technique assembles smaller local maps, each associated with a diffusion model, to collectively generate long-horizon, data-driven trajectories. In our experiments, we tested three MMD methods—MMD-PP, MMD-ECBS, and MMD-xECBS—in 120 trajectory generation tests, allowing a relaxed 240-second time frame. A standout feature of the sequencing method is its ability to create trajectories that follow a task-skeleton: passing through a series of local maps within the larger global map. For this purpose,\nour experiments assign a random sequence of three tasks per robot (a sequence of local maps), and randomly selects start and goal states within the first and last local maps in the sequence. The results (Fig. [5(f)](https://ar5iv.org/html/2410.03072#S4.F5.sf6 \"In Figure 5 ‣ 4.2 MMD Outperforms MAPF with Learned Cost Maps ‣ 4 Experimental Analysis ‣ Multi-Robot Motion Planning with Diffusion Models\")) show MMD-xECBS scaling to long planning horizons without compromising data adherence. This demonstrates MMD’s capability to efficiently produce multi-robot trajectories in large environments by utilizing diffusion models trained with easily gathered data from small, local maps.\n\n## 5 Related Work\n\nMulti-Robot Motion Planning.\nDue to the PSPACE-hardness of MRMP (Hopcroft & Wilfong, [1986](https://ar5iv.org/html/2410.03072#bib.bib11 \"\")), most practical algorithms make various approximations to relax the planning problem. Some of the most successful MRMP methods reduce the problem to a multi-agent path finding problem (MAPF) (Stern et al., [2019](https://ar5iv.org/html/2410.03072#bib.bib34 \"\")) by discretizing state and time and assuming zero-volume shapes, constant velocities and rectilinear movements (Chen et al., [2021](https://ar5iv.org/html/2410.03072#bib.bib4 \"\")).\nHowever, this introduces a gap between the MAPF formulation and MRMP which is problematic in many domains.\nTo relax the restriction of planning on a grid, recent works (Solis et al., [2021](https://ar5iv.org/html/2410.03072#bib.bib31 \"\"); Hönig et al., [2018](https://ar5iv.org/html/2410.03072#bib.bib10 \"\")) have generalized MAPF algorithms to continuous state spaces by using sampling-based motion planners to construct probabilistic roadmaps (PRM)  (Kavraki et al., [1996](https://ar5iv.org/html/2410.03072#bib.bib15 \"\")) for robots.\n\nMore generally, _coupled_ MRMP algorithms, like Sanchez & Latombe ( [2002](https://ar5iv.org/html/2410.03072#bib.bib25 \"\")); Solovey et al. ( [2016](https://ar5iv.org/html/2410.03072#bib.bib32 \"\")) apply sampling-based planners like PRM and RRT (Karaman & Frazzoli, [2011](https://ar5iv.org/html/2410.03072#bib.bib14 \"\")) to the composite configuration space of all the robots. This approach guarantees completeness but struggles to scale with the number of robots as the configuration space grows exponentially.\nConversely, _decoupled_ algorithms like prioritized planning (Erdmann & Lozano-Perez, [1987](https://ar5iv.org/html/2410.03072#bib.bib8 \"\")) and Leroy et al. ( [1999](https://ar5iv.org/html/2410.03072#bib.bib16 \"\")) generate robot motions one after another, fixing each plan and regarding them as dynamic obstacles in subsequent planning iterations. This allows them to quickly find solutions for large numbers of robots, but sometimes fail to find any solution even if one exists, i.e., they are often incomplete.\nSeeking to balance theoretical guarantees with practical efficiency, hybrid algorithms like CBS (Sharon et al., [2015](https://ar5iv.org/html/2410.03072#bib.bib28 \"\")) plan independently for every robot and loosely couple them to resolve conflicts.\n\nPlanning with Diffusion Models.\nLately, there has been a surge of interest in applying diffusion models (Sohl-Dickstein et al., [2015](https://ar5iv.org/html/2410.03072#bib.bib29 \"\")) to solve sequential decision making tasks, including planning and reinforcement learning (Ubukata et al., [2024](https://ar5iv.org/html/2410.03072#bib.bib36 \"\")).\nDiffuser (Janner et al., [2022](https://ar5iv.org/html/2410.03072#bib.bib12 \"\")) first proposed the idea of using diffusion models for trajectory planning and showed how classifier-guided sampling and image inpainting can be used for adaptation at test time.\nRecent works have used diffusion models\nas priors\nfor single-robot motion planning (Carvalho et al., [2023](https://ar5iv.org/html/2410.03072#bib.bib3 \"\")), for learning visuomotor policies (Chi et al., [2024](https://ar5iv.org/html/2410.03072#bib.bib5 \"\")), and for offline decision-making (Ajay et al., [2023](https://ar5iv.org/html/2410.03072#bib.bib1 \"\")).\nMost of these works have been limited to single-agent planning with two notable exceptions.\nJiang et al. ( [2023](https://ar5iv.org/html/2410.03072#bib.bib13 \"\")) learn a joint motion distribution for multi-agent motion prediction using a diffusion model. By contrast, we focus on generating kinodynamically feasible and collision-free trajectories without having to learn a joint distribution.\nConcurrent work by Mishra et al. ( [2024](https://ar5iv.org/html/2410.03072#bib.bib21 \"\")) uses spatial-temporal factor graphs to compose modular generative models for solving long-horizon bimanual coordination tasks. By contrast, our approach can scale diffusion models to dozens of robots and complex environments by leveraging multi-agent search algorithms.\n\n## 6 Conclusion\n\nIn this paper, we present Multi-robot Multi-model planning Diffusion (MMD), a multi-robot motion planner that learns to generate smooth collision-free trajectories for dozens of robots in complex environments.\nOur key contribution is showing how single robot diffusion models can be effectively combined with state-of-the-art multi-agent search algorithms to generate data-driven multi-robot trajectories.\nBy learning only single-robot diffusion models, MMD simplifies data requirements and breaks the curse of dimensionality plaguing approaches that learn from multi-robot data. Additionally, by learning generative models of robot trajectories, MMD overcomes many of the limitations of popular model-based MAPF algorithms, such as state discretization, known cost function, and constant velocities.\nWe believe MMD opens up exciting avenues for future work on combining the strengths of search algorithms and diffusion planning.\n\nLimitations. We are excited about the potential of MMD to push forward multi-robot coordination and collaboration and offer a few avenues for future work. First is allowing for more flexibility in MMD’s planning horizon. As it stands, MMD generates trajectories of fixed duration—a limitation it inherits from diffusion planning. Sequencing models helps extend the time horizon but still, it must be determined a priori.\nSecond, we believe that the CBS-based MMD methods can be greatly accelerated, mostly through parallelization of the high-level search. Finally, we believe the frontier of MRMP lies in collaboration. Currently, MMD focuses on coordinating robots, seeking to produce collision-free data-driven trajectories. Carrying out collaborative tasks is an interesting next step.\n\n## 7 Reproducibility\n\nWe aspire for MMD to be easily used and extended by researchers and practitioners. To this end, we make our source code for all MMD algorithms, scripts for data generation, training, and evaluation, and evaluation maps publicly available at [https://github.com/yoraish/mmd](https://github.com/yoraish/mmd \"\"). This code, along with the parameter values detailed in Sec. [A.4](https://ar5iv.org/html/2410.03072#A1.SS4 \"A.4 Implementation Details ‣ Appendix A Appendix ‣ Multi-Robot Motion Planning with Diffusion Models\"), is sufficient for reproducing the experiments and results presented in this paper.\nTo run our code “out of the box,” without dataset generation or training, we provide pre-trained models and datasets detailed in Sec. [4](https://ar5iv.org/html/2410.03072#S4 \"4 Experimental Analysis ‣ Multi-Robot Motion Planning with Diffusion Models\") with detailed instructions. For hardware and software dependencies, we specify the exact versions of libraries and tools required in our repository and also detail our hardware setup in Sec. [A.4](https://ar5iv.org/html/2410.03072#A1.SS4 \"A.4 Implementation Details ‣ Appendix A Appendix ‣ Multi-Robot Motion Planning with Diffusion Models\").\n\n#### Acknowledgments\n\nThe work was supported by the National Science Foundation under Grant IIS-2328671 and the CMU Manufacturing Futures Institute, made possible by the Richard King Mellon Foundation.\nWe thank Mohit Sharma and Ilan Mitnikov for fruitful discussions.\n\n## References\n\n- Ajay et al. (2023)\nAnurag Ajay, Yilun Du, Abhi Gupta, Joshua B. Tenenbaum, Tommi S. Jaakkola, and Pulkit Agrawal.\n\nIs conditional generative modeling all you need for decision making?\n\nIn _The Eleventh International Conference on Learning Representations, ICLR 2023, Kigali, Rwanda, May 1-5, 2023_. OpenReview.net, 2023.\n\nURL [https://openreview.net/forum?id=sP1fo2K9DFG](https://openreview.net/forum?id=sP1fo2K9DFG \"\").\n\n- Barer et al. (2014)\nMax Barer, Guni Sharon, Roni Stern, and Ariel Felner.\n\nSuboptimal variants of the conflict-based search algorithm for the multi-agent pathfinding problem.\n\nIn _International Symposium on Combinatorial Search_, pp.  19–27, 2014.\n\n- Carvalho et al. (2023)\nJoao Carvalho, An T Le, Mark Baierl, Dorothea Koert, and Jan Peters.\n\nMotion planning diffusion: Learning and planning of robot motions with diffusion models.\n\nIn _International Conference on Intelligent Robots and Systems_. IEEE, 2023.\n\n- Chen et al. (2021)\nJingkai Chen, Jiaoyang Li, Chuchu Fan, and Brian C Williams.\n\nScalable and safe multi-agent motion planning with nonlinear dynamics and bounded disturbances.\n\nIn _Proceedings of the AAAI conference on artificial intelligence_, volume 35, pp.  11237–11245, 2021.\n\n- Chi et al. (2024)\nCheng Chi, Zhenjia Xu, Siyuan Feng, Eric Cousineau, Yilun Du, Benjamin Burchfiel, Russ Tedrake, and Shuran Song.\n\nDiffusion policy: Visuomotor policy learning via action diffusion.\n\n_The International Journal of Robotics Research_, 2024.\n\n- Choudhury et al. (2018)\nSanjiban Choudhury, Mohak Bhardwaj, Sankalp Arora, Ashish Kapoor, Gireeja Ranade, Sebastian Scherer, and Debadeepta Dey.\n\nData-driven planning via imitation learning.\n\n_The International Journal of Robotics Research_, 37(13-14):1632–1672, 2018.\n\n- Cohen et al. (2016)\nLiron Cohen, Tansel Uras, TK Satish Kumar, Hong Xu, Nora Ayanian, and Sven Koenig.\n\nImproved solvers for bounded-suboptimal multi-agent path finding.\n\nIn _IJCAI_, 2016.\n\n- Erdmann & Lozano-Perez (1987)\nMichael Erdmann and Tomas Lozano-Perez.\n\nOn multiple moving objects.\n\n_Algorithmica_, pp.  477–521, 1987.\n\n- Ho et al. (2020)\nJonathan Ho, Ajay Jain, and Pieter Abbeel.\n\nDenoising diffusion probabilistic models.\n\nIn H. Larochelle, M. Ranzato, R. Hadsell, M.F. Balcan, and H. Lin (eds.), _Advances in Neural Information Processing Systems_, volume 33, pp.  6840–6851. Curran Associates, Inc., 2020.\n\nURL [https://proceedings.neurips.cc/paper\\_files/paper/2020/file/4c5bcfec8584af0d967f1ab10179ca4b-Paper.pdf](https://proceedings.neurips.cc/paper_files/paper/2020/file/4c5bcfec8584af0d967f1ab10179ca4b-Paper.pdf \"\").\n\n- Hönig et al. (2018)\nWolfgang Hönig, James A Preiss, TK Satish Kumar, Gaurav S Sukhatme, and Nora Ayanian.\n\nTrajectory planning for quadrotor swarms.\n\n_IEEE Transactions on Robotics_, 34(4):856–869, 2018.\n\n- Hopcroft & Wilfong (1986)\nJohn E Hopcroft and Gordon T. Wilfong.\n\nReducing multiple object motion planning to graph searching.\n\n_SIAM Journal on Computing_, 15(3):768–785, 1986.\n\n- Janner et al. (2022)\nMichael Janner, Yilun Du, Joshua Tenenbaum, and Sergey Levine.\n\nPlanning with diffusion for flexible behavior synthesis.\n\nIn _International Conference on Machine Learning_. PMLR, 2022.\n\n- Jiang et al. (2023)\nChiyu Jiang, Andre Cornman, Cheolho Park, Benjamin Sapp, Yin Zhou, Dragomir Anguelov, et al.\n\nMotiondiffuser: Controllable multi-agent motion prediction using diffusion.\n\nIn _Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition_, pp.  9644–9653, 2023.\n\n- Karaman & Frazzoli (2011)\nSertac Karaman and Emilio Frazzoli.\n\nSampling-based algorithms for optimal motion planning.\n\n_The International Journal of Robotics Research_, pp.  846–894, 2011.\n\n- Kavraki et al. (1996)\nLydia E Kavraki, Petr Svestka, J-C Latombe, and Mark H Overmars.\n\nProbabilistic roadmaps for path planning in high-dimensional configuration spaces.\n\n_IEEE transactions on Robotics and Automation_, 12(4):566–580, 1996.\n\n- Leroy et al. (1999)\nStephane Leroy, Jean-Paul Laumond, and Thierry Siméon.\n\nMultiple path coordination for mobile robots: A geometric algorithm.\n\nIn _IJCAI_, volume 99, pp.  1118–1123, 1999.\n\n- Li et al. (2019)\nJiaoyang Li, Pavel Surynek, Ariel Felner, Hang Ma, TK Satish Kumar, and Sven Koenig.\n\nMulti-agent path finding for large agents.\n\nIn _AAAI Conference on Artificial Intelligence_, pp.  7627–7634, 2019.\n\n- Li et al. (2021)\nJiaoyang Li, Wheeler Ruml, and Sven Koenig.\n\nEecbs: A bounded-suboptimal search for multi-agent path finding.\n\nIn _AAAI Conference on Artificial Intelligence_, pp.  12353–12362, 2021.\n\n- Lugmayr et al. (2022)\nAndreas Lugmayr, Martin Danelljan, Andres Romero, Fisher Yu, Radu Timofte, and Luc Van Gool.\n\nRepaint: Inpainting using denoising diffusion probabilistic models, 2022.\n\nURL [https://arxiv.org/abs/2201.09865](https://arxiv.org/abs/2201.09865 \"\").\n\n- Mishra et al. (2023)\nUtkarsh Aashu Mishra, Shangjie Xue, Yongxin Chen, and Danfei Xu.\n\nGenerative skill chaining: Long-horizon skill planning with diffusion models.\n\nIn _Conference on Robot Learning_, 2023.\n\nURL [https://openreview.net/forum?id=HtJE9ly5dT](https://openreview.net/forum?id=HtJE9ly5dT \"\").\n\n- Mishra et al. (2024)\nUtkarsh Aashu Mishra, Yongxin Chen, and Danfei Xu.\n\nGenerative factor chaining: Coordinated manipulation with diffusion-based factor graph.\n\nIn _8th Annual Conference on Robot Learning_, 2024.\n\nURL [https://openreview.net/forum?id=p6Wq6TjjHH](https://openreview.net/forum?id=p6Wq6TjjHH \"\").\n\n- Okumura (2024)\nKeisuke Okumura.\n\nEngineering lacam\\*: Towards real-time, large-scale, and near-optimal multi-agent pathfinding.\n\nIn _23rd International Conference on Autonomous Agents and Multiagent Systems_, 2024.\n\n- Pearl & Kim (1982)\nJudea Pearl and Jin H. Kim.\n\nStudies in semi-admissible heuristics.\n\n_IEEE Transactions on Pattern Analysis and Machine Intelligence_, pp.  392–399, 1982.\n\n- Qureshi et al. (2020)\nAhmed Hussain Qureshi, Yinglong Miao, Anthony Simeonov, and Michael C Yip.\n\nMotion planning networks: Bridging the gap between learning-based and classical motion planners.\n\n_IEEE Transactions on Robotics_, 37(1):48–66, 2020.\n\n- Sanchez & Latombe (2002)\nGildardo Sanchez and J-C Latombe.\n\nUsing a prm planner to compare centralized and decoupled planning for multi-robot systems.\n\nIn _Proceedings 2002 IEEE international conference on robotics and automation (Cat. No. 02CH37292)_, volume 2, pp.  2112–2119. IEEE, 2002.\n\n- Shaoul et al. (2024a)\nYorai Shaoul, Itamar Mishani, Maxim Likhachev, and Jiaoyang Li.\n\nAccelerating search-based planning for multi-robot manipulation by leveraging online-generated experiences.\n\nIn _International Conference on Automated Planning and Scheduling_, 2024a.\n\n- Shaoul et al. (2024b)\nYorai Shaoul, Rishi Veerapaneni, Maxim Likhachev, and Jiaoyang Li.\n\nUnconstraining multi-robot manipulation: Enabling arbitrary constraints in ecbs with bounded sub-optimality.\n\nIn _International Symposium on Combinatorial Search_, 2024b.\n\n- Sharon et al. (2015)\nGuni Sharon, Roni Stern, Ariel Felner, and Nathan R Sturtevant.\n\nConflict-based search for optimal multi-agent pathfinding.\n\n_Artificial Intelligence_, pp.  40–66, 2015.\n\n- Sohl-Dickstein et al. (2015)\nJascha Sohl-Dickstein, Eric Weiss, Niru Maheswaranathan, and Surya Ganguli.\n\nDeep unsupervised learning using nonequilibrium thermodynamics.\n\nIn _International conference on machine learning_, pp.  2256–2265. PMLR, 2015.\n\n- Sohn et al. (2015)\nKihyuk Sohn, Honglak Lee, and Xinchen Yan.\n\nLearning structured output representation using deep conditional generative models.\n\n_Advances in neural information processing systems_, 28, 2015.\n\n- Solis et al. (2021)\nIrving Solis, James Motes, Read Sandström, and Nancy M Amato.\n\nRepresentation-optimal multi-robot motion planning using conflict-based search.\n\n_IEEE Robotics and Automation Letters_, pp.  4608–4615, 2021.\n\n- Solovey et al. (2016)\nKiril Solovey, Oren Salzman, and Dan Halperin.\n\nFinding a needle in an exponential haystack: Discrete rrt for exploration of implicit roadmaps in multi-robot motion planning.\n\n_The International Journal of Robotics Research_, 35(5):501–513, 2016.\n\n- Song et al. (2021)\nYang Song, Jascha Sohl-Dickstein, Diederik P. Kingma, Abhishek Kumar, Stefano Ermon, and Ben Poole.\n\nScore-based generative modeling through stochastic differential equations.\n\nIn _9th International Conference on Learning Representations, ICLR 2021, Virtual Event, Austria, May 3-7, 2021_. OpenReview.net, 2021.\n\nURL [https://openreview.net/forum?id=PxTIG12RRHS](https://openreview.net/forum?id=PxTIG12RRHS \"\").\n\n- Stern et al. (2019)\nRoni Stern, Nathan Sturtevant, Ariel Felner, Sven Koenig, Hang Ma, Thayne Walker, Jiaoyang Li, Dor Atzmon, Liron Cohen, TK Kumar, et al.\n\nMulti-agent pathfinding: Definitions, variants, and benchmarks.\n\nIn _International Symposium on Combinatorial Search_, pp.  151–158, 2019.\n\n- Tajbakhsh et al. (2024)\nArdalan Tajbakhsh, Lorenz T Biegler, and Aaron M Johnson.\n\nConflict-based model predictive control for scalable multi-robot motion planning.\n\nIn _IEEE International Conference on Robotics and Automation_. IEEE, 2024.\n\n- Ubukata et al. (2024)\nToshihide Ubukata, Jialong Li, and Kenji Tei.\n\nDiffusion model for planning: A systematic literature review.\n\n_arXiv preprint arXiv:2408.10266_, 2024.\n\n- Vemula et al. (2021)\nAnirudh Vemula, J Andrew Bagnell, and Maxim Likhachev.\n\nCmax++: Leveraging experience in planning and execution using inaccurate models.\n\nIn _Proceedings of the AAAI Conference on Artificial Intelligence_, volume 35, pp.  6147–6155, 2021.\n\n- Xiao et al. (2022)\nXuesu Xiao, Bo Liu, Garrett Warnell, and Peter Stone.\n\nMotion planning and control for mobile robot navigation using machine learning: a survey.\n\n_Autonomous Robots_, 46(5):569–597, 2022.\n\n- Zhou et al. (2024)\nSiyuan Zhou, Yilun Du, Shun Zhang, Mengdi Xu, Yikang Shen, Wei Xiao, Dit-Yan Yeung, and Chuang Gan.\n\nAdaptive online replanning with diffusion models.\n\n_Advances in Neural Information Processing Systems_, 2024.\n\n\n## Appendix A Appendix\n\nThese additional materials come to add auxiliary details on our algorithms and their implementation, alongside providing further experimental evidence that we omitted from the main text. We begin with an additional discussion on our algorithmic framework, move on to provide additional results, and conclude with implementation and baseline details.\n\n### A.1 Additional Algorithmic Discussion\n\nIn this section, we expand on a few key ways in which MMD-PP and MMD-CBS improve on their classical counterparts. These were lightly touched on in the main text. We outline them in more detail here.\n\nCT Node Ordering in CBS. Traditionally, MAPF algorithms aim to find the shortest paths from starts to goals. Therefore, in CBS, the high-level nodes N𝑁N popped from the CT are the ones of least cost. In our case, where the data-driven objective function scoring trajectories is generally not available in practice, we instead aim to quickly find solutions that are collision-free, delegating the task of finding high-quality solutions to the diffusion models. To this end, the MMD CBS strategies choose CT nodes with the least number of conflicts to explore first, as they are more likely to lead to collision-free solutions quickly. This is similar to the algorithm GCBS-H outlined in Barer et al. ( [2014](https://ar5iv.org/html/2410.03072#bib.bib2 \"\")). Resembling their outcomes, we also observed a significant runtime improvement between prioritizing CT nodes based on their geometric quality and their collision count.\n\nBatch Trajectory Generation. Planning with diffusion models has the added benefit of being able to generate a diverse set of solutions with a single inference pass (Carvalho et al., [2023](https://ar5iv.org/html/2410.03072#bib.bib3 \"\")). MMD makes use of this property. In contrast to the original CBS, where CT nodes N𝑁N store a single path for each robot within N.Πformulae-sequence𝑁ΠN.\\\\Pi, MMD stores trajectory batches for each robot ℛisubscriptℛ𝑖\\\\mathcal{R}\\_{i} within N.𝝉formulae-sequence𝑁𝝉N.\\\\boldsymbol{\\\\tau}. That is, N.𝝉iformulae-sequence𝑁superscript𝝉𝑖N.\\\\boldsymbol{\\\\tau}^{i} may be a set of B∈ℤ>0𝐵superscriptℤabsent0B\\\\in\\\\mathbb{Z}^{>0} trajectories, with B𝐵B being a batch size. MMD-PP follows similarly, storing a batch of trajectories for each robot. When planning for ℛisubscriptℛ𝑖\\\\mathcal{R}\\_{i}, MMD generates a batch of trajectories under the currently active constraint set N.Ciformulae-sequence𝑁superscript𝐶𝑖N.C^{i} (see Fig. [1](https://ar5iv.org/html/2410.03072#S2.F1 \"Figure 1 ‣ 2.3 Planning with Diffusion Models ‣ 2 Preliminary ‣ Multi-Robot Motion Planning with Diffusion Models\")). Once the batch is generated, MMD iterates over the new resulting trajectories N.𝝉iformulae-sequence𝑁superscript𝝉𝑖N.\\\\boldsymbol{\\\\tau}^{i} and marks the one with the least collisions as the representative trajectory for ℛisubscriptℛ𝑖\\\\mathcal{R}\\_{i}. In MMD-PP this trajectory is used to define the placement of soft-constraints in following iterations and will be part of the solution. In MMD-ECBS, weak soft-constraints will similarly be added. All MMD CBS-based algorithms use representative trajectories to compute the number of conflicts within CT nodes. When a conflict-free CT node is found (e.g., there are no collisions between representative trajectories), MMD returns the representative trajectories of N.𝝉formulae-sequence𝑁𝝉N.\\\\boldsymbol{\\\\tau} as the solution.\n\n### A.2 Experimental Evaluation: Additional Results\n\nWe provide additional quantitative and qualitative results for our first two experiment sets, outlined in Table [1](https://ar5iv.org/html/2410.03072#A1.T1 \"Table 1 ‣ A.2.1 Additional Quantitative Resutls ‣ A.2 Experimental Evaluation: Additional Results ‣ Appendix A Appendix ‣ Multi-Robot Motion Planning with Diffusion Models\"), Table [2](https://ar5iv.org/html/2410.03072#A1.T2 \"Table 2 ‣ A.2.1 Additional Quantitative Resutls ‣ A.2 Experimental Evaluation: Additional Results ‣ Appendix A Appendix ‣ Multi-Robot Motion Planning with Diffusion Models\"), and Fig. [6](https://ar5iv.org/html/2410.03072#A1.F6 \"Figure 6 ‣ A.2.1 Additional Quantitative Resutls ‣ A.2 Experimental Evaluation: Additional Results ‣ Appendix A Appendix ‣ Multi-Robot Motion Planning with Diffusion Models\"). Discussions of these experimental results are included.\n\n#### A.2.1 Additional Quantitative Resutls\n\nOur manuscript mainly evaluated algorithms based on their performance in terms of success rate and data adherence (Fig. [2](https://ar5iv.org/html/2410.03072#S3.F2 \"Figure 2 ‣ 3.3 Sequencing Diffusion Models for Long Horizon Planning ‣ 3 Method ‣ Multi-Robot Motion Planning with Diffusion Models\"), Fig. [3(j)](https://ar5iv.org/html/2410.03072#S4.F3.sf10 \"In Figure 3 ‣ 4 Experimental Analysis ‣ Multi-Robot Motion Planning with Diffusion Models\"), and Fig. [5(f)](https://ar5iv.org/html/2410.03072#S4.F5.sf6 \"In Figure 5 ‣ 4.2 MMD Outperforms MAPF with Learned Cost Maps ‣ 4 Experimental Analysis ‣ Multi-Robot Motion Planning with Diffusion Models\")). While these metrics are sufficient to capture MMD’s ability to consistently produce trajectories that follow an underlying motion data distribution, one may also be interested in solutions’ smoothness and the wall-clock time it takes to generate those.\nTo this end, we include results for the average acceleration per robot (column A in Table [1](https://ar5iv.org/html/2410.03072#A1.T1 \"Table 1 ‣ A.2.1 Additional Quantitative Resutls ‣ A.2 Experimental Evaluation: Additional Results ‣ Appendix A Appendix ‣ Multi-Robot Motion Planning with Diffusion Models\") and Table [2](https://ar5iv.org/html/2410.03072#A1.T2 \"Table 2 ‣ A.2.1 Additional Quantitative Resutls ‣ A.2 Experimental Evaluation: Additional Results ‣ Appendix A Appendix ‣ Multi-Robot Motion Planning with Diffusion Models\")), as a proxy for smoothness, and the runtime for trajectory generation (column T).\n\n| Empty Map | Highways Map |\n| --- | --- |\n| n𝑛n | Method | S↑↑\\\\uparrow | D↑↑\\\\uparrow | T↓↓\\\\downarrow | A↓↓\\\\downarrow | n𝑛n | Method | S↑↑\\\\uparrow | D↑↑\\\\uparrow | T↓↓\\\\downarrow | A↓↓\\\\downarrow |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| 3 | MMD | 100% | 0.999 | 3.4 | 0.002 | 3 | MMD | 100% | 0.96 | 3.3 | 0.042 |\n| MPD-C | 100% | 1.000 | 2.1 | 0.010 | MPD-C | 100% | 0.98 | 2.1 | 0.032 |\n| 6 | MMD | 100% | 0.995 | 7.0 | 0.002 | 6 | MMD | 98% | 0.97 | 6.9 | 0.045 |\n| MPD-C | 62% | 0.331 | 2.2 | 0.142 | MPD-C | 0% | - | - | - |\n| 9 | MMD | 100% | 0.991 | 11.1 | 0.002 | 9 | MMD | 96% | 0.97 | 10.7 | 0.043 |\n| MPD-C | 0% | - | - | \\- | MPD-C | 0% | - | - | - |\n\nTable 1: Comparison of methods by number of agents in the Empty environment (left) and the Highways environment (right). S is the success rate (%), D the data adherence score (see Sec. [4](https://ar5iv.org/html/2410.03072#S4 \"4 Experimental Analysis ‣ Multi-Robot Motion Planning with Diffusion Models\")), T is the average planning time (seconds), and A is average acceleration (length units/s2superscript𝑠2s^{2}), a proxy for smoothness. Despite being computationally efficient, the composite baseline struggles to maintain high data adherence scores. Here, MMD is MMD-xECBS.\n\n| Highways Map | Conveyor Map | Drop-Region Map |\n| --- | --- | --- |\n| n𝑛n | Method | S↑↑\\\\uparrow | D↑↑\\\\uparrow | T↓↓\\\\downarrow | A↓↓\\\\downarrow | S↑↑\\\\uparrow | D↑↑\\\\uparrow | T↓↓\\\\downarrow | A↓↓\\\\downarrow | S↑↑\\\\uparrow | D↑↑\\\\uparrow | T↓↓\\\\downarrow | A↓↓\\\\downarrow |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| 3 | MMD-xECBS | 100% | 0.93 | 3.6 | 0.04 | 100% | 0.87 | 3.9 | 0.10 | 100% | 1.00 | 3.7 | 0.05 |\n| MMD-ECBS | 100% | 0.93 | 3.5 | 0.04 | 100% | 0.87 | 4.5 | 0.09 | 100% | 1.00 | 3.8 | 0.05 |\n| MMD-PP | 100% | 0.93 | 4.3 | 0.04 | 100% | 0.80 | 4.2 | 0.09 | 100% | 0.97 | 4.2 | 0.05 |\n| MMD-CBS | 100% | 0.93 | 4.0 | 0.04 | 100% | 0.93 | 5.7 | 0.10 | 100% | 1.00 | 6.7 | 0.06 |\n| MMD-xCBS | 100% | 0.93 | 3.6 | 0.04 | 100% | 0.93 | 4.3 | 0.11 | 100% | 1.00 | 4.5 | 0.07 |\n| A\\*Data-ECBS | 100% | 0.87 | 3.4 | \\- | 100% | 0.03 | 0.2 | \\- | 100% | 0.27 | 0.2 | - |\n| A\\*-ECBS | 100% | 0.57 | 0.1 | \\- | 100% | 0.00 | 0.5 | \\- | 100% | 0.27 | 0.2 | - |\n| 6 | MMD-xECBS | 100% | 1.00 | 7.0 | 0.05 | 100% | 0.95 | 9.3 | 0.11 | 100% | 0.90 | 7.7 | 0.06 |\n| MMD-ECBS | 100% | 1.00 | 7.3 | 0.05 | 100% | 0.92 | 13.2 | 0.09 | 100% | 0.95 | 8.4 | 0.05 |\n| MMD-PP | 100% | 0.98 | 8.9 | 0.04 | 70% | 0.90 | 8.7 | 0.09 | 100% | 0.93 | 8.4 | 0.05 |\n| MMD-CBS | 100% | 1.00 | 14.2 | 0.05 | 100% | 0.93 | 18.9 | 0.10 | 100% | 1.00 | 16.7 | 0.06 |\n| MMD-xCBS | 100% | 1.00 | 10.2 | 0.05 | 100% | 0.95 | 11.0 | 0.14 | 100% | 0.97 | 12.1 | 0.08 |\n| A\\*Data-ECBS | 100% | 0.88 | 4.5 | \\- | 100% | 0.17 | 1.1 | \\- | 100% | 0.13 | 0.9 | - |\n| A\\*-ECBS | 100% | 0.55 | 0.7 | \\- | 100% | 0.05 | 2.4 | \\- | 100% | 0.12 | 1.1 | - |\n| 9 | MMD-xECBS | 100% | 0.97 | 12.7 | 0.05 | 100% | 0.93 | 14.6 | 0.11 | 100% | 0.94 | 12.9 | 0.06 |\n| MMD-ECBS | 100% | 0.97 | 15.0 | 0.05 | 100% | 0.92 | 19.6 | 0.09 | 100% | 0.96 | 15.5 | 0.06 |\n| MMD-PP | 90% | 0.96 | 13.5 | 0.05 | 30% | 1.00 | 12.4 | 0.10 | 60% | 0.93 | 12.3 | 0.06 |\n| MMD-CBS | 100% | 0.96 | 43.8 | 0.05 | 60% | 0.94 | 46.6 | 0.11 | 50% | 0.93 | 47.5 | 0.08 |\n| MMD-xCBS | 100% | 0.96 | 29.8 | 0.05 | 100% | 0.94 | 32.8 | 0.20 | 70% | 0.92 | 39.1 | 0.11 |\n| A\\*Data-ECBS | 100% | 0.88 | 14.0 | \\- | 100% | 0.10 | 2.7 | \\- | 100% | 0.22 | 1.3 | - |\n| A\\*-ECBS | 100% | 0.51 | 3.4 | \\- | 100% | 0.06 | 3.4 | \\- | 100% | 0.19 | 0.8 | - |\n| 12 | MMD-xECBS | 100% | 0.99 | 15.8 | 0.04 | 100% | 0.94 | 23.1 | 0.13 | 100% | 0.87 | 22.9 | 0.07 |\n| MMD-ECBS | 100% | 0.99 | 17.6 | 0.04 | 100% | 0.95 | 28.4 | 0.10 | 100% | 0.88 | 29.6 | 0.06 |\n| MMD-PP | 80% | 0.99 | 18.4 | 0.05 | 30% | 0.86 | 16.9 | 0.10 | 0% | - | - | - |\n| MMD-CBS | 0% | - | - | \\- | 0% | - | - | \\- | 0% | - | - | - |\n| MMD-xCBS | 30% | 0.97 | 54.6 | 0.05 | 10% | 1.00 | 53.5 | 0.19 | 0% | - | - | - |\n| A\\*Data-ECBS | 80% | 0.83 | 19.7 | \\- | 100% | 0.14 | 3.8 | \\- | 100% | 0.22 | 4.0 | - |\n| A\\*-ECBS | 100% | 0.52 | 6.0 | \\- | 100% | 0.03 | 4.0 | \\- | 100% | 0.23 | 4.4 | - |\n| 15 | MMD-xECBS | 100% | 0.97 | 24.3 | 0.05 | 90% | 0.96 | 38.3 | 0.14 | 100% | 0.80 | 35.7 | 0.07 |\n| MMD-ECBS | 100% | 0.97 | 29.3 | 0.05 | 80% | 0.97 | 43.7 | 0.10 | 60% | 0.86 | 43.0 | 0.06 |\n| MMD-PP | 60% | 0.99 | 23.2 | 0.05 | 0% | - | - | \\- | 0% | - | - | - |\n| MMD-CBS | 0% | - | - | \\- | 0% | - | - | \\- | 0% | - | - | - |\n| MMD-xCBS | 0% | - | - | \\- | 0% | - | - | \\- | 0% | - | - | - |\n| A\\*Data-ECBS | 50% | 0.85 | 32.0 | \\- | 100% | 0.11 | 14.4 | \\- | 100% | 0.24 | 7.7 | - |\n| A\\*-ECBS | 100% | 0.47 | 10.5 | \\- | 100% | 0.04 | 13.4 | \\- | 100% | 0.21 | 9.3 | - |\n| 20 | MMD-xECBS | 100% | 0.96 | 46.1 | 0.05 | 0% | - | - | \\- | 0% | - | - | - |\n| MMD-ECBS | 60% | 0.97 | 51.8 | 0.05 | 0% | - | - | \\- | 0% | - | - | - |\n| MMD-PP | 0% | - | - | \\- | 0% | - | - | \\- | 0% | - | - | - |\n| MMD-CBS | 0% | - | - | \\- | 0% | - | - | \\- | 0% | - | - | - |\n| MMD-xCBS | 0% | - | - | \\- | 0% | - | - | \\- | 0% | - | - | - |\n| A\\*Data-ECBS | 22% | 0.82 | 43.5 | \\- | 100% | 0.11 | 15.6 | \\- | 100% | 0.23 | 15.7 | - |\n| A\\*-ECBS | 80% | 0.46 | 21.6 | \\- | 100% | 0.05 | 21.0 | \\- | 100% | 0.22 | 16.5 | - |\n\nTable 2: Additional results for a subset of our MMD and MAPF evaluation. Table columns are similar to Table [1](https://ar5iv.org/html/2410.03072#A1.T1 \"Table 1 ‣ A.2.1 Additional Quantitative Resutls ‣ A.2 Experimental Evaluation: Additional Results ‣ Appendix A Appendix ‣ Multi-Robot Motion Planning with Diffusion Models\").\nWe omit acceleration information from the MAPF methods as those plan on a grid graph and assume constant velocities.\n\nAverage Acceleration Per Robot. Despite showing little information, since the composite baseline quickly failed to produce valid trajectories, Table [1](https://ar5iv.org/html/2410.03072#A1.T1 \"Table 1 ‣ A.2.1 Additional Quantitative Resutls ‣ A.2 Experimental Evaluation: Additional Results ‣ Appendix A Appendix ‣ Multi-Robot Motion Planning with Diffusion Models\") offers valuable insights nonetheless. The A column provides a glance into the reason for composite-model’s failure. Consistent with our observations, we notice that the average acceleration per robot in the 666-robot case is drastically higher for the composite model than for MMD. This behavior, visually, translates to trajectories including small loops and sharp turns. See Fig. [6](https://ar5iv.org/html/2410.03072#A1.F6 \"Figure 6 ‣ A.2.1 Additional Quantitative Resutls ‣ A.2 Experimental Evaluation: Additional Results ‣ Appendix A Appendix ‣ Multi-Robot Motion Planning with Diffusion Models\") for an example.\nWe have trained MPD-Composite to convergence using our datasets (Sec. [A.6](https://ar5iv.org/html/2410.03072#A1.SS6 \"A.6 Baseline Details ‣ Appendix A Appendix ‣ Multi-Robot Motion Planning with Diffusion Models\")) and performed additional tuning, however, its generated motions struggled to capture the smooth, dynamically feasible transitions as the number of robots grew to 999.\nMMD, however, produced better and larger-scale trajectories. Table [1](https://ar5iv.org/html/2410.03072#A1.T1 \"Table 1 ‣ A.2.1 Additional Quantitative Resutls ‣ A.2 Experimental Evaluation: Additional Results ‣ Appendix A Appendix ‣ Multi-Robot Motion Planning with Diffusion Models\") shows MMD keeping low average accelerations per robot. In larger teams of robots, we notice the acceleration remaining mostly constant within each map even when the number of robots grows. This shows that robots produce similar motions within each map regardless of congestion levels—a sign of consistency that we seek as the number of robots scales.\n\nTrajectory Generation Runtime. While the composite models enjoy an invariance to the number of robots, as those only require a single inference pass for multi-robot trajectory generation, this is not the case for MMD. For once, all MMD algorithms begin with the sequential process of generating trajectories for all robots one at a time. The time for this operation, of course, scales linearly with the number of robots. As mentioned in our conclusion, the MMD CBS-based methods are naturally parallelized. Since the runtime of these methods is tightly related to the number of CT nodes created, which could be evaluated in parallel, doing so may drastically reduce runtimes. We leave this to future work.\n\nMAPF Baseline Runtime. The trends of our timing results for the MAPF baselines shown in Table [2](https://ar5iv.org/html/2410.03072#A1.T2 \"Table 2 ‣ A.2.1 Additional Quantitative Resutls ‣ A.2 Experimental Evaluation: Additional Results ‣ Appendix A Appendix ‣ Multi-Robot Motion Planning with Diffusion Models\") are inconsistent across maps. Interestingly, the planning time for A\\*Data-ECBS in the Highways map was significantly higher than that of A\\*-ECBS. This comes with the added benefit of the produced paths better adhering to data. In the other two maps, which have more challenging underlying motion data distributions, the difference between A\\*Data-ECBS and A\\*-ECBS was insignificant, though so were the data adherence scores. It is unclear to us how to effectively incorporate demonstrations from data into MAPF solvers without compromising their ability to scale.\n\n|  | MMD-xECBS | MMD-PP | MPD-Composite | A\\*Data-ECBS |\n| Empty 3 | \\[0.21\\]![Refer to caption](https://ar5iv.org/html/2410.03072/assets/figures/appendix_figures/mmd_xecbs_empty_3.png) | \\[0.21\\]![Refer to caption](https://ar5iv.org/html/2410.03072/assets/figures/appendix_figures/mmd_pp_empty_3.png) | \\[0.21\\]![Refer to caption](https://ar5iv.org/html/2410.03072/assets/figures/appendix_figures/mpdc_empty_3.png) | \\[0.21\\]![Refer to caption](https://ar5iv.org/html/2410.03072/assets/figures/appendix_figures/astar_data_empty_3.png) |\n| Highways 3 | \\[0.21\\]![Refer to caption](https://ar5iv.org/html/2410.03072/assets/figures/appendix_figures/mmd_xecbs_highways_3.png) | \\[0.21\\]![Refer to caption](https://ar5iv.org/html/2410.03072/assets/figures/appendix_figures/mmd_pp_highways_3.png) | \\[0.21\\]![Refer to caption](https://ar5iv.org/html/2410.03072/assets/figures/appendix_figures/mpdc_highways_3.png) | \\[0.21\\]![Refer to caption](https://ar5iv.org/html/2410.03072/assets/figures/appendix_figures/astar_data_highways_3.png) |\n| Empty 6 | \\[0.21\\]![Refer to caption](https://ar5iv.org/html/2410.03072/assets/figures/appendix_figures/mmd_xecbs_empty_6.png) | \\[0.21\\]![Refer to caption](https://ar5iv.org/html/2410.03072/assets/figures/appendix_figures/mmd_pp_empty_6.png) | \\[0.21\\]![Refer to caption](https://ar5iv.org/html/2410.03072/assets/figures/appendix_figures/mpdc_empty_6.png) | \\[0.21\\]![Refer to caption](https://ar5iv.org/html/2410.03072/assets/figures/appendix_figures/astar_data_empty_6.png) |\n| Highways 6 | \\[0.21\\]![Refer to caption](https://ar5iv.org/html/2410.03072/assets/figures/appendix_figures/mmd_xecbs_highways_6.png) | \\[0.21\\]![Refer to caption](https://ar5iv.org/html/2410.03072/assets/figures/appendix_figures/mmd_pp_highways_6.png) | Fail | \\[0.21\\]![Refer to caption](https://ar5iv.org/html/2410.03072/assets/figures/appendix_figures/astar_data_highways_6.png) |\n\n(a) \\*(b) \\*\n\n(c) \\*(d) \\*\n\n(e) \\*(f) \\*\n\n(g) \\*(h) \\*\n\n(i) \\*(j) \\*\n\n(k) \\*(l) \\*\n\n(m) \\*(n) \\*\n\n(o) \\*\n\nFigure 6: Visual examples of trajectories generated by MMD-xECBS, MMD-PP, MPD-Composite, and A\\*Data-ECBS in tests within the Empty and Highways maps. The top two rows show test cases with 333 robots, and the bottom two rows with 666. All planning problems follow the _circle_ setup (Sec. [4.2](https://ar5iv.org/html/2410.03072#S4.SS2 \"4.2 MMD Outperforms MAPF with Learned Cost Maps ‣ 4 Experimental Analysis ‣ Multi-Robot Motion Planning with Diffusion Models\")) with radius 0.60.60.6 for the Highways map and 0.80.80.8 for the Empty map.\n\n### A.3 Additional Qualitative Results\n\nTo better capture the behavior of the various trajectory generators discussed in this paper, Fig. [6](https://ar5iv.org/html/2410.03072#A1.F6 \"Figure 6 ‣ A.2.1 Additional Quantitative Resutls ‣ A.2 Experimental Evaluation: Additional Results ‣ Appendix A Appendix ‣ Multi-Robot Motion Planning with Diffusion Models\") shows a series of images of generated trajectories in two problems. We keep the number of robots low for clarity. Videos are available in our supplementary materials as well.\n\n### A.4 Implementation Details\n\nWe implemented all of our algorithms in Python and ran our experiments on a laptop with an Intel Core i9-12900H CPU, 32GB RAM (5.2GHz), and Nvidia GeForce RTX 3080Ti Laptop GPU (16 GB). We based our diffusion planning implementation on the official code of Carvalho et al. ( [2023](https://ar5iv.org/html/2410.03072#bib.bib3 \"\")) and used an exponential variance schedule. The guidance function cost components we used were 𝒥smoothsubscript𝒥smooth\\\\mathcal{J}\\_{\\\\text{smooth}} to encourage dynamically feasible trajectory generation with GPMP, 𝒥objsubscript𝒥obj\\\\mathcal{J}\\_{\\\\text{obj}} for obstacle avoidance (both from Carvalho et al. ( [2023](https://ar5iv.org/html/2410.03072#bib.bib3 \"\"))), and 𝒥csubscript𝒥c\\\\mathcal{J}\\_{\\\\text{c}} for constraint satisfaction. We set the weights λsmooth=8​e−2subscript𝜆smooth8e2\\\\lambda\\_{\\\\text{smooth}}=8\\\\mathrm{e}{-2}, λobj=2​e−2subscript𝜆obj2e2\\\\lambda\\_{\\\\text{obj}}=2\\\\mathrm{e}{-2}, and λc=2​e−1subscript𝜆c2e1\\\\lambda\\_{\\\\text{c}}=2\\\\mathrm{e}{-1} for strong soft-constraints and λc=2​e−2subscript𝜆c2e2\\\\lambda\\_{\\\\text{c}}=2\\\\mathrm{e}{-2} for weak soft-constraints.\n\nIn our experiments, the size of each local map was 2×2222\\\\times 2 units, and the diameter of each disk robot was 0.10.10.1 units.\nThe radius for CBS sphere constraints was the disk robot radius multiplied by a margin, resulting in a radius value of 0.120.120.12 units, and the time interval Δ​tΔ𝑡\\\\Delta t was 0.080.080.08 seconds (2 time steps).\n\n### A.5 Experimental Evaluation: Additional Details\n\nThis section provides details about our experimental setup, namely the data adherence scoring function costdata​(𝝉i)subscriptcostdatasuperscript𝝉𝑖\\\\text{cost}\\_{\\\\text{data}}(\\\\boldsymbol{\\\\tau}^{i}) that we used to evaluate trajectories 𝝉isuperscript𝝉𝑖\\\\boldsymbol{\\\\tau}^{i} in each map. We also include details on our baseline implementations.\n\n#### A.5.1 Data Adherence Functions\n\nAs discussed in Sec. [4](https://ar5iv.org/html/2410.03072#S4 \"4 Experimental Analysis ‣ Multi-Robot Motion Planning with Diffusion Models\"), each of our local maps has an associated motion pattern for robots to follow when those move within it. This motion pattern is reflected in the trajectory dataset associated with each map. Sec. [4](https://ar5iv.org/html/2410.03072#S4 \"4 Experimental Analysis ‣ Multi-Robot Motion Planning with Diffusion Models\") briefly outlined the data adherence score functions for each map, and we provide more specific definitions here.\n\nDrop-Region map (Fig. [3(i)](https://ar5iv.org/html/2410.03072#S4.F3.sf9 \"In Figure 3 ‣ 4 Experimental Analysis ‣ Multi-Robot Motion Planning with Diffusion Models\")) simulates package drop-off chutes.\nAdherence is met for 𝝉isuperscript𝝉𝑖\\\\boldsymbol{\\\\tau}^{i}, i.e., costdata​(𝝉i)=1subscriptcostdatasuperscript𝝉𝑖1\\\\text{cost}\\_{\\\\text{data}}(\\\\boldsymbol{\\\\tau}^{i})=1, if the trajectory spends at least 25%percent2525\\\\% of its duration, consecutively, in a region of radius 0.150.150.15 centered 0.150.150.15 units off the midpoint of each of the 161616 chutes.\n\nConveyor map (Fig. [3(e)](https://ar5iv.org/html/2410.03072#S4.F3.sf5 \"In Figure 3 ‣ 4 Experimental Analysis ‣ Multi-Robot Motion Planning with Diffusion Models\")) features narrow passages with directional motion requirements. Trajectory 𝝉isuperscript𝝉𝑖\\\\boldsymbol{\\\\tau}^{i} adheres to data if it includes a section that enters the top corridor from the right and leaves it from the left, or vice versa for the bottom corridor. There is no restriction on robots transitioning through the corridors in reverse, and no restriction on start or goal states being within the corridors. This requires robots to reason about traversal ordering.\n\nHighways map (Fig. [3(a)](https://ar5iv.org/html/2410.03072#S4.F3.sf1 \"In Figure 3 ‣ 4 Experimental Analysis ‣ Multi-Robot Motion Planning with Diffusion Models\")), requires counter-clockwise movement around a central obstacle. The origin of the map is at the middle of the centeral obstacle. For each state transition of a trajectory 𝝉isuperscript𝝉𝑖\\\\boldsymbol{\\\\tau}^{i}, from 𝝉tisubscriptsuperscript𝝉𝑖𝑡\\\\boldsymbol{\\\\tau}^{i}\\_{t} to 𝝉t+1isubscriptsuperscript𝝉𝑖𝑡1\\\\boldsymbol{\\\\tau}^{i}\\_{t+1}, the angle between the vectors pointing from the origin to 𝐪t+1isubscriptsuperscript𝐪𝑖𝑡1\\\\mathbf{q}^{i}\\_{t+1} and to 𝐪tisubscriptsuperscript𝐪𝑖𝑡\\\\mathbf{q}^{i}\\_{t} is computed. 𝐪tisubscriptsuperscript𝐪𝑖𝑡\\\\mathbf{q}^{i}\\_{t} is the associated configuration at 𝝉tisubscriptsuperscript𝝉𝑖𝑡\\\\boldsymbol{\\\\tau}^{i}\\_{t}. We define adherence to be met for 𝝉isuperscript𝝉𝑖\\\\boldsymbol{\\\\tau}^{i} if its cumulative angle is positive, i.e., counter-clockwise.\n\nEmpty map (Fig. [2(a)](https://ar5iv.org/html/2410.03072#S3.F2.sf1 \"In Figure 2 ‣ 3.3 Sequencing Diffusion Models for Long Horizon Planning ‣ 3 Method ‣ Multi-Robot Motion Planning with Diffusion Models\")) is our simplest. Trajectories 𝝉isuperscript𝝉𝑖\\\\boldsymbol{\\\\tau}^{i}, which have H𝐻H time steps, are scored based on the fraction of their steps that lie within a margin of a straight-line interpolation between a initial and final configurations 𝐪1i,𝐪Hisubscriptsuperscript𝐪𝑖1subscriptsuperscript𝐪𝑖𝐻\\\\mathbf{q}^{i}\\_{1},\\\\mathbf{q}^{i}\\_{H} in 𝝉isuperscript𝝉𝑖\\\\boldsymbol{\\\\tau}^{i}. Specifically, let l𝑙l be the distance between the first and last configurations in 𝝉isuperscript𝝉𝑖\\\\boldsymbol{\\\\tau}^{i}, and let m𝑚m be the number of trajectory configurations whose distance to the line 𝐪Hi−𝐪1isubscriptsuperscript𝐪𝑖𝐻subscriptsuperscript𝐪𝑖1\\\\mathbf{q}^{i}\\_{H}-\\\\mathbf{q}^{i}\\_{1} is less than l10𝑙10\\\\frac{l}{10}.\nWe define costdata​(𝝉i):=mHassignsubscriptcostdatasuperscript𝝉𝑖𝑚𝐻\\\\text{cost}\\_{\\\\text{data}}(\\\\boldsymbol{\\\\tau}^{i}):=\\\\frac{m}{H}.\n\n#### A.5.2 Large Scale Experiments\n\nTo mimic real-world scenarios, we have staggered the start times of robots in our large scale experiments in Sec. [4.3](https://ar5iv.org/html/2410.03072#S4.SS3 \"4.3 Sequenced Diffusion Models for Long-Horizon Planning ‣ 4 Experimental Analysis ‣ Multi-Robot Motion Planning with Diffusion Models\"). There, robots began moving 10 time steps apart. Robots in motion were required to avoid static robots, which may be stopped in high-density regions.\n\n### A.6 Baseline Details\n\nOur experiments include two families of baselines: composite models and MAPF methods. Both baselines attempt to produce trajectories (or paths) that distribute according to an underlying motion pattern that is reflected in a dataset.\nThis section comes to provide additional details regarding these baseline methods.\n\nComposite Models. Training composite models requires two components. The first is a dataset of multi-robot motions, and the second is a model that can be trained to generate trajectories that resemble those in the data. Given that obtaining multi-robot motion datasets is generally intractable as it requires solving an MRMP problem for each datapoint, in this paper we focus on single-robot data and construct our multi-robot datasets from collision-free subsets of our single-robot datasets.\nIt is worth noting that given that our multi-robot datasets were composed of single-robot data, the conclusions from our results is that it is difficult to learn multi-robot trajectory generation from composed single-robot data, and not that it is a uniquely challenging task in the general case. See Sec. [4.1](https://ar5iv.org/html/2410.03072#S4.SS1 \"4.1 Decoupling Scales Multi-Robot Diffusion Planning ‣ 4 Experimental Analysis ‣ Multi-Robot Motion Planning with Diffusion Models\") for a description of our composite models.\n\nMAPF Baselines.\nOur MAPF baselines, termed A\\*Data-ECBS and A\\*-ECBS, are both similar algorithmically and only differ in the edge costs they use for single-robot graphs. We will start with describing the algorithms and then give additional details for cost map creation.\nThe low-level planners used in these baselines are A\\* with a focal list mechanism, also known as Aϵ∗subscriptsuperscript𝐴italic-ϵA^{\\*}\\_{\\\\epsilon}(Pearl & Kim, [1982](https://ar5iv.org/html/2410.03072#bib.bib23 \"\")). We set the focal list bound to 1.51.51.5 and did not allow for re-expansions in our implementation. On the high-level search, we prioritized CT nodes strictly based on their conflict count to match the strategy in MMD. All robots in our experiments travelled on a 4-connected regular grid graph with step size of 0.10.10.1, and were allowed to move up, down, left, right, or wait on each time step, with each action incurring a unit cost in A\\*-ECBS. It is worth noting that the robots in our experiments are not point-robots, and so robot-robot collision checking is needed to find conflicts (e.g., two robots traversing different edges between t𝑡t and t′superscript𝑡′t^{\\\\prime} may still cause an edge conflict). This affected runtime.\nTo encode dataset demonstrations in A\\*Data-ECBS, we created cost maps for each evaluation map as discussed in Sec. [4.2](https://ar5iv.org/html/2410.03072#S4.SS2 \"4.2 MMD Outperforms MAPF with Learned Cost Maps ‣ 4 Experimental Analysis ‣ Multi-Robot Motion Planning with Diffusion Models\"). To do so in a given map, we iterate over all its dataset entries, and follow each trajectory, keeping track of which discretized cells (centered at states s𝑠s) it visited. For each cell that the trajectory visited, we find the first trajectory state outside of its center s𝑠s, call it s′superscript𝑠′s^{\\\\prime}, and increment a count for the outgoing graph (directed) edge from s𝑠s that aligns best with the line between s𝑠s and s′superscript𝑠′s^{\\\\prime}. Eventually, we assign directed edge costs of 1+10m110𝑚1+\\\\frac{10}{m} with m𝑚m being the number of trajectories that incremented this edge or 111 if none have.\nOur A\\*Data-ECBS and A\\*-ECBS implementation was done in Python.\n\n[◄](https://ar5iv.org/html/2410.03071) [![ar5iv homepage](https://ar5iv.org/assets/ar5iv.png)](https://ar5iv.org/) [Feeling\\\\\n\\\\\nlucky?](https://ar5iv.org/feeling_lucky) [Conversion\\\\\n\\\\\nreport](https://ar5iv.org/log/2410.03072) [Report\\\\\n\\\\\nan issue](https://github.com/dginev/ar5iv/issues/new?template=improve-article--arxiv-id-.md&title=Improve+article+2410.03072) [View original\\\\\n\\\\\non arXiv](https://arxiv.org/abs/2410.03072) [►](https://ar5iv.org/html/2410.03073)",
  "sections": {
    "1 Introduction": {
      "content": "Multi-robot motion planning (MRMP) is a fundamental challenge in many real-world applications where teams of robots have to work in close proximity to each other to complete their tasks.\nIn automated warehouses, for example, hundreds of mobile robots and robotic manipulators need to coordinate with each other to transport and exchange items while avoiding collisions. Learning motions from demonstrations can oftentimes allow robots to complete tasks they couldn’t otherwise, like navigating a region in a pattern frequently followed by human workers; however, it is unclear how to best incorporate demonstrations in MRMP. In fact, MRMP at its simplest form, where robots are only concerned with finding short trajectories between start and goal configurations, is already known to be computationally intractable (Hopcroft & Wilfong, [1986])—significantly harder than single-agent motion planning due to the complexity of mutual interactions between robots.\nAttempting to simplify the problem, various approximate formulations have been proposed in the literature. For example, a popular approach is to formulate the problem as a multi-agent path finding problem (MAPF) (Stern et al., [2019]) by discretizing space and time. While the latest MAPF planners (Li et al., [2021]; Okumura, [2024]) can compute near-optimal plans and scale to hundreds of agents, they make strong assumptions, such as constant velocities and rectilinear movements that limit their real-world application and reduce their ability to generate complex behaviors learned from demonstrations.\n\nIn single-agent motion planning, methods that learn to plan from data (Xiao et al., [2022]) have been widely used to circumvent similar limitations resulting from inaccurate models (Vemula et al., [2021]), partial observability (Choudhury et al., [2018]) and slow planning (Sohn et al., [2015]; Qureshi et al., [2020]).\nMore recently, diffusion models (DM) have emerged as the generative model of choice for learning visuomotor manipulation policies from demonstrations (Chi et al., [2024]), motion planning (Carvalho et al., [2023]), and reinforcement learning (Janner et al., [2022]). However, there has been relatively little work on extending these ideas to multi-robot motion planning. This is due to the twin challenges of generating high quality multi-agent data and the _curse of dimensionality_, i.e., significantly higher sample complexity of learning multi-robot models.\n\nIn this paper, we propose a data-efficient and scalable multi-robot diffusion planning algorithm, Multi-robot Multi-model planning Diffusion (MMD), that addresses both these challenges by combining constraint-based MAPF planners with diffusion models.\nImportantly, our approach calls for learning only _single-robot diffusion models_, which does away with the difficulty of obtaining multi-robot interaction data and breaks the curse of dimensionality. MMD generates collision-free trajectories by _constraining_ single-robot diffusion models using our\nnovel spatio-temporal guiding functions and choosing constraint placement via strategies inspired by MAPF algorithms.\nOur contributions in this paper are threefold:\n\n- •\n\n\nWe propose a data-efficient framework for multi-robot diffusion planning inspired by constraint-based search algorithms.\n\n- •\n\n\nWe provide a comparative analysis of the performance of five MMD algorithms, each based on a different MAPF algorithm, shedding light on their applicability to coordinating robots leveraging diffusion models for planning.\n\n- •\n\n\nWe show that we can scale our approach to arbitrarily large and diverse maps by learning and composing multiple diffusion models for each robot.\n\n\nOur experimental results from varied motion planning problems in simulated scenarios motivated by logistics environments suggest that our approach scales favorably with both the number of agents and the size of the environment when compared to alternatives.",
      "citations": [
        {
          "start_pos": 816,
          "end_pos": 842,
          "text": "Hopcroft & Wilfong, [1986]",
          "paper_id": "bib.bib11",
          "single_citation": true,
          "citation_type": "others",
          "nearest_citations": null
        },
        {
          "start_pos": 1173,
          "end_pos": 1193,
          "text": "Stern et al., [2019]",
          "paper_id": "bib.bib34",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        },
        {
          "start_pos": 1259,
          "end_pos": 1276,
          "text": "Li et al., [2021]",
          "paper_id": "bib.bib18",
          "single_citation": false,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1278,
          "end_pos": 1293,
          "text": "Okumura, [2024]",
          "paper_id": "bib.bib22",
          "single_citation": false,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib21",
            "bib.bib9",
            "bib.bib19"
          ]
        },
        {
          "start_pos": 1639,
          "end_pos": 1658,
          "text": "Xiao et al., [2022]",
          "paper_id": "bib.bib38",
          "single_citation": true,
          "citation_type": "others",
          "nearest_citations": null
        },
        {
          "start_pos": 1750,
          "end_pos": 1771,
          "text": "Vemula et al., [2021]",
          "paper_id": "bib.bib37",
          "single_citation": true,
          "citation_type": "others",
          "nearest_citations": null
        },
        {
          "start_pos": 1797,
          "end_pos": 1821,
          "text": "Choudhury et al., [2018]",
          "paper_id": "bib.bib6",
          "single_citation": true,
          "citation_type": "others",
          "nearest_citations": null
        },
        {
          "start_pos": 1842,
          "end_pos": 1861,
          "text": "Sohn et al., [2015]",
          "paper_id": "bib.bib30",
          "single_citation": false,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1863,
          "end_pos": 1885,
          "text": "Qureshi et al., [2020]",
          "paper_id": "bib.bib24",
          "single_citation": false,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 2039,
          "end_pos": 2057,
          "text": "Chi et al., [2024]",
          "paper_id": "bib.bib5",
          "single_citation": true,
          "citation_type": "others",
          "nearest_citations": null
        },
        {
          "start_pos": 2077,
          "end_pos": 2100,
          "text": "Carvalho et al., [2023]",
          "paper_id": "bib.bib3",
          "single_citation": true,
          "citation_type": "others",
          "nearest_citations": null
        },
        {
          "start_pos": 2131,
          "end_pos": 2152,
          "text": "Janner et al., [2022]",
          "paper_id": "bib.bib12",
          "single_citation": true,
          "citation_type": "others",
          "nearest_citations": null
        }
      ]
    },
    "2 Preliminary": {
      "content": "In this section we define the MRMP problem and provide relevant background on constraint-based MAPF algorithms and on planning with diffusion models. Sec. [3]Method ‣ Multi-Robot Motion Planning with Diffusion Models\") elaborates on how we combine these concepts to coordinate numerous robots that plan with diffusion models.\n\n### 2.1 Multi-Robot Motion Planning (MRMP)\n\nGiven n𝑛n robots ℛisubscriptℛ𝑖\\\\mathcal{R}\\_{i}, MRMP seeks a set of collision-free trajectories, one for each robot, that optimize a given objective function.\nLet 𝒮isuperscript𝒮𝑖\\\\mathcal{S}^{i} be the state space of a single robot and a state be 𝐬i:=\\[𝐪i,𝐪˙i\\]⊺∈𝒮iassignsuperscript𝐬𝑖superscriptsuperscript𝐪𝑖superscript˙𝐪𝑖⊺superscript𝒮𝑖\\\\mathbf{s}^{i}:=\\[\\\\mathbf{q}^{i},\\\\dot{\\\\mathbf{q}}^{i}\\]^{\\\\intercal}\\\\in\\\\mathcal{S}^{i} where 𝐪isuperscript𝐪𝑖\\\\mathbf{q}^{i} and 𝐪˙isuperscript˙𝐪𝑖\\\\dot{\\\\mathbf{q}}^{i} are the configuration and velocity of the robot.\nEach robot has an assigned start state 𝐬starti∈𝒮isubscriptsuperscript𝐬𝑖startsuperscript𝒮𝑖\\\\mathbf{s}^{i}\\_{\\\\text{start}}\\\\in\\\\mathcal{S}^{i} and binary termination (goal) condition 𝒯i:𝒮i→{0,1}:superscript𝒯𝑖→superscript𝒮𝑖01\\\\mathcal{T}^{i}:\\\\mathcal{S}^{i}\\\\to\\\\{0,1\\\\}.\nAn MRMP solution is a multi-robot trajectory 𝝉={𝝉1,⋯​𝝉n}𝝉superscript𝝉1⋯superscript𝝉𝑛\\\\boldsymbol{\\\\tau}=\\\\{\\\\boldsymbol{\\\\tau}^{1},\\\\cdots\\\\boldsymbol{\\\\tau}^{n}\\\\}, where 𝝉i:\\[0,Ti\\]→𝒮i:superscript𝝉𝑖→0superscript𝑇𝑖superscript𝒮𝑖\\\\boldsymbol{\\\\tau}^{i}:\\[0,T^{i}\\]\\\\to\\\\mathcal{S}^{i} represents the trajectory of robot ℛisubscriptℛ𝑖\\\\mathcal{R}\\_{i} over the time interval \\[0,Ti\\]0superscript𝑇𝑖\\[0,T^{i}\\], with Tisuperscript𝑇𝑖T^{i} being the terminal time. In practice, we uniformly discretize the time horizon into H𝐻H time steps and optimize over a sequence of states 𝝉i={𝐬1i,𝐬2i,…,𝐬Hi}superscript𝝉𝑖subscriptsuperscript𝐬𝑖1subscriptsuperscript𝐬𝑖2…subscriptsuperscript𝐬𝑖𝐻\\\\boldsymbol{\\\\tau}^{i}=\\\\{\\\\mathbf{s}^{i}\\_{1},\\\\mathbf{s}^{i}\\_{2},...,\\\\mathbf{s}^{i}\\_{H}\\\\}.\nSubscripts, e.g., 𝝉tisubscriptsuperscript𝝉𝑖𝑡\\\\boldsymbol{\\\\tau}^{i}\\_{t}, indicate indexing into a trajectory.\nEach trajectory 𝝉isuperscript𝝉𝑖\\\\boldsymbol{\\\\tau}^{i} must avoid collisions between robots and with obstacles in the environment.\nIn MRMP, robots share a workspace 𝒲𝒲\\\\mathcal{W} (i.e., 𝒲⊆ℝ3𝒲superscriptℝ3\\\\mathcal{W}\\\\subseteq\\\\mathbb{R}^{3} for general robots and 𝒲⊆ℝ2𝒲superscriptℝ2\\\\mathcal{W}\\\\subseteq\\\\mathbb{R}^{2} for robots on the plane) and occupy some volume or area within 𝒲𝒲\\\\mathcal{W}, which we denote as ℛi​(𝐪i)⊆𝒲subscriptℛ𝑖superscript𝐪𝑖𝒲\\\\mathcal{R}\\_{i}(\\\\mathbf{q}^{i})\\\\subseteq\\\\mathcal{W} for robot ℛisubscriptℛ𝑖\\\\mathcal{R}\\_{i} in configuration 𝐪isuperscript𝐪𝑖\\\\mathbf{q}^{i}.\n\nThe usual MRMP objective is to minimize the sum of the single-robot costs (e.g., the cumulative motion) across all robots.\nGeneral cost functions can be defined on the trajectories, and the objective then becomes 𝒥​(𝝉)=1n​∑i=1ncost​(𝝉i)𝒥𝝉1𝑛superscriptsubscript𝑖1𝑛costsuperscript𝝉𝑖\\\\mathcal{J}(\\\\boldsymbol{\\\\tau})=\\\\frac{1}{n}\\\\sum\\_{i=1}^{n}\\\\text{cost}(\\\\boldsymbol{\\\\tau}^{i}). When learning from data, we are interested in _data adherence_, i.e., the trajectories should match the underlying trajectory distribution. We define costdata​(𝝉)=1n​∑i=1ncostdata​(𝝉i)subscriptcostdata𝝉1𝑛superscriptsubscript𝑖1𝑛subscriptcostdatasuperscript𝝉𝑖\\\\text{cost}\\_{\\\\text{data}}(\\\\boldsymbol{\\\\tau})=\\\\frac{1}{n}\\\\sum\\_{i=1}^{n}\\\\text{cost}\\_{\\\\text{data}}(\\\\boldsymbol{\\\\tau}^{i}) to quantify how well, on average, trajectories in 𝝉𝝉\\\\boldsymbol{\\\\tau} follow their underlying data distribution. This metric is task-specific; we provide some examples in Sec. [4]Experimental Analysis ‣ Multi-Robot Motion Planning with Diffusion Models\").\n\n### 2.2 Multi-Agent Path Finding (MAPF)\n\nThe MAPF problem, a simpler form of MRMP, seeks the shortest collision-free pathsΠ={𝝅1,𝝅2,⋯​𝝅n}Πsuperscript𝝅1superscript𝝅2⋯superscript𝝅𝑛\\\\Pi=\\\\{\\\\boldsymbol{\\\\pi}^{1},\\\\boldsymbol{\\\\pi}^{2},\\\\cdots\\\\boldsymbol{\\\\pi}^{n}\\\\} for n𝑛n agents on a graph. This graph approximates their configuration space, with vertices corresponding to configurations and edges to transitions. Each path𝝅i={𝐪1i,⋯​𝐪Hi}superscript𝝅𝑖subscriptsuperscript𝐪𝑖1⋯subscriptsuperscript𝐪𝑖𝐻\\\\boldsymbol{\\\\pi}^{i}=\\\\{\\\\mathbf{q}^{i}\\_{1},\\\\cdots\\\\mathbf{q}^{i}\\_{H}\\\\} is a trajectory without velocity that need not be dynamically feasible.\nIn MAPF studies, constraint-based algorithms have become popular due to their simplicity and scalability. These algorithms are effective, in part, because they avoid the complexity of the multi-agent configuration space by delegating planning to single-agent planners and avoid collision via constraints. For instance, if a configuration 𝐪isuperscript𝐪𝑖\\\\mathbf{q}^{i} for ℛisubscriptℛ𝑖\\\\mathcal{R}\\_{i} leads to a collision at time (or interval) t𝑡t, this can be prevented by applying the constraint set C={⟨ℛi,𝐪i,t⟩}𝐶subscriptℛ𝑖superscript𝐪𝑖𝑡C=\\\\{\\\\langle\\\\mathcal{R}\\_{i},\\\\mathbf{q}^{i},t\\\\rangle\\\\} to the path 𝝅isuperscript𝝅𝑖\\\\boldsymbol{\\\\pi}^{i}, thereby preventing the configuration from being used at that time.\nSeveral MAPF algorithms, including Prioritized Planning (PP) (Erdmann & Lozano-Perez, [1987]) and Conflict-Based Search (CBS) (Sharon et al., [2015]), use this mechanism to force single-agent planning queries to avoid states that would lead to collisions. We detail these methods in Sec. [3]Method ‣ Multi-Robot Motion Planning with Diffusion Models\") and explain how, despite traditionally being used for MAPF, their principles can be applied to coordinating robots in continuous space that generate data-driven trajectories via diffusion models.\n\n### 2.3 Planning with Diffusion Models\n\nMotion planning diffusion models are generative models that learn a denoising process to recover a dynamically-feasible trajectory from noise (Carvalho et al., [2023]; Janner et al., [2022]). Given a dataset of multi-modal trajectories, diffusion models aim to generate new trajectories that follow the underlying distribution of the data. Additionally, these trajectories may be conditioned on a task objective 𝒪𝒪\\\\mathcal{O}, for example, goal condition and collision avoidance. Specifically, given a task objective 𝒪𝒪\\\\mathcal{O}, motion planning diffusion models aim to sample from the posterior distribution of trajectories:\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n|  |  | arg​max𝝉i⁡log⁡p​(𝝉i\\|𝒪)=arg​max𝝉i⁡(log⁡p​(𝒪\\|𝝉i)+log⁡p​(𝝉i))subscriptargmaxsuperscript𝝉𝑖𝑝conditionalsuperscript𝝉𝑖𝒪subscriptargmaxsuperscript𝝉𝑖𝑝conditional𝒪superscript𝝉𝑖𝑝superscript𝝉𝑖\\\\displaystyle\\\\operatorname\\*{arg\\\\,max}\\_{\\\\boldsymbol{\\\\tau}^{i}}\\\\log p(\\\\boldsymbol{\\\\tau}^{i}\\|\\\\mathcal{O})=\\\\operatorname\\*{arg\\\\,max}\\_{\\\\boldsymbol{\\\\tau}^{i}}\\\\left(\\\\log p(\\\\mathcal{O}\\|\\\\boldsymbol{\\\\tau}^{i})+\\\\log p(\\\\boldsymbol{\\\\tau}^{i})\\\\right) |  | (1) |\n|  |  | =arg​min𝝉i⁡(−log⁡p​(𝒪\\|𝝉i)−log⁡p​(𝝉i))=arg​min𝝉i⁡(𝒥​(𝝉i)−log⁡p​(𝝉i))absentsubscriptargminsuperscript𝝉𝑖𝑝conditional𝒪superscript𝝉𝑖𝑝superscript𝝉𝑖subscriptargminsuperscript𝝉𝑖𝒥superscript𝝉𝑖𝑝superscript𝝉𝑖\\\\displaystyle=\\\\operatorname\\*{arg\\\\,min}\\_{\\\\boldsymbol{\\\\tau}^{i}}\\\\left(-\\\\log p(\\\\mathcal{O}\\|\\\\boldsymbol{\\\\tau}^{i})-\\\\log p(\\\\boldsymbol{\\\\tau}^{i})\\\\right)=\\\\operatorname\\*{arg\\\\,min}\\_{\\\\boldsymbol{\\\\tau}^{i}}\\\\left(\\\\mathcal{J}(\\\\boldsymbol{\\\\tau}^{i})-\\\\log p(\\\\boldsymbol{\\\\tau}^{i})\\\\right) |  |\n\nThe first term of the objective, 𝒥​(𝝉i)𝒥superscript𝝉𝑖\\\\mathcal{J}(\\\\boldsymbol{\\\\tau}^{i}), can be interpreted as a standard motion planning objective (Carvalho et al., [2023]), in which we try to minimize a cost function (or, equivalently, maximize a reward function). The second term, log⁡p​(𝝉i)𝑝superscript𝝉𝑖\\\\log p(\\\\boldsymbol{\\\\tau}^{i}), is the prior corresponding to the data adherence discussed in Sec. [2.1]Multi-Robot Motion Planning (MRMP) ‣ 2 Preliminary ‣ Multi-Robot Motion Planning with Diffusion Models\").\n\nDiffusion models are a type of score-based model (Song et al., [2021]), where the focus is on learning the score function (the gradient of the data distribution’s log-probability) rather than learning the probability distribution directly.\nThe score function is learned using denoising score matching, a technique for learning to estimate the score by gradually denoising noisy samples.\nThe diffusion inference process consists of a K𝐾K-step denoising process that takes a noisy trajectory 𝝉iKsuperscriptsuperscript𝝉𝑖𝐾{}^{K}\\\\boldsymbol{\\\\tau}^{i} and recovers a feasible trajectory 𝝉i0superscriptsuperscript𝝉𝑖0{}^{0}\\\\boldsymbol{\\\\tau}^{i}, which also follows the data distribution. We use the notation 𝝉i0,1𝝉i,⋯,K𝝉i{}^{0}\\\\boldsymbol{\\\\tau}^{i},^{1}\\\\boldsymbol{\\\\tau}^{i},\\\\cdots,^{K}\\\\boldsymbol{\\\\tau}^{i} to denote the evolution of the trajectory in the diffusion process.\nTo generate a trajectory 𝝉i0superscriptsuperscript𝝉𝑖0{}^{0}\\\\boldsymbol{\\\\tau}^{i} from a noise trajectory 𝝉iK∼𝒩​(𝟎,𝐈)similar-tosuperscriptsuperscript𝝉𝑖𝐾𝒩0𝐈{}^{K}\\\\boldsymbol{\\\\tau}^{i}\\\\sim\\\\mathcal{N}(\\\\mathbf{0},\\\\mathbf{I}), we use Langevin dynamics sampling (Ho et al., [2020]), an iterative process that is a type of Markov Chain Monte Carlo method. At each denoising step k∈{K,…,1}𝑘𝐾…1k\\\\in\\\\{K,\\\\dots,1\\\\}, a trajectory-space mean μk−1isubscriptsuperscript𝜇𝑖𝑘1\\\\mu^{i}\\_{k-1} is sampled from the network μθsubscript𝜇𝜃\\\\mu\\_{\\\\theta}:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | μk−1i=μθ(k𝝉i)\\\\mu^{i}\\_{k-1}=\\\\mu\\_{\\\\theta}(^{k}\\\\boldsymbol{\\\\tau}^{i}) |  | (2) |\n\nNow, with the variance prescribed by a deterministic schedule {βk∣k∈{K,⋯,1}}conditional-setsubscript𝛽𝑘𝑘𝐾⋯1\\\\{\\\\beta\\_{k}\\\\mid k\\\\in\\\\{K,\\\\cdots,1\\\\}\\\\}, the next trajectory in the denoising sequence is sampled from the following distribution:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | 𝝉ik−1∼𝒩​(μk−1i+η​βk−1​∇𝝉𝒥​(μk−1i)⏟Guidance,βk−1)similar-tosuperscriptsuperscript𝝉𝑖𝑘1𝒩subscriptsuperscript𝜇𝑖𝑘1subscript⏟𝜂subscript𝛽𝑘1subscript∇𝝉𝒥superscriptsubscript𝜇𝑘1𝑖Guidancesubscript𝛽𝑘1{}^{k-1}\\\\boldsymbol{\\\\tau}^{i}\\\\sim\\\\mathcal{N}\\\\big{(}\\\\mu^{i}\\_{k-1}+\\\\underbrace{\\\\eta\\\\beta\\_{k-1}\\\\nabla\\_{\\\\boldsymbol{\\\\tau}}\\\\mathcal{J}(\\\\mu\\_{k-1}^{i})}\\_{\\\\text{Guidance}},\\\\beta\\_{k-1}\\\\big{)} |  | (3) |\n\nThe term ∇𝝉𝒥​(μk−1i)subscript∇𝝉𝒥superscriptsubscript𝜇𝑘1𝑖\\\\nabla\\_{\\\\boldsymbol{\\\\tau}}\\\\mathcal{J}(\\\\mu\\_{k-1}^{i}) is the gradient of additional trajectory-space objectives (described in Eq. [1]In 2.3 Planning with Diffusion Models ‣ 2 Preliminary ‣ Multi-Robot Motion Planning with Diffusion Models\")) imposed on the generation process. This term, also called _guidance_, can include multiple weighted cost components, each optimizing for a different objective. For instance, we can have 𝒥=λobj​𝒥obj+λsmooth​𝒥smooth𝒥subscript𝜆objsubscript𝒥objsubscript𝜆smoothsubscript𝒥smooth\\\\mathcal{J}=\\\\lambda\\_{\\\\text{obj}}\\\\mathcal{J}\\_{\\\\text{obj}}+\\\\lambda\\_{\\\\text{smooth}}\\\\mathcal{J}\\_{\\\\text{smooth}} to penalize trajectories in collision with objects via 𝒥objsubscript𝒥obj\\\\mathcal{J}\\_{\\\\text{obj}} and to encourage the trajectory to be dynamically feasible via 𝒥smoothsubscript𝒥smooth\\\\mathcal{J}\\_{\\\\text{smooth}}. We denote the trajectory generation process queried with a start state 𝐬startisubscriptsuperscript𝐬𝑖start\\\\mathbf{s}^{i}\\_{\\\\text{start}}, goal condition 𝒯isuperscript𝒯𝑖\\\\mathcal{T}^{i}, and costraint set C𝐶C (Sec. [3.1]Constraints in Diffusion Models ‣ 3 Method ‣ Multi-Robot Motion Planning with Diffusion Models\")) as fθi​(𝐬starti,𝒯i,C)superscriptsubscript𝑓𝜃𝑖subscriptsuperscript𝐬𝑖startsuperscript𝒯𝑖𝐶f\\_{\\\\theta}^{i}(\\\\mathbf{s}^{i}\\_{\\\\text{start}},\\\\mathcal{T}^{i},C).\n\nInput:Starts, goal conditions, and single-robot diffusion models {𝐬starti,𝒯i,fθi}i=1nsubscriptsuperscriptsubscriptsuperscript𝐬𝑖startsuperscript𝒯𝑖subscriptsuperscript𝑓𝑖𝜃𝑛𝑖1\\\\left\\\\{\\\\mathbf{s}^{i}\\_{\\\\text{start}},\\\\mathcal{T}^{i},f^{i}\\_{\\\\theta}\\\\right\\\\}^{n}\\_{i=1}\n\nOutput:Trajectories 𝝉={𝝉i}i=1n𝝉subscriptsuperscriptsuperscript𝝉𝑖𝑛𝑖1\\\\boldsymbol{\\\\tau}=\\\\left\\\\{\\\\boldsymbol{\\\\tau}^{i}\\\\right\\\\}^{n}\\_{i=1}\n\nNroot←←subscript𝑁rootabsentN\\_{\\\\text{root}}\\\\leftarrow new CT node; Nroot.Ci←∅​∀i∈{1,⋯​n}formulae-sequencesubscript𝑁root←superscript𝐶𝑖for-all𝑖1⋯𝑛N\\_{\\\\text{root}}.C^{i}\\\\leftarrow\\\\emptyset\\\\;\\\\forall i\\\\in\\\\{1,\\\\cdots n\\\\}\n\nfor _i∈{1,⋯,n}𝑖1⋯𝑛i\\\\in\\\\left\\\\{1,\\\\cdots,n\\\\right\\\\}_ do\n\nCstrongi,Cweaki←∅,∅formulae-sequence←subscriptsuperscript𝐶𝑖strongsubscriptsuperscript𝐶𝑖weakC^{i}\\_{\\\\text{strong}},C^{i}\\_{\\\\text{weak}}\\\\leftarrow\\\\emptyset,\\\\emptyset// Empty constraints set.\n\nCstrongi←{⟨ℛi,Nroot.𝝉⟩}C^{i}\\_{\\\\text{strong}}\\\\leftarrow\\\\{\\\\langle\\\\mathcal{R}\\_{i},N\\_{\\\\text{root}}.\\\\boldsymbol{\\\\tau}\\\\rangle\\\\}// Avoid other robots.\n\nCweaki←{⟨ℛi,Nroot.𝝉⟩}C^{i}\\_{\\\\text{weak}}\\\\leftarrow\\\\{\\\\langle\\\\mathcal{R}\\_{i},N\\_{\\\\text{root}}.\\\\boldsymbol{\\\\tau}\\\\rangle\\\\}// Penalize collisions.\n\nNroot.𝝉i←fθi​(𝐬starti,𝒯i,Cstrongi∪Cweaki)formulae-sequencesubscript𝑁root←superscript𝝉𝑖subscriptsuperscript𝑓𝑖𝜃subscriptsuperscript𝐬𝑖startsuperscript𝒯𝑖subscriptsuperscript𝐶𝑖strongsubscriptsuperscript𝐶𝑖weakN\\_{\\\\text{root}}.\\\\boldsymbol{\\\\tau}^{i}\\\\leftarrow f^{i}\\_{\\\\theta}(\\\\mathbf{s}^{i}\\_{\\\\text{start}},\\\\mathcal{T}^{i},C^{i}\\_{\\\\text{strong}}\\\\cup C^{i}\\_{\\\\text{weak}})\n\nend for\n\nreturnNroot.𝝉formulae-sequencesubscript𝑁root𝝉N\\_{\\\\text{root}}.\\\\boldsymbol{\\\\tau}\n\nCT ←{Nroot}←absentsubscript𝑁root\\\\leftarrow\\\\left\\\\{N\\_{\\\\text{root}}\\\\right\\\\}// Initialize CT.\n\nwhile _CT ≠∅absent\\\\neq\\\\emptyset_ do\n\nN←arg​minN′∈CTnumConflicts(N′.𝝉)N\\\\leftarrow\\\\operatorname\\*{arg\\\\,min}\\\\limits\\_{N^{\\\\prime}\\\\in\\\\text{CT}}\\\\textnormal{{numConflicts}}(N^{\\\\prime}.\\\\boldsymbol{\\\\tau})\n\nRemove N𝑁N from CT\n\nif _N.𝛕formulae-sequence𝑁𝛕N.\\\\boldsymbol{\\\\tau} conflict-free_ then\n\nreturnN.𝝉formulae-sequence𝑁𝝉N.\\\\boldsymbol{\\\\tau}// Return if collision free.\n\n    end if\n\np,t,ℛi,ℛj←getOneConflict(N.𝝉)p,t,\\\\mathcal{R}\\_{i},\\\\mathcal{R}\\_{j}\\\\leftarrow\\\\textnormal{{getOneConflict}}(N.\\\\boldsymbol{\\\\tau})\n\nfor _k∈{i,j}𝑘𝑖𝑗k\\\\in\\\\{i,j\\\\}// Split N𝑁N; constrain conflicting robots._ do\n\nN′←N.copyformulae-sequence←superscript𝑁′𝑁copyN^{\\\\prime}\\\\leftarrow N.\\\\text{copy}\n\nN′.Ck←Ck∪{⟨ℛk,Sr​(p),𝐭⟩}formulae-sequencesuperscript𝑁′←superscript𝐶𝑘superscript𝐶𝑘subscriptℛ𝑘subscript𝑆𝑟𝑝𝐭N^{\\\\prime}.C^{k}\\\\leftarrow C^{k}\\\\cup\\\\{\\\\langle\\\\mathcal{R}\\_{k},S\\_{r}(p),\\\\mathbf{t}\\\\rangle\\\\}\n\nCweakk←{ℛk,⟨N′.𝝉⟩}C^{k}\\_{\\\\text{weak}}\\\\leftarrow\\\\{\\\\mathcal{R}\\_{k},\\\\langle N^{\\\\prime}.\\\\boldsymbol{\\\\tau}\\\\rangle\\\\}// Penalize collisions.\n\nN′.𝝉k←fθk(𝐬startk,𝒯k,N′.Ck∪Cweakk)N^{\\\\prime}.\\\\boldsymbol{\\\\tau}^{k}\\\\leftarrow f^{k}\\_{\\\\theta}(\\\\mathbf{s}^{k}\\_{\\\\text{start}},\\\\mathcal{T}^{k},N^{\\\\prime}.C^{k}{\\\\color\\[rgb\\]{0.5,0.5,0}\\\\cup C^{k}\\_{\\\\text{weak}}})\n\nCT ←←\\\\leftarrow CT ∪{N′}superscript𝑁′\\\\cup\\\\{N^{\\\\prime}\\\\}\n\n    end for\n\nend while\n\nAlgorithm 1MMD-CBS sketch. Colored lines are only in  MMD-PP,  MMD-ECBS\n\n![Refer to caption](a) Two robots aim to switch positions. Blindly generated single-robot trajectories collide.\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n(b) The diffusion denoising process for the left robot in (a), under a temporally-activated constraint (in red), yields multi-modal trajectories.\n\n![Refer to caption](c) Collision-free solution.\n\nFigure 1: An illustration of how MMD-CBS generates collision-free trajectories with constrained diffusion models.",
      "citations": [
        {
          "start_pos": 5163,
          "end_pos": 5176,
          "text": "Perez, [1987]",
          "paper_id": "bib.bib8",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        },
        {
          "start_pos": 5211,
          "end_pos": 5232,
          "text": "Sharon et al., [2015]",
          "paper_id": "bib.bib28",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        },
        {
          "start_pos": 5816,
          "end_pos": 5839,
          "text": "Carvalho et al., [2023]",
          "paper_id": "bib.bib3",
          "single_citation": false,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 5841,
          "end_pos": 5862,
          "text": "Janner et al., [2022]",
          "paper_id": "bib.bib12",
          "single_citation": false,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 7502,
          "end_pos": 7525,
          "text": "Carvalho et al., [2023]",
          "paper_id": "bib.bib3",
          "single_citation": true,
          "citation_type": "others",
          "nearest_citations": null
        },
        {
          "start_pos": 7924,
          "end_pos": 7943,
          "text": "Song et al., [2021]",
          "paper_id": "bib.bib33",
          "single_citation": true,
          "citation_type": "others",
          "nearest_citations": null
        },
        {
          "start_pos": 9017,
          "end_pos": 9034,
          "text": "Ho et al., [2020]",
          "paper_id": "bib.bib9",
          "single_citation": true,
          "citation_type": "others",
          "nearest_citations": [
            "bib.bib19",
            "bib.bib21",
            "bib.bib22"
          ]
        }
      ]
    },
    "3 Method": {
      "content": "We present Multi-robot Multi-model planning Diffusion (MMD), an algorithm for flexibly scaling diffusion planning to multiple robots and long horizons using only single-robot data.\nMMD imposes constraints on diffusion models to generate collision-free trajectories, addressing three main questions: how, when, and where to impose them. First, we discuss integrating spatio-temporal constraints into the diffusion denoising process through guiding functions. Next, we introduce five MMD algorithms, each inspired by a MAPF algorithm regarding constraint placement and timing. Finally, we demonstrate how to sequence multiple models for long-horizon planning.\n\n### 3.1 Constraints in Diffusion Models\n\nAn intuitive and effective constraint for multi-robot motion planning in robotics is the sphere constraint111The sphere constraint generalizes the MAPF vertex constraint, as it constrains robots from visiting the point of collision itself instead of a single colliding configuration corresponding to a vertex in a graph. In MAPF, the point of collision and the graph vertex coincide.(Li et al., [2019]; Shaoul et al., [2024b]).\nIt is defined by a point p∈𝒲𝑝𝒲p\\\\in\\\\mathcal{W} and restricts robots from being closer to p𝑝p than a radius r∈ℝ𝑟ℝr\\\\in\\\\mathbb{R} at a certain time range 𝐭:=\\[t−Δ​t,t+Δ​t\\]assign𝐭𝑡Δ𝑡𝑡Δ𝑡\\\\mathbf{t}:=\\[t-\\\\Delta t,t+\\\\Delta t\\].\nThe sphere constraint can be imposed as a soft-constraint on a diffusion model by incorporating it in its guiding function 𝒥​(⋅)𝒥⋅\\\\mathcal{J}(\\\\cdot). This can be done by adding a cost term 𝒥csubscript𝒥c\\\\mathcal{J}\\_{\\\\text{c}} that repels the robots from the sphere’s center point p𝑝p. Let 𝝉iksuperscriptsuperscript𝝉𝑖𝑘{}^{k}\\\\boldsymbol{\\\\tau}^{i} be the generated trajectory for ℛisubscriptℛ𝑖\\\\mathcal{R}\\_{i} at step k𝑘k of the diffusion denoising process, and ⟨ℛi,Sr​(p),𝐭⟩subscriptℛ𝑖subscript𝑆𝑟𝑝𝐭\\\\langle\\\\mathcal{R}\\_{i},S\\_{r}(p),\\\\mathbf{t}\\\\rangle be a sphere constraint centered at p𝑝p with radius r𝑟r over time interval 𝐭𝐭\\\\mathbf{t}. The guidance cost term for ℛisubscriptℛ𝑖\\\\mathcal{R}\\_{i} can be defined as:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | 𝒥c(k𝝉ti):=∑t∈𝐭max(ϵ⋅r−d(ℛi(k𝝉ti),p), 0)\\\\mathcal{J}\\_{\\\\text{c}}(^{k}\\\\boldsymbol{\\\\tau}^{i}\\_{t}):=\\\\sum\\_{t\\\\in\\\\mathbf{t}}\\\\max\\\\left(\\\\epsilon\\\\cdot r-d\\\\left({\\\\mathcal{R}\\_{i}(^{k}\\\\boldsymbol{\\\\tau}^{i}\\_{t}),p}\\\\right),\\\\;0\\\\right) |  | (4) |\n\nwith d(ℛi(k𝝉ti),p)d\\\\left({\\\\mathcal{R}\\_{i}(^{k}\\\\boldsymbol{\\\\tau}^{i}\\_{t}),p}\\\\right) as the distance from point p𝑝p to ℛisubscriptℛ𝑖\\\\mathcal{R}\\_{i} at 𝝉tiksuperscriptsubscriptsuperscript𝝉𝑖𝑡𝑘{}^{k}\\\\boldsymbol{\\\\tau}^{i}\\_{t}, and ϵ≥1italic-ϵ1\\\\epsilon\\\\geq 1 a padding factor.\n\n### 3.2 Constraining Strategies\n\nTo determine _when_ and _where_ to apply constraints on diffusion models, MMD draws on MAPF strategies like CBS and PP. We propose five MMD variants, each inspired by a state-of-the-art search algorithm. Alg. [1]In Figure 1 ‣ 2.3 Planning with Diffusion Models ‣ 2 Preliminary ‣ Multi-Robot Motion Planning with Diffusion Models\") provides a summary of these methods and we elaborate upon them here.\n\nMMD-PP.\nPrioritized Planning sequentially plans paths for robots ℛi​∀i∈{1,…​n}subscriptℛ𝑖for-all𝑖1…𝑛\\\\mathcal{R}\\_{i}\\\\;\\\\forall\\\\;i\\\\in\\\\{1,\\\\dots n\\\\}. This ordering of robots is treated as a priority ordering in that, on each call, robot ℛisubscriptℛ𝑖\\\\mathcal{R}\\_{i} must generate a path 𝝅isuperscript𝝅𝑖\\\\boldsymbol{\\\\pi}^{i} that avoids all ℛjsubscriptℛ𝑗\\\\mathcal{R}\\_{j} that previously planned. Robot ℛisubscriptℛ𝑖\\\\mathcal{R}\\_{i} does so by respecting the constraints C:={⟨ℛi,𝐪i,t⟩∣ℛi​(𝐪i)∩ℛj​(𝝅tj)≠∅​∀t}assign𝐶conditional-setsubscriptℛ𝑖superscript𝐪𝑖𝑡subscriptℛ𝑖superscript𝐪𝑖subscriptℛ𝑗subscriptsuperscript𝝅𝑗𝑡for-all𝑡C:=\\\\{\\\\langle\\\\mathcal{R}\\_{i},\\\\mathbf{q}^{i},t\\\\rangle\\\\mid\\\\mathcal{R}\\_{i}(\\\\mathbf{q}^{i})\\\\cap\\\\mathcal{R}\\_{j}(\\\\boldsymbol{\\\\pi}^{j}\\_{t})\\\\neq\\\\emptyset\\\\;\\\\forall t\\\\}.\nTo translate this approach to trajectory generation with diffusion models, _MMD-PP_ represents robot volumes using spheres, as is common in robotics, and uses the sphere representation of higher-priority robots as sphere soft-constraints for lower-priority robots.\nSpecifically, let a high-priority robot ℛjsubscriptℛ𝑗\\\\mathcal{R}\\_{j} be modeled with Mjsubscript𝑀𝑗M\\_{j} spheres and pmjsubscriptsuperscript𝑝𝑗𝑚p^{j}\\_{m} and rmjsubscriptsuperscript𝑟𝑗𝑚r^{j}\\_{m} be the position and radius of the mthsuperscript𝑚thm^{\\\\text{th}} sphere at time t𝑡t. Then, lower-priority robot ℛisubscriptℛ𝑖\\\\mathcal{R}\\_{i} generates a trajectory under the constraint set {⟨ℛi,Srmj​(pmj),t⟩∣m∈{1,⋯​Mj},j≺i}conditional-setsubscriptℛ𝑖subscript𝑆subscriptsuperscript𝑟𝑗𝑚subscriptsuperscript𝑝𝑗𝑚𝑡formulae-sequence𝑚1⋯subscript𝑀𝑗precedes𝑗𝑖\\\\{\\\\langle\\\\mathcal{R}\\_{i},S\\_{r^{j}\\_{m}}(p^{j}\\_{m}),t\\\\rangle\\\\mid m\\\\in\\\\{1,\\\\cdots M\\_{j}\\\\},j\\\\prec i\\\\}, where ≺precedes\\\\prec indicates priority precedence. In Alg. [1]In Figure 1 ‣ 2.3 Planning with Diffusion Models ‣ 2 Preliminary ‣ Multi-Robot Motion Planning with Diffusion Models\"), ⟨ℛi,𝝉⟩subscriptℛ𝑖𝝉\\\\langle\\\\mathcal{R}\\_{i},\\\\boldsymbol{\\\\tau}\\\\rangle means that all trajectories of ℛj≠isubscriptℛ𝑗𝑖\\\\mathcal{R}\\_{j\\\\neq i} in 𝝉𝝉\\\\boldsymbol{\\\\tau} must be similarly avoided.\n\nMMD-CBS. CBS is a popular MAPF solver that combines “low-level” planners for individual agents with a “high-level” constraint tree (CT) to resolve conflicts (i.e., collisions). The algorithm initiates by creating the root node Nrootsubscript𝑁rootN\\_{\\\\text{root}} in the CT, planning paths for each agent independently, and storing these paths in Nroot.Πformulae-sequencesubscript𝑁rootΠN\\_{\\\\text{root}}.\\\\Pi.\nCBS repeatedly extracts nodes N𝑁N from the CT and inspects N.Πformulae-sequence𝑁ΠN.\\\\Pi for conflicts. If no conflicts exist, the algorithm terminates, returning N.Πformulae-sequence𝑁ΠN.\\\\Pi. Otherwise, CBS selects a conflict time t𝑡t where agents ℛisubscriptℛ𝑖\\\\mathcal{R}\\_{i} and ℛjsubscriptℛ𝑗\\\\mathcal{R}\\_{j} collide at positions 𝐪i=𝝅tisuperscript𝐪𝑖subscriptsuperscript𝝅𝑖𝑡\\\\mathbf{q}^{i}=\\\\boldsymbol{\\\\pi}^{i}\\_{t} and 𝐪j=𝝅tjsuperscript𝐪𝑗subscriptsuperscript𝝅𝑗𝑡\\\\mathbf{q}^{j}=\\\\boldsymbol{\\\\pi}^{j}\\_{t} in N.Πformulae-sequence𝑁ΠN.\\\\Pi.\nCBS then splits node N𝑁N into two new CT nodes, Nisubscript𝑁𝑖N\\_{i} and Njsubscript𝑁𝑗N\\_{j}, each inheriting the (initially empty) constraint set N.Cformulae-sequence𝑁𝐶N.C and paths N.Πformulae-sequence𝑁ΠN.\\\\Pi from N𝑁N, and incorporating a new constraint for preventing the respective agent from occupying the conflict position at time t𝑡t. For example, Ni.C←N.C∪{⟨ℛi,𝐪i,t⟩}formulae-sequencesubscript𝑁𝑖←𝐶𝑁𝐶subscriptℛ𝑖superscript𝐪𝑖𝑡N\\_{i}.C\\\\leftarrow N.C\\\\cup\\\\{\\\\langle\\\\mathcal{R}\\_{i},\\\\mathbf{q}^{i},t\\\\rangle\\\\} for ℛisubscriptℛ𝑖\\\\mathcal{R}\\_{i}.\nPaths for ℛisubscriptℛ𝑖\\\\mathcal{R}\\_{i} and ℛjsubscriptℛ𝑗\\\\mathcal{R}\\_{j} are then replanned using low-level planners under the updated constraints in Ni.Cformulae-sequencesubscript𝑁𝑖𝐶N\\_{i}.C and Nj.Cformulae-sequencesubscript𝑁𝑗𝐶N\\_{j}.C. The new CT nodes, with updated paths in Ni.Πformulae-sequencesubscript𝑁𝑖ΠN\\_{i}.\\\\Pi and Nj.Πformulae-sequencesubscript𝑁𝑗ΠN\\_{j}.\\\\Pi, are added to the CT.\n_MMD-CBS_ follows the general CBS structure. It keeps a CT of nodes N𝑁N, each with trajectories N.𝝉formulae-sequence𝑁𝝉N.\\\\boldsymbol{\\\\tau}, and uses motion planning diffusion models as low-level planners. The algorithm identifies a collision pointp𝑝p for each conflict and resolves it by imposing sphere soft-constraints centered at p𝑝p on affected robots (see Fig. [1]Figure 1 ‣ 2.3 Planning with Diffusion Models ‣ 2 Preliminary ‣ Multi-Robot Motion Planning with Diffusion Models\") for an illustration and Sec. [A.4]A.4 Implementation Details ‣ Appendix A Appendix ‣ Multi-Robot Motion Planning with Diffusion Models\") for parameter values).\n\nMMD-ECBS. Enhanced-CBS (ECBS) (Barer et al., [2014]) informs CBS low-level planners of the paths of other robots in the same CT node and steers the search towards solutions that are more likely to be collision-free.\nTo emulate this in diffusion-based trajectory generation, MMD-ECBS imposes two types of soft constraints: “weak” and “strong.” For each robot ℛjsubscriptℛ𝑗\\\\mathcal{R}\\_{j} with a trajectory in the CT node N𝑁N, a weak soft-constraint that forbids ℛisubscriptℛ𝑖\\\\mathcal{R}\\_{i} from colliding with any other ℛjsubscriptℛ𝑗\\\\mathcal{R}\\_{j} with 𝝉j∈N.𝝉formulae-sequencesuperscript𝝉𝑗𝑁𝝉\\\\boldsymbol{\\\\tau}^{j}\\\\in N.\\\\boldsymbol{\\\\tau} is imposed. This is done in a similar way to MMD-PP but with a lower penalty value (Sec. [A.4]A.4 Implementation Details ‣ Appendix A Appendix ‣ Multi-Robot Motion Planning with Diffusion Models\")). The strong constraints are the same as those in MMD-CBS, resolving previously observed conflicts.\n\nReusing Experience in CBS.\nRecent studies indicate that leveraging previous single-robot solutions to guide replanning enhances the efficiency of CBS (Shaoul et al., [2024a]). This is primarily because the motion planning problem between a CT node and its successors is nearly identical, with the only difference being a single constraint, making planning from scratch wasteful. This can be utilized in MMD replanning by initially adding noise to the stored trajectory for a limited number of steps (333 in our experiments; regular inference uses 252525 steps) and then denoising with the new soft-constraints. This approach, in the context of single-robot planning, was first proposed in Janner et al. ( [2022]) and further refined in Zhou et al. ( [2024]).\nAdding this functionality to MMD-CBS and MMD-ECBS yields our two final MMD algorithms, MMD-xCBS and MMD-xECBS, respectively. Both reuse previous solutions to inform replanning and are otherwise unchanged.\n\n### 3.3 Sequencing Diffusion Models for Long Horizon Planning\n\nDiffusion models have shown notable success in learning trajectory distributions within specific contexts. However, they face challenges in modeling complex trajectory distributions and generalizing to diverse contexts (e.g., significantly different obstacle layouts). To tackle this issue, we propose utilizing an ensemble of local diffusion models rather than a single model for a single robot. Each local model is trained to capture the trajectory distribution of a particular motion pattern within a local map segment, and we combine multiple models sequentially for long-horizon single-robot planning.\nThis approach offers three advantages: (1) Easier learning with simple, demonstrable motion patterns. (2) Better generalization across different contexts. (3) Effective scaling for large maps, aiding long-term planning.\n\nDuring online planning, given a specific single-robot task 𝒪isuperscript𝒪𝑖\\\\mathcal{O}^{i} (which includes the start state and the termination condition), we can query the task-relevant local diffusion models to generate a full-horizon motion plan. Motivated by Mishra et al. ( [2023]), this is done by sampling from the local models in parallel, while incorporating a cross-conditioning term that constrains the local trajectories to connect seamlessly.\nLet 𝝉i,lsuperscript𝝉𝑖𝑙\\\\boldsymbol{\\\\tau}^{i,l} be a local trajectory sampled from a local probability distribution plsuperscript𝑝𝑙p^{l}. The goal of the single-robot planner is to sample from the posterior distribution of trajectories:\n\n|     |     |     |     |     |     |\n| --- | --- | --- | --- | --- | --- |\n|  |\n|  | arg​max𝝉isubscriptargmaxsuperscript𝝉𝑖\\\\displaystyle\\\\operatorname\\*{arg\\\\,max}\\_{\\\\boldsymbol{\\\\tau}^{i}} |  | log⁡p​(𝝉i\\|𝒪)=arg​max𝝉i,1,…,𝝉i,L⁡log⁡p​(𝝉i,1,…,𝝉i,L\\|𝒪)𝑝conditionalsuperscript𝝉𝑖𝒪subscriptargmaxsuperscript𝝉𝑖1…superscript𝝉𝑖𝐿𝑝superscript𝝉𝑖1…conditionalsuperscript𝝉𝑖𝐿𝒪\\\\displaystyle\\\\log p(\\\\boldsymbol{\\\\tau}^{i}\\|\\\\mathcal{O})=\\\\operatorname\\*{arg\\\\,max}\\_{\\\\boldsymbol{\\\\tau}^{i,1},\\\\dots,\\\\boldsymbol{\\\\tau}^{i,L}}\\\\log p(\\\\boldsymbol{\\\\tau}^{i,1},\\\\dots,\\\\boldsymbol{\\\\tau}^{i,L}\\|\\\\mathcal{O}) |  | (5a) |\n|  | subject to |  | 𝝉1i,l=𝝉Hl−1i,l−1,∀l=1,…,Lformulae-sequencesubscriptsuperscript𝝉𝑖𝑙1subscriptsuperscript𝝉𝑖𝑙1subscript𝐻𝑙1for-all𝑙1…𝐿\\\\displaystyle\\\\boldsymbol{\\\\tau}^{i,l}\\_{1}=\\\\boldsymbol{\\\\tau}^{i,l-1}\\_{H\\_{l-1}},\\\\forall l=1,\\\\dots,L |  | (5b) |\n\nFollowing Eq. [1]In 2.3 Planning with Diffusion Models ‣ 2 Preliminary ‣ Multi-Robot Motion Planning with Diffusion Models\"), the new objective becomes:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | arg​min𝝉i,1,…,𝝉i,L⁡(𝒥​(𝝉i,1,…,𝝉i,L)−∑l=1Llog⁡p​(𝝉i,l))subscriptargminsuperscript𝝉𝑖1…superscript𝝉𝑖𝐿𝒥superscript𝝉𝑖1…superscript𝝉𝑖𝐿superscriptsubscript𝑙1𝐿𝑝superscript𝝉𝑖𝑙\\\\displaystyle\\\\operatorname\\*{arg\\\\,min}\\_{\\\\boldsymbol{\\\\tau}^{i,1},\\\\dots,\\\\boldsymbol{\\\\tau}^{i,L}}\\\\left(\\\\mathcal{J}(\\\\boldsymbol{\\\\tau}^{i,1},\\\\dots,\\\\boldsymbol{\\\\tau}^{i,L})-\\\\sum\\_{l=1}^{L}\\\\log p(\\\\boldsymbol{\\\\tau}^{i,l})\\\\right) |  | (6) |\n\nIn practice, MMD ensures proper sequencing of the L𝐿L local diffusion models by introducing constraints requiring the last state of the trajectory from model l𝑙l to be equal to the first state from model l+1𝑙1l+1 (see Eq. [5b]In 5 ‣ 3.3 Sequencing Diffusion Models for Long Horizon Planning ‣ 3 Method ‣ Multi-Robot Motion Planning with Diffusion Models\")) and treating generation of local trajectories as inpainting (Lugmayr et al., [2022]).\n222Another option is to add a guidance term penalizing discontinuity. This approach is more flexible as it can optimize for connection points that are learned as well (e.g., via classifier guidance on the connection itself).\n\n![Refer to caption](a) Empty map.\n\n![Refer to caption](b) Data adherence in the Empty map.\n\n![Refer to caption](c) Highways map.\n\n![Refer to caption](d) Data adherence in the Highways map.\n\nFigure 2: A comparison between MMD and “composite” diffusion models that generate trajectories for all agents at once.\nWe observed consistent performance from MMD but a sharp decrease for the baseline, unable to produce valid solutions for 999 agents (denoted as zero adherence score). Since MMD uses the same single-agent model for all robots in these experiments, it is straightforward to keep increasing the number of agents without needing any retraining or new datasets.",
      "citations": [
        {
          "start_pos": 1084,
          "end_pos": 1101,
          "text": "Li et al., [2019]",
          "paper_id": "bib.bib17",
          "single_citation": false,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1103,
          "end_pos": 1125,
          "text": "Shaoul et al., [2024b]",
          "paper_id": "bib.bib27",
          "single_citation": false,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 7807,
          "end_pos": 7827,
          "text": "Barer et al., [2014]",
          "paper_id": "bib.bib2",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        },
        {
          "start_pos": 8873,
          "end_pos": 8895,
          "text": "Shaoul et al., [2024a]",
          "paper_id": "bib.bib26",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        },
        {
          "start_pos": 9411,
          "end_pos": 9433,
          "text": "Janner et al. ( [2022]",
          "paper_id": "bib.bib12",
          "single_citation": true,
          "citation_type": "others",
          "nearest_citations": null
        },
        {
          "start_pos": 9458,
          "end_pos": 9478,
          "text": "Zhou et al. ( [2024]",
          "paper_id": "bib.bib39",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        },
        {
          "start_pos": 10840,
          "end_pos": 10862,
          "text": "Mishra et al. ( [2023]",
          "paper_id": "bib.bib20",
          "single_citation": true,
          "citation_type": "others",
          "nearest_citations": null
        },
        {
          "start_pos": 13182,
          "end_pos": 13204,
          "text": "Lugmayr et al., [2022]",
          "paper_id": "bib.bib19",
          "single_citation": true,
          "citation_type": "others",
          "nearest_citations": [
            "bib.bib9",
            "bib.bib21",
            "bib.bib22"
          ]
        }
      ]
    },
    "4 Experimental Analysis": {
      "content": "We tested MMD’s efficacy in learning multi-robot trajectories on increasingly complex maps with varying numbers of holonomic ground robots in a simulated warehouse, modeling robots as 2D disks. Our goals were to (i) compare our approach with common methods for integrating data into multi-robot trajectory generation, (ii) identify the most effective constraining strategies with MMD, and (iii) evaluate MMD’s scalability.\nEach experiment with n𝑛n robots begins by randomly picking start and goal states on a map for various algorithms to compute valid trajectories 𝝉𝝉\\\\boldsymbol{\\\\tau} (or MAPF paths ΠΠ\\\\Pi) between. We evaluated the methods by  success rate, the percentage of problems solved with no collision within a time limit, and data adherence, the average alignment of 𝝉i∈𝝉superscript𝝉𝑖𝝉\\\\boldsymbol{\\\\tau}^{i}\\\\in\\\\boldsymbol{\\\\tau} with the dataset motion patterns. Data adherence uses a map-specific function costdata​(𝝉i)subscriptcostdatasuperscript𝝉𝑖\\\\text{cost}\\_{\\\\text{data}}(\\\\boldsymbol{\\\\tau}^{i}), scoring 111 for perfect conformity and lower otherwise. Our evaluation maps, datasets, and adherence functions are summarized here with simple illustrations and more details are in the appendix.\n\n![[Uncaptioned image]]\n\nDrop-Region map (Fig. [3(i)]In Figure 3 ‣ 4 Experimental Analysis ‣ Multi-Robot Motion Planning with Diffusion Models\")) simulates package drop-off chutes. Motion demonstrations are trajectories between random states that include a pause at one of sixteen drop-off regions—next to any chute edge midpoint. Adherence is met for 𝝉isuperscript𝝉𝑖\\\\boldsymbol{\\\\tau}^{i}, i.e., costdata​(𝝉i)=1subscriptcostdatasuperscript𝝉𝑖1\\\\text{cost}\\_{\\\\text{data}}(\\\\boldsymbol{\\\\tau}^{i})=1, if it includes such a pause. Otherwise, it is zero.\n\n![[Uncaptioned image]]\n\nConveyor map (Fig. [3(e)]In Figure 3 ‣ 4 Experimental Analysis ‣ Multi-Robot Motion Planning with Diffusion Models\")) features narrow passages with directional motion requirements. Demonstrations connect random states with trajectories that pass along the top corridor to the left, or through the bottom corridor to the right. Trajectory 𝝉isuperscript𝝉𝑖\\\\boldsymbol{\\\\tau}^{i} adheres to data if it similarly passes through either corridor before reaching its goal.\n\n![[Uncaptioned image]]\n\nHighways map (Fig. [3(a)]In Figure 3 ‣ 4 Experimental Analysis ‣ Multi-Robot Motion Planning with Diffusion Models\")), requires counter-clockwise movement around a central obstacle—a pattern shown in its associated data. This map can be seen as a modular building block for larger multi-robot environments with its required motion pattern promoting easier coordination. Adherence is met for 𝝉isuperscript𝝉𝑖\\\\boldsymbol{\\\\tau}^{i} if its cumulative motion within the map is counter-clockwise.\n\n![[Uncaptioned image]]\n\nEmpty map (Fig. [2(a)]In Figure 2 ‣ 3.3 Sequencing Diffusion Models for Long Horizon Planning ‣ 3 Method ‣ Multi-Robot Motion Planning with Diffusion Models\")) is our simplest. Robots are scored highly if they move in straight lines and gradually worse the more they deviate. Demonstrations are of straight line motions.\n\n![[Uncaptioned image]]\n\nLarger Maps (Fig. [5(f)]In Figure 5 ‣ 4.2 MMD Outperforms MAPF with Learned Cost Maps ‣ 4 Experimental Analysis ‣ Multi-Robot Motion Planning with Diffusion Models\")). In our larger scale experiments (Sec. [4.3]Sequenced Diffusion Models for Long-Horizon Planning ‣ 4 Experimental Analysis ‣ Multi-Robot Motion Planning with Diffusion Models\")) trajectories are computed within 2×2222\\\\times 2 and 3×3333\\\\times 3 maps composed of smaller, local maps. Required motions are dictated by spanned local maps, and the overall adherence is the average adherence per local map.\n\n![Refer to caption](a) Highways map.\n\n(b) \\*(c) \\*(d) \\*\n\n\\[0.12\\]![[Uncaptioned image]]\n\n\\[0.32\\]![[Uncaptioned image]]\n\n\\[0.32\\]![[Uncaptioned image]]\n\n![Refer to caption](e) Conveyor map.\n\n(f) \\*(g) \\*(h) \\*\n\n\\[0.12\\]![[Uncaptioned image]]\n\n\\[0.32\\]![[Uncaptioned image]]\n\n\\[0.32\\]![[Uncaptioned image]]\n\n![Refer to caption](i) Drop-Region map.\n\n(j) \\*(k) \\*(l) \\*Figure 3: Analysis of success rates and data adherence scores in randomly generated planning queries.\nWe report on all five MMD instantiations, each influenced by a constraint-based search algorithm, and a MAPF method with and without a learned cost map. The left column shows our test maps, the middle column compares success rates across 101010 trials per robot count, and the right column presents the average data adherence scores. Sec. [4]Experimental Analysis ‣ Multi-Robot Motion Planning with Diffusion Models\") discusses the experiments and results.\n\n\\[0.12\\]![[Uncaptioned image]]\n\n\\[0.32\\]![[Uncaptioned image]]\n\n\\[0.32\\]![[Uncaptioned image]]\n\n### 4.1 Decoupling Scales Multi-Robot Diffusion Planning\n\nAn appealing approach for learning multi-robot trajectory generation is by obtaining multi-robot trajectory datasets and training a single model to jointly generate trajectories for all robots. To test this approach, we evaluated MPD-Composite, a state-of-the-art motion planning diffusion model (MPD) (Carvalho et al., [2023]) that we trained on multi-robot data we collected in two maps: Empty and Highways. We created three models: for 333, 666, and 999 robots. Each model was also given an additional guidance term that penalized collisions between robots.\nAcross 300300300 tests, 505050 for each map and group size, we compared MPD-Composite to MMD-xECBS (referred to as MMD). See Fig. [2]Figure 2 ‣ 3.3 Sequencing Diffusion Models for Long Horizon Planning ‣ 3 Method ‣ Multi-Robot Motion Planning with Diffusion Models\") for results. The composite model achieved perfect success rates and high data adherence scores with 3 robots but struggled as the number of robots increased to 666. No valid trajectories were generated in any test with 999 agents using MPD-Composite in either map. In contrast, MMD solved all 300 problems successfully and further scaled to 40 agents in additional random tests, also producing trajectories with high data adherence scores and no collisions.\n\n### 4.2 MMD Outperforms MAPF with Learned Cost Maps\n\nFrom a search-based planning viewpoint, a compelling way to integrate motion data into multi-agent planning is by reducing MRMP to MAPF and forming cost maps to direct algorithms like ECBS (Cohen et al., [2016]). This sacrifices dynamic feasibility, limiting solutions to a fixed graph, but can still offer a desirable homotopy class and be assessed for data compliance.\nOur second experiment set evaluates this method’s potential to produce data-compliant motions (see Fig. [3(j)]In Figure 3 ‣ 4 Experimental Analysis ‣ Multi-Robot Motion Planning with Diffusion Models\")). We created 180 motion planning problems, 10 per group size across three maps, and assessed two search-based methods: A\\*Data-ECBS and A\\*-ECBS. The former plans single-robot paths with A\\* using map-specific statistical cost maps, where edges have lower costs if those are visited more frequently by the map’s dataset trajectories (discretized to map cells). The latter uses uniform costs (i.e., has no knowledge of the data) and is reported only to provide context for A\\*Data-ECBS’s performance.\n\nWe find that integrating motion data into statistical cost maps yields mixed outcomes: it enhances adherence in the Highways map by around 35%percent3535\\\\% compared to A\\*-ECBS but decreases success rates. In other maps, this approach finds collision-free paths, but falls short in managing complex motion distributions.\nIn contrast, our results for running MMD methods for the same planning problems show that those can solve complex trajectory generation tasks with high data adherence scores across all methods, and for some, with high success rates too.\n\n![Refer to caption](a) _Circle_ setup.\n\n(b) \\*(c) \\*(d) \\*\n\n\\[0.12\\]![[Uncaptioned image]]\n\n\\[0.32\\]![[Uncaptioned image]]\n\n\\[0.32\\]![[Uncaptioned image]]\n\n![Refer to caption](e) _Weave_ setup.\n\n(f) \\*(g) \\*(h) \\*Figure 4: Scalability tests for our five MMD methods in free-space MRMP. Starts and goals were chosen to induce robot collisions. The top row shows the _circle_ setup, where robots swap positions between opposite points on the perimeter. The _weave_ setup results are below, with robots exchanging positions along uniformly spaced boundary points. Length is zero for failed problems (in MMD-PP, caused by yielding invalid solutions, and in the rest, by computing for longer than 240 seconds).\n\n\\[0.12\\]![[Uncaptioned image]]\n\n\\[0.32\\]![[Uncaptioned image]]\n\n\\[0.32\\]![[Uncaptioned image]]\n\nAnalyzing MMD Constraining Strategies.\nFurther analysis reveals a trend familiar from the MAPF literature. MMD-CBS struggles with scalability, reaching the time limit with more than 999 robots. MMD-ECBS significantly outperforms MMD-CBS, and accelerated versions further improve performance.\nMMD-PP finds efficiency in requiring only one inference pass per robot, however, because the constraints on diffusion models are soft, trajectory generation queries are not guaranteed to completely avoid higher-priority robots, and as such MMD-PP may fail to produce collision-free solutions. This is reflected in lower success rates in congested maps. In contrast, CBS-based MMD methods only failed by exceeding our 60-second runtime limit. MMD-xECBS outperformd other MMD algorithms in success rates and matched MMD-ECBS in data adherence.\n\nTo test MMD’s MRMP solving ability without regard to data adherence, we created two free-space experiments focusing on robot interactions (Fig. [4(f)]In Figure 4 ‣ 4.2 MMD Outperforms MAPF with Learned Cost Maps ‣ 4 Experimental Analysis ‣ Multi-Robot Motion Planning with Diffusion Models\")). In the _circle_ setup, robots move between opposite points on a circle, likely colliding at the center. In the _weave_ setup (inspired by Tajbakhsh et al. ( [2024])), robots begin on opposite points of a square, aiming to switch places.\nCBS-based methods were challenged in _circle_ since incrementally constraining the center region is time consuming. MMD-PP’s stronger constraints navigated around congestion and solved more problems, however, occasionally failed to produce valid solutions. In _weave_, where navigating around congestion is more difficult, CBS-based methods generated collision-free trajectories more effectively.\n\n![Refer to caption](a) 2×2222\\\\times 2 map.\n\n(b) \\*(c) \\*(d) \\*\n\n\\[0.12\\]![[Uncaptioned image]]\n\n\\[0.32\\]![[Uncaptioned image]]\n\n\\[0.32\\]![[Uncaptioned image]]\n\n![Refer to caption](e) 3×3333\\\\times 3 map.\n\n(f) \\*(g) \\*(h) \\*Figure 5: Experimental setup and results for scaling MMD to larger environments and longer planning horizons. MMD still relies on single agent data in small, local maps and does not require training of new networks for this scale-up. We evaluate three MMD variants across two large maps made of tiled local maps to cover a significantly larger area.\n\n\\[0.12\\]![[Uncaptioned image]]\n\n\\[0.32\\]![[Uncaptioned image]]\n\n\\[0.32\\]![[Uncaptioned image]]\n\n### 4.3 Sequenced Diffusion Models for Long-Horizon Planning\n\nWe present a feasibility study on expanding MMD algorithms to larger maps using the sequencing method described in Sec. [3.3]Sequencing Diffusion Models for Long Horizon Planning ‣ 3 Method ‣ Multi-Robot Motion Planning with Diffusion Models\"). This technique assembles smaller local maps, each associated with a diffusion model, to collectively generate long-horizon, data-driven trajectories. In our experiments, we tested three MMD methods—MMD-PP, MMD-ECBS, and MMD-xECBS—in 120 trajectory generation tests, allowing a relaxed 240-second time frame. A standout feature of the sequencing method is its ability to create trajectories that follow a task-skeleton: passing through a series of local maps within the larger global map. For this purpose,\nour experiments assign a random sequence of three tasks per robot (a sequence of local maps), and randomly selects start and goal states within the first and last local maps in the sequence. The results (Fig. [5(f)]In Figure 5 ‣ 4.2 MMD Outperforms MAPF with Learned Cost Maps ‣ 4 Experimental Analysis ‣ Multi-Robot Motion Planning with Diffusion Models\")) show MMD-xECBS scaling to long planning horizons without compromising data adherence. This demonstrates MMD’s capability to efficiently produce multi-robot trajectories in large environments by utilizing diffusion models trained with easily gathered data from small, local maps.",
      "citations": [
        {
          "start_pos": 5105,
          "end_pos": 5128,
          "text": "Carvalho et al., [2023]",
          "paper_id": "bib.bib3",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        },
        {
          "start_pos": 6332,
          "end_pos": 6352,
          "text": "Cohen et al., [2016]",
          "paper_id": "bib.bib7",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        },
        {
          "start_pos": 9846,
          "end_pos": 9871,
          "text": "Tajbakhsh et al. ( [2024]",
          "paper_id": "bib.bib35",
          "single_citation": true,
          "citation_type": "others",
          "nearest_citations": null
        }
      ]
    },
    "5 Related Work": {
      "content": "Multi-Robot Motion Planning.\nDue to the PSPACE-hardness of MRMP (Hopcroft & Wilfong, [1986]), most practical algorithms make various approximations to relax the planning problem. Some of the most successful MRMP methods reduce the problem to a multi-agent path finding problem (MAPF) (Stern et al., [2019]) by discretizing state and time and assuming zero-volume shapes, constant velocities and rectilinear movements (Chen et al., [2021]).\nHowever, this introduces a gap between the MAPF formulation and MRMP which is problematic in many domains.\nTo relax the restriction of planning on a grid, recent works (Solis et al., [2021]; Hönig et al., [2018]) have generalized MAPF algorithms to continuous state spaces by using sampling-based motion planners to construct probabilistic roadmaps (PRM)  (Kavraki et al., [1996]) for robots.\n\nMore generally, _coupled_ MRMP algorithms, like Sanchez & Latombe ( [2002])); Solovey et al. ( [2016]) apply sampling-based planners like PRM and RRT (Karaman & Frazzoli, [2011]) to the composite configuration space of all the robots. This approach guarantees completeness but struggles to scale with the number of robots as the configuration space grows exponentially.\nConversely, _decoupled_ algorithms like prioritized planning (Erdmann & Lozano-Perez, [1987]) and Leroy et al. ( [1999]) generate robot motions one after another, fixing each plan and regarding them as dynamic obstacles in subsequent planning iterations. This allows them to quickly find solutions for large numbers of robots, but sometimes fail to find any solution even if one exists, i.e., they are often incomplete.\nSeeking to balance theoretical guarantees with practical efficiency, hybrid algorithms like CBS (Sharon et al., [2015]) plan independently for every robot and loosely couple them to resolve conflicts.\n\nPlanning with Diffusion Models.\nLately, there has been a surge of interest in applying diffusion models (Sohl-Dickstein et al., [2015]) to solve sequential decision making tasks, including planning and reinforcement learning (Ubukata et al., [2024]).\nDiffuser (Janner et al., [2022]) first proposed the idea of using diffusion models for trajectory planning and showed how classifier-guided sampling and image inpainting can be used for adaptation at test time.\nRecent works have used diffusion models\nas priors\nfor single-robot motion planning (Carvalho et al., [2023]), for learning visuomotor policies (Chi et al., [2024]), and for offline decision-making (Ajay et al., [2023]).\nMost of these works have been limited to single-agent planning with two notable exceptions.\nJiang et al. ( [2023]) learn a joint motion distribution for multi-agent motion prediction using a diffusion model. By contrast, we focus on generating kinodynamically feasible and collision-free trajectories without having to learn a joint distribution.\nConcurrent work by Mishra et al. ( [2024]) uses spatial-temporal factor graphs to compose modular generative models for solving long-horizon bimanual coordination tasks. By contrast, our approach can scale diffusion models to dozens of robots and complex environments by leveraging multi-agent search algorithms.",
      "citations": [
        {
          "start_pos": 65,
          "end_pos": 91,
          "text": "Hopcroft & Wilfong, [1986]",
          "paper_id": "bib.bib11",
          "single_citation": true,
          "citation_type": "others",
          "nearest_citations": null
        },
        {
          "start_pos": 285,
          "end_pos": 305,
          "text": "Stern et al., [2019]",
          "paper_id": "bib.bib34",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        },
        {
          "start_pos": 418,
          "end_pos": 437,
          "text": "Chen et al., [2021]",
          "paper_id": "bib.bib4",
          "single_citation": true,
          "citation_type": "others",
          "nearest_citations": null
        },
        {
          "start_pos": 609,
          "end_pos": 629,
          "text": "Solis et al., [2021]",
          "paper_id": "bib.bib31",
          "single_citation": true,
          "citation_type": "others",
          "nearest_citations": null
        },
        {
          "start_pos": 633,
          "end_pos": 651,
          "text": "nig et al., [2018]",
          "paper_id": "bib.bib10",
          "single_citation": true,
          "citation_type": "others",
          "nearest_citations": null
        },
        {
          "start_pos": 797,
          "end_pos": 819,
          "text": "Kavraki et al., [1996]",
          "paper_id": "bib.bib15",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        },
        {
          "start_pos": 912,
          "end_pos": 935,
          "text": "Solovey et al. ( [2016]",
          "paper_id": "bib.bib32",
          "single_citation": true,
          "citation_type": "others",
          "nearest_citations": null
        },
        {
          "start_pos": 985,
          "end_pos": 1011,
          "text": "Karaman & Frazzoli, [2011]",
          "paper_id": "bib.bib14",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        },
        {
          "start_pos": 1283,
          "end_pos": 1296,
          "text": "Perez, [1987]",
          "paper_id": "bib.bib8",
          "single_citation": true,
          "citation_type": "others",
          "nearest_citations": null
        },
        {
          "start_pos": 1302,
          "end_pos": 1323,
          "text": "Leroy et al. ( [1999]",
          "paper_id": "bib.bib16",
          "single_citation": true,
          "citation_type": "others",
          "nearest_citations": null
        },
        {
          "start_pos": 1721,
          "end_pos": 1742,
          "text": "Sharon et al., [2015]",
          "paper_id": "bib.bib28",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        },
        {
          "start_pos": 1936,
          "end_pos": 1960,
          "text": "Dickstein et al., [2015]",
          "paper_id": "bib.bib29",
          "single_citation": true,
          "citation_type": "others",
          "nearest_citations": null
        },
        {
          "start_pos": 2052,
          "end_pos": 2074,
          "text": "Ubukata et al., [2024]",
          "paper_id": "bib.bib36",
          "single_citation": true,
          "citation_type": "others",
          "nearest_citations": null
        },
        {
          "start_pos": 2087,
          "end_pos": 2108,
          "text": "Janner et al., [2022]",
          "paper_id": "bib.bib12",
          "single_citation": true,
          "citation_type": "method",
          "nearest_citations": null
        },
        {
          "start_pos": 2372,
          "end_pos": 2395,
          "text": "Carvalho et al., [2023]",
          "paper_id": "bib.bib3",
          "single_citation": true,
          "citation_type": "others",
          "nearest_citations": null
        },
        {
          "start_pos": 2432,
          "end_pos": 2450,
          "text": "Chi et al., [2024]",
          "paper_id": "bib.bib5",
          "single_citation": true,
          "citation_type": "others",
          "nearest_citations": null
        },
        {
          "start_pos": 2486,
          "end_pos": 2505,
          "text": "Ajay et al., [2023]",
          "paper_id": "bib.bib1",
          "single_citation": true,
          "citation_type": "others",
          "nearest_citations": null
        },
        {
          "start_pos": 2600,
          "end_pos": 2621,
          "text": "Jiang et al. ( [2023]",
          "paper_id": "bib.bib13",
          "single_citation": true,
          "citation_type": "others",
          "nearest_citations": null
        },
        {
          "start_pos": 2874,
          "end_pos": 2896,
          "text": "Mishra et al. ( [2024]",
          "paper_id": "bib.bib21",
          "single_citation": true,
          "citation_type": "others",
          "nearest_citations": [
            "bib.bib22",
            "bib.bib9",
            "bib.bib19"
          ]
        }
      ]
    },
    "6 Conclusion": {
      "content": "In this paper, we present Multi-robot Multi-model planning Diffusion (MMD), a multi-robot motion planner that learns to generate smooth collision-free trajectories for dozens of robots in complex environments.\nOur key contribution is showing how single robot diffusion models can be effectively combined with state-of-the-art multi-agent search algorithms to generate data-driven multi-robot trajectories.\nBy learning only single-robot diffusion models, MMD simplifies data requirements and breaks the curse of dimensionality plaguing approaches that learn from multi-robot data. Additionally, by learning generative models of robot trajectories, MMD overcomes many of the limitations of popular model-based MAPF algorithms, such as state discretization, known cost function, and constant velocities.\nWe believe MMD opens up exciting avenues for future work on combining the strengths of search algorithms and diffusion planning.\n\nLimitations. We are excited about the potential of MMD to push forward multi-robot coordination and collaboration and offer a few avenues for future work. First is allowing for more flexibility in MMD’s planning horizon. As it stands, MMD generates trajectories of fixed duration—a limitation it inherits from diffusion planning. Sequencing models helps extend the time horizon but still, it must be determined a priori.\nSecond, we believe that the CBS-based MMD methods can be greatly accelerated, mostly through parallelization of the high-level search. Finally, we believe the frontier of MRMP lies in collaboration. Currently, MMD focuses on coordinating robots, seeking to produce collision-free data-driven trajectories. Carrying out collaborative tasks is an interesting next step.",
      "citations": []
    },
    "7 Reproducibility": {
      "content": "We aspire for MMD to be easily used and extended by researchers and practitioners. To this end, we make our source code for all MMD algorithms, scripts for data generation, training, and evaluation, and evaluation maps publicly available at [https://github.com/yoraish/mmd]. This code, along with the parameter values detailed in Sec. [A.4]A.4 Implementation Details ‣ Appendix A Appendix ‣ Multi-Robot Motion Planning with Diffusion Models\"), is sufficient for reproducing the experiments and results presented in this paper.\nTo run our code “out of the box,” without dataset generation or training, we provide pre-trained models and datasets detailed in Sec. [4]Experimental Analysis ‣ Multi-Robot Motion Planning with Diffusion Models\") with detailed instructions. For hardware and software dependencies, we specify the exact versions of libraries and tools required in our repository and also detail our hardware setup in Sec. [A.4]A.4 Implementation Details ‣ Appendix A Appendix ‣ Multi-Robot Motion Planning with Diffusion Models\").\n\n#### Acknowledgments\n\nThe work was supported by the National Science Foundation under Grant IIS-2328671 and the CMU Manufacturing Futures Institute, made possible by the Richard King Mellon Foundation.\nWe thank Mohit Sharma and Ilan Mitnikov for fruitful discussions.",
      "citations": []
    }
  },
  "references": {
    "data": {
      "bib.bib9": {
        "id": "bib.bib9",
        "citation": "Ho et al. (2020)",
        "authors": "",
        "year": "",
        "title": "Denoising diffusion probabilistic models.",
        "venue": "Advances in Neural Information Processing Systems",
        "pages": "",
        "url": "https://proceedings.neurips.cc/paper_files/paper/2020/file/4c5bcfec8584af0d967f1ab10179ca4b-Paper.pdf",
        "arxiv_id": "2201.09865",
        "doi": null,
        "sections": {
          "1 Introduction": {
            "content": "Image Inpainting, also known as Image Completion, aims at filling missing regions within an image.\nSuch inpainted regions need to harmonize with the rest of the image and be semantically reasonable. Inpainting approaches thus require strong generative capabilities.\nTo this end, current State-of-the-Art approaches \\[ [48]), [20]), [51]), [40])\\] rely on GANs \\[ [8])\\] or Autoregressive Modeling \\[ [33]), [42]), [49])\\].\nMoreover, inpainting methods need to handle various forms of masks such as thin or thick brushes, squares, or even extreme masks where the vast majority of the image is missing. This is highly challenging since existing approaches train with a certain mask distribution, which can lead to poor generalization to novel mask types. In this work, we investigate an alternative generative approach for inpainting, aiming to design an approach that requires no mask-specific training.\n\nDenoising Diffusion Probabilistic Models (DDPM) is an emerging alternative paradigm for generative modelling \\[ [12]), [38])\\]. Recently, Dhariwal and Nichol \\[ [7])\\] demonstrated that DDPM can even outperform the state-of-the-art GAN-based method \\[ [4])\\] for image synthesis.\nIn essence, the DDPM is trained to iteratively denoise the image by reversing a diffusion process.\nStarting from randomly sampled noise, the DDPM is then iteratively applied for a certain number of steps, which yields the final image sample.\nWhile founded in principled probabilistic modeling, DDPMs have been shown to generate diverse and high-quality images \\[ [12]), [28]), [7])\\].\n\nWe propose RePaint: an inpainting method that solely leverages an off-the-shelf unconditionally trained DDPM. Specifically, instead of learning a mask-conditional generative model, we condition the generation process by sampling from the given pixels during the reverse diffusion iterations. Remarkably, our model is therefore not trained for the inpainting task itself. This has two important advantages.\nFirst, it allows our network to generalize to any mask during inference.\nSecond, it enables our network to learn more semantic generation capabilities since it has a powerful DDPM image synthesis prior (Figure LABEL:fig:intro).\n\nAlthough the standard DDPM sampling strategy produces matching textures, the inpainting is often semantically incorrect.\nTherefore, we introduce an improved denoising strategy that resamples (RePaint) iterations to better condition the image.\nNotably, instead of slowing down the diffusion process \\[ [7])\\], our approach goes forward and backward in diffusion time, producing remarkable semantically meaningful images.\nOur approach allows the network to effectively harmonize the generated image information during the entire inference process, leading to a more effective conditioning on the given image information.\n\nWe perform experiments on CelebA-HQ \\[ [21])\\] and ImageNet \\[ [36])\\], and compare with other State-of-the-Art inpainting approaches.\nOur approach generalizes better and has overall more semantically meaningful inpainted regions.",
            "citations": null
          },
          "2 Related Work": {
            "content": "Early attempts on Image Inpainting or Image Completion exploited low-level cues within the input image \\[ [2]), [1]), [3])\\], or within the neighbor of a large image dataset \\[ [10])\\] to fill the missing region.\n\nDeterministic Image Inpainting:\nSince the introduction of GANs \\[ [8])\\], most of the existing methods follow a standard configuration, first proposed by Pathak _et al_.\\[ [32])\\], that is, using an encoder-decoder architecture as the main inpainting generator, adversarial training, and tailored losses that aim at photo-realism. Follow-up works have produced impressive results in recent years \\[ [34]), [50]), [20]), [30]), [15])\\].\n\nAs image inpainting requires a high-level semantic context, and to explicitly include it in the generation pipeline, there exist hand-crafted architectural designs such as Dilated Convolutions \\[ [16]), [45])\\] to increase the receptive field, Partial Convolutions \\[ [19])\\] and Gated Convolutions \\[ [48])\\] to guide the convolution kernel according to the inpainted mask, Contextual Attention \\[ [46])\\] to leverage on global information, Edges maps \\[ [27]), [43]), [44]), [9])\\] or Semantic Segmentation maps \\[ [14]), [31])\\] to further guide the generation, and Fourier Convolutions \\[ [40])\\] to include both global and local information efficiently. Although recent works produce photo-realistic results, GANs are well known for textural synthesis, so these methods shine on background completion or removing objects, which require repetitive structural synthesis, and struggle with semantic synthesis (Figure [4]Figure 4 ‣ 5.2 Metrics ‣ 5 Experiments ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\")).\n\nDiverse Image Inpainting:\nMost GAN-based Image Inpainting methods are prone to deterministic transformations due to the lack of control during the image synthesis. To overcome this issue, Zheng _et al_.\\[ [55])\\] and Zhao _et al_.\\[ [53])\\] propose a VAE-based network that trade-offs between diversity and reconstruction. Zhao _et al_.\\[ [54])\\], inspired by the StyleGAN2 \\[ [18])\\] modulated convolutions, introduces a co-modulation layer for the inpainting task in order to improve both diversity and reconstruction.\nA new family of auto-regressive methods \\[ [49]), [33]), [42])\\], which can handle irregular masks, has recently emerged as a powerful alternative for free-form image inpainting.\n\nUsage of Image Prior:\nIn a different direction closer to ours Richardson _et al_.\\[ [35])\\] exploits the StyleGAN \\[ [17])\\] prior to successfully inpaint missing regions.\nHowever, similar to super-resolution methods \\[ [26]), [5])\\] that leverage the StyleGAN latent space, it is to limited specific scenarios like faces.\nNoteworthy, a Ulyanov _et al_.\\[ [41])\\] showed that the structure of a non-trained generator network contains an inherent prior that can be used for inpaining and other applications.\nIn contrast to these methods, we are leveraging on the high expressiveness of a pretrained Denoising Diffusion Probabilistic Model \\[ [12])\\] (DDPM) and therefore use it as a prior for generic image inpainting. Our method generates very detailed, high-quality images for both semantically meaningful generation and texture synthesis. Moreover, our method is not trained for the image inpainting task, and instead, we take full advantage of the prior DDPM, so each image is optimized independently.\n\nImage Conditional Diffusion Models:\nThe work by Sohl-Dickstein _et al_.\\[ [38])\\] applied early diffusion models to inpainting. More recently, Song _et al_.\\[ [39])\\] develop a score-based formulation using stochastic differential equations for unconditional image generation, with an additional application to inpainting. However, both these works only show qualitative results, and do not compare with other inpainting approaches. In contrast, we aim to advance the state-of-the-art in image inpainting, and provide comprehensive comparisons with the top competing methods in literature.\n\nA different line of research is guided image synthesis with DDPM-based approaches \\[ [6]), [25])\\].\nIn the case of ILVR \\[ [6])\\], a trained diffusion model is guided using the low-frequency information from a conditional image.\nHowever, this conditioning strategy cannot be adopted for inpainting, since both high and low-frequency information is absent in the masked-out regions.\nAnother approach for image-conditional synthesis is developed by \\[ [25])\\].\nGuided generation is performed by initializing the reverse diffusion process from the guiding image at some intermediate diffusion time.\nAn iterative strategy, repeating the reverse process several times, is further adopted to improve harmonization.\nSince a guiding image is required to start the reverse process at an intermediate time step, this approach is not applicable to inpainting, where new image content needs to be generated solely conditioned on the non-masked pixels.\nFurthermore, the resampling strategy proposed in this work differs from the concurrent \\[ [25])\\].\nWe proceed through the full reverse diffusion process, starting at the end time, at each step jumping back and forth a fixed number of time steps to progressively improve generation quality.\n\nWhile we propose a method that conditions an unconditionally trained model, the concurrent work \\[ [29])\\] is based on classifier-free guidance \\[ [13])\\] for training an image-conditional diffusion model.\nAnother direction for image manipulation is image-to-image translation using diffusion models as explored in the concurrent work \\[ [37])\\].\nIt trains an image-conditional DDPM, and shows an application to inpainting.\nUnlike both these concurrent works, we leverage an unconditional DDPM and only condition through the reverse diffusion process itself. It allows our approach to effortlessly generalize to any mask shape for free-form inpainting. Moreover, we propose a sampling schedule for the reverse process, which greatly improves image quality.",
            "citations": null
          },
          "3 Preliminaries: Denoising Diffusion Probabilistic Models": {
            "content": "In this paper, we use diffusion models \\[ [38])\\] as a generative method.\nAs other generative models, the DDPM learns a distribution of images given a training set.\nThe inference process works by sampling a random noise vector xTsubscript𝑥𝑇{x\\_{T}} and gradually denoising it until it reaches a high-quality output image x0subscript𝑥0{x\\_{0}}.\nDuring training, DDPM methods define a diffusion process that transforms an image x0subscript𝑥0x\\_{0} to white Gaussian noise xT∼𝒩​(0,1)similar-tosubscript𝑥𝑇𝒩01x\\_{T}\\\\sim\\\\mathcal{N}(0,1) in T𝑇T time steps. Each step in the forward direction is given by,\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n|  | q​(xt\\|xt−1)𝑞conditionalsubscript𝑥𝑡subscript𝑥𝑡1\\\\displaystyle q(x\\_{t}\\|x\\_{t-1}) | =𝒩​(xt;1−βt​xt−1,βt​𝐈)absent𝒩subscript𝑥𝑡1subscript𝛽𝑡subscript𝑥𝑡1subscript𝛽𝑡𝐈\\\\displaystyle=\\\\mathcal{N}(x\\_{t};\\\\sqrt{1-\\\\beta\\_{t}}x\\_{t-1},\\\\beta\\_{t}\\\\mathbf{I}) |  | (1) |\n\nThe sample xtsubscript𝑥𝑡x\\_{t} is obtained by adding i.i.d. Gaussian noise with variance βtsubscript𝛽𝑡\\\\beta\\_{t} at timestep t𝑡t and scaling the previous sample xt−1subscript𝑥𝑡1x\\_{t-1} with 1−βt1subscript𝛽𝑡\\\\sqrt{1-\\\\beta\\_{t}} according to a variance schedule.\n\nThe DDPM is trained to reverse the process in ( [1]Equation 1 ‣ 3 Preliminaries: Denoising Diffusion Probabilistic Models ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\")).\nThe reverse process is modeled by a neural network that predicts the parameters μθ​(xt,t)subscript𝜇𝜃subscript𝑥𝑡𝑡\\\\mu\\_{\\\\theta}(x\\_{t},t) and Σθ​(xt,t)subscriptΣ𝜃subscript𝑥𝑡𝑡\\\\Sigma\\_{\\\\theta}(x\\_{t},t) of a Gaussian distribution,\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | pθ​(xt−1\\|xt)=𝒩​(xt−1;μθ​(xt,t),Σθ​(xt,t))subscript𝑝𝜃conditionalsubscript𝑥𝑡1subscript𝑥𝑡𝒩subscript𝑥𝑡1subscript𝜇𝜃subscript𝑥𝑡𝑡subscriptΣ𝜃subscript𝑥𝑡𝑡p\\_{\\\\theta}(x\\_{t-1}\\|x\\_{t})=\\\\mathcal{N}(x\\_{t-1};\\\\mu\\_{\\\\theta}(x\\_{t},t),\\\\Sigma\\_{\\\\theta}(x\\_{t},t)) |  | (2) |\n\nThe learning objective for the model ( [2]Equation 2 ‣ 3 Preliminaries: Denoising Diffusion Probabilistic Models ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\")) is derived by considering the variational lower bound,\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n|  | 𝔼\\[−logpθ(𝐱0)\\]≤𝔼q\\[\\\\displaystyle\\\\mathbb{E}\\\\left\\[-\\\\log p\\_{\\\\theta}(\\\\mathbf{x}\\_{0})\\\\right\\]\\\\leq\\\\mathbb{E}\\_{q}\\\\bigg{\\[} | −logpθ​(𝐱0:T)q​(𝐱1:T\\|𝐱0)\\]\\\\displaystyle-\\\\log\\\\frac{p\\_{\\\\theta}(\\\\mathbf{x}\\_{0:T})}{q(\\\\mathbf{x}\\_{1:T}\\|\\\\mathbf{x}\\_{0})}\\\\bigg{\\]} |  | (3) |\n|  | =𝔼q\\[−logp(𝐱T)\\\\displaystyle=\\\\mathbb{E}\\_{q}\\\\bigg{\\[}-\\\\log p(\\\\mathbf{x}\\_{T}) | −∑t≥1logpθ​(𝐱t−1\\|𝐱t)q​(𝐱t\\|𝐱t−1)\\]=L\\\\displaystyle-\\\\sum\\_{t\\\\geq 1}\\\\log\\\\frac{p\\_{\\\\theta}(\\\\mathbf{x}\\_{t-1}\\|\\\\mathbf{x}\\_{t})}{q(\\\\mathbf{x}\\_{t}\\|\\\\mathbf{x}\\_{t-1})}\\\\bigg{\\]}=L |  |\n\nAs extended by Ho _et al_.\\[ [12])\\], this loss can be further decomposed as,\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n|  |  | 𝔼q\\[DKL​(q​(𝐱T\\|𝐱0)∥p​(𝐱T))⏟LT\\\\displaystyle\\\\mathbb{E}\\_{q}\\\\bigg{\\[}\\\\underbrace{D\\_{\\\\mathrm{KL}}\\\\!\\\\left(q(\\\\mathbf{x}\\_{T}\\|\\\\mathbf{x}\\_{0})~{}\\\\\\|~{}p(\\\\mathbf{x}\\_{T})\\\\right)}\\_{L\\_{T}} |  | (4) |\\\n|  |  | +∑t>1DKL(q(𝐱t−1\\|𝐱t,𝐱0)∥pθ(𝐱t−1\\|𝐱t))⏟Lt−1−log⁡pθ​(𝐱0\\|𝐱1)⏟L0\\]\\\\displaystyle+\\\\sum\\_{t>1}\\\\underbrace{D\\_{\\\\mathrm{KL}}\\\\!\\\\left(q(\\\\mathbf{x}\\_{t-1}\\|\\\\mathbf{x}\\_{t},\\\\mathbf{x}\\_{0})~{}\\\\\\|~{}p\\_{\\\\theta}(\\\\mathbf{x}\\_{t-1}\\|\\\\mathbf{x}\\_{t})\\\\right)}\\_{L\\_{t-1}}\\\\underbrace{-\\\\log p\\_{\\\\theta}(\\\\mathbf{x}\\_{0}\\|\\\\mathbf{x}\\_{1})}\\_{L\\_{0}}\\\\bigg{\\]} |  |\n\nImportantly the term Lt−1subscript𝐿𝑡1L\\_{t-1} trains the network ( [2]Equation 2 ‣ 3 Preliminaries: Denoising Diffusion Probabilistic Models ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\")) to perform one reverse diffusion step. Furthermore, it allows for a closed from expression of the objective since q​(𝐱t−1\\|𝐱t,𝐱0)𝑞conditionalsubscript𝐱𝑡1subscript𝐱𝑡subscript𝐱0q(\\\\mathbf{x}\\_{t-1}\\|\\\\mathbf{x}\\_{t},\\\\mathbf{x}\\_{0}) is also Gaussian \\[ [12])\\].\n\nAs reported by Ho _et al_.\\[ [12])\\], the best way to parametrize the model is to predict the cumulative noise ϵ0subscriptitalic-ϵ0\\\\epsilon\\_{0} that is added to the current intermediate image xtsubscript𝑥𝑡x\\_{t}. Thus, we obtain the following parametrization of the predicted mean μθ​(xt,t)subscript𝜇𝜃subscript𝑥𝑡𝑡\\\\mu\\_{\\\\theta}(x\\_{t},t),\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | μθ​(xt,t)=1αt​(xt−βt1−α¯t​ϵθ​(xt,t))subscript𝜇𝜃subscript𝑥𝑡𝑡1subscript𝛼𝑡subscript𝑥𝑡subscript𝛽𝑡1subscript¯𝛼𝑡subscriptitalic-ϵ𝜃subscript𝑥𝑡𝑡\\\\mu\\_{\\\\theta}(x\\_{t},t)=\\\\frac{1}{\\\\sqrt{\\\\alpha\\_{t}}}\\\\left(x\\_{t}-\\\\frac{\\\\beta\\_{t}}{\\\\sqrt{1-\\\\bar{\\\\alpha}\\_{t}}}\\\\epsilon\\_{\\\\theta}(x\\_{t},t)\\\\right) |  | (5) |\n\nFrom Lt−1subscript𝐿𝑡1L\\_{t-1} in ( [4]Equation 4 ‣ 3 Preliminaries: Denoising Diffusion Probabilistic Models ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\")), the following simplified training objective is derived by Ho _et al_.\\[ [12])\\],\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | Lsimple=Et,x0,ϵ​\\[‖ϵ−ϵθ​(xt,t)‖2\\]subscript𝐿simplesubscript𝐸𝑡subscript𝑥0italic-ϵdelimited-\\[\\]superscriptnormitalic-ϵsubscriptitalic-ϵ𝜃subscript𝑥𝑡𝑡2L\\_{\\\\text{simple}}=E\\_{t,x\\_{0},\\\\epsilon}\\\\left\\[\\|\\|\\\\epsilon-\\\\epsilon\\_{\\\\theta}(x\\_{t},t)\\|\\|^{2}\\\\right\\] |  | (6) |\n\nAs introduced by Nichol and Dhariwal \\[ [28])\\], learning the variance Σθ​(xt,t)subscriptΣ𝜃subscript𝑥𝑡𝑡\\\\Sigma\\_{\\\\theta}(x\\_{t},t) in ( [2]Equation 2 ‣ 3 Preliminaries: Denoising Diffusion Probabilistic Models ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\")) of the reverse process helps to reduce the number of sampling steps by an order of magnitude. They, therefore, add the variational lower bound loss.\nSpecifically, we base our training and inference approach on the recent work \\[ [7])\\], which further reduced the inference time by factor four.\n\nTo train the DDPM, we need a sample xtsubscript𝑥𝑡x\\_{t} and corresponding noise that is used to transform x0subscript𝑥0x\\_{0} to xtsubscript𝑥𝑡x\\_{t}.\nBy using the independence property of the noise added at each step ( [1]Equation 1 ‣ 3 Preliminaries: Denoising Diffusion Probabilistic Models ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\")), we can calculate the total noise variance as αt¯=∏s=1t(1−βs)¯subscript𝛼𝑡superscriptsubscriptproduct𝑠1𝑡1subscript𝛽𝑠\\\\bar{\\\\alpha\\_{t}}=\\\\prod\\_{s=1}^{t}(1-\\\\beta\\_{s}). We can thus rewrite ( [1]Equation 1 ‣ 3 Preliminaries: Denoising Diffusion Probabilistic Models ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\")), as a single step,\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n|  | q​(xt\\|x0)𝑞conditionalsubscript𝑥𝑡subscript𝑥0\\\\displaystyle q(x\\_{t}\\|x\\_{0}) | =𝒩​(xt;α¯t​x0,(1−α¯t)​𝐈)absent𝒩subscript𝑥𝑡subscript¯𝛼𝑡subscript𝑥01subscript¯𝛼𝑡𝐈\\\\displaystyle=\\\\mathcal{N}(x\\_{t};\\\\sqrt{\\\\bar{\\\\alpha}\\_{t}}x\\_{0},(1-\\\\bar{\\\\alpha}\\_{t})\\\\mathbf{I}) |  | (7) |\n\nIt allows us to efficiently sample pairs of training data to train a reverse transition step.\n\n![Refer to caption]Figure 1: Overview of our approach. RePaint modifies the standard denoising process in order to condition on the given image content. In each step, we sample the known region (top) from the input and the inpainted part from the DDPM output (bottom).",
            "citations": null
          },
          "4 Method": {
            "content": "In this section, we first present our approach for conditioning the reverse diffusion process of an unconditional DDPM for image inpainting in Section [4.1]Conditioning on the known Region ‣ 4 Method ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\"). Then, we introduce an approach to improve the reverse process itself for inpainting in Section [4.2]Resampling ‣ 4 Method ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\").\n\n![Refer to caption]\n\n|     |     |     |     |     |     |     |     |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| Input | n = 1 | n = 2 | n = 3 | n = 4 | n = 5 | n = 10 | n = 20 |\n\nFigure 2: The effect of applying n𝑛n sampling steps. The first example with n=1𝑛1n=1 is the DDPM baseline, the second with n=2𝑛2n=2 is with one resample step. More resampling steps lead to more harmonized images. The benefit saturates at about n=10𝑛10n=10 resamplings.\n\n### 4.1 Conditioning on the known Region\n\nThe goal of inpainting is to predict missing pixels of an image using a mask region as a condition. In the remaining of the paper, we consider a trained unconditional denoising diffusion probabilistic model ( [2]Equation 2 ‣ 3 Preliminaries: Denoising Diffusion Probabilistic Models ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\")). We denote the ground truth image as x𝑥x, the unknown pixels as m⊙xdirect-product𝑚𝑥m\\\\odot x and the known pixels as (1−m)⊙xdirect-product1𝑚𝑥(1-m)\\\\odot x.\n\nAlgorithm 1 Inpainting using our RePaint approach.\n\n1:xT∼𝒩​(𝟎,𝐈)similar-tosubscript𝑥𝑇𝒩0𝐈x\\_{T}\\\\sim\\\\mathcal{N}(\\\\mathbf{0},\\\\mathbf{I})\n\n2:fort=T,…,1𝑡𝑇…1t=T,\\\\dotsc,1do\n\n3:foru=1,…,U𝑢1…𝑈u=1,\\\\dotsc,Udo\n\n4:ϵ∼𝒩​(𝟎,𝐈)similar-toitalic-ϵ𝒩0𝐈\\\\epsilon\\\\sim\\\\mathcal{N}(\\\\mathbf{0},\\\\mathbf{I}) if t>1𝑡1t>1, else ϵ=𝟎italic-ϵ0\\\\epsilon=\\\\mathbf{0}\n\n5:xt−1known=α¯t​x0+(1−α¯t)​ϵsuperscriptsubscript𝑥𝑡1knownsubscript¯𝛼𝑡subscript𝑥01subscript¯𝛼𝑡italic-ϵx\\_{t-1}^{\\\\text{known}}=\\\\sqrt{\\\\bar{\\\\alpha}\\_{t}}x\\_{0}+(1-\\\\bar{\\\\alpha}\\_{t})\\\\epsilon\n\n6:z∼𝒩​(𝟎,𝐈)similar-to𝑧𝒩0𝐈z\\\\sim\\\\mathcal{N}(\\\\mathbf{0},\\\\mathbf{I}) if t>1𝑡1t>1, else 𝐳=𝟎𝐳0\\\\mathbf{z}=\\\\mathbf{0}\n\n7:xt−1unknown=1αt​(xt−βt1−α¯t​ϵθ​(xt,t))+σt​zsuperscriptsubscript𝑥𝑡1unknown1subscript𝛼𝑡subscript𝑥𝑡subscript𝛽𝑡1subscript¯𝛼𝑡subscriptbold-italic-ϵ𝜃subscript𝑥𝑡𝑡subscript𝜎𝑡𝑧x\\_{t-1}^{\\\\text{unknown}}=\\\\frac{1}{\\\\sqrt{\\\\alpha\\_{t}}}\\\\left(x\\_{t}-\\\\frac{\\\\beta\\_{t}}{\\\\sqrt{1-\\\\bar{\\\\alpha}\\_{t}}}{\\\\boldsymbol{\\\\epsilon}}\\_{\\\\theta}(x\\_{t},t)\\\\right)+\\\\sigma\\_{t}z\n\n8:xt−1=m⊙xt−1known+(1−m)⊙xt−1unknownsubscript𝑥𝑡1direct-product𝑚superscriptsubscript𝑥𝑡1knowndirect-product1𝑚superscriptsubscript𝑥𝑡1unknownx\\_{t-1}=m\\\\odot x\\_{t-1}^{\\\\text{known}}+(1-m)\\\\odot x\\_{t-1}^{\\\\text{unknown}}\n\n9:ifu​<U​and​t>​1𝑢expectation𝑈and𝑡1u<U~{}\\\\text{and}~{}t>1then\n\n10:xt∼𝒩​(1−βt−1​xt−1,βt−1​𝐈)similar-tosubscript𝑥𝑡𝒩1subscript𝛽𝑡1subscript𝑥𝑡1subscript𝛽𝑡1𝐈x\\_{t}\\\\sim\\\\mathcal{N}(\\\\sqrt{1-\\\\beta\\_{t-1}}x\\_{t-1},\\\\beta\\_{t-1}\\\\mathbf{I})\n\n11:endif\n\n12:endfor\n\n13:endfor\n\n14:returnx0subscript𝑥0x\\_{0}\n\nSince every reverse step ( [2]Equation 2 ‣ 3 Preliminaries: Denoising Diffusion Probabilistic Models ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\")) from xtsubscript𝑥𝑡x\\_{t} to xt−1subscript𝑥𝑡1x\\_{t-1} depends solely on xtsubscript𝑥𝑡x\\_{t}, we can alter the known regions (1−m)⊙xtdirect-product1𝑚subscript𝑥𝑡(1-m)\\\\odot x\\_{t} as long as we keep the correct properties of the corresponding distribution.\nSince the forward process is defined by a Markov Chain ( [1]Equation 1 ‣ 3 Preliminaries: Denoising Diffusion Probabilistic Models ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\")) of added Gaussian noise, we can sample the intermediate image xtsubscript𝑥𝑡x\\_{t} at any point in time using ( [7]Equation 7 ‣ 3 Preliminaries: Denoising Diffusion Probabilistic Models ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\")). This allows us to sample the know regions m⊙xtdirect-product𝑚subscript𝑥𝑡m\\\\odot x\\_{t} at any time step t𝑡t. Thus, using ( [2]Equation 2 ‣ 3 Preliminaries: Denoising Diffusion Probabilistic Models ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\")) for the unknown region and ( [7]Equation 7 ‣ 3 Preliminaries: Denoising Diffusion Probabilistic Models ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\")) for the known regions, we achieve the following expression for one reverse step in our approach,\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n|  |\n|  | xt−1knownsuperscriptsubscript𝑥𝑡1known\\\\displaystyle x\\_{t-1}^{\\\\text{known}} | ∼𝒩​(α¯t​x0,(1−α¯t)​𝐈)similar-toabsent𝒩subscript¯𝛼𝑡subscript𝑥01subscript¯𝛼𝑡𝐈\\\\displaystyle\\\\sim\\\\mathcal{N}(\\\\sqrt{\\\\bar{\\\\alpha}\\_{t}}x\\_{0},(1-\\\\bar{\\\\alpha}\\_{t})\\\\mathbf{I}) |  | (8a) |\n|  | xt−1unknownsuperscriptsubscript𝑥𝑡1unknown\\\\displaystyle x\\_{t-1}^{\\\\text{unknown}} | ∼𝒩​(μθ​(xt,t),Σθ​(xt,t))similar-toabsent𝒩subscript𝜇𝜃subscript𝑥𝑡𝑡subscriptΣ𝜃subscript𝑥𝑡𝑡\\\\displaystyle\\\\sim\\\\mathcal{N}(\\\\mu\\_{\\\\theta}(x\\_{t},t),\\\\Sigma\\_{\\\\theta}(x\\_{t},t)) |  | (8b) |\n|  | xt−1subscript𝑥𝑡1\\\\displaystyle x\\_{t-1} | =m⊙xt−1known+(1−m)⊙xt−1unknownabsentdirect-product𝑚superscriptsubscript𝑥𝑡1knowndirect-product1𝑚superscriptsubscript𝑥𝑡1unknown\\\\displaystyle=m\\\\odot x\\_{t-1}^{\\\\text{known}}+(1-m)\\\\odot x\\_{t-1}^{\\\\text{unknown}} |  | (8c) |\n\nThus, xt−1knownsuperscriptsubscript𝑥𝑡1knownx\\_{t-1}^{\\\\text{known}} is sampled using the known pixels in the given image m⊙x0direct-product𝑚subscript𝑥0m\\\\odot x\\_{0}, while xt−1unknownsuperscriptsubscript𝑥𝑡1unknownx\\_{t-1}^{\\\\text{unknown}} is sampled from the model, given the previous iteration xtsubscript𝑥𝑡x\\_{t}. These are then combined to the new sample xt−1subscript𝑥𝑡1x\\_{t-1} using the mask. Our approach is illustrated in Figure [1]Figure 1 ‣ 3 Preliminaries: Denoising Diffusion Probabilistic Models ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\").\n\n|     |     |     |     |     |     |\n| --- | --- | --- | --- | --- | --- |\n| Half | Expand | Alt. Lines | SR 2×2\\\\times | Narrow | Wide |\n\n![Refer to caption]![Refer to caption]![Refer to caption]![Refer to caption]![Refer to caption]![Refer to caption]\n\n|     |     |     |     |     |     |     |\n| --- | --- | --- | --- | --- | --- | --- |\n| Input | AOT \\[ [51])\\] | DSI \\[ [33])\\] | ICT \\[ [42])\\] | Deep Fill v2 \\[ [47])\\] | LaMa \\[ [40])\\] | RePaint (ours) |\n\nFigure 3: CelebA-HQ Qualitative Results. Comparison against the state-of-the-art methods for Face Inpainting over several mask settings. Zoom-in for better details.\n\n### 4.2 Resampling\n\nWhen directly applying the method described in Section [4.1]Conditioning on the known Region ‣ 4 Method ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\"), we observe that only the content type matches with the known regions.\nFor example, in Figure [2]Figure 2 ‣ 4 Method ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\") n=1𝑛1n=1, the inpainted area is a furry texture matching the hair of the dog. Although the inpainted region matches the texture of the neighboring region, it is semantically incorrect. Therefore, the DDPM is leveraging on the context of the known region, yet it is not harmonizing it well with the rest of the image. Next, we discuss possible reasons for this behavior.\n\nFrom Figure [1]Figure 1 ‣ 3 Preliminaries: Denoising Diffusion Probabilistic Models ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\"), we analyze how the method is conditioning the known regions.\nAs shown in ( [8]Equation 8 ‣ 4.1 Conditioning on the known Region ‣ 4 Method ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\")), the model predicts xt−1subscript𝑥𝑡1x\\_{t-1} using xtsubscript𝑥𝑡x\\_{t}, which comprises the output of the DDPM ( [2]Equation 2 ‣ 3 Preliminaries: Denoising Diffusion Probabilistic Models ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\")) and the sample from the known region.\nHowever, the sampling of the known pixels using ( [7]Equation 7 ‣ 3 Preliminaries: Denoising Diffusion Probabilistic Models ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\")) is performed without considering the generated parts of the image, which introduces disharmony.\nAlthough the model tries to harmonize the image again in every step, it can never fully converge because the same issue occurs in the next step.\nMoreover, in each reverse step, the maximum change to an image declines due to the variance schedule of βtsubscript𝛽𝑡\\\\beta\\_{t}.\nThus, the method cannot correct mistakes that lead to disharmonious boundaries in the subsequent steps due to restricted flexibility.\nAs a consequence, the model needs more time to harmonize the conditional information xt−1knownsuperscriptsubscript𝑥𝑡1knownx\\_{t-1}^{\\\\text{known}} with the generated information xt−1unknownsuperscriptsubscript𝑥𝑡1unknownx\\_{t-1}^{\\\\text{unknown}} in one step before advancing to the next denoising step.\n\nSince the DDPM is trained to generate an image that lies within a data distribution, it naturally aims at producing consistent structures.\nIn our resampling approach, we use this DDPM property to harmonize the input of the model.\nConsequently, we diffuse the output xt−1subscript𝑥𝑡1x\\_{t-1} back to xtsubscript𝑥𝑡x\\_{t} by sampling from ( [1]Equation 1 ‣ 3 Preliminaries: Denoising Diffusion Probabilistic Models ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\")) as xt∼𝒩​(1−βt​xt−1,βt​𝐈)similar-tosubscript𝑥𝑡𝒩1subscript𝛽𝑡subscript𝑥𝑡1subscript𝛽𝑡𝐈x\\_{t}\\\\sim\\\\mathcal{N}(\\\\sqrt{1-\\\\beta\\_{t}}x\\_{t-1},\\\\beta\\_{t}\\\\mathbf{I}).\nAlthough this operation scales back the output and adds noise, some information incorporated in the generated region xt−1unknownsuperscriptsubscript𝑥𝑡1unknownx\\_{t-1}^{\\\\text{unknown}} is still preserved in xtunknownsuperscriptsubscript𝑥𝑡unknownx\\_{t}^{\\\\text{unknown}}. It leads to a new xtunknownsuperscriptsubscript𝑥𝑡unknownx\\_{t}^{\\\\text{unknown}} which is both more harmonized with xt𝚔𝚗𝚘𝚠𝚗superscriptsubscript𝑥𝑡𝚔𝚗𝚘𝚠𝚗x\\_{t}^{\\\\mathtt{known}} and contains conditional information from it.\n\nSince this operation can only harmonize one step, it might not be able to incorporate the semantic information over the entire denoising process.\nTo overcome this problem, we denote the time horizon of this operation as jump length, which is j=1𝑗1j=1 for the previous case.\nSimilar to the standard change in diffusion speed \\[ [7])\\] (a.k.a. slowing down), the resampling also increases the runtime of the reverse diffusion.\nSlowing down applies smaller but more resampling steps by reducing the added variance in each denoising step.\nHowever, that is a fundamentally different approach because slowing down the diffusion still has the problem of not harmonizing the image, as described in our resampling strategy. We empirically demonstrate this advantage of our approach in Sec. [5.6]Ablation Study ‣ 5 Experiments ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\").",
            "citations": null
          },
          "5 Experiments": {
            "content": "We perform extensive experiments for face and generic inpainting, compare to the state-of-the-art solutions, and conduct an ablative analysis. In Section [5.3]Comparison with State-of-the-Art ‣ 5 Experiments ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\") and [5.4]Analysis of Diversity ‣ 5 Experiments ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\"), we report a detailed discussion of mask robustness and diversity, respectively. We also report with additional results, analysis, and visuals in the appendix.\n\n### 5.1 Implementation Details\n\nWe validate our solution over the CelebA-HQ \\[ [21])\\], and Imagenet \\[ [36])\\] datasets. As our method relies on a pretrained guided diffusion model \\[ [7])\\], we use the provided ImageNet model. For CelebA-HQ, we follow the same training hyper-parameters as for ImageNet. We use 256×256256256256\\\\times 256 crops in three batches on 4×\\\\timesV100 GPUs each.\nIn contrast to the pretrained ImageNet model, the CelebA-HQ one is only trained for 250,000 iterations during roughly five days. Note that all our qualitative and quantitative results in the main paper are for 256 image size.\n\n| CelebA-HQ | Wide | Narrow | Super-Resolve 2×2\\\\times | Altern. Lines | Half | Expand |\n| --- | --- | --- | --- | --- | --- | --- |\n| Methods | LPIPS↓↓\\\\downarrow | Votes \\[%\\] | LPIPS↓↓\\\\downarrow | Votes \\[%\\] | LPIPS↓↓\\\\downarrow | Votes \\[%\\] | LPIPS↓↓\\\\downarrow | Votes \\[%\\] | LPIPS↓↓\\\\downarrow | Votes \\[%\\] | LPIPS↓↓\\\\downarrow | Votes \\[%\\] |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| AOT \\[ [51])\\] | 0.104 | 11.6±2.0plus-or-minus11.62.011.6\\\\pm 2.0 | 0.047 | 12.8±2.1plus-or-minus12.82.112.8\\\\pm 2.1 | 0.714 | 1.1±0.6plus-or-minus1.10.61.1\\\\pm 0.6 | 0.667 | 2.4±1.0plus-or-minus2.41.02.4\\\\pm 1.0 | 0.287 | 9.0±1.8plus-or-minus9.01.89.0\\\\pm 1.8 | 0.604 | 8.3±1.7plus-or-minus8.31.78.3\\\\pm 1.7 |\n| DSI \\[ [33])\\] | 0.067 | 16.0±2.3plus-or-minus16.02.316.0\\\\pm 2.3 | 0.038 | 22.3±2.6plus-or-minus22.32.622.3\\\\pm 2.6 | 0.128 | 5.5±1.4plus-or-minus5.51.45.5\\\\pm 1.4 | 0.049 | 5.1±1.4plus-or-minus5.11.45.1\\\\pm 1.4 | 0.211 | 4.5±1.3plus-or-minus4.51.34.5\\\\pm 1.3 | 0.487 | 4.7±1.3plus-or-minus4.71.34.7\\\\pm 1.3 |\n| ICT \\[ [42])\\] | 0.063 | 27.6±2.8plus-or-minus27.62.827.6\\\\pm 2.8 | 0.036 | 30.9±2.9plus-or-minus30.92.930.9\\\\pm 2.9 | 0.483 | 4.2±1.2plus-or-minus4.21.24.2\\\\pm 1.2 | 0.353 | 0.7±0.5plus-or-minus0.70.50.7\\\\pm 0.5 | 0.166 | 12.7±2.1plus-or-minus12.72.112.7\\\\pm 2.1 | 0.432 | 8.8±1.8plus-or-minus8.81.88.8\\\\pm 1.8 |\n| DeepFillv2 \\[ [47])\\] | 0.066 | 23.9±2.6plus-or-minus23.92.623.9\\\\pm 2.6 | 0.049 | 21.0±2.5plus-or-minus21.02.521.0\\\\pm 2.5 | 0.119 | 9.8±1.8plus-or-minus9.81.89.8\\\\pm 1.8 | 0.049 | 10.6±1.9plus-or-minus10.61.910.6\\\\pm 1.9 | 0.209 | 4.1±1.2plus-or-minus4.11.24.1\\\\pm 1.2 | 0.467 | 13.1±2.1plus-or-minus13.12.113.1\\\\pm 2.1 |\n| LaMa \\[ [40])\\] | 0.045 | 41.8±3.1plus-or-minus41.83.141.8\\\\pm 3.1 | 0.028 | 33.8±3.0plus-or-minus33.83.033.8\\\\pm 3.0 | 0.177 | 5.5±1.4plus-or-minus5.51.45.5\\\\pm 1.4 | 0.083 | 20.6±2.5plus-or-minus20.62.520.6\\\\pm 2.5 | 0.138 | 35.6±3.0plus-or-minus35.63.035.6\\\\pm 3.0 | 0.342 | 24.7±2.7plus-or-minus24.72.724.7\\\\pm 2.7 |\n| RePaint | 0.059 | Reference | 0.028 | Reference | 0.029 | Reference | 0.009 | Reference | 0.165 | Reference | 0.435 | Reference |\n\n| ImageNet | Wide | Narrow | Super-Resolve 2×2\\\\times | Altern. Lines | Half | Expand |\n| --- | --- | --- | --- | --- | --- | --- |\n| Methods | LPIPS↓↓\\\\downarrow | Votes \\[%\\] | LPIPS↓↓\\\\downarrow | Votes \\[%\\] | LPIPS↓↓\\\\downarrow | Votes \\[%\\] | LPIPS↓↓\\\\downarrow | Votes \\[%\\] | LPIPS↓↓\\\\downarrow | Votes \\[%\\] | LPIPS↓↓\\\\downarrow | Votes \\[%\\] |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| DSI \\[ [33])\\] | 0.117 | 31.7±2.9plus-or-minus31.72.931.7\\\\pm 2.9 | 0.072 | 28.6±2.8plus-or-minus28.62.828.6\\\\pm 2.8 | 0.153 | 26.9±2.8plus-or-minus26.92.826.9\\\\pm 2.8 | 0.069 | 23.6±2.6plus-or-minus23.62.623.6\\\\pm 2.6 | 0.283 | 31.4±2.9plus-or-minus31.42.931.4\\\\pm 2.9 | 0.583 | 9.2±1.8plus-or-minus9.21.89.2\\\\pm 1.8 |\n| ICT \\[ [42])\\] | 0.107 | 42.9±3.1plus-or-minus42.93.142.9\\\\pm 3.1 | 0.073 | 33.0±2.9plus-or-minus33.02.933.0\\\\pm 2.9 | 0.708 | 1.1±0.6plus-or-minus1.10.61.1\\\\pm 0.6 | 0.620 | 6.6±1.5plus-or-minus6.61.56.6\\\\pm 1.5 | 0.255 | 51.5±3.1plus-or-minus51.53.151.5\\\\pm 3.1 | 0.544 | 25.6±2.7plus-or-minus25.62.725.6\\\\pm 2.7 |\n| LaMa \\[ [40])\\] | 0.105 | 42.4±3.1plus-or-minus42.43.142.4\\\\pm 3.1 | 0.061 | 33.6±2.9plus-or-minus33.62.933.6\\\\pm 2.9 | 0.272 | 13.0±2.1plus-or-minus13.02.113.0\\\\pm 2.1 | 0.121 | 9.6±1.8plus-or-minus9.61.89.6\\\\pm 1.8 | 0.254 | 41.1±3.1plus-or-minus41.13.141.1\\\\pm 3.1 | 0.534 | 20.3±2.5plus-or-minus20.32.520.3\\\\pm 2.5 |\n| RePaint | 0.134 | Reference | 0.064 | Reference | 0.183 | Reference | 0.089 | Reference | 0.304 | Reference | 0.629 | Reference |\n\nTable 1: CelebA-HQ (top) and ImageNet (bottom) Quantitative Results. Comparison against the state-of-the-art methods. We compute the LPIPS (lower is better) and Votes for six different mask settings. Votes refers to the ratio of votes with respect to ours.\n\nFor our final approach, we use T=250𝑇250T=250 timesteps, and applied r=10𝑟10r=10 times resampling with jumpy size j=10𝑗10j=10.\n\n### 5.2 Metrics\n\nWe compare our RePaint with the baseline methods in a user study described as follows. The user is shown the input image with the blanked missing regions.\nNext to this image, we display two different inpainting solutions.\nThe user is asked to select “Which image looks more realistic?”.\nThe user thus evaluates the realism of our RePaint to the result of a baseline.\nTo avoid biasing the user towards an approach, the methods were anonymized shown in a different random order for each image.\nMoreover, each user was asked every question twice and could only submit their answer if they were consistent with themselves in at least 75% of their answer. A self-consistency in 100% of the cases is often not possible since, for example, the LaMa method can have a very similar quality to RePaint on the mask settings they provide.\nOur user study evaluates all 100 test images of the test datasets CelebA-HQ and ImageNet for the following masks: Wide, Narrow, Every Second Line, Half Image, Expand, and Super-Resolve.\nWe use the answers of five different humans for every image query, resulting in 1000 votes per method-to-method comparison in each dataset and mask setting, and show the 95% confidence interval next to the mean votes.\nIn addition to the user study, we report the commonly reported perceptual metric LPIPS \\[ [52])\\], which is a learned distance metric based on the deep feature space of AlexNet. We compute the LPIPS over the same 100 test images used in the user study. The results are shown in Table [1]Table 1 ‣ 5.1 Implementation Details ‣ 5 Experiments ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\"). Furthermore, please refer to the appendix for additional quantitative results.\n\n![Refer to caption]![Refer to caption]![Refer to caption]![Refer to caption]![Refer to caption]![Refer to caption]\n\n|     |     |     |     |     |     |\n| --- | --- | --- | --- | --- | --- |\n| Half | Expand | Altern. Lines | SR 2×2\\\\times | Thin | Thick |\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n| Input | DSI \\[ [33])\\] | ICT \\[ [42])\\] | LaMa \\[ [40])\\] | RePaint (ours) |\n\nFigure 4: ImageNet Qualitative Results. Comparison against the state-of-the-art methods for pluralistic inpainting methods over different mask settings. Zoom-in for better details.\n\n### 5.3 Comparison with State-of-the-Art\n\nIn this section, we first compare our approach against state-of-the-art on standard mask distributions, commonly employed for benchmarking. We then analyze the generalization capabilities of our method against other approaches. To this end, we evaluate their robustness under four challenging mask settings. Firstly, two different masks that probe if the methods can incorporate information from thin structures. Secondly, two masks that require to inpaint a large connected area of the image. All quantitative results are reported in Table [1]Table 1 ‣ 5.1 Implementation Details ‣ 5 Experiments ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\") and visual results in Figure [3]Figure 3 ‣ 4.1 Conditioning on the known Region ‣ 4 Method ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\") and [4]Figure 4 ‣ 5.2 Metrics ‣ 5 Experiments ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\").\n\nMethods:\nWe compare our approach against several state-of-the-art autoregressive-based or GAN-based approaches. The autoregressive methods are DSI \\[ [33])\\] and ICT \\[ [42])\\], and the GAN methods are DeepFillv2 \\[ [47])\\], AOT \\[ [51])\\], and LaMa \\[ [40])\\].\nWe use their publicly available pretrained models.\nWe used the existing FFHQ \\[ [17])\\] pretrained model of ICT for our CelebA-HQ testing. As LaMa does not provide ImageNet models, we trained their system for 300,000 iterations of batch size five using the original implementation.\n\nSettings:\nWe use 100 images of size 256×\\\\times256 from CelebA-HQ \\[ [21])\\] and ImageNet test sets. The resulting LPIPS and the average votes of the user study are shown in Table [1]Table 1 ‣ 5.1 Implementation Details ‣ 5 Experiments ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\"). Additionally, refer to the appendix for qualitative and quantitative results over the Places2 \\[ [56])\\] dataset.\n\nWide and Narrow masks:\nTo validate our method on the standard image inpainting scenario, we use the LaMa \\[ [40])\\] settings for Wide and Narrow masks.\nRePaint outperforms all other methods with a significance margin of 95% in both CelebA-HQ and ImageNet, for both Wide and Narrow settings.\nSee qualitative results in Figure [3]Figure 3 ‣ 4.1 Conditioning on the known Region ‣ 4 Method ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\") and [4]Figure 4 ‣ 5.2 Metrics ‣ 5 Experiments ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\") and quantitative in Table [1]Table 1 ‣ 5.1 Implementation Details ‣ 5 Experiments ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\").\nThe best autoregressive method ICT seems to have less global consistency as observed in Figure [3]Figure 3 ‣ 4.1 Conditioning on the known Region ‣ 4 Method ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\") in the second row, where the eyes do not to match well.\nIn general, the best GAN approach LaMa \\[ [40])\\] has better global consistency, yet it produces notorious checkerboard artifacts. Those observations might have influenced the users to vote for RePaint for the majority of images, in which our method generates more realistic images.\n\nThin Masks:\nSimilar to a Nearest-Neighbor Super Resolution problem, the “Super-Resolution 2×2\\\\times” mask only leaves pixels with a stride of 2 in height and width dimension, and the “Alternating Lines” mask removes the pixels every second row of an image. As seen in Figure [3]Figure 3 ‣ 4.1 Conditioning on the known Region ‣ 4 Method ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\") and [4]Figure 4 ‣ 5.2 Metrics ‣ 5 Experiments ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\"), AOT \\[ [51])\\] fails completely, while the others either produce blurry images or generate visible artifacts, or both. These observations are also confirmed by the user study, where RePaint achieves between 73.1% and 99.3% of the user votes.\n\nThick Masks:\nThe “Expand” mask only leaves a center crop of 64×64646464\\\\times 64 from a 256×256256256256\\\\times 256 image, and “Half” mask, which provides the left half of the image as input. As there is less contextual information, most of the methods struggle (see Figure [3]Figure 3 ‣ 4.1 Conditioning on the known Region ‣ 4 Method ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\") and [4]Figure 4 ‣ 5.2 Metrics ‣ 5 Experiments ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\")). Qualitatively, LaMa comes closer to ours, yet our generated images are sharper and have overall more semantic hallucination.\nNoteworthy, LaMa outperforms RePaint in therms of LPIPS on “Expand” and “Half” for both CelebA and ImageNet (Tab. [1]Table 1 ‣ 5.1 Implementation Details ‣ 5 Experiments ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\")). We argue that this behavior is due to our method being more flexible and diverse in the generation. By generating a semantically different image than that in the Ground-Truth, it makes the LPIPS an unsuitable metric for this particular solution.\n\nThe artifacts produced by the baselines can be explained by strong overfitting to the training masks. In contrast, as our method does not involve mask training, our RePaint can handle any type of mask. In the case of large-area inpainting, RePaint produces a semantically meaningful filling, while others generate artifacts or copy texture.\nFinally, RePaint is preferred by the users with confidence 95% except for the inconclusive result of ICT with “Half” masks as shown in Table [1]Table 1 ‣ 5.1 Implementation Details ‣ 5 Experiments ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\").\n\n### 5.4 Analysis of Diversity\n\nAs shown in ( [2]Equation 2 ‣ 3 Preliminaries: Denoising Diffusion Probabilistic Models ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\")), every reverse diffusion step is inherently stochastic since it incorporates new noise from a Gaussian Distribution. Moreover, as we do not directly guide the inpainted area with any loss, the model is, therefore, free to inpaint anything that semantically aligns with the training set. Figure LABEL:fig:intro illustrates the diversity and flexibility of our model.\n\n### 5.5 Class conditional Experiment\n\nThe pretrained ImageNet DDPM is capable of class-conditional generation sampling. In Figure [5]Figure 5 ‣ 5.5 Class conditional Experiment ‣ 5 Experiments ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\") we show examples for the “Expand” mask for the “Granny Smith” class, as well as other classes.\n\n![Refer to caption]\n\n|     |     |     |     |     |     |\n| --- | --- | --- | --- | --- | --- |\n| Input | Apple Samples | Head Cabbage | Broccoli | Cauliflower | Knot |\n\nFigure 5: Visual results for class guided generation on ImageNet.\n\n### 5.6 Ablation Study\n\nComparison to slowing down:  To analyze if the increased computational budget causes the improved performance of resampling, we compare it with the commonly used technique of slowing down the diffusion process as described in Section [4.2]Resampling ‣ 4 Method ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\").\nTherefore, in Figure [6]Figure 6 ‣ 5.6 Ablation Study ‣ 5 Experiments ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\") and Table [2]Table 2 ‣ 5.6 Ablation Study ‣ 5 Experiments ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\"), we show a comparison resampling and the slow down in diffusion using the same computational budget for each setting. We observe that the resampling uses the extra computational budget for harmonizing the image, whereas there is no visible improvement at slowing down the diffusion process.\n\n|  | T | r | LPIPS | T | r | LPIPS | T | r | LPIPS | T | r | LPIPS |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| Slowing down | 250 | 1 | 0.168 | 500 | 1 | 0.167 | 750 | 1 | 0.179 | 1000 | 1 | 0.161 |\n| Resampling | 250 | 1 | 0.168 | 250 | 2 | 0.148 | 250 | 3 | 0.142 | 250 | 4 | 0.134 |\n\nTable 2: Analysis of the use of computational budget. We compare slowing down the diffusion process and resampling. We use the ImageNet validation set with 32 images over the LaMa \\[ [40])\\] Wide mask setting. The number of diffusion steps is denoted by T𝑇T, and the number of resamplings by r𝑟r.\n\n|  | j=1𝑗1j=1 | j=5𝑗5j=5 | j=10𝑗10j=10 |\n| --- | --- | --- | --- |\n| r | LPIPS | Votes \\[%\\] | LPIPS | Votes \\[%\\] | LPIPS | Votes \\[%\\] |\n| --- | --- | --- | --- | --- | --- | --- |\n| 5 | 0.075 | 42.50±plus-or-minus\\\\pm7.7 | 0.072 | 46.88±plus-or-minus\\\\pm7.8 | 0.073 | 53.12±plus-or-minus\\\\pm7.8 |\n| 10 | 0.088 | 42.50±plus-or-minus\\\\pm7.7 | 0.073 | 45.62±plus-or-minus\\\\pm7.8 | 0.068 | 56.25±plus-or-minus\\\\pm7.8 |\n| 15 | 0.065 | 46.25±plus-or-minus\\\\pm7.8 | 0.063 | 53.12±plus-or-minus\\\\pm5.5 | 0.065 | 53.75±plus-or-minus\\\\pm7.8 |\n\nTable 3: Ablation Study. Analysis of length of the jumps j𝑗j and number of resamplings r𝑟r. We report LPIPS and the average user-study votes with respect to LaMa \\[ [40])\\]. We use 32 images from the CelebA validation set, and use the LaMa Wide mask setting.\n\nJumps Length:  Moreover, to ablate the jump lengths j𝑗j and the number of resampling r𝑟r, we study nine different settings in Table [3]Table 3 ‣ 5.6 Ablation Study ‣ 5 Experiments ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\"). We obtain better performance at applying the larger jump j=10𝑗10j=10 length than smaller step length steps. We observe that for jump length j=1𝑗1j=1, the DDPM is more likely to output a blurry image. Furthermore, this observation is stable across different numbers of resampling. Furthermore, the number of resamplings increases the performance.\n\n|     |\n| --- |\n| Slow-Down |\n\n![Refer to caption]\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n| Input | T=250, r=1 | T=500, r=1 | T=750, r=1 | T=1000, r=1 |\n\n|     |\n| --- |\n| Resampling |\n\n![Refer to caption]\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n| Input | T=250, r=1 | T=250, r=2 | T=250, r=3 | T=250, r=4 |\n\nFigure 6: Qualitative Analysis of the use of computational budget. RePaint produces higher visual quality with the same computational budget by resampling (bottom) compared to slowing down the diffusion process (top). The number of diffusion steps is denoted by T𝑇T and resamplings by r𝑟r.\n\nComparison to alternative sampling strategy:\nTo compare our resampling approach to SDEdit \\[ [25])\\], we first perform reverse diffusion from t=T𝑡𝑇t=T to t=T/2𝑡𝑇2t=T/2 to obtain the required initial inpainting at t=T/2𝑡𝑇2t=T/2. We then apply the resampling method from SDEdit, which repeats the reverse process from t=T/2𝑡𝑇2t=T/2 to t=0𝑡0t=0 several times.\nThe results are shown in Table [4]Table 4 ‣ 5.6 Ablation Study ‣ 5 Experiments ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\").\nOur approach achieves significantly better performance across all mask types except for one “Expand” case, where LPIPS >0.6absent0.6>0.6 is outside a meaningful range for comparisons. In case of ‘super-resolution masks’, our approach reduces the LPIPS by over 53% on all datasets, clearly demonstrating the advantage of our resampling strategy.\n\n| Dataset | Method | Wide | Narrow | Super-Res. | Alt. Lin. | Half | Expand |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| ImageNet | SDEdit \\[ [25])\\] | 0.1532 | 0.0952 | 0.3902 | 0.1852 | 0.3272 | 0.6281 |\n|  | RePaint (Ours) | 0.1341 | 0.0641 | 0.1831 | 0.0891 | 0.3041 | 0.6292 |\n| Places2 | SDEdit \\[ [25])\\] | 0.1302 | 0.0622 | 0.2712 | 0.1302 | 0.3042 | 0.6202 |\n|  | RePaint (Ours) | 0.1051 | 0.0441 | 0.0991 | 0.0511 | 0.2861 | 0.6151 |\n| CelebA-HQ | SDEdit \\[ [25])\\] | 0.0762 | 0.0462 | 0.1132 | 0.0302 | 0.1892 | 0.4492 |\n|  | RePaint (Ours) | 0.0591 | 0.0281 | 0.0291 | 0.0091 | 0.1651 | 0.4351 |\n\nTable 4: Comparison with the resampling schedule proposed in \\[ [25])\\] in terms of LPIPS. The resampling method proposed in our RePaint (Sec. 4.2) achieves substantially better results, in particular for the Super-Resolution masks.",
            "citations": null
          },
          "6 Limitations": {
            "content": "Our method produces sharp, highly detailed, and semantically meaningful images. We believe that our work opens interesting research directions for addressing the current limitations of the method. Two directions are of particular interest. First, naturally, the per-image DDPM optimization process is significantly slower than the GAN-based and Autoregressive-based counterparts. That makes it currently difficult to apply it for real-time applications. Nonetheless, DDPM is gaining in popularity, and recent publications are working on improving the efficiency \\[ [24]), [23])\\]. Secondly, for the extreme mask cases, RePaint can produce realistic images completions that are very different from the Ground Truth image. That makes the quantitative evaluation challenging for those conditions. An alternative solution is to employ the FID score \\[ [11])\\] over a test set. However, a reliable FID for inpainting is usually computed with more than 1,000 images. For current DDPM, this would result in a runtime that is not feasible for most research institutes.",
            "citations": null
          },
          "7 Potential Negative Societal Impact": {
            "content": "On the one hand, RePaint is an inpainting method that relies on an unconditional pretrained DDPM. Therefore, the algorithm might be biased towards the dataset on which it was trained. Since the model aims to generate images of the same distribution as the training set, it might reflect the same biases, such as gender, age, and ethnicity.\nOn the other hand, RePaint could be used for the anonymization of faces. For example, one could remove the information about the identity of people shown at public events and hallucinate artificial faces for data protection.",
            "citations": null
          },
          "8 Conclusions": {
            "content": "We presented a novel denoising diffusion probabilistic model solution for the image inpainting task. In detail, we developed a mask-agnostic approach that widely increases the degree of freedom of masks for the free-form inpainting. Since the novel conditioning approach of RePaint complies with the model assumptions of a DDPM, it produces a photo-realistic image regardless of the type of the mask.\n\nAcknowledgements:\nThis work was supported by the ETH Zürich Fund (OK), a Huawei Technologies Oy (Finland) project, and an Nvidia GPU grant.",
            "citations": null
          }
        },
        "abstract": "Free-form inpainting is the task of adding new content to an image in the\nregions specified by an arbitrary binary mask. Most existing approaches train\nfor a certain distribution of masks, which limits their generalization\ncapabilities to unseen mask types. Furthermore, training with pixel-wise and\nperceptual losses often leads to simple textural extensions towards the missing\nareas instead of semantically meaningful generation. In this work, we propose\nRePaint: A Denoising Diffusion Probabilistic Model (DDPM) based inpainting\napproach that is applicable to even extreme masks. We employ a pretrained\nunconditional DDPM as the generative prior. To condition the generation\nprocess, we only alter the reverse diffusion iterations by sampling the\nunmasked regions using the given image information. Since this technique does\nnot modify or condition the original DDPM network itself, the model produces\nhigh-quality and diverse output images for any inpainting form. We validate our\nmethod for both faces and general-purpose image inpainting using standard and\nextreme masks.\n  RePaint outperforms state-of-the-art Autoregressive, and GAN approaches for\nat least five out of six mask distributions.\n  Github Repository: git.io/RePaint"
      },
      "bib.bib19": {
        "id": "bib.bib19",
        "citation": "Lugmayr et al. (2022)",
        "authors": "",
        "year": "",
        "title": "Repaint: Inpainting using denoising diffusion probabilistic models, 2022.",
        "venue": "",
        "pages": "",
        "url": "https://arxiv.org/abs/2201.09865",
        "arxiv_id": "2201.09865",
        "doi": null,
        "sections": {
          "1 Introduction": {
            "content": "Image Inpainting, also known as Image Completion, aims at filling missing regions within an image.\nSuch inpainted regions need to harmonize with the rest of the image and be semantically reasonable. Inpainting approaches thus require strong generative capabilities.\nTo this end, current State-of-the-Art approaches \\[ [48]), [20]), [51]), [40])\\] rely on GANs \\[ [8])\\] or Autoregressive Modeling \\[ [33]), [42]), [49])\\].\nMoreover, inpainting methods need to handle various forms of masks such as thin or thick brushes, squares, or even extreme masks where the vast majority of the image is missing. This is highly challenging since existing approaches train with a certain mask distribution, which can lead to poor generalization to novel mask types. In this work, we investigate an alternative generative approach for inpainting, aiming to design an approach that requires no mask-specific training.\n\nDenoising Diffusion Probabilistic Models (DDPM) is an emerging alternative paradigm for generative modelling \\[ [12]), [38])\\]. Recently, Dhariwal and Nichol \\[ [7])\\] demonstrated that DDPM can even outperform the state-of-the-art GAN-based method \\[ [4])\\] for image synthesis.\nIn essence, the DDPM is trained to iteratively denoise the image by reversing a diffusion process.\nStarting from randomly sampled noise, the DDPM is then iteratively applied for a certain number of steps, which yields the final image sample.\nWhile founded in principled probabilistic modeling, DDPMs have been shown to generate diverse and high-quality images \\[ [12]), [28]), [7])\\].\n\nWe propose RePaint: an inpainting method that solely leverages an off-the-shelf unconditionally trained DDPM. Specifically, instead of learning a mask-conditional generative model, we condition the generation process by sampling from the given pixels during the reverse diffusion iterations. Remarkably, our model is therefore not trained for the inpainting task itself. This has two important advantages.\nFirst, it allows our network to generalize to any mask during inference.\nSecond, it enables our network to learn more semantic generation capabilities since it has a powerful DDPM image synthesis prior (Figure LABEL:fig:intro).\n\nAlthough the standard DDPM sampling strategy produces matching textures, the inpainting is often semantically incorrect.\nTherefore, we introduce an improved denoising strategy that resamples (RePaint) iterations to better condition the image.\nNotably, instead of slowing down the diffusion process \\[ [7])\\], our approach goes forward and backward in diffusion time, producing remarkable semantically meaningful images.\nOur approach allows the network to effectively harmonize the generated image information during the entire inference process, leading to a more effective conditioning on the given image information.\n\nWe perform experiments on CelebA-HQ \\[ [21])\\] and ImageNet \\[ [36])\\], and compare with other State-of-the-Art inpainting approaches.\nOur approach generalizes better and has overall more semantically meaningful inpainted regions.",
            "citations": null
          },
          "2 Related Work": {
            "content": "Early attempts on Image Inpainting or Image Completion exploited low-level cues within the input image \\[ [2]), [1]), [3])\\], or within the neighbor of a large image dataset \\[ [10])\\] to fill the missing region.\n\nDeterministic Image Inpainting:\nSince the introduction of GANs \\[ [8])\\], most of the existing methods follow a standard configuration, first proposed by Pathak _et al_.\\[ [32])\\], that is, using an encoder-decoder architecture as the main inpainting generator, adversarial training, and tailored losses that aim at photo-realism. Follow-up works have produced impressive results in recent years \\[ [34]), [50]), [20]), [30]), [15])\\].\n\nAs image inpainting requires a high-level semantic context, and to explicitly include it in the generation pipeline, there exist hand-crafted architectural designs such as Dilated Convolutions \\[ [16]), [45])\\] to increase the receptive field, Partial Convolutions \\[ [19])\\] and Gated Convolutions \\[ [48])\\] to guide the convolution kernel according to the inpainted mask, Contextual Attention \\[ [46])\\] to leverage on global information, Edges maps \\[ [27]), [43]), [44]), [9])\\] or Semantic Segmentation maps \\[ [14]), [31])\\] to further guide the generation, and Fourier Convolutions \\[ [40])\\] to include both global and local information efficiently. Although recent works produce photo-realistic results, GANs are well known for textural synthesis, so these methods shine on background completion or removing objects, which require repetitive structural synthesis, and struggle with semantic synthesis (Figure [4]Figure 4 ‣ 5.2 Metrics ‣ 5 Experiments ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\")).\n\nDiverse Image Inpainting:\nMost GAN-based Image Inpainting methods are prone to deterministic transformations due to the lack of control during the image synthesis. To overcome this issue, Zheng _et al_.\\[ [55])\\] and Zhao _et al_.\\[ [53])\\] propose a VAE-based network that trade-offs between diversity and reconstruction. Zhao _et al_.\\[ [54])\\], inspired by the StyleGAN2 \\[ [18])\\] modulated convolutions, introduces a co-modulation layer for the inpainting task in order to improve both diversity and reconstruction.\nA new family of auto-regressive methods \\[ [49]), [33]), [42])\\], which can handle irregular masks, has recently emerged as a powerful alternative for free-form image inpainting.\n\nUsage of Image Prior:\nIn a different direction closer to ours Richardson _et al_.\\[ [35])\\] exploits the StyleGAN \\[ [17])\\] prior to successfully inpaint missing regions.\nHowever, similar to super-resolution methods \\[ [26]), [5])\\] that leverage the StyleGAN latent space, it is to limited specific scenarios like faces.\nNoteworthy, a Ulyanov _et al_.\\[ [41])\\] showed that the structure of a non-trained generator network contains an inherent prior that can be used for inpaining and other applications.\nIn contrast to these methods, we are leveraging on the high expressiveness of a pretrained Denoising Diffusion Probabilistic Model \\[ [12])\\] (DDPM) and therefore use it as a prior for generic image inpainting. Our method generates very detailed, high-quality images for both semantically meaningful generation and texture synthesis. Moreover, our method is not trained for the image inpainting task, and instead, we take full advantage of the prior DDPM, so each image is optimized independently.\n\nImage Conditional Diffusion Models:\nThe work by Sohl-Dickstein _et al_.\\[ [38])\\] applied early diffusion models to inpainting. More recently, Song _et al_.\\[ [39])\\] develop a score-based formulation using stochastic differential equations for unconditional image generation, with an additional application to inpainting. However, both these works only show qualitative results, and do not compare with other inpainting approaches. In contrast, we aim to advance the state-of-the-art in image inpainting, and provide comprehensive comparisons with the top competing methods in literature.\n\nA different line of research is guided image synthesis with DDPM-based approaches \\[ [6]), [25])\\].\nIn the case of ILVR \\[ [6])\\], a trained diffusion model is guided using the low-frequency information from a conditional image.\nHowever, this conditioning strategy cannot be adopted for inpainting, since both high and low-frequency information is absent in the masked-out regions.\nAnother approach for image-conditional synthesis is developed by \\[ [25])\\].\nGuided generation is performed by initializing the reverse diffusion process from the guiding image at some intermediate diffusion time.\nAn iterative strategy, repeating the reverse process several times, is further adopted to improve harmonization.\nSince a guiding image is required to start the reverse process at an intermediate time step, this approach is not applicable to inpainting, where new image content needs to be generated solely conditioned on the non-masked pixels.\nFurthermore, the resampling strategy proposed in this work differs from the concurrent \\[ [25])\\].\nWe proceed through the full reverse diffusion process, starting at the end time, at each step jumping back and forth a fixed number of time steps to progressively improve generation quality.\n\nWhile we propose a method that conditions an unconditionally trained model, the concurrent work \\[ [29])\\] is based on classifier-free guidance \\[ [13])\\] for training an image-conditional diffusion model.\nAnother direction for image manipulation is image-to-image translation using diffusion models as explored in the concurrent work \\[ [37])\\].\nIt trains an image-conditional DDPM, and shows an application to inpainting.\nUnlike both these concurrent works, we leverage an unconditional DDPM and only condition through the reverse diffusion process itself. It allows our approach to effortlessly generalize to any mask shape for free-form inpainting. Moreover, we propose a sampling schedule for the reverse process, which greatly improves image quality.",
            "citations": null
          },
          "3 Preliminaries: Denoising Diffusion Probabilistic Models": {
            "content": "In this paper, we use diffusion models \\[ [38])\\] as a generative method.\nAs other generative models, the DDPM learns a distribution of images given a training set.\nThe inference process works by sampling a random noise vector xTsubscript𝑥𝑇{x\\_{T}} and gradually denoising it until it reaches a high-quality output image x0subscript𝑥0{x\\_{0}}.\nDuring training, DDPM methods define a diffusion process that transforms an image x0subscript𝑥0x\\_{0} to white Gaussian noise xT∼𝒩​(0,1)similar-tosubscript𝑥𝑇𝒩01x\\_{T}\\\\sim\\\\mathcal{N}(0,1) in T𝑇T time steps. Each step in the forward direction is given by,\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n|  | q​(xt\\|xt−1)𝑞conditionalsubscript𝑥𝑡subscript𝑥𝑡1\\\\displaystyle q(x\\_{t}\\|x\\_{t-1}) | =𝒩​(xt;1−βt​xt−1,βt​𝐈)absent𝒩subscript𝑥𝑡1subscript𝛽𝑡subscript𝑥𝑡1subscript𝛽𝑡𝐈\\\\displaystyle=\\\\mathcal{N}(x\\_{t};\\\\sqrt{1-\\\\beta\\_{t}}x\\_{t-1},\\\\beta\\_{t}\\\\mathbf{I}) |  | (1) |\n\nThe sample xtsubscript𝑥𝑡x\\_{t} is obtained by adding i.i.d. Gaussian noise with variance βtsubscript𝛽𝑡\\\\beta\\_{t} at timestep t𝑡t and scaling the previous sample xt−1subscript𝑥𝑡1x\\_{t-1} with 1−βt1subscript𝛽𝑡\\\\sqrt{1-\\\\beta\\_{t}} according to a variance schedule.\n\nThe DDPM is trained to reverse the process in ( [1]Equation 1 ‣ 3 Preliminaries: Denoising Diffusion Probabilistic Models ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\")).\nThe reverse process is modeled by a neural network that predicts the parameters μθ​(xt,t)subscript𝜇𝜃subscript𝑥𝑡𝑡\\\\mu\\_{\\\\theta}(x\\_{t},t) and Σθ​(xt,t)subscriptΣ𝜃subscript𝑥𝑡𝑡\\\\Sigma\\_{\\\\theta}(x\\_{t},t) of a Gaussian distribution,\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | pθ​(xt−1\\|xt)=𝒩​(xt−1;μθ​(xt,t),Σθ​(xt,t))subscript𝑝𝜃conditionalsubscript𝑥𝑡1subscript𝑥𝑡𝒩subscript𝑥𝑡1subscript𝜇𝜃subscript𝑥𝑡𝑡subscriptΣ𝜃subscript𝑥𝑡𝑡p\\_{\\\\theta}(x\\_{t-1}\\|x\\_{t})=\\\\mathcal{N}(x\\_{t-1};\\\\mu\\_{\\\\theta}(x\\_{t},t),\\\\Sigma\\_{\\\\theta}(x\\_{t},t)) |  | (2) |\n\nThe learning objective for the model ( [2]Equation 2 ‣ 3 Preliminaries: Denoising Diffusion Probabilistic Models ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\")) is derived by considering the variational lower bound,\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n|  | 𝔼\\[−logpθ(𝐱0)\\]≤𝔼q\\[\\\\displaystyle\\\\mathbb{E}\\\\left\\[-\\\\log p\\_{\\\\theta}(\\\\mathbf{x}\\_{0})\\\\right\\]\\\\leq\\\\mathbb{E}\\_{q}\\\\bigg{\\[} | −logpθ​(𝐱0:T)q​(𝐱1:T\\|𝐱0)\\]\\\\displaystyle-\\\\log\\\\frac{p\\_{\\\\theta}(\\\\mathbf{x}\\_{0:T})}{q(\\\\mathbf{x}\\_{1:T}\\|\\\\mathbf{x}\\_{0})}\\\\bigg{\\]} |  | (3) |\n|  | =𝔼q\\[−logp(𝐱T)\\\\displaystyle=\\\\mathbb{E}\\_{q}\\\\bigg{\\[}-\\\\log p(\\\\mathbf{x}\\_{T}) | −∑t≥1logpθ​(𝐱t−1\\|𝐱t)q​(𝐱t\\|𝐱t−1)\\]=L\\\\displaystyle-\\\\sum\\_{t\\\\geq 1}\\\\log\\\\frac{p\\_{\\\\theta}(\\\\mathbf{x}\\_{t-1}\\|\\\\mathbf{x}\\_{t})}{q(\\\\mathbf{x}\\_{t}\\|\\\\mathbf{x}\\_{t-1})}\\\\bigg{\\]}=L |  |\n\nAs extended by Ho _et al_.\\[ [12])\\], this loss can be further decomposed as,\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n|  |  | 𝔼q\\[DKL​(q​(𝐱T\\|𝐱0)∥p​(𝐱T))⏟LT\\\\displaystyle\\\\mathbb{E}\\_{q}\\\\bigg{\\[}\\\\underbrace{D\\_{\\\\mathrm{KL}}\\\\!\\\\left(q(\\\\mathbf{x}\\_{T}\\|\\\\mathbf{x}\\_{0})~{}\\\\\\|~{}p(\\\\mathbf{x}\\_{T})\\\\right)}\\_{L\\_{T}} |  | (4) |\\\n|  |  | +∑t>1DKL(q(𝐱t−1\\|𝐱t,𝐱0)∥pθ(𝐱t−1\\|𝐱t))⏟Lt−1−log⁡pθ​(𝐱0\\|𝐱1)⏟L0\\]\\\\displaystyle+\\\\sum\\_{t>1}\\\\underbrace{D\\_{\\\\mathrm{KL}}\\\\!\\\\left(q(\\\\mathbf{x}\\_{t-1}\\|\\\\mathbf{x}\\_{t},\\\\mathbf{x}\\_{0})~{}\\\\\\|~{}p\\_{\\\\theta}(\\\\mathbf{x}\\_{t-1}\\|\\\\mathbf{x}\\_{t})\\\\right)}\\_{L\\_{t-1}}\\\\underbrace{-\\\\log p\\_{\\\\theta}(\\\\mathbf{x}\\_{0}\\|\\\\mathbf{x}\\_{1})}\\_{L\\_{0}}\\\\bigg{\\]} |  |\n\nImportantly the term Lt−1subscript𝐿𝑡1L\\_{t-1} trains the network ( [2]Equation 2 ‣ 3 Preliminaries: Denoising Diffusion Probabilistic Models ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\")) to perform one reverse diffusion step. Furthermore, it allows for a closed from expression of the objective since q​(𝐱t−1\\|𝐱t,𝐱0)𝑞conditionalsubscript𝐱𝑡1subscript𝐱𝑡subscript𝐱0q(\\\\mathbf{x}\\_{t-1}\\|\\\\mathbf{x}\\_{t},\\\\mathbf{x}\\_{0}) is also Gaussian \\[ [12])\\].\n\nAs reported by Ho _et al_.\\[ [12])\\], the best way to parametrize the model is to predict the cumulative noise ϵ0subscriptitalic-ϵ0\\\\epsilon\\_{0} that is added to the current intermediate image xtsubscript𝑥𝑡x\\_{t}. Thus, we obtain the following parametrization of the predicted mean μθ​(xt,t)subscript𝜇𝜃subscript𝑥𝑡𝑡\\\\mu\\_{\\\\theta}(x\\_{t},t),\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | μθ​(xt,t)=1αt​(xt−βt1−α¯t​ϵθ​(xt,t))subscript𝜇𝜃subscript𝑥𝑡𝑡1subscript𝛼𝑡subscript𝑥𝑡subscript𝛽𝑡1subscript¯𝛼𝑡subscriptitalic-ϵ𝜃subscript𝑥𝑡𝑡\\\\mu\\_{\\\\theta}(x\\_{t},t)=\\\\frac{1}{\\\\sqrt{\\\\alpha\\_{t}}}\\\\left(x\\_{t}-\\\\frac{\\\\beta\\_{t}}{\\\\sqrt{1-\\\\bar{\\\\alpha}\\_{t}}}\\\\epsilon\\_{\\\\theta}(x\\_{t},t)\\\\right) |  | (5) |\n\nFrom Lt−1subscript𝐿𝑡1L\\_{t-1} in ( [4]Equation 4 ‣ 3 Preliminaries: Denoising Diffusion Probabilistic Models ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\")), the following simplified training objective is derived by Ho _et al_.\\[ [12])\\],\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | Lsimple=Et,x0,ϵ​\\[‖ϵ−ϵθ​(xt,t)‖2\\]subscript𝐿simplesubscript𝐸𝑡subscript𝑥0italic-ϵdelimited-\\[\\]superscriptnormitalic-ϵsubscriptitalic-ϵ𝜃subscript𝑥𝑡𝑡2L\\_{\\\\text{simple}}=E\\_{t,x\\_{0},\\\\epsilon}\\\\left\\[\\|\\|\\\\epsilon-\\\\epsilon\\_{\\\\theta}(x\\_{t},t)\\|\\|^{2}\\\\right\\] |  | (6) |\n\nAs introduced by Nichol and Dhariwal \\[ [28])\\], learning the variance Σθ​(xt,t)subscriptΣ𝜃subscript𝑥𝑡𝑡\\\\Sigma\\_{\\\\theta}(x\\_{t},t) in ( [2]Equation 2 ‣ 3 Preliminaries: Denoising Diffusion Probabilistic Models ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\")) of the reverse process helps to reduce the number of sampling steps by an order of magnitude. They, therefore, add the variational lower bound loss.\nSpecifically, we base our training and inference approach on the recent work \\[ [7])\\], which further reduced the inference time by factor four.\n\nTo train the DDPM, we need a sample xtsubscript𝑥𝑡x\\_{t} and corresponding noise that is used to transform x0subscript𝑥0x\\_{0} to xtsubscript𝑥𝑡x\\_{t}.\nBy using the independence property of the noise added at each step ( [1]Equation 1 ‣ 3 Preliminaries: Denoising Diffusion Probabilistic Models ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\")), we can calculate the total noise variance as αt¯=∏s=1t(1−βs)¯subscript𝛼𝑡superscriptsubscriptproduct𝑠1𝑡1subscript𝛽𝑠\\\\bar{\\\\alpha\\_{t}}=\\\\prod\\_{s=1}^{t}(1-\\\\beta\\_{s}). We can thus rewrite ( [1]Equation 1 ‣ 3 Preliminaries: Denoising Diffusion Probabilistic Models ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\")), as a single step,\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n|  | q​(xt\\|x0)𝑞conditionalsubscript𝑥𝑡subscript𝑥0\\\\displaystyle q(x\\_{t}\\|x\\_{0}) | =𝒩​(xt;α¯t​x0,(1−α¯t)​𝐈)absent𝒩subscript𝑥𝑡subscript¯𝛼𝑡subscript𝑥01subscript¯𝛼𝑡𝐈\\\\displaystyle=\\\\mathcal{N}(x\\_{t};\\\\sqrt{\\\\bar{\\\\alpha}\\_{t}}x\\_{0},(1-\\\\bar{\\\\alpha}\\_{t})\\\\mathbf{I}) |  | (7) |\n\nIt allows us to efficiently sample pairs of training data to train a reverse transition step.\n\n![Refer to caption]Figure 1: Overview of our approach. RePaint modifies the standard denoising process in order to condition on the given image content. In each step, we sample the known region (top) from the input and the inpainted part from the DDPM output (bottom).",
            "citations": null
          },
          "4 Method": {
            "content": "In this section, we first present our approach for conditioning the reverse diffusion process of an unconditional DDPM for image inpainting in Section [4.1]Conditioning on the known Region ‣ 4 Method ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\"). Then, we introduce an approach to improve the reverse process itself for inpainting in Section [4.2]Resampling ‣ 4 Method ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\").\n\n![Refer to caption]\n\n|     |     |     |     |     |     |     |     |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| Input | n = 1 | n = 2 | n = 3 | n = 4 | n = 5 | n = 10 | n = 20 |\n\nFigure 2: The effect of applying n𝑛n sampling steps. The first example with n=1𝑛1n=1 is the DDPM baseline, the second with n=2𝑛2n=2 is with one resample step. More resampling steps lead to more harmonized images. The benefit saturates at about n=10𝑛10n=10 resamplings.\n\n### 4.1 Conditioning on the known Region\n\nThe goal of inpainting is to predict missing pixels of an image using a mask region as a condition. In the remaining of the paper, we consider a trained unconditional denoising diffusion probabilistic model ( [2]Equation 2 ‣ 3 Preliminaries: Denoising Diffusion Probabilistic Models ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\")). We denote the ground truth image as x𝑥x, the unknown pixels as m⊙xdirect-product𝑚𝑥m\\\\odot x and the known pixels as (1−m)⊙xdirect-product1𝑚𝑥(1-m)\\\\odot x.\n\nAlgorithm 1 Inpainting using our RePaint approach.\n\n1:xT∼𝒩​(𝟎,𝐈)similar-tosubscript𝑥𝑇𝒩0𝐈x\\_{T}\\\\sim\\\\mathcal{N}(\\\\mathbf{0},\\\\mathbf{I})\n\n2:fort=T,…,1𝑡𝑇…1t=T,\\\\dotsc,1do\n\n3:foru=1,…,U𝑢1…𝑈u=1,\\\\dotsc,Udo\n\n4:ϵ∼𝒩​(𝟎,𝐈)similar-toitalic-ϵ𝒩0𝐈\\\\epsilon\\\\sim\\\\mathcal{N}(\\\\mathbf{0},\\\\mathbf{I}) if t>1𝑡1t>1, else ϵ=𝟎italic-ϵ0\\\\epsilon=\\\\mathbf{0}\n\n5:xt−1known=α¯t​x0+(1−α¯t)​ϵsuperscriptsubscript𝑥𝑡1knownsubscript¯𝛼𝑡subscript𝑥01subscript¯𝛼𝑡italic-ϵx\\_{t-1}^{\\\\text{known}}=\\\\sqrt{\\\\bar{\\\\alpha}\\_{t}}x\\_{0}+(1-\\\\bar{\\\\alpha}\\_{t})\\\\epsilon\n\n6:z∼𝒩​(𝟎,𝐈)similar-to𝑧𝒩0𝐈z\\\\sim\\\\mathcal{N}(\\\\mathbf{0},\\\\mathbf{I}) if t>1𝑡1t>1, else 𝐳=𝟎𝐳0\\\\mathbf{z}=\\\\mathbf{0}\n\n7:xt−1unknown=1αt​(xt−βt1−α¯t​ϵθ​(xt,t))+σt​zsuperscriptsubscript𝑥𝑡1unknown1subscript𝛼𝑡subscript𝑥𝑡subscript𝛽𝑡1subscript¯𝛼𝑡subscriptbold-italic-ϵ𝜃subscript𝑥𝑡𝑡subscript𝜎𝑡𝑧x\\_{t-1}^{\\\\text{unknown}}=\\\\frac{1}{\\\\sqrt{\\\\alpha\\_{t}}}\\\\left(x\\_{t}-\\\\frac{\\\\beta\\_{t}}{\\\\sqrt{1-\\\\bar{\\\\alpha}\\_{t}}}{\\\\boldsymbol{\\\\epsilon}}\\_{\\\\theta}(x\\_{t},t)\\\\right)+\\\\sigma\\_{t}z\n\n8:xt−1=m⊙xt−1known+(1−m)⊙xt−1unknownsubscript𝑥𝑡1direct-product𝑚superscriptsubscript𝑥𝑡1knowndirect-product1𝑚superscriptsubscript𝑥𝑡1unknownx\\_{t-1}=m\\\\odot x\\_{t-1}^{\\\\text{known}}+(1-m)\\\\odot x\\_{t-1}^{\\\\text{unknown}}\n\n9:ifu​<U​and​t>​1𝑢expectation𝑈and𝑡1u<U~{}\\\\text{and}~{}t>1then\n\n10:xt∼𝒩​(1−βt−1​xt−1,βt−1​𝐈)similar-tosubscript𝑥𝑡𝒩1subscript𝛽𝑡1subscript𝑥𝑡1subscript𝛽𝑡1𝐈x\\_{t}\\\\sim\\\\mathcal{N}(\\\\sqrt{1-\\\\beta\\_{t-1}}x\\_{t-1},\\\\beta\\_{t-1}\\\\mathbf{I})\n\n11:endif\n\n12:endfor\n\n13:endfor\n\n14:returnx0subscript𝑥0x\\_{0}\n\nSince every reverse step ( [2]Equation 2 ‣ 3 Preliminaries: Denoising Diffusion Probabilistic Models ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\")) from xtsubscript𝑥𝑡x\\_{t} to xt−1subscript𝑥𝑡1x\\_{t-1} depends solely on xtsubscript𝑥𝑡x\\_{t}, we can alter the known regions (1−m)⊙xtdirect-product1𝑚subscript𝑥𝑡(1-m)\\\\odot x\\_{t} as long as we keep the correct properties of the corresponding distribution.\nSince the forward process is defined by a Markov Chain ( [1]Equation 1 ‣ 3 Preliminaries: Denoising Diffusion Probabilistic Models ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\")) of added Gaussian noise, we can sample the intermediate image xtsubscript𝑥𝑡x\\_{t} at any point in time using ( [7]Equation 7 ‣ 3 Preliminaries: Denoising Diffusion Probabilistic Models ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\")). This allows us to sample the know regions m⊙xtdirect-product𝑚subscript𝑥𝑡m\\\\odot x\\_{t} at any time step t𝑡t. Thus, using ( [2]Equation 2 ‣ 3 Preliminaries: Denoising Diffusion Probabilistic Models ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\")) for the unknown region and ( [7]Equation 7 ‣ 3 Preliminaries: Denoising Diffusion Probabilistic Models ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\")) for the known regions, we achieve the following expression for one reverse step in our approach,\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n|  |\n|  | xt−1knownsuperscriptsubscript𝑥𝑡1known\\\\displaystyle x\\_{t-1}^{\\\\text{known}} | ∼𝒩​(α¯t​x0,(1−α¯t)​𝐈)similar-toabsent𝒩subscript¯𝛼𝑡subscript𝑥01subscript¯𝛼𝑡𝐈\\\\displaystyle\\\\sim\\\\mathcal{N}(\\\\sqrt{\\\\bar{\\\\alpha}\\_{t}}x\\_{0},(1-\\\\bar{\\\\alpha}\\_{t})\\\\mathbf{I}) |  | (8a) |\n|  | xt−1unknownsuperscriptsubscript𝑥𝑡1unknown\\\\displaystyle x\\_{t-1}^{\\\\text{unknown}} | ∼𝒩​(μθ​(xt,t),Σθ​(xt,t))similar-toabsent𝒩subscript𝜇𝜃subscript𝑥𝑡𝑡subscriptΣ𝜃subscript𝑥𝑡𝑡\\\\displaystyle\\\\sim\\\\mathcal{N}(\\\\mu\\_{\\\\theta}(x\\_{t},t),\\\\Sigma\\_{\\\\theta}(x\\_{t},t)) |  | (8b) |\n|  | xt−1subscript𝑥𝑡1\\\\displaystyle x\\_{t-1} | =m⊙xt−1known+(1−m)⊙xt−1unknownabsentdirect-product𝑚superscriptsubscript𝑥𝑡1knowndirect-product1𝑚superscriptsubscript𝑥𝑡1unknown\\\\displaystyle=m\\\\odot x\\_{t-1}^{\\\\text{known}}+(1-m)\\\\odot x\\_{t-1}^{\\\\text{unknown}} |  | (8c) |\n\nThus, xt−1knownsuperscriptsubscript𝑥𝑡1knownx\\_{t-1}^{\\\\text{known}} is sampled using the known pixels in the given image m⊙x0direct-product𝑚subscript𝑥0m\\\\odot x\\_{0}, while xt−1unknownsuperscriptsubscript𝑥𝑡1unknownx\\_{t-1}^{\\\\text{unknown}} is sampled from the model, given the previous iteration xtsubscript𝑥𝑡x\\_{t}. These are then combined to the new sample xt−1subscript𝑥𝑡1x\\_{t-1} using the mask. Our approach is illustrated in Figure [1]Figure 1 ‣ 3 Preliminaries: Denoising Diffusion Probabilistic Models ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\").\n\n|     |     |     |     |     |     |\n| --- | --- | --- | --- | --- | --- |\n| Half | Expand | Alt. Lines | SR 2×2\\\\times | Narrow | Wide |\n\n![Refer to caption]![Refer to caption]![Refer to caption]![Refer to caption]![Refer to caption]![Refer to caption]\n\n|     |     |     |     |     |     |     |\n| --- | --- | --- | --- | --- | --- | --- |\n| Input | AOT \\[ [51])\\] | DSI \\[ [33])\\] | ICT \\[ [42])\\] | Deep Fill v2 \\[ [47])\\] | LaMa \\[ [40])\\] | RePaint (ours) |\n\nFigure 3: CelebA-HQ Qualitative Results. Comparison against the state-of-the-art methods for Face Inpainting over several mask settings. Zoom-in for better details.\n\n### 4.2 Resampling\n\nWhen directly applying the method described in Section [4.1]Conditioning on the known Region ‣ 4 Method ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\"), we observe that only the content type matches with the known regions.\nFor example, in Figure [2]Figure 2 ‣ 4 Method ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\") n=1𝑛1n=1, the inpainted area is a furry texture matching the hair of the dog. Although the inpainted region matches the texture of the neighboring region, it is semantically incorrect. Therefore, the DDPM is leveraging on the context of the known region, yet it is not harmonizing it well with the rest of the image. Next, we discuss possible reasons for this behavior.\n\nFrom Figure [1]Figure 1 ‣ 3 Preliminaries: Denoising Diffusion Probabilistic Models ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\"), we analyze how the method is conditioning the known regions.\nAs shown in ( [8]Equation 8 ‣ 4.1 Conditioning on the known Region ‣ 4 Method ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\")), the model predicts xt−1subscript𝑥𝑡1x\\_{t-1} using xtsubscript𝑥𝑡x\\_{t}, which comprises the output of the DDPM ( [2]Equation 2 ‣ 3 Preliminaries: Denoising Diffusion Probabilistic Models ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\")) and the sample from the known region.\nHowever, the sampling of the known pixels using ( [7]Equation 7 ‣ 3 Preliminaries: Denoising Diffusion Probabilistic Models ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\")) is performed without considering the generated parts of the image, which introduces disharmony.\nAlthough the model tries to harmonize the image again in every step, it can never fully converge because the same issue occurs in the next step.\nMoreover, in each reverse step, the maximum change to an image declines due to the variance schedule of βtsubscript𝛽𝑡\\\\beta\\_{t}.\nThus, the method cannot correct mistakes that lead to disharmonious boundaries in the subsequent steps due to restricted flexibility.\nAs a consequence, the model needs more time to harmonize the conditional information xt−1knownsuperscriptsubscript𝑥𝑡1knownx\\_{t-1}^{\\\\text{known}} with the generated information xt−1unknownsuperscriptsubscript𝑥𝑡1unknownx\\_{t-1}^{\\\\text{unknown}} in one step before advancing to the next denoising step.\n\nSince the DDPM is trained to generate an image that lies within a data distribution, it naturally aims at producing consistent structures.\nIn our resampling approach, we use this DDPM property to harmonize the input of the model.\nConsequently, we diffuse the output xt−1subscript𝑥𝑡1x\\_{t-1} back to xtsubscript𝑥𝑡x\\_{t} by sampling from ( [1]Equation 1 ‣ 3 Preliminaries: Denoising Diffusion Probabilistic Models ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\")) as xt∼𝒩​(1−βt​xt−1,βt​𝐈)similar-tosubscript𝑥𝑡𝒩1subscript𝛽𝑡subscript𝑥𝑡1subscript𝛽𝑡𝐈x\\_{t}\\\\sim\\\\mathcal{N}(\\\\sqrt{1-\\\\beta\\_{t}}x\\_{t-1},\\\\beta\\_{t}\\\\mathbf{I}).\nAlthough this operation scales back the output and adds noise, some information incorporated in the generated region xt−1unknownsuperscriptsubscript𝑥𝑡1unknownx\\_{t-1}^{\\\\text{unknown}} is still preserved in xtunknownsuperscriptsubscript𝑥𝑡unknownx\\_{t}^{\\\\text{unknown}}. It leads to a new xtunknownsuperscriptsubscript𝑥𝑡unknownx\\_{t}^{\\\\text{unknown}} which is both more harmonized with xt𝚔𝚗𝚘𝚠𝚗superscriptsubscript𝑥𝑡𝚔𝚗𝚘𝚠𝚗x\\_{t}^{\\\\mathtt{known}} and contains conditional information from it.\n\nSince this operation can only harmonize one step, it might not be able to incorporate the semantic information over the entire denoising process.\nTo overcome this problem, we denote the time horizon of this operation as jump length, which is j=1𝑗1j=1 for the previous case.\nSimilar to the standard change in diffusion speed \\[ [7])\\] (a.k.a. slowing down), the resampling also increases the runtime of the reverse diffusion.\nSlowing down applies smaller but more resampling steps by reducing the added variance in each denoising step.\nHowever, that is a fundamentally different approach because slowing down the diffusion still has the problem of not harmonizing the image, as described in our resampling strategy. We empirically demonstrate this advantage of our approach in Sec. [5.6]Ablation Study ‣ 5 Experiments ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\").",
            "citations": null
          },
          "5 Experiments": {
            "content": "We perform extensive experiments for face and generic inpainting, compare to the state-of-the-art solutions, and conduct an ablative analysis. In Section [5.3]Comparison with State-of-the-Art ‣ 5 Experiments ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\") and [5.4]Analysis of Diversity ‣ 5 Experiments ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\"), we report a detailed discussion of mask robustness and diversity, respectively. We also report with additional results, analysis, and visuals in the appendix.\n\n### 5.1 Implementation Details\n\nWe validate our solution over the CelebA-HQ \\[ [21])\\], and Imagenet \\[ [36])\\] datasets. As our method relies on a pretrained guided diffusion model \\[ [7])\\], we use the provided ImageNet model. For CelebA-HQ, we follow the same training hyper-parameters as for ImageNet. We use 256×256256256256\\\\times 256 crops in three batches on 4×\\\\timesV100 GPUs each.\nIn contrast to the pretrained ImageNet model, the CelebA-HQ one is only trained for 250,000 iterations during roughly five days. Note that all our qualitative and quantitative results in the main paper are for 256 image size.\n\n| CelebA-HQ | Wide | Narrow | Super-Resolve 2×2\\\\times | Altern. Lines | Half | Expand |\n| --- | --- | --- | --- | --- | --- | --- |\n| Methods | LPIPS↓↓\\\\downarrow | Votes \\[%\\] | LPIPS↓↓\\\\downarrow | Votes \\[%\\] | LPIPS↓↓\\\\downarrow | Votes \\[%\\] | LPIPS↓↓\\\\downarrow | Votes \\[%\\] | LPIPS↓↓\\\\downarrow | Votes \\[%\\] | LPIPS↓↓\\\\downarrow | Votes \\[%\\] |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| AOT \\[ [51])\\] | 0.104 | 11.6±2.0plus-or-minus11.62.011.6\\\\pm 2.0 | 0.047 | 12.8±2.1plus-or-minus12.82.112.8\\\\pm 2.1 | 0.714 | 1.1±0.6plus-or-minus1.10.61.1\\\\pm 0.6 | 0.667 | 2.4±1.0plus-or-minus2.41.02.4\\\\pm 1.0 | 0.287 | 9.0±1.8plus-or-minus9.01.89.0\\\\pm 1.8 | 0.604 | 8.3±1.7plus-or-minus8.31.78.3\\\\pm 1.7 |\n| DSI \\[ [33])\\] | 0.067 | 16.0±2.3plus-or-minus16.02.316.0\\\\pm 2.3 | 0.038 | 22.3±2.6plus-or-minus22.32.622.3\\\\pm 2.6 | 0.128 | 5.5±1.4plus-or-minus5.51.45.5\\\\pm 1.4 | 0.049 | 5.1±1.4plus-or-minus5.11.45.1\\\\pm 1.4 | 0.211 | 4.5±1.3plus-or-minus4.51.34.5\\\\pm 1.3 | 0.487 | 4.7±1.3plus-or-minus4.71.34.7\\\\pm 1.3 |\n| ICT \\[ [42])\\] | 0.063 | 27.6±2.8plus-or-minus27.62.827.6\\\\pm 2.8 | 0.036 | 30.9±2.9plus-or-minus30.92.930.9\\\\pm 2.9 | 0.483 | 4.2±1.2plus-or-minus4.21.24.2\\\\pm 1.2 | 0.353 | 0.7±0.5plus-or-minus0.70.50.7\\\\pm 0.5 | 0.166 | 12.7±2.1plus-or-minus12.72.112.7\\\\pm 2.1 | 0.432 | 8.8±1.8plus-or-minus8.81.88.8\\\\pm 1.8 |\n| DeepFillv2 \\[ [47])\\] | 0.066 | 23.9±2.6plus-or-minus23.92.623.9\\\\pm 2.6 | 0.049 | 21.0±2.5plus-or-minus21.02.521.0\\\\pm 2.5 | 0.119 | 9.8±1.8plus-or-minus9.81.89.8\\\\pm 1.8 | 0.049 | 10.6±1.9plus-or-minus10.61.910.6\\\\pm 1.9 | 0.209 | 4.1±1.2plus-or-minus4.11.24.1\\\\pm 1.2 | 0.467 | 13.1±2.1plus-or-minus13.12.113.1\\\\pm 2.1 |\n| LaMa \\[ [40])\\] | 0.045 | 41.8±3.1plus-or-minus41.83.141.8\\\\pm 3.1 | 0.028 | 33.8±3.0plus-or-minus33.83.033.8\\\\pm 3.0 | 0.177 | 5.5±1.4plus-or-minus5.51.45.5\\\\pm 1.4 | 0.083 | 20.6±2.5plus-or-minus20.62.520.6\\\\pm 2.5 | 0.138 | 35.6±3.0plus-or-minus35.63.035.6\\\\pm 3.0 | 0.342 | 24.7±2.7plus-or-minus24.72.724.7\\\\pm 2.7 |\n| RePaint | 0.059 | Reference | 0.028 | Reference | 0.029 | Reference | 0.009 | Reference | 0.165 | Reference | 0.435 | Reference |\n\n| ImageNet | Wide | Narrow | Super-Resolve 2×2\\\\times | Altern. Lines | Half | Expand |\n| --- | --- | --- | --- | --- | --- | --- |\n| Methods | LPIPS↓↓\\\\downarrow | Votes \\[%\\] | LPIPS↓↓\\\\downarrow | Votes \\[%\\] | LPIPS↓↓\\\\downarrow | Votes \\[%\\] | LPIPS↓↓\\\\downarrow | Votes \\[%\\] | LPIPS↓↓\\\\downarrow | Votes \\[%\\] | LPIPS↓↓\\\\downarrow | Votes \\[%\\] |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| DSI \\[ [33])\\] | 0.117 | 31.7±2.9plus-or-minus31.72.931.7\\\\pm 2.9 | 0.072 | 28.6±2.8plus-or-minus28.62.828.6\\\\pm 2.8 | 0.153 | 26.9±2.8plus-or-minus26.92.826.9\\\\pm 2.8 | 0.069 | 23.6±2.6plus-or-minus23.62.623.6\\\\pm 2.6 | 0.283 | 31.4±2.9plus-or-minus31.42.931.4\\\\pm 2.9 | 0.583 | 9.2±1.8plus-or-minus9.21.89.2\\\\pm 1.8 |\n| ICT \\[ [42])\\] | 0.107 | 42.9±3.1plus-or-minus42.93.142.9\\\\pm 3.1 | 0.073 | 33.0±2.9plus-or-minus33.02.933.0\\\\pm 2.9 | 0.708 | 1.1±0.6plus-or-minus1.10.61.1\\\\pm 0.6 | 0.620 | 6.6±1.5plus-or-minus6.61.56.6\\\\pm 1.5 | 0.255 | 51.5±3.1plus-or-minus51.53.151.5\\\\pm 3.1 | 0.544 | 25.6±2.7plus-or-minus25.62.725.6\\\\pm 2.7 |\n| LaMa \\[ [40])\\] | 0.105 | 42.4±3.1plus-or-minus42.43.142.4\\\\pm 3.1 | 0.061 | 33.6±2.9plus-or-minus33.62.933.6\\\\pm 2.9 | 0.272 | 13.0±2.1plus-or-minus13.02.113.0\\\\pm 2.1 | 0.121 | 9.6±1.8plus-or-minus9.61.89.6\\\\pm 1.8 | 0.254 | 41.1±3.1plus-or-minus41.13.141.1\\\\pm 3.1 | 0.534 | 20.3±2.5plus-or-minus20.32.520.3\\\\pm 2.5 |\n| RePaint | 0.134 | Reference | 0.064 | Reference | 0.183 | Reference | 0.089 | Reference | 0.304 | Reference | 0.629 | Reference |\n\nTable 1: CelebA-HQ (top) and ImageNet (bottom) Quantitative Results. Comparison against the state-of-the-art methods. We compute the LPIPS (lower is better) and Votes for six different mask settings. Votes refers to the ratio of votes with respect to ours.\n\nFor our final approach, we use T=250𝑇250T=250 timesteps, and applied r=10𝑟10r=10 times resampling with jumpy size j=10𝑗10j=10.\n\n### 5.2 Metrics\n\nWe compare our RePaint with the baseline methods in a user study described as follows. The user is shown the input image with the blanked missing regions.\nNext to this image, we display two different inpainting solutions.\nThe user is asked to select “Which image looks more realistic?”.\nThe user thus evaluates the realism of our RePaint to the result of a baseline.\nTo avoid biasing the user towards an approach, the methods were anonymized shown in a different random order for each image.\nMoreover, each user was asked every question twice and could only submit their answer if they were consistent with themselves in at least 75% of their answer. A self-consistency in 100% of the cases is often not possible since, for example, the LaMa method can have a very similar quality to RePaint on the mask settings they provide.\nOur user study evaluates all 100 test images of the test datasets CelebA-HQ and ImageNet for the following masks: Wide, Narrow, Every Second Line, Half Image, Expand, and Super-Resolve.\nWe use the answers of five different humans for every image query, resulting in 1000 votes per method-to-method comparison in each dataset and mask setting, and show the 95% confidence interval next to the mean votes.\nIn addition to the user study, we report the commonly reported perceptual metric LPIPS \\[ [52])\\], which is a learned distance metric based on the deep feature space of AlexNet. We compute the LPIPS over the same 100 test images used in the user study. The results are shown in Table [1]Table 1 ‣ 5.1 Implementation Details ‣ 5 Experiments ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\"). Furthermore, please refer to the appendix for additional quantitative results.\n\n![Refer to caption]![Refer to caption]![Refer to caption]![Refer to caption]![Refer to caption]![Refer to caption]\n\n|     |     |     |     |     |     |\n| --- | --- | --- | --- | --- | --- |\n| Half | Expand | Altern. Lines | SR 2×2\\\\times | Thin | Thick |\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n| Input | DSI \\[ [33])\\] | ICT \\[ [42])\\] | LaMa \\[ [40])\\] | RePaint (ours) |\n\nFigure 4: ImageNet Qualitative Results. Comparison against the state-of-the-art methods for pluralistic inpainting methods over different mask settings. Zoom-in for better details.\n\n### 5.3 Comparison with State-of-the-Art\n\nIn this section, we first compare our approach against state-of-the-art on standard mask distributions, commonly employed for benchmarking. We then analyze the generalization capabilities of our method against other approaches. To this end, we evaluate their robustness under four challenging mask settings. Firstly, two different masks that probe if the methods can incorporate information from thin structures. Secondly, two masks that require to inpaint a large connected area of the image. All quantitative results are reported in Table [1]Table 1 ‣ 5.1 Implementation Details ‣ 5 Experiments ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\") and visual results in Figure [3]Figure 3 ‣ 4.1 Conditioning on the known Region ‣ 4 Method ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\") and [4]Figure 4 ‣ 5.2 Metrics ‣ 5 Experiments ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\").\n\nMethods:\nWe compare our approach against several state-of-the-art autoregressive-based or GAN-based approaches. The autoregressive methods are DSI \\[ [33])\\] and ICT \\[ [42])\\], and the GAN methods are DeepFillv2 \\[ [47])\\], AOT \\[ [51])\\], and LaMa \\[ [40])\\].\nWe use their publicly available pretrained models.\nWe used the existing FFHQ \\[ [17])\\] pretrained model of ICT for our CelebA-HQ testing. As LaMa does not provide ImageNet models, we trained their system for 300,000 iterations of batch size five using the original implementation.\n\nSettings:\nWe use 100 images of size 256×\\\\times256 from CelebA-HQ \\[ [21])\\] and ImageNet test sets. The resulting LPIPS and the average votes of the user study are shown in Table [1]Table 1 ‣ 5.1 Implementation Details ‣ 5 Experiments ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\"). Additionally, refer to the appendix for qualitative and quantitative results over the Places2 \\[ [56])\\] dataset.\n\nWide and Narrow masks:\nTo validate our method on the standard image inpainting scenario, we use the LaMa \\[ [40])\\] settings for Wide and Narrow masks.\nRePaint outperforms all other methods with a significance margin of 95% in both CelebA-HQ and ImageNet, for both Wide and Narrow settings.\nSee qualitative results in Figure [3]Figure 3 ‣ 4.1 Conditioning on the known Region ‣ 4 Method ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\") and [4]Figure 4 ‣ 5.2 Metrics ‣ 5 Experiments ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\") and quantitative in Table [1]Table 1 ‣ 5.1 Implementation Details ‣ 5 Experiments ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\").\nThe best autoregressive method ICT seems to have less global consistency as observed in Figure [3]Figure 3 ‣ 4.1 Conditioning on the known Region ‣ 4 Method ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\") in the second row, where the eyes do not to match well.\nIn general, the best GAN approach LaMa \\[ [40])\\] has better global consistency, yet it produces notorious checkerboard artifacts. Those observations might have influenced the users to vote for RePaint for the majority of images, in which our method generates more realistic images.\n\nThin Masks:\nSimilar to a Nearest-Neighbor Super Resolution problem, the “Super-Resolution 2×2\\\\times” mask only leaves pixels with a stride of 2 in height and width dimension, and the “Alternating Lines” mask removes the pixels every second row of an image. As seen in Figure [3]Figure 3 ‣ 4.1 Conditioning on the known Region ‣ 4 Method ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\") and [4]Figure 4 ‣ 5.2 Metrics ‣ 5 Experiments ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\"), AOT \\[ [51])\\] fails completely, while the others either produce blurry images or generate visible artifacts, or both. These observations are also confirmed by the user study, where RePaint achieves between 73.1% and 99.3% of the user votes.\n\nThick Masks:\nThe “Expand” mask only leaves a center crop of 64×64646464\\\\times 64 from a 256×256256256256\\\\times 256 image, and “Half” mask, which provides the left half of the image as input. As there is less contextual information, most of the methods struggle (see Figure [3]Figure 3 ‣ 4.1 Conditioning on the known Region ‣ 4 Method ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\") and [4]Figure 4 ‣ 5.2 Metrics ‣ 5 Experiments ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\")). Qualitatively, LaMa comes closer to ours, yet our generated images are sharper and have overall more semantic hallucination.\nNoteworthy, LaMa outperforms RePaint in therms of LPIPS on “Expand” and “Half” for both CelebA and ImageNet (Tab. [1]Table 1 ‣ 5.1 Implementation Details ‣ 5 Experiments ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\")). We argue that this behavior is due to our method being more flexible and diverse in the generation. By generating a semantically different image than that in the Ground-Truth, it makes the LPIPS an unsuitable metric for this particular solution.\n\nThe artifacts produced by the baselines can be explained by strong overfitting to the training masks. In contrast, as our method does not involve mask training, our RePaint can handle any type of mask. In the case of large-area inpainting, RePaint produces a semantically meaningful filling, while others generate artifacts or copy texture.\nFinally, RePaint is preferred by the users with confidence 95% except for the inconclusive result of ICT with “Half” masks as shown in Table [1]Table 1 ‣ 5.1 Implementation Details ‣ 5 Experiments ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\").\n\n### 5.4 Analysis of Diversity\n\nAs shown in ( [2]Equation 2 ‣ 3 Preliminaries: Denoising Diffusion Probabilistic Models ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\")), every reverse diffusion step is inherently stochastic since it incorporates new noise from a Gaussian Distribution. Moreover, as we do not directly guide the inpainted area with any loss, the model is, therefore, free to inpaint anything that semantically aligns with the training set. Figure LABEL:fig:intro illustrates the diversity and flexibility of our model.\n\n### 5.5 Class conditional Experiment\n\nThe pretrained ImageNet DDPM is capable of class-conditional generation sampling. In Figure [5]Figure 5 ‣ 5.5 Class conditional Experiment ‣ 5 Experiments ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\") we show examples for the “Expand” mask for the “Granny Smith” class, as well as other classes.\n\n![Refer to caption]\n\n|     |     |     |     |     |     |\n| --- | --- | --- | --- | --- | --- |\n| Input | Apple Samples | Head Cabbage | Broccoli | Cauliflower | Knot |\n\nFigure 5: Visual results for class guided generation on ImageNet.\n\n### 5.6 Ablation Study\n\nComparison to slowing down:  To analyze if the increased computational budget causes the improved performance of resampling, we compare it with the commonly used technique of slowing down the diffusion process as described in Section [4.2]Resampling ‣ 4 Method ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\").\nTherefore, in Figure [6]Figure 6 ‣ 5.6 Ablation Study ‣ 5 Experiments ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\") and Table [2]Table 2 ‣ 5.6 Ablation Study ‣ 5 Experiments ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\"), we show a comparison resampling and the slow down in diffusion using the same computational budget for each setting. We observe that the resampling uses the extra computational budget for harmonizing the image, whereas there is no visible improvement at slowing down the diffusion process.\n\n|  | T | r | LPIPS | T | r | LPIPS | T | r | LPIPS | T | r | LPIPS |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| Slowing down | 250 | 1 | 0.168 | 500 | 1 | 0.167 | 750 | 1 | 0.179 | 1000 | 1 | 0.161 |\n| Resampling | 250 | 1 | 0.168 | 250 | 2 | 0.148 | 250 | 3 | 0.142 | 250 | 4 | 0.134 |\n\nTable 2: Analysis of the use of computational budget. We compare slowing down the diffusion process and resampling. We use the ImageNet validation set with 32 images over the LaMa \\[ [40])\\] Wide mask setting. The number of diffusion steps is denoted by T𝑇T, and the number of resamplings by r𝑟r.\n\n|  | j=1𝑗1j=1 | j=5𝑗5j=5 | j=10𝑗10j=10 |\n| --- | --- | --- | --- |\n| r | LPIPS | Votes \\[%\\] | LPIPS | Votes \\[%\\] | LPIPS | Votes \\[%\\] |\n| --- | --- | --- | --- | --- | --- | --- |\n| 5 | 0.075 | 42.50±plus-or-minus\\\\pm7.7 | 0.072 | 46.88±plus-or-minus\\\\pm7.8 | 0.073 | 53.12±plus-or-minus\\\\pm7.8 |\n| 10 | 0.088 | 42.50±plus-or-minus\\\\pm7.7 | 0.073 | 45.62±plus-or-minus\\\\pm7.8 | 0.068 | 56.25±plus-or-minus\\\\pm7.8 |\n| 15 | 0.065 | 46.25±plus-or-minus\\\\pm7.8 | 0.063 | 53.12±plus-or-minus\\\\pm5.5 | 0.065 | 53.75±plus-or-minus\\\\pm7.8 |\n\nTable 3: Ablation Study. Analysis of length of the jumps j𝑗j and number of resamplings r𝑟r. We report LPIPS and the average user-study votes with respect to LaMa \\[ [40])\\]. We use 32 images from the CelebA validation set, and use the LaMa Wide mask setting.\n\nJumps Length:  Moreover, to ablate the jump lengths j𝑗j and the number of resampling r𝑟r, we study nine different settings in Table [3]Table 3 ‣ 5.6 Ablation Study ‣ 5 Experiments ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\"). We obtain better performance at applying the larger jump j=10𝑗10j=10 length than smaller step length steps. We observe that for jump length j=1𝑗1j=1, the DDPM is more likely to output a blurry image. Furthermore, this observation is stable across different numbers of resampling. Furthermore, the number of resamplings increases the performance.\n\n|     |\n| --- |\n| Slow-Down |\n\n![Refer to caption]\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n| Input | T=250, r=1 | T=500, r=1 | T=750, r=1 | T=1000, r=1 |\n\n|     |\n| --- |\n| Resampling |\n\n![Refer to caption]\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n| Input | T=250, r=1 | T=250, r=2 | T=250, r=3 | T=250, r=4 |\n\nFigure 6: Qualitative Analysis of the use of computational budget. RePaint produces higher visual quality with the same computational budget by resampling (bottom) compared to slowing down the diffusion process (top). The number of diffusion steps is denoted by T𝑇T and resamplings by r𝑟r.\n\nComparison to alternative sampling strategy:\nTo compare our resampling approach to SDEdit \\[ [25])\\], we first perform reverse diffusion from t=T𝑡𝑇t=T to t=T/2𝑡𝑇2t=T/2 to obtain the required initial inpainting at t=T/2𝑡𝑇2t=T/2. We then apply the resampling method from SDEdit, which repeats the reverse process from t=T/2𝑡𝑇2t=T/2 to t=0𝑡0t=0 several times.\nThe results are shown in Table [4]Table 4 ‣ 5.6 Ablation Study ‣ 5 Experiments ‣ RePaint: Inpainting using Denoising Diffusion Probabilistic Models\").\nOur approach achieves significantly better performance across all mask types except for one “Expand” case, where LPIPS >0.6absent0.6>0.6 is outside a meaningful range for comparisons. In case of ‘super-resolution masks’, our approach reduces the LPIPS by over 53% on all datasets, clearly demonstrating the advantage of our resampling strategy.\n\n| Dataset | Method | Wide | Narrow | Super-Res. | Alt. Lin. | Half | Expand |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| ImageNet | SDEdit \\[ [25])\\] | 0.1532 | 0.0952 | 0.3902 | 0.1852 | 0.3272 | 0.6281 |\n|  | RePaint (Ours) | 0.1341 | 0.0641 | 0.1831 | 0.0891 | 0.3041 | 0.6292 |\n| Places2 | SDEdit \\[ [25])\\] | 0.1302 | 0.0622 | 0.2712 | 0.1302 | 0.3042 | 0.6202 |\n|  | RePaint (Ours) | 0.1051 | 0.0441 | 0.0991 | 0.0511 | 0.2861 | 0.6151 |\n| CelebA-HQ | SDEdit \\[ [25])\\] | 0.0762 | 0.0462 | 0.1132 | 0.0302 | 0.1892 | 0.4492 |\n|  | RePaint (Ours) | 0.0591 | 0.0281 | 0.0291 | 0.0091 | 0.1651 | 0.4351 |\n\nTable 4: Comparison with the resampling schedule proposed in \\[ [25])\\] in terms of LPIPS. The resampling method proposed in our RePaint (Sec. 4.2) achieves substantially better results, in particular for the Super-Resolution masks.",
            "citations": null
          },
          "6 Limitations": {
            "content": "Our method produces sharp, highly detailed, and semantically meaningful images. We believe that our work opens interesting research directions for addressing the current limitations of the method. Two directions are of particular interest. First, naturally, the per-image DDPM optimization process is significantly slower than the GAN-based and Autoregressive-based counterparts. That makes it currently difficult to apply it for real-time applications. Nonetheless, DDPM is gaining in popularity, and recent publications are working on improving the efficiency \\[ [24]), [23])\\]. Secondly, for the extreme mask cases, RePaint can produce realistic images completions that are very different from the Ground Truth image. That makes the quantitative evaluation challenging for those conditions. An alternative solution is to employ the FID score \\[ [11])\\] over a test set. However, a reliable FID for inpainting is usually computed with more than 1,000 images. For current DDPM, this would result in a runtime that is not feasible for most research institutes.",
            "citations": null
          },
          "7 Potential Negative Societal Impact": {
            "content": "On the one hand, RePaint is an inpainting method that relies on an unconditional pretrained DDPM. Therefore, the algorithm might be biased towards the dataset on which it was trained. Since the model aims to generate images of the same distribution as the training set, it might reflect the same biases, such as gender, age, and ethnicity.\nOn the other hand, RePaint could be used for the anonymization of faces. For example, one could remove the information about the identity of people shown at public events and hallucinate artificial faces for data protection.",
            "citations": null
          },
          "8 Conclusions": {
            "content": "We presented a novel denoising diffusion probabilistic model solution for the image inpainting task. In detail, we developed a mask-agnostic approach that widely increases the degree of freedom of masks for the free-form inpainting. Since the novel conditioning approach of RePaint complies with the model assumptions of a DDPM, it produces a photo-realistic image regardless of the type of the mask.\n\nAcknowledgements:\nThis work was supported by the ETH Zürich Fund (OK), a Huawei Technologies Oy (Finland) project, and an Nvidia GPU grant.",
            "citations": null
          }
        },
        "abstract": "Free-form inpainting is the task of adding new content to an image in the\nregions specified by an arbitrary binary mask. Most existing approaches train\nfor a certain distribution of masks, which limits their generalization\ncapabilities to unseen mask types. Furthermore, training with pixel-wise and\nperceptual losses often leads to simple textural extensions towards the missing\nareas instead of semantically meaningful generation. In this work, we propose\nRePaint: A Denoising Diffusion Probabilistic Model (DDPM) based inpainting\napproach that is applicable to even extreme masks. We employ a pretrained\nunconditional DDPM as the generative prior. To condition the generation\nprocess, we only alter the reverse diffusion iterations by sampling the\nunmasked regions using the given image information. Since this technique does\nnot modify or condition the original DDPM network itself, the model produces\nhigh-quality and diverse output images for any inpainting form. We validate our\nmethod for both faces and general-purpose image inpainting using standard and\nextreme masks.\n  RePaint outperforms state-of-the-art Autoregressive, and GAN approaches for\nat least five out of six mask distributions.\n  Github Repository: git.io/RePaint"
      },
      "bib.bib21": {
        "id": "bib.bib21",
        "citation": "Mishra et al. (2024)",
        "authors": "",
        "year": "",
        "title": "Generative factor chaining: Coordinated manipulation with diffusion-based factor graph.",
        "venue": "8th Annual Conference on Robot Learning",
        "pages": "",
        "url": "https://openreview.net/forum?id=p6Wq6TjjHH",
        "arxiv_id": "2409.16275",
        "doi": null,
        "sections": {
          "1 Introduction": {
            "content": "Solving real-world sequential manipulation tasks requires reasoning about sequential dependencies among manipulation steps. For example, a robot needs to grip the center or the tail of a hammer, instead of its head, in order to subsequently hammer a nail. The complexity of planning problems increases when multiple manipulators are involved, where spatial coordination constraints among manipulators need to be satisfied. In the example shown in [Figure 1]Figure 1 ‣ 1 Introduction ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\"), the robot has to reason about the optimal pose to grasp the hammer with the left arm, such that the right arm can coordinate to re-grasp. Subsequently, the two arms must coordinate to hammer the nail.\nWhile classical Task and Motion Planning (TAMP) methods have shown to be effective at solving such problems by hierarchical decomposition \\[ [1])\\], they require accurate system state and kinodynamic model. Further, searching in such a large solution space to satisfy numerous constraints poses a severe scalability challenge. In this work, we aim to develop a learning-based planning framework to tackle complex manipulation tasks with both sequential and spatial coordination constraints.\n\nTo solve complex sequential manipulation problems, prior learning-to-plan methods have largely adopted the options framework and modeled the preconditions and effect of the options or primitive skills \\[ [2]), [3]), [4]), [5]), [6]), [7])\\]. Key to their successes are skill chaining functions that determine whether executing a skill can satisfy the precondition of the next skill in the plan, and eventually the success condition of the overall task. However, the use of vectorized states and the assumption of a linear chain of sequential dependencies limits the expressiveness of these methods. Consider a task where a robot fetches two items from a box. Intuitively, the skills for fetching one object should not influence the other. However, due to vectorized states and the linear dependency assumption, the skill-chaining methods are forced to model such sequential dependencies. Similarly, a skill intended to satisfy a future skill’s condition will be forced to influence the steps in between. Finally, the skill chain representation forbids these methods from effectively modeling multiple-arm manipulation tasks, where concurrent skills must be planned to jointly satisfy a constraint.\n\n![Refer to caption]Figure 1: Factor graph for a multi-arm coordination task. Our factor graph-based planning formulation solves for a sequence of spatial factor graphs from the initial state to a goal factor by chaining them using temporal skill factors. The figure illustrates the temporal evolution of a factor graph by executing single or multiple skills sequentially or in-parallel to handover a hammer, pick up a nail, and coordinate both arms to strike the nail. Task: The task objective is to place the hammer inside the box. However, since the left arm cannot reach the box, the hammer is handed over to the right arm such that the right arm can complete the task. (a) Inputs: The initial scene and a symbolically feasible spatial-temporal factor graph plan to complete the goal objective. (b) GFC: We formulate all factors as distributions of the nodes connected to them. GFC represents spatial factors as classifiers and temporal factors as diffusion models. We leverage compositionality of diffusion models to compose spatial-temporal distributions and find the joint distribution of the complete plan directly at inference. Finally, samples drawn from such a joint distribution are symbolically and geometrically feasible solutions of the whole plan. (c) Output: A sequence of skill choices and optimizer continuous parameters executed on robots with parameterized skill controllers.\n\nTo move beyond the linear chain and model complex coordinated manipulation, we introduce Generative Factor Chaining (GFC), a learning-to-plan framework built on flexible composable generative models. For a given symbolically feasible plan graph, GFC adopts a spatial-temporal factor graph \\[ [8])\\] representation, where nodes are objects and robot states, and spatial factors represent the relationship constraints between these nodes. Skills are temporal factors that connect these state-factor graphs via transition distributions.\nA single skill factor can simultaneously connect to multiple object and robot nodes, allowing for natural representation of complex multi-object interactions and steps that necessitate coordination between multiple manipulators.\nDuring inference, this factor graph can be treated as a probabilistic graphical model, where the learned skill factor and spatial constraint factor distributions are composed to form a joint distribution of complete plans. Through 13 long-horizon manipulation tasks in simulation and the real world, we show that GFC can solve complex bimanual manipulation tasks and exhibits strong generalization to unseen planning tasks with novel combinations of objects and constraints.",
            "citations": null
          },
          "2 Related Work": {
            "content": "Task and Motion Planning (TAMP). TAMP frameworks decompose a complex planning problem into constraint satisfaction problems at task and motion levels \\[ [9]), [2]), [10]), [11]), [12])\\]. Notably, Garret et al. \\[ [1])\\] drew connections between TAMP and factor graphs \\[ [8])\\], representing constraints as factors and objects/robots as nodes. This formalism naturally allows reusing per-constraint solvers across tasks. However, classical TAMP approaches often rely on accurate perception and system dynamics, limiting their practical applications and scalability. We instead opt for a learning approach, while our compositional factor graph representation remains heavily inspired by the classical TAMP paradigm.\n\nGenerative models for planning. Modern generative models have been applied to offline imitation \\[ [13]), [14]), [15]), [16]), [17]), [18]), [19]), [20])\\] and reinforcement learning \\[ [21]), [22])\\]. In addition to modeling complex state and action distributions, generative models have also been shown to encourage compositional generalization \\[ [23]), [6]), [24])\\] by combining data across tasks \\[ [22]), [21])\\]. Most relevant to us are Generative Skill Chaining (GSC) \\[ [6])\\] and Diffusion-CCSP \\[ [25])\\], both designed to achieve systematic compositional generalization. GSC composes skill chains through a guided diffusion process. However, similar to other skill-chaining methods \\[ [4]), [5])\\], GSC cannot model non-linear dependencies such as parallel skills and independence among skills.\nDiffusion-CCSP trains diffusion models to generate object configurations to satisfy spatial constraints, while relying on external solvers to plan the manipulation sequence.\nOur method is a unified framework to solve the combined problem: it generates skill plans to satisfy both spatial and temporal constraints represented in a factor graph.\n\nLearning for coordinated manipulation. Coordinating two or more arms for manipulation presents numerous planning challenges \\[ [26]), [27]), [28])\\], including the combinatorial search space complex constraints for coordinated motion. Recent works have utilized learning-based frameworks \\[ [29]), [30]), [31]), [32]), [33])\\] in both Reinforcement Learning \\[ [29]), [31])\\] and offline Imitation Learning \\[ [33]), [32])\\]. However, most existing works have focused on learning task-specific policies \\[ [29]), [32])\\] or require multi-arm demonstration data collected through a specialized teleoperation device \\[ [33])\\]. In contrast, our factor graph-based representation enables solving multi-arm tasks by composing multiple single-arm skills through inference-time optimization.",
            "citations": null
          },
          "3 Background": {
            "content": "Diffusion Models. A core component of our method is based on distributions learned using diffusion models. A diffusion model learns an unknown distribution p​(x(0))𝑝superscriptx0p(\\\\textbf{x}^{(0)}) from its samples by approximating the score function ∇log⁡p∇𝑝\\\\nabla\\\\log p. It consists of two processes: a forward diffusion or noising process that progressively injects noise and a reverse diffusion or denoising process that iteratively removes noise to recover clean data. The forward process simply adds Gaussian noise ϵitalic-ϵ\\\\epsilon to clean data as x(t)=x(0)+σt​ϵsuperscriptx𝑡superscriptx0subscript𝜎𝑡italic-ϵ\\\\textbf{x}^{(t)}=\\\\textbf{x}^{(0)}+\\\\sigma\\_{t}\\\\epsilon for a monotonically increasing σtsubscript𝜎𝑡\\\\sigma\\_{t}. The reverse process relies on the score function ∇xlog⁡pt​(x(t))subscript∇xsubscript𝑝𝑡superscriptx𝑡\\\\nabla\\_{\\\\textbf{x}}\\\\log p\\_{t}(\\\\textbf{x}^{(t)}) where ptsubscript𝑝𝑡p\\_{t} is the distribution of noised data x(t)superscriptx𝑡\\\\textbf{x}^{(t)}.\nIn practice,\nthe unknown score function is estimated using a neural network ϵϕ​(x(t),t)subscriptitalic-ϵitalic-ϕsuperscriptx𝑡𝑡\\\\epsilon\\_{\\\\phi}(\\\\textbf{x}^{(t)},t) by minimizing the denoising score matching \\[ [34])\\] objective\n𝔼t,ϵ,x(0)​\\[λ​(t)​‖ϵ−ϵϕ​(x(t),t)‖2\\]subscript𝔼𝑡italic-ϵsuperscriptx0delimited-\\[\\]𝜆𝑡superscriptnormitalic-ϵsubscriptitalic-ϵitalic-ϕsuperscriptx𝑡𝑡2\\\\mathbb{E}\\_{t,\\\\epsilon,\\\\textbf{x}^{(0)}}\\[\\\\lambda(t)\\\\\\|\\\\epsilon-\\\\epsilon\\_{\\\\phi}(\\\\textbf{x}^{(t)},t)\\\\\\|^{2}\\]\nwhere λ​(t)𝜆𝑡\\\\lambda(t) is a time-dependent weight. Several recent works have explored the advantages of diffusion models like scalability \\[ [35]), [36]), [37]), [38])\\] and the ability to learn multi-modal distributions \\[ [39]), [40]), [41]), [22])\\]. We are particularly interested in the compositional ability \\[ [23]), [13]), [24]), [25]), [6])\\] of these models for the proposed method.\n\nProblem setup. We assume access to a library of parameterized skills \\[ [42])\\]π∼Πsimilar-to𝜋Π\\\\pi\\\\sim\\\\Pi such as primitive actions like Pick and Place. Each skill π𝜋\\\\pi requires a pre-condition to be fulfilled and is parameterized by a continuous parameter a∈Aπ𝑎subscript𝐴𝜋a\\\\in A\\_{\\\\pi} governing the desired motion while executing the skill in a state s𝑠s. For a given symbolically feasible task plan from a starting state s0subscript𝑠0s\\_{0} to reach a specified goal condition sg​o​a​lsubscript𝑠𝑔𝑜𝑎𝑙s\\_{goal}, generated by a task planner or given by an oracle, the problem is to obtain the sequence of continuous parameters to make the plan geometrically feasible. For example, given a nail at a target location and a hammer on a table, the symbolic plan is to Pick the hammer and Reach the nail. A geometrically-feasible plan requires suitable Pick and Reach parameters such that the hammer’s head can strike the nail.\n\nLearning for skill chaining. Existing works along this direction model the planning problem as a “chaining” problem: They first model the pre-conditions and effect state distributions for every skill π∼Πsimilar-to𝜋Π\\\\pi\\\\sim\\\\Pi from the available data and a symbolic plan skeletonΦK={π1,π2,…,πK}subscriptΦ𝐾subscript𝜋1subscript𝜋2…subscript𝜋𝐾\\\\Phi\\_{K}=\\\\{\\\\pi\\_{1},\\\\pi\\_{2},...,\\\\pi\\_{K}\\\\} consisting of K𝐾K-skills is constructed. With this model, they search for the given skill sequence (plan) such that each skill satisfies the pre-conditions of the next skill in the plan. STAP \\[ [5])\\] used learned priors to perform data-driven optimization with the cross-entropy maximization method. In GSC \\[ [6])\\], the policy and transition model is formulated as a diffusion model based distribution pπ​(s,aπ,s′)subscript𝑝𝜋𝑠subscript𝑎𝜋superscript𝑠′p\\_{\\\\pi}(s,a\\_{\\\\pi},s^{\\\\prime}) which allows for flexible chaining. While the forward chain ensures dynamics consistency in the plan, backward chain ensures that the goal is reachable from the intermediate states. For a forward rollout trajectory τ={s0,aπ1,s1,aπ2,sg​o​a​l}𝜏subscript𝑠0subscript𝑎subscript𝜋1subscript𝑠1subscript𝑎subscript𝜋2subscript𝑠𝑔𝑜𝑎𝑙\\\\tau=\\\\{s\\_{0},a\\_{\\\\pi\\_{1}},s\\_{1},a\\_{\\\\pi\\_{2}},s\\_{goal}\\\\} associated with skeleton Φ2={π1,π2}subscriptΦ2subscript𝜋1subscript𝜋2\\\\Phi\\_{2}=\\\\{\\\\pi\\_{1},\\\\pi\\_{2}\\\\},\nthe resulting forward-backward combination based on GSC \\[ [6])\\] can be represented as\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | pτ​(τ\\|s0,sg​o​a​l)∝pπ1​(s0,aπ1,s1)​pπ2​(s1,aπ2,sg​o​a​l)pπ1​(s1)​pπ2​(s1)proportional-tosubscript𝑝𝜏conditional𝜏subscript𝑠0subscript𝑠𝑔𝑜𝑎𝑙subscript𝑝subscript𝜋1subscript𝑠0subscript𝑎subscript𝜋1subscript𝑠1subscript𝑝subscript𝜋2subscript𝑠1subscript𝑎subscript𝜋2subscript𝑠𝑔𝑜𝑎𝑙subscript𝑝subscript𝜋1subscript𝑠1subscript𝑝subscript𝜋2subscript𝑠1p\\_{\\\\tau}(\\\\tau\\|s\\_{0},s\\_{goal})\\\\propto\\\\frac{p\\_{\\\\pi\\_{1}}(s\\_{0},a\\_{\\\\pi\\_{1}},s\\_{1})p\\_{\\\\pi\\_{2}}(s\\_{1},a\\_{\\\\pi\\_{2}},s\\_{goal})}{\\\\sqrt{p\\_{\\\\pi\\_{1}}(s\\_{1})p\\_{\\\\pi\\_{2}}(s\\_{1})}} |  | (1) |",
            "citations": null
          },
          "4 Method": {
            "content": "We aim to solve unseen long-horizon planning problems by exploiting the inter-dependencies between the objects important for the task at hand in the scene. Our method adopts factor graphs to represent states and realize their temporal evolution by the application of skills. While previous works have considered vectorized state representations making it difficult to decouple spatial-independence, we focus on factorized state representations such that the state of the environment is entirely modular, containing information about all the objects in the scenario and the task-specific constraints between them. We use a spatial-temporal factor graph \\[ [8])\\] that is transformed into a probabilistic graphical model by representing temporal factors as skill-level transition distributions and spatial factors as constraint-satisfaction distributions. A composition of all the factors jointly represents sequential and coordinated manipulation plans directly at inference and can be solved by sampling optimal node variables using reverse diffusion sampling.\n\n### 4.1 Representing States, Skills, and Plans in Factor Graphs\n\nStates as factor graphs. We define a factor graph {𝒱,ℱ}𝒱ℱ\\\\{\\\\mathcal{V},\\\\mathcal{F}\\\\} of a state s𝑠s consisting of the decision variable 𝒱𝒱\\\\mathcal{V} and factor ℱℱ\\\\mathcal{F} nodes. Every robot and object is represented as a decision variable node v∈𝒱𝑣𝒱v\\\\in\\\\mathcal{V} containing their respective state. Factors f∈ℱ𝑓ℱf\\\\in\\\\mathcal{F} between nodes in a given state are _spatial constraints_. For example, a Grasped spatial factor specifies admissible rigid transforms between a gripper and an object.\nWhen we construct a probabilistic graphical model from the representation described above, an intuitive way of calculating the distribution of a state, p​(s)𝑝𝑠p(s), is the composition of all the factor distributions. Mathematically:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | p​(s)∝∏f∈ℱpf​(𝒮f) where ​s≡⋃f∈ℱ𝒮fformulae-sequenceproportional-to𝑝𝑠subscriptproduct𝑓ℱsubscript𝑝𝑓subscript𝒮𝑓 where 𝑠subscript𝑓ℱsubscript𝒮𝑓p(s)\\\\propto\\\\prod\\_{f\\\\in\\\\mathcal{F}}p\\_{f}(\\\\mathcal{S}\\_{f})\\\\quad\\\\text{ where }s\\\\equiv\\\\bigcup\\_{f\\\\in\\\\mathcal{F}}\\\\mathcal{S}\\_{f} |  | (2) |\n\nwhere pf​(𝒮f)subscript𝑝𝑓subscript𝒮𝑓p\\_{f}(\\\\mathcal{S}\\_{f}) represents the joint factor potential of nodes v∈𝒮f⊆𝒱𝑣subscript𝒮𝑓𝒱v\\\\in\\\\mathcal{S}\\_{f}\\\\subseteq\\\\mathcal{V}, i.e. all nodes involved in a factor 111i.e. a factor f𝑓f is included iff there is an edge between f𝑓f and some v∈𝒱𝑣𝒱v\\\\in\\\\mathcal{V} which also implies v∈𝒮f⊆𝒱𝑣subscript𝒮𝑓𝒱v\\\\in\\\\mathcal{S}\\_{f}\\\\subseteq\\\\mathcal{V}. and s𝑠s is the joint distribution of all such nodes.\nThis indicates that the joint distribution of all the nodes must satisfy each of the factors, also explored by Diffusion-CCSP \\[ [25])\\].\n\nSkills as temporal factors. To represent transitions between states, we adapt parameterized skills \\[ [42])\\] for a factor graph formulation. We define the preconditions of a skill as a set of nodes and factors, thus considering a skill feasible _iff_ the precondition factors are satisfied. For example, for state s0subscript𝑠0s\\_{0} illustrated in [Figure 1]Figure 1 ‣ 1 Introduction ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\"), the nodes of a factor graph are {L0,H0,R0,B0subscript𝐿0subscript𝐻0subscript𝑅0subscript𝐵0L\\_{0},H\\_{0},R\\_{0},B\\_{0}} and the factors existing in this scene are {Grasped(L0,H0subscript𝐿0subscript𝐻0L\\_{0},H\\_{0})=True}. Now, since this factor is a precondition of the skill Move(L0,H0)subscript𝐿0subscript𝐻0(L\\_{0},H\\_{0}) that moves the hammer in hand to align with the box, it must be satisfied for the skill to be feasible. The effect of executing a skill creates a new factor graph s′superscript𝑠′s^{\\\\prime} by changing the state of the nodes involved and, optionally, adding or removing their factors. This results in a _temporal factor_ between the transitioned nodes of s𝑠s and s′superscript𝑠′s^{\\\\prime} with the continuous action parameter of the skill aπsubscript𝑎𝜋a\\_{\\\\pi}.\nThe skill definitions can be extracted from standard PDDL symbolic skill operator with minor adaptations, following the duality of factor graphs and plan skeletons \\[ [1])\\]. Eventually, we solve an optimization problem: satisfying the Aligned, Grasped, and the transition dynamics constraints by finding the correct Move parameters aπ1subscript𝑎subscript𝜋1a\\_{\\\\pi\\_{1}}. Each skill in a plan introduces additional nodes and factors to the factor graph, with added complexity for optimization.\n\nMathematically, we can use the distribution p​(s)𝑝𝑠p(s) as established in [Equation 2]Representing States, Skills, and Plans in Factor Graphs ‣ 4 Method ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\") with all the spatial factors, and represent the temporal skill factor distribution of kt​hsuperscript𝑘𝑡ℎk^{th}-skill πksubscript𝜋𝑘\\\\pi\\_{k} as the joint distribution:\npπk​(s,a,s′)≡pπk​(Sπk,a,Sπk′),Sπk⊆𝒱p​r​eπkformulae-sequencesubscript𝑝subscript𝜋𝑘𝑠𝑎superscript𝑠′subscript𝑝subscript𝜋𝑘subscript𝑆subscript𝜋𝑘𝑎subscriptsuperscript𝑆′subscript𝜋𝑘subscript𝑆subscript𝜋𝑘subscriptsuperscript𝒱subscript𝜋𝑘𝑝𝑟𝑒p\\_{\\\\pi\\_{k}}(s,a,s^{\\\\prime})\\\\equiv p\\_{\\\\pi\\_{k}}(S\\_{\\\\pi\\_{k}},a,S^{\\\\prime}\\_{\\\\pi\\_{k}}),\\\\;\\\\;S\\_{\\\\pi\\_{k}}\\\\subseteq\\\\mathcal{V}^{\\\\pi\\_{k}}\\_{pre}\nwhich is executable iff the skill’s pre-condition sp​r​eπk≡{𝒱p​r​eπk,ℱp​r​eπk}subscriptsuperscript𝑠subscript𝜋𝑘𝑝𝑟𝑒subscriptsuperscript𝒱subscript𝜋𝑘𝑝𝑟𝑒subscriptsuperscriptℱsubscript𝜋𝑘𝑝𝑟𝑒s^{\\\\pi\\_{k}}\\_{pre}~{}\\\\equiv~{}\\\\{\\\\mathcal{V}^{\\\\pi\\_{k}}\\_{pre},\\\\mathcal{F}^{\\\\pi\\_{k}}\\_{pre}\\\\} is satisfied by the current state i.e. 𝒱p​r​eπk⊆𝒱subscriptsuperscript𝒱subscript𝜋𝑘𝑝𝑟𝑒𝒱\\\\mathcal{V}^{\\\\pi\\_{k}}\\_{pre}\\\\subseteq\\\\mathcal{V} and ℱp​r​eπk⊆ℱsubscriptsuperscriptℱsubscript𝜋𝑘𝑝𝑟𝑒ℱ\\\\mathcal{F}^{\\\\pi\\_{k}}\\_{pre}\\\\subseteq\\\\mathcal{F}.\nOnce executed, it leads to the transitioned state Sπk′subscriptsuperscript𝑆′subscript𝜋𝑘S^{\\\\prime}\\_{\\\\pi\\_{k}}.\nBased on the above formulation of a short-horizon transition distribution, we extend to construct a plan-level distribution as already established by GSC \\[ [6])\\] and shown in [Equation 1]Background ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\").\nWe leverage the modularity of factored states by replacing states s𝑠s with a set of decision variables Sπksubscript𝑆subscript𝜋𝑘S\\_{\\\\pi\\_{k}} in the interest of skill πksubscript𝜋𝑘\\\\pi\\_{k}. This allows us to chain multiple skills in series and parallel. In such a scenario, the denominator term exists only for certain decision nodes iff they are common in two consecutive skills. We can indeed rewrite [Equation 1]Background ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\") as:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | p​(τ)∝∏πk∈Φpπk​(vk∈𝒱p​r​eπk,ak,vk′∈𝒱e​f​f​e​c​tπk)∏vi∈𝒱ipπi−​(vi)​pπi+​(vi)proportional-to𝑝𝜏subscriptproductsubscript𝜋𝑘Φsubscript𝑝subscript𝜋𝑘formulae-sequencesubscript𝑣𝑘subscriptsuperscript𝒱subscript𝜋𝑘𝑝𝑟𝑒subscript𝑎𝑘subscriptsuperscript𝑣′𝑘subscriptsuperscript𝒱subscript𝜋𝑘𝑒𝑓𝑓𝑒𝑐𝑡subscriptproductsubscript𝑣𝑖subscript𝒱𝑖subscript𝑝subscript𝜋limit-from𝑖subscript𝑣𝑖subscript𝑝subscript𝜋limit-from𝑖subscript𝑣𝑖p(\\\\tau)\\\\propto\\\\frac{\\\\prod\\_{\\\\pi\\_{k}\\\\in\\\\Phi}p\\_{\\\\pi\\_{k}}(v\\_{k}\\\\in\\\\mathcal{V}^{\\\\pi\\_{k}}\\_{pre},a\\_{k},v^{\\\\prime}\\_{k}\\\\in\\\\mathcal{V}^{\\\\pi\\_{k}}\\_{effect})}{\\\\sqrt{\\\\prod\\_{v\\_{i}\\\\in\\\\mathcal{V}\\_{i}}p\\_{\\\\pi\\_{i-}}(v\\_{i})p\\_{\\\\pi\\_{i+}}(v\\_{i})}} |  | (3) |\n\nif we consider that some set of intermediate nodes 𝒱isubscript𝒱𝑖\\\\mathcal{V}\\_{i} are connected by two sequential skills πi−subscript𝜋limit-from𝑖\\\\pi\\_{i-} and πi+subscript𝜋limit-from𝑖\\\\pi\\_{i+}.\n\n![Refer to caption]Figure 2: (Left) Parallel independent chaining The figure shows the execution of two skills (π1subscript𝜋1\\\\pi\\_{1} and π2subscript𝜋2\\\\pi\\_{2}) in-parallel on two independent sets of nodes (L, C and R, M) to modify their existing factors (Grasped). The two independent executions can be connected via external factors μ1subscript𝜇1\\\\mu\\_{1} (FixedTransform) introducing spatial dependencies between nodes C and M. (Right) Parallel dependent chaining The figure shows overlapping nodes of interest while parallel execution of two skills. The pot is to be picked by using both arms simultaneously. The effect of this is resulting factors (Grasped) between (L, P and R, P) and external factor μ2subscript𝜇2\\\\mu\\_{2} (FixedTransform) between L and R. Overlapping nodes satisfy both skill’s temporal effects.\n\nRepresenting coordination. A key advantage of the factor graph representation is the ability to model multi-arm coordination tasks by connecting the temporal chains of each arm using spatial constraints. Such tasks often require skills to be simultaneously executed on each arm to operate on different or the same objects.\nWe consider two cases for parallel skill execution, where multiple robots are operating on: (1) independent objects and (2) the same object, leading to independent and dependent temporal chains respectively. With our factorized state representation, we can independently control the execution of individual skills correlated with the nodes of interest and calculate the cumulative effect by applying the union of the effects of all the skills to the current factor graph.\nWe consider a scenario shown in [Figure 2]Figure 2 ‣ 4.1 Representing States, Skills, and Plans in Factor Graphs ‣ 4 Method ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\") (Left). The left and right gripper arm L0subscript𝐿0L\\_{0} are holding the pink C0subscript𝐶0C\\_{0} and green M0subscript𝑀0M\\_{0} cup ({Grasped(L0,C0subscript𝐿0subscript𝐶0L\\_{0},C\\_{0})=True} and {Grasped(R0,M0subscript𝑅0subscript𝑀0R\\_{0},M\\_{0})=True}) respectively. While both the grippers can independently execute the skill Move to modify separate factors (f1π1subscriptsuperscript𝑓subscript𝜋11f^{\\\\pi\\_{1}}\\_{1} and f2π2subscriptsuperscript𝑓subscript𝜋22f^{\\\\pi\\_{2}}\\_{2}), one can add a constrained relationship factor (μ1subscript𝜇1\\\\mu\\_{1}) between the two mugs representing a set of transforms that satisfy the precondition of Pour. Such an ability to augment constraints flexibly allows zero-shot coordination planning for unseen tasks at test time even with parallel skill executions on the same object as shown in [Figure 2]Figure 2 ‣ 4.1 Representing States, Skills, and Plans in Factor Graphs ‣ 4 Method ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\") (Right).\n\n### 4.2 Generative Factor Chaining\n\nNow we have a formulation to construct a symbolic spatial-temporal factor graph plan for a task and chain them using spatial factor and temporal skill factors sequentially or in parallel. To make this plan geometrically feasible, we must find the optimal node variable values. While classical solvers require modeling the transition dynamics of complex manipulation tasks, sampling-driven optimization with learned models provides less flexibility and modularity \\[ [6])\\]. In this work, we leverage the expressive generative model to capture the transition dynamics and exploit the compositionality of diffusion models. Given a symbolically feasible factor graph plan, our method, termed Generative Factor Chaining (GFC), can flexibly compose spatial-temporal factor distributions to sample optimal node variable values for the complete plan.\n\nProbabilistic model for trajectory plan as spatial-temporal factor graphs. Now, we again consider the spatial graph for representing the state, where the probability of finding a state s𝑠s is the joint distribution of all the nodes in the factor graph. We will now integrate the spatial factors with the temporal factors considering the compensation term introduced in [Equation 2]Representing States, Skills, and Plans in Factor Graphs ‣ 4 Method ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\") and [Equation 3]Representing States, Skills, and Plans in Factor Graphs ‣ 4 Method ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\") along with the constraint factors across the chain μ∈ℳ𝜇ℳ\\\\mu\\\\in\\\\mathcal{M} as:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | p​(τ)∝∏πk∈Φpπk​(vk∈𝒱p​r​eπk,ak,vk+1∈𝒱e​f​f​e​c​tπk)​∏k=0K∏f∈ℱkpf​(𝒮f)∏vi∈𝒱ipπi−​(vi)​pπi+​(vi)​Πℳ​fμ​(Sμ)proportional-to𝑝𝜏subscriptproductsubscript𝜋𝑘Φsubscript𝑝subscript𝜋𝑘formulae-sequencesubscript𝑣𝑘subscriptsuperscript𝒱subscript𝜋𝑘𝑝𝑟𝑒subscript𝑎𝑘subscript𝑣𝑘1subscriptsuperscript𝒱subscript𝜋𝑘𝑒𝑓𝑓𝑒𝑐𝑡superscriptsubscriptproduct𝑘0𝐾subscriptproduct𝑓subscriptℱ𝑘subscript𝑝𝑓subscript𝒮𝑓subscriptproductsubscript𝑣𝑖subscript𝒱𝑖subscript𝑝subscript𝜋limit-from𝑖subscript𝑣𝑖subscript𝑝subscript𝜋limit-from𝑖subscript𝑣𝑖subscriptΠℳsubscript𝑓𝜇subscript𝑆𝜇p(\\\\tau)\\\\propto\\\\frac{\\\\prod\\_{\\\\pi\\_{k}\\\\in\\\\Phi}p\\_{\\\\pi\\_{k}}(v\\_{k}\\\\in\\\\mathcal{V}^{\\\\pi\\_{k}}\\_{pre},a\\_{k},v\\_{k+1}\\\\in\\\\mathcal{V}^{\\\\pi\\_{k}}\\_{effect})\\\\prod\\_{k=0}^{K}\\\\prod\\_{f\\\\in\\\\mathcal{F}\\_{k}}p\\_{f}(\\\\mathcal{S}\\_{f})}{\\\\sqrt{\\\\prod\\_{v\\_{i}\\\\in\\\\mathcal{V}\\_{i}}p\\_{\\\\pi\\_{i-}}(v\\_{i})p\\_{\\\\pi\\_{i+}}(v\\_{i})}}\\\\Pi\\_{\\\\mathcal{M}}f\\_{\\\\mu}(S\\_{\\\\mu}) |  | (4) |\n\nThis completes the joint distribution of all the nodes in the spatial-temporal factor graph plan considering the temporal factors for all skills with their pre-condition and effect nodes, all spatial factors for all states in the plan, and all intermediate nodes in the temporal chain. We show our implementation of this formulation in [algorithm 1]Appendix S2 Additional Related Works ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\").\n\nFor the sake of simplicity, we will formulate the probabilistic model for the two chains shown in [Figure 2]Figure 2 ‣ 4.1 Representing States, Skills, and Plans in Factor Graphs ‣ 4 Method ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\") by following the forward-backward analysis introduced by GSC and discussed in [section 3]Background ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\"). We can write the top chain as:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | pπ1​(L0,C0,aπ1,L1,C1)​pπ2​(R0,M0,aπ2,R1,M1)​pμ1​(C1,M1)subscript𝑝subscript𝜋1subscript𝐿0subscript𝐶0subscript𝑎subscript𝜋1subscript𝐿1subscript𝐶1subscript𝑝subscript𝜋2subscript𝑅0subscript𝑀0subscript𝑎subscript𝜋2subscript𝑅1subscript𝑀1subscript𝑝subscript𝜇1subscript𝐶1subscript𝑀1p\\_{\\\\pi\\_{1}}(L\\_{0},C\\_{0},a\\_{\\\\pi\\_{1}},L\\_{1},C\\_{1})p\\_{\\\\pi\\_{2}}(R\\_{0},M\\_{0},a\\_{\\\\pi\\_{2}},R\\_{1},M\\_{1})p\\_{\\\\mu\\_{1}}(C\\_{1},M\\_{1}) |  | (5) |\n\nshowing the independence of factors. Similarly, the bottom chain can be constructed based on [Equation 4]Generative Factor Chaining ‣ 4 Method ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\") as:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | pπ1​(L0,P0,aπ1,L1,P1)​pπ2​(R0,P0,aπ2,R1,P1)pπ1​(P1)​pπ2​(P1)​pμ2​(L1,R1)subscript𝑝subscript𝜋1subscript𝐿0subscript𝑃0subscript𝑎subscript𝜋1subscript𝐿1subscript𝑃1subscript𝑝subscript𝜋2subscript𝑅0subscript𝑃0subscript𝑎subscript𝜋2subscript𝑅1subscript𝑃1subscript𝑝subscript𝜋1subscript𝑃1subscript𝑝subscript𝜋2subscript𝑃1subscript𝑝subscript𝜇2subscript𝐿1subscript𝑅1\\\\frac{p\\_{\\\\pi\\_{1}}(L\\_{0},P\\_{0},a\\_{\\\\pi\\_{1}},L\\_{1},P\\_{1})p\\_{\\\\pi\\_{2}}(R\\_{0},P\\_{0},a\\_{\\\\pi\\_{2}},R\\_{1},P\\_{1})}{\\\\sqrt{p\\_{\\\\pi\\_{1}}(P\\_{1})p\\_{\\\\pi\\_{2}}(P\\_{1})}}p\\_{\\\\mu\\_{2}}(L\\_{1},R\\_{1}) |  | (6) |\n\nwhere the factors are dependent on each other. It is worth noting that the augmented constraint factors pμsubscript𝑝𝜇p\\_{\\\\mu} work as a weighing function and can be more precisely represented by pμ​(Sμ)≡pμ​(y=1\\|Sμ)subscript𝑝𝜇subscript𝑆𝜇subscript𝑝𝜇𝑦conditional1subscript𝑆𝜇p\\_{\\\\mu}(S\\_{\\\\mu})\\\\equiv p\\_{\\\\mu}(y=1\\|S\\_{\\\\mu}) for some constraint-satisfaction index y𝑦y.\n\nWe align towards diffusion model-based learned distributions to represent the probabilities in the formulated probabilistic graphical model. We transform the probabilities into their respective score functions ϵ​(x(t),t)italic-ϵsuperscriptx𝑡𝑡\\\\epsilon(\\\\textbf{x}^{(t)},t) for a particular reverse diffusion sampling step t𝑡t and train it using score matching loss. Hence, for sampling a scene-graph for [Equation 4]Generative Factor Chaining ‣ 4 Method ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\"), we have\n\n|     |     |     |\n| --- | --- | --- |\n|  | ϵ​(τ(t),t)=∑πk∈Φϵπk​(vk(t)∈𝒱p​r​eπk,ak(t),vk+1(t)∈𝒱e​f​f​e​c​tπk,t)+∑k=0K∑f∈ℱkϵf​(𝒮f(t),t)italic-ϵsuperscript𝜏𝑡𝑡subscriptsubscript𝜋𝑘Φsubscriptitalic-ϵsubscript𝜋𝑘formulae-sequencesubscriptsuperscript𝑣𝑡𝑘subscriptsuperscript𝒱subscript𝜋𝑘𝑝𝑟𝑒subscriptsuperscript𝑎𝑡𝑘subscriptsuperscript𝑣𝑡𝑘1subscriptsuperscript𝒱subscript𝜋𝑘𝑒𝑓𝑓𝑒𝑐𝑡𝑡superscriptsubscript𝑘0𝐾subscript𝑓subscriptℱ𝑘subscriptitalic-ϵ𝑓subscriptsuperscript𝒮𝑡𝑓𝑡\\\\displaystyle\\\\epsilon(\\\\tau^{(t)},t)=\\\\sum\\_{\\\\pi\\_{k}\\\\in\\\\Phi}\\\\epsilon\\_{\\\\pi\\_{k}}(v^{(t)}\\_{k}\\\\in\\\\mathcal{V}^{\\\\pi\\_{k}}\\_{pre},a^{(t)}\\_{k},v^{(t)}\\_{k+1}\\\\in\\\\mathcal{V}^{\\\\pi\\_{k}}\\_{effect},t)+\\\\sum\\_{k=0}^{K}\\\\sum\\_{f\\\\in\\\\mathcal{F}\\_{k}}\\\\epsilon\\_{f}(\\\\mathcal{S}^{(t)}\\_{f},t) |  |\n|  | −12​∑vi∈𝒱i\\[ϵπi−​(vi(t),t)​ϵπi+​(vi(t),t)\\]+∑ℳϵfμ​(Sμ(t),t)12subscriptsubscript𝑣𝑖subscript𝒱𝑖delimited-\\[\\]subscriptitalic-ϵsubscript𝜋limit-from𝑖subscriptsuperscript𝑣𝑡𝑖𝑡subscriptitalic-ϵsubscript𝜋limit-from𝑖subscriptsuperscript𝑣𝑡𝑖𝑡subscriptℳsubscriptitalic-ϵsubscript𝑓𝜇subscriptsuperscript𝑆𝑡𝜇𝑡\\\\displaystyle-\\\\frac{1}{2}\\\\sum\\_{v\\_{i}\\\\in\\\\mathcal{V}\\_{i}}\\\\Big{\\[}\\\\epsilon\\_{\\\\pi\\_{i-}}(v^{(t)}\\_{i},t)\\\\epsilon\\_{\\\\pi\\_{i+}}(v^{(t)}\\_{i},t)\\\\Big{\\]}+\\\\sum\\_{\\\\mathcal{M}}\\\\epsilon\\_{f\\_{\\\\mu}}(S^{(t)}\\_{\\\\mu},t) |  |\n\nFollowing this, we can show for the dependent factor chain in [Equation 6]Generative Factor Chaining ‣ 4 Method ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\") as:\n\n|     |     |     |\n| --- | --- | --- |\n|  | ϵ​(L0(t),P0(t),R0(t),L1(t),P1(t),R1(t),t)=ϵπ1​(L0(t),P0(t),aπ1(t),L1(t),P1(t),t)+italic-ϵsubscriptsuperscript𝐿𝑡0subscriptsuperscript𝑃𝑡0subscriptsuperscript𝑅𝑡0subscriptsuperscript𝐿𝑡1subscriptsuperscript𝑃𝑡1subscriptsuperscript𝑅𝑡1𝑡limit-fromsubscriptitalic-ϵsubscript𝜋1subscriptsuperscript𝐿𝑡0subscriptsuperscript𝑃𝑡0subscriptsuperscript𝑎𝑡subscript𝜋1subscriptsuperscript𝐿𝑡1subscriptsuperscript𝑃𝑡1𝑡\\\\displaystyle\\\\epsilon(L^{(t)}\\_{0},P^{(t)}\\_{0},R^{(t)}\\_{0},L^{(t)}\\_{1},P^{(t)}\\_{1},R^{(t)}\\_{1},t)=\\\\epsilon\\_{\\\\pi\\_{1}}(L^{(t)}\\_{0},P^{(t)}\\_{0},a^{(t)}\\_{\\\\pi\\_{1}},L^{(t)}\\_{1},P^{(t)}\\_{1},t)+ |  |\n|  | ϵπ2​(R0(t),P0(t),aπ2(t)​R1(t),P1(t),t)−12​ϵπ1​(P1(t),t)−12​ϵπ2​(P1(t),t)+ϵμ2​(L1(t),R1(t),t)subscriptitalic-ϵsubscript𝜋2subscriptsuperscript𝑅𝑡0subscriptsuperscript𝑃𝑡0subscriptsuperscript𝑎𝑡subscript𝜋2subscriptsuperscript𝑅𝑡1subscriptsuperscript𝑃𝑡1𝑡12subscriptitalic-ϵsubscript𝜋1subscriptsuperscript𝑃𝑡1𝑡12subscriptitalic-ϵsubscript𝜋2subscriptsuperscript𝑃𝑡1𝑡subscriptitalic-ϵsubscript𝜇2subscriptsuperscript𝐿𝑡1subscriptsuperscript𝑅𝑡1𝑡\\\\displaystyle\\\\epsilon\\_{\\\\pi\\_{2}}(R^{(t)}\\_{0},P^{(t)}\\_{0},a^{(t)}\\_{\\\\pi\\_{2}}R^{(t)}\\_{1},P^{(t)}\\_{1},t)-\\\\frac{1}{2}\\\\epsilon\\_{\\\\pi\\_{1}}(P^{(t)}\\_{1},t)-\\\\frac{1}{2}\\\\epsilon\\_{\\\\pi\\_{2}}(P^{(t)}\\_{1},t)+\\\\epsilon\\_{\\\\mu\\_{2}}(L^{(t)}\\_{1},R^{(t)}\\_{1},t) |  |\n\nSuch a representation leads to a cumulative score calculation of the joint distribution of all the nodes of interest to the factor using linear addition and subtraction.\nWe can realize from [subsection 4.2]Generative Factor Chaining ‣ 4 Method ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\") that the final score function depends on the composition of all the factors in the spatial-temporal factor graph. While factors f∈ℱ𝑓ℱf\\\\in\\\\mathcal{F} are mostly modeled implicitly by the temporal skills, the external factors can be any arbitrary spatial constraints that ensure the satisfaction of the pre-condition of the subsequent skills. Hence, with new additions to the set of external factors μ′∈ℳ′superscript𝜇′superscriptℳ′\\\\mu^{\\\\prime}\\\\in\\\\mathcal{M^{\\\\prime}}, one can reuse the same temporal skills with added new spatial constraints.\n\nSummary GFC is a new paradigm to solve complex manipulation problems using spatial-temporal factor graphs. GFC can be divided into the following segments: (1) train individual skill factor distributions individually, without any prior knowledge or data from other skills in the library\n(2) create spatial-temporal factor graph from a plan skeleton, (3) compose individual spatial and temporal factor distributions to construct a probabilistic graphical model, and (4) use the plan-level distribution to sample plan solutions. The proposed approach is modular as the individual skill factors and constraints can be flexibly connected to form new graphs. GFC can connect parallel skill chains with added spatial factors to solve coordinated manipulation problems directly at inference. Additional detail in [algorithm 1]Appendix S2 Additional Related Works ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\").",
            "citations": null
          },
          "5 Experiment": {
            "content": "In this section, we seek to validate the following hypotheses: (1) GFC relaxes strict temporal dependency to allow spatial-temporal reasoning, performing better or on par with prior works in single-arm long-horizon sequential manipulation tasks, (2) GFC can effectively solve unseen coordination tasks, and (3) GFC is adept in reasoning about long-horizon action dependency while being robust to increasing task horizons. We systematically evaluated our method on 9 long-horizon single-arm manipulation tasks from prior works and 4 complex multi-arm coordination tasks in simulation. We also demonstrate deploying GFC on a bimanual Franka Panda setup in the real world.\n\nRelevant baselines and metrics: Our proposed method is based on factorized states and supports long-horizon planning for collaborative tasks directly at inference via probabilistic chaining. In this context, we consider prior methods based on probabilistic chaining with vectorized states (GSC\\[ [6])\\]) and discriminative search-based approaches for solving long-horizon planning by skill chaining: with uniform priors (Random CEM or RCEM) or learned policy priors (STAP\\[ [5])\\]). Since all prior works use sequential planning, we compare the performance of the proposed method on the sequential version of the parallel skeleton.\n\n### 5.1 Setup\n\nSkill Data Collection and Skill Training We consider a finite set of parameterized skills in our skill library. While our framework supports flexible addition of new skills to the skill library, we choose skills appropriate for the considered tasks. The parameterization, data collection, and training method for each of the skills is described as follows:\n\n1. 1.\n\n\nPick: Gripper picks up an object from the table and the parameters contain 6-DoF pose in the object’s frame of reference. The skill diffusion models are trained on successful pick actions on all the available set of objects namely lid, cube, hammer, and nail/stake.\n\n2. 2.\n\n\nPlace: Gripper places an object at the target location and parameters contain 6-DoF pose in the place target’s frame of reference. This skill requires specifying two set of parameters, the target pose and the target object (e.g. box, table). The picked object is placed and successful placements are used to train the skill diffusion model.\n\n3. 3.\n\n\nMove: Gripper reaches a target location with an object in hand and parameters contain 6-DoF pose in the manipulator’s frame of reference within the workspace. This skill captures the distribution of the reachable workspace of the robot. When composed with the Move skill of the second manipulator, the combined distribution captures the common workspace.\n\n4. 4.\n\n\nReGrasp: Gripper grasps object mid-air and the parameters contain 6-DoF pose in the object’s frame of reference. While collecting data directly for this skill is non-trivial, we consider that if an object is picked up with parameters q1subscript𝑞1q\\_{1} and moved with parameters q2subscript𝑞2q\\_{2}, then the object can be grasped at the workspace location defined by q2subscript𝑞2q\\_{2} with the ReGrasp parameters as q1subscript𝑞1q\\_{1}. Thus, we reuse Pick and Move data to train the skill diffusion model for ReGrasp. While this is a design choice, with appropriate skill level data, we can train this skill separately too.\n\n5. 5.\n\n\nPush: Gripper uses the grasped object to push away another object. The skill is motivated from prior work \\[ [6]), [5])\\] where a hook object is used to Push blocks. The parameters of this skill are (x,y,r,θ)𝑥𝑦𝑟𝜃(x,y,r,\\\\theta) such that the hook is placed at the (x,y)𝑥𝑦(x,y) position on the table and pushed by a distance r𝑟r in the radial direction θ𝜃\\\\theta w.r.t. the origin of the manipulator. The skill diffusion models is trained following GSC \\[ [6])\\].\n\n6. 6.\n\n\nPull: Gripper uses the grasped object to pull another object inwards. The skill is also motivated from prior work \\[ [6]), [5])\\] where a hook object is used to Pull blocks. The parameters of this skill are (x,y,r,θ)𝑥𝑦𝑟𝜃(x,y,r,\\\\theta) such that the hook is placed at the (x,y)𝑥𝑦(x,y) position on the table and pulled by a distance r𝑟r in the radial direction θ𝜃\\\\theta w.r.t. the origin of the manipulator. The skill diffusion models is trained following GSC \\[ [6])\\].\n\n7. 7.\n\n\nStrike: Gripper strikes another object with one object in hand (e.g., a hammer). As a design choice, we do not train a skill diffusion model for this skill. Strike is primarily used as a terminal skill. We are only concerned about the pre-condition as their effects can be designed manually, which is similar to “subgoal skill” used in prior work. For example, in order to satisfy the pre-condition of Strike, the hammer and nail must be aligned. This can be satisfied in diverse configurations. However, the effect is achieved through a deterministic motion.\n\n8. 8.\n\n\nPour: Gripper rotates the object in hand in a pouring fashion. Similar to Strike, we use Pour as a terminal skill too. In order to satisfy the pre-condition of Pour, the transform between the source and target mug must belong to the family of admissible distributions. We achieve the actual trajectory by designing a deterministic motion. With appropriate skill level data, we can also train skill diffusion models, however, such improvement is out of scope of this work.\n\n\nTraining. We train individual skill diffusion score-functions using the denoising score-matching (DSM) loss following [algorithm 2]Appendix S3 Model Training and Architecture ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\"). We collect datasets of transitions observed during the execution of a skill on an object and use them to train the score networks. The dataset size varies according to the difficulty and diversity of a skill’s execution on a particular object. For example, we need 100 successful Pick parameters for training the skill to pick the hammer and 300 successful Move parameters to cover the whole workspace of the robot. For ReGrasp, we use both the Pick and Move parameters.\n\nEffect of training data coverage. If we consider “ideal” score functions and a perfect representation of the factor distributions, a solution exists if there is an overlap between two connected factor distributions. If such an overlapping segment does not exist, GFC will not be able to complete the spatial-temporal plan. Hence, the training data for each factor (here temporal factors only) must be diverse enough to ensure that the overlap exists. For example, a successful handover in Hammer Place and Hammer Strike is not possible if the training data only consists of Pick parameters to pick the hammer from the center of the handle. Similarly, if the training data for Move does not cover the common workspace of both robots, our proposed algorithm will be unable to complete the coordinated plan.\n\nExample of spatial factors. Previous work \\[ [25])\\] considered a family of spatial factors like (left, right, top, bottom, near and far) to model collision-free object configurations. In this work, we are particularly interested in constructing a family of fixed transforms (FixedTransform) to model coordinated manipulation motion. For example, in order to satisfy the pre-condition of strike(A, B), the transform between nodes A𝐴A and B𝐵B must satisfy a family of transforms signifying that B𝐵B must be Aligned with A𝐴A to strike it. Thus the factor for strike(A, B) with Aligned transforms ℋAsubscriptℋ𝐴\\\\mathcal{H}\\_{A} will look like: f≡distance​(transform​(A,B),ℋA)≤permisible error𝑓distancetransform𝐴𝐵subscriptℋ𝐴permisible errorf\\\\equiv\\\\text{distance}(\\\\text{transform}(A,B),\\\\mathcal{H}\\_{A})\\\\leq\\\\text{permisible error} for at least one transform. In that case, the distribution of the factor will be: p​(f=True\\|A,B)∝exp⁡\\[−distance​(transform​(A,B),ℋA)\\]proportional-to𝑝𝑓conditionalTrue𝐴𝐵distancetransform𝐴𝐵subscriptℋ𝐴p(f=\\\\texttt{True}\\|A,B)\\\\propto\\\\exp\\[-\\\\text{distance}(\\\\text{transform}(A,B),\\\\mathcal{H}\\_{A})\\]. The score of such a distribution can then be calculated as\n\n|     |     |     |\n| --- | --- | --- |\n|  | ϵf​(A(t),B(t),t)=−∇A(t),B(t)distance​(transform​(A(t),B(t)),hA)subscriptitalic-ϵ𝑓superscript𝐴𝑡superscript𝐵𝑡𝑡subscript∇superscript𝐴𝑡superscript𝐵𝑡distancetransformsuperscript𝐴𝑡superscript𝐵𝑡subscriptℎ𝐴\\\\epsilon\\_{f}(A^{(t)},B^{(t)},t)=-\\\\nabla\\_{A^{(t)},B^{(t)}}\\\\text{distance}(\\\\text{transform}(A^{(t)},B^{(t)}),h\\_{A}) |  |\n\nwhere hA∈ℋAsubscriptℎ𝐴subscriptℋ𝐴h\\_{A}\\\\in\\\\mathcal{H}\\_{A} is the closest transform to the current transform. The distance between transforms is calculated as the summation of the Cartesian distance and the quaternion distance.\n\n![Refer to caption]Figure 3: Evaluation tasks: (a) Hook reach: Hook is used to pull an object in the robot’s workspace followed by other skills. (b) Constrained packing: Multiple objects must be placed on a rack without collisions. (c) Rearrangement push: Hook is used to push objects to a desired arrangement followed by other skills. (d) Hammer place: A hammer must be handed over to another manipulator and placed in a target box. (e) Hammer nail: A hammer must be handed over to another manipulator and a configuration must be achieved to strike a nail. (f) Pour cup: Cups must be brought in a configuration that allows successful pouring from one to another.\n\n### 5.2 Key Findings\n\nGFC relaxes strict linear dependency assumptions. We first evaluate GFC on single-manipulator long-horizon tasks introduced by STAP \\[ [5])\\] and also used by GSC \\[ [6])\\]. These tasks consider manipulation by reasoning about the usage of a tool (a hook) to manipulate blocks out of or into the robot workspace (sample initial states shown in [Figure 3]Figure 3 ‣ 5.1 Setup ‣ 5 Experiment ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\")(a-c)). Hook Reach is to hook the cube in order for the arm to grasp and move the block to a target. Rearrangement Push requires placing a cube such that it can be pushed beneath a rack using the tool. Constrained Packing is to place four cubes on a constrained surface without collisions. While these tasks are originally designed to highlight linear sequential dependencies, there are steps with indirect dependencies or independence that only GFC can effectively model because of the factorized states. For example, in Rearrangement Push, the picking pose of the cube should not affect the tool use steps. As shown in [Table 1]Table 1 ‣ 5.2 Key Findings ‣ 5 Experiment ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\"), we observe that the performance of GFC is consistently on-par with the baseline for tasks with strict linear dependencies such as Hook Reach and on-par or better for tasks with more complex dependency structures such as Rearrangement Push. This validates our hypothesis that GFC effectively models sequential dependencies, in addition to independence and skipped-step dependencies in long-horizon tasks.\n\nTable 1: We show performance comparison of our method with relevant baselines on 9 single manipulator tasks and 3 two-manipulator tasks based on 100 trials for each of them. The task length shows the relative difficulty of solving them. We also conduct evaluation on 3 extended tasks to show robustness of GFC to task length (\\|𝒯\\|𝒯\\|\\\\mathcal{T}\\|) and efficient reasoning about interstep dependencies. More details about the environments are provided in [Supp. S4]Appendix S4 More Details on Evaluation Tasks ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\") and [Supp. S5]Appendix S5 Extending Hammer Nail task to longer horizons ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\"). We also provide the breakdown of success rate per skill step in [Supp. S6]Appendix S6 Justifying success rates with breakdowns ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\").\n\n|     |     |     |     |     |     |     |     |     |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| Evaluation Tasks | RCEM | DAF \\[ [4])\\] | STAP \\[ [5])\\] | GSC \\[ [6])\\] | GFC | \\|𝒯\\|𝒯\\|\\\\mathcal{T}\\| |\n| SingleManipulator | Hook Reach | T1 | 0.54 | 0.32 | 0.88 | 0.84 | 0.82 | 4 |\n| T2 | 0.40 | 0.05 | 0.82 | 0.84 | 0.82 | 5 |\n| T3 | 0.30 | 0.00 | 0.76 | 0.76 | 0.80 | 5 |\n| RearrangementPush | T1 | 0.30 | 0.0 | 0.40 | 0.68 | 0.68 | 4 |\n| T2 | 0.10 | 0.08 | 0.52 | 0.60 | 0.65 | 6 |\n| T3 | 0.02 | 0.0 | 0.18 | 0.18 | 0.25 | 8 |\n| ConstrainedPacking | T1 | 0.45 | 0.45 | 0.65 | 0.75 | 0.75 | 6 |\n| T2 | 0.45 | 0.70 | 0.68 | 1.0 | 1.0 | 6 |\n| T3 | 0.10 | 0.0 | 0.20 | 1.0 | 1.0 | 8 |\n| BimanualManipulation | Hammer Place | 0.05 | - | 0.28 | 0.41 | 0.63 | 8 |\n| Pour Cup | 0.10 | - | 0.18 | 0.15 | 0.41 | 4 |\n| Hammer Nail | 0.02 | - | 0.15 | 0.15 | 0.34 | 11 |\n| Longer Horizon Evaluation Tasks |\n| Handback Hammer Nail | 0.24 | 16 |\n| Handback Hammer Nail w/ auxilliary tasks | 0.25 | 18 |\n| Handback Hammer Nail w/ extended auxilliary tasks | 0.21 | 20 |\n\nGFC can solve complex coordinated manipulation tasks. Here, we aim to validate that GFC can effectively plan and solve different types of coordinated manipulation tasks. We present results on tasks with increased collaboration challenges. First, we consider tasks that require coordination but can be serialized into interleaved skill chains and solved by prior skill-chaining methods. Hammer Place, as shown in [Figure S17]Figure S17 ‣ Appendix S5 Extending Hammer Nail task to longer horizons ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\"), is for one arm to pick a hammer, hand it over to another arm for placemement into a target box. Hammer Nail is an extension where, after hammer handover, first arm picks up a nail and both arms coordinate to move to positions such that the hammer’s head is aligned with the nail for the subsequent striking step. The task is illustrated in [Figure S17]Figure S17 ‣ Appendix S5 Extending Hammer Nail task to longer horizons ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\"). As evident from [Table 1]Table 1 ‣ 5.2 Key Findings ‣ 5 Experiment ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\"), GFC significantly outperforms all baselines in both tasks. The gap is larger in the more challenging _Hammer Nail_ task, which includes additional spatial and temporal constraints such as the hammer must be re-grasped towards the tail end for the subsequent hammering step, and the hammer and nail must be aligned for a successful strike. This demonstrates that GFC can effectively model and resolve both spatial and temporal constraints in complex tasks.\n\n![Refer to caption]Figure 4: Evaluating GFC on bimanual reorientation where two arms simultaneously pick and reorient a pot.\n\nGFC can zero-shot generalize to new bimanual tasks by composing single-arm skill chains. The Pour Cup ( [Figure 11]Figure 11 ‣ 5.3 Real Robot Experiments ‣ 5 Experiment ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\")) task is to Pick a cup with each arm, Move to position the two cups, and Pour the content of one into the other. GFC can directly reuse Pick and Move skill models and adapt the Strike skill model for the Pour step by adding a new spatial constraint. Unlike hammer that can strike from either face of the head, the cups can only be poured using the open top and not the closed bottom. The constraint can be directly added as a factor and optimized globally through guided diffusion process. A quantitative comparison is shown in [Table 1]Table 1 ‣ 5.2 Key Findings ‣ 5 Experiment ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\").\n\nFinally, we consider the Bimanual Reorientation ( [Figure 12]Figure 12 ‣ 5.3 Real Robot Experiments ‣ 5 Experiment ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\")) task where two arms must simultaneously operate on the same object of interest (a pot), lift it up, and rotate it to a target reorientation angle (about z-axis) as illustrated in [Figure 4]Figure 4 ‣ 5.2 Key Findings ‣ 5 Experiment ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\") (Top) for a 454545-deg angle. The tasks must be solved via parallel skill chaining with spatial constraints and hence none of the prior baselines can be used. The factor graph ( [Figure 2]Figure 2 ‣ 4.1 Representing States, Skills, and Plans in Factor Graphs ‣ 4 Method ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\") Right) includes a spatial fixed transform constraint between both the arms and hence the subsequent skills operate while satisfying the constraint. [Figure 4]Figure 4 ‣ 5.2 Key Findings ‣ 5 Experiment ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\") (Bottom) shows a detailed task success rate breakdown given different orientation goals. The spatial and temporal challenges posed by the task are detailed further in [Supp. S4]Appendix S4 More Details on Evaluation Tasks ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\").\n\nGFC can handle independence and inconsistent skill chains. Here, we analyze how _independent_ steps in a sequential manipulation chain affects the performance of each method. We consider Hammer Place, where the order of transporting the cube and handing over hammer is interchangeable. As illustrated in [Figure 5]Figure 5 ‣ 5.2 Key Findings ‣ 5 Experiment ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\"), we consider a _consistent_ plan skeleton where sequentially-dependent steps for the two main objectives, i.e., (1) opening lid then transporting cube and (2) picking, handing over, and placing hammers, are completely sequentially. We also consider an _inconsistent_ plan skeleton where the steps are interleaved. We show the handover success and overall task success in [Figure 5]Figure 5 ‣ 5.2 Key Findings ‣ 5 Experiment ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\") (Right). A successful handover requires choosing compatible parameters for Pick, Regrasp, and Move skills. While this increases the difficulty leading to lower scores in the handover success rate, even with a minor distraction in inconsistent skeleton, the previous approaches failed to propagate the skipped-step dependencies as evident from the task success rate.\n\n![Refer to caption]Figure 5: Linear chaining has limitations. Baseline methods with linear chain assumption suffers from performance drop when given inconsistent skill chains, where steps with sequential dependencies are swapped. GFC retains high success rate using the parallel skeleton.![Refer to caption]Figure 6: Analysis of coordination. We show that the planner is able to reason about the long-horizon action dependency of Pick and Grasp skills. (Left) While we see that Hammer Place can be solved by pick/grasp at head/tail and vice versa, to satisfy the precondition of Strike in Hammer Nail, the hammer must be grasped near tail so must be picked near head. (Right) We show orientation reasoning, where the hammer can either be grasped on the same side or the flip side.\n\nGFC can reason about action dependency while being robust to increasing task horizons. We observe in  [Figure 6]Figure 6 ‣ 5.2 Key Findings ‣ 5 Experiment ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\") (left) that while Hammer Place task can be solved by picking or grasping on any end of the hammer handle, Hammer Nail requires more constrained parameter sampling. Further, in addition to the parameter selection along the handle axis, the method also samples suitable orientation (same or flip side) for grasping as shown by two examples in [Figure 6]Figure 6 ‣ 5.2 Key Findings ‣ 5 Experiment ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\") (right). We further give an example of the capability of our method in handling longer horizon inter-step dependencies.\nWe particularly want to emphasize that hammering a nail not only requires extensive affordance planning to perform a handover but also requires allowing sufficient reachable workspace to align the hammer head with the nail. For an even longer task which requires performing a second handover, the choice of parameters for the first handover also affects the success of the second handover, thus increasing the action-dependency horizon as illustrated in [Figure 7]Figure 7 ‣ 5.2 Key Findings ‣ 5 Experiment ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\"). Our framework is able to compose learned factors (diffusion models) to solve a wide variety of tasks, as long as their solutions fall in the combinatorial space. We also want to emphasize that GFC is robust with respect to the task length as shown in [Table 1]Table 1 ‣ 5.2 Key Findings ‣ 5 Experiment ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\").\n\n![Refer to caption]Figure 7: Inter-step dependencies. We show the steps and reasoning required to solve the Hammer Nail task. An improper initial pick can lead to a failed or unfavorable handover which might lead to difficulty in performing Strike and the second handover. Thus the algorithm must reason about inter-step action dependency over longer horizons to solve the task successfully.![Refer to caption]Figure 8: Real-World Experimental Setup\n\n### 5.3 Real Robot Experiments\n\nComplete setup.\nWe use two Franka Panda robot arms placed in parallel to demonstrate the coordinated tasks as illustrated in [Figure 8]Figure 8 ‣ 5.2 Key Findings ‣ 5 Experiment ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\"). A pair of flexible Finray fingers \\[ [43])\\] is attached to the parallel jaw grippers. For each of the arm, we set up a Kinect Azure camera calibrated to the origin of the arm. We use objects like mallet (hammer), stake (tent peg, nail), garden foam, a kitchen pot, two types of mugs and a rack for the considered tasks. We use segment-anything \\[ [44])\\] and CLIP \\[ [45])\\] to segment the objects from the RGBD image based on text descriptions and use the segmented masks to obtain the point clouds for the objects. Finally, we use ICP to align the obtained and model point clouds to calculate the transformation of the object. The procedure is done for both cameras to obtain transforms for all the detected objects in both robot’s frame of reference. For a particular object, we select the transform from the arm closest to the object to get precise pose estimation (due to better depth data). We finally use the obtained transforms to recreate the physical scene in simulation, employ GFC in simulation and rollout the results in the real-world. While planning, the Frankx controller \\[ [46])\\] is used to generate smooth motion toward the desired pose.\n\nQualitative analysis. We perform qualitative analysis for all four coordinated tasks using the hardware setup as shown in [Figure 9]Figure 9 ‣ 5.3 Real Robot Experiments ‣ 5 Experiment ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\"), [Figure 10]Figure 10 ‣ 5.3 Real Robot Experiments ‣ 5 Experiment ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\"), [Figure 11]Figure 11 ‣ 5.3 Real Robot Experiments ‣ 5 Experiment ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\") and [Figure 12]Figure 12 ‣ 5.3 Real Robot Experiments ‣ 5 Experiment ‣ Generative Factor Chaining: Coordinated Manipulation with Diffusion-based Factor Graph\"). We further provide detailed videos of execution in the supplementary video.\n\n![Refer to caption]Figure 9: Coordination task: Hammer Place The left arm must handover the hammer to the right arm such that the hammer can be placed inside the box.![Refer to caption]Figure 10: Coordination task: Hammer Nail The left arm must handover the hammer to the right arm and pick up the nail. Both arms have to coordinate in order to move the hammer and nail to a configuration in which the hammer can strike the nail.![Refer to caption]Figure 11: Coordination task: Pour Cup The left arm and right arm must pick up the pink mug and green mug respectively. Both arms have to coordinate in order to move the mugs to a configuration in which the left arm can pour the pink mug contents into the green mug.![Refer to caption]Figure 12: Coordination task: Bimanual Reorientation The left arm and right arm must pick up the pot simultaneously. Both arms have to coordinate in order to rotate the pot to a specified target reorientation angle. For the above illustration, the reorientation angle is 30deg.\n\nFailure analysis. We try to analyze the reason for the failure of GFC in certain cases. A limiting factor of our planning framework is that the nodes denote waypoints required to be reached for completing the geometric execution and satisfying the goal condition without caring about the trajectory between them. Since we do not explicitly provide the intuition of inverse kinematics (IK) or collision, we assume that these properties are learned implicitly using the successful transitions in the training data. Hence, apart from sim-to-real gap (consisting of pose-estimation error, nature of surfaces in contact, and weight of the objects like hammer and pot), the primary reasons for failure are: (1) sampling a pose where IK cannot be computed, i.e. unreachable. (2) The sampled pose is not collision-free. We provide sim-to-real gap failures in the supplementary video.",
            "citations": null
          },
          "6 Limitations and Future Directions": {
            "content": "First, our method does not generate high-level task plans. Solving the full TAMP problem with a unified generative model is an important future direction. Second, our method operates in a low-dimensional state space and hence requires a state estimator. We plan to extend GFC to work with high-dimensional observations. Finally, similar to prior works \\[ [4]), [5]), [6])\\], our approach operates on parameterized skills. Future work can explore integrating learned skills or trajectory generators for additional generality and scalability.",
            "citations": null
          },
          "7 Conclusion": {
            "content": "We presented GFC, a learning-to-plan method for complex coordinated manipulation tasks. GFC can flexibly represent multi-arm manipulation with one or more objects with a spatial-temporal factor graph. During inference, GFC composes factor graphs where each factor is a diffusion model and samples long-horizon plans with reverse denoising. GFC is shown to solve sequential and coordinated tasks directly at inference and reason about long-horizon action dependency across multiple temporal chains. Our framework generalizes well to unseen multiple-manipulator tasks.",
            "citations": null
          }
        },
        "abstract": "Learning to plan for multi-step, multi-manipulator tasks is notoriously\ndifficult because of the large search space and the complex constraint\nsatisfaction problems. We present Generative Factor Chaining~(GFC), a\ncomposable generative model for planning. GFC represents a planning problem as\na spatial-temporal factor graph, where nodes represent objects and robots in\nthe scene, spatial factors capture the distributions of valid relationships\namong nodes, and temporal factors represent the distributions of skill\ntransitions. Each factor is implemented as a modular diffusion model, which are\ncomposed during inference to generate feasible long-horizon plans through\nbi-directional message passing. We show that GFC can solve complex bimanual\nmanipulation tasks and exhibits strong generalization to unseen planning tasks\nwith novel combinations of objects and constraints. More details can be found\nat: https://generative-fc.github.io/"
      },
      "bib.bib22": {
        "id": "bib.bib22",
        "citation": "Okumura (2024)",
        "authors": "",
        "year": "",
        "title": "Engineering lacam*: Towards real-time, large-scale, and near-optimal multi-agent pathfinding.",
        "venue": "23rd International Conference on Autonomous Agents and Multiagent Systems",
        "pages": "",
        "url": "",
        "arxiv_id": "2308.04292",
        "doi": null,
        "sections": {},
        "abstract": "This paper addresses the challenges of real-time, large-scale, and\nnear-optimal multi-agent pathfinding (MAPF) through enhancements to the\nrecently proposed LaCAM* algorithm. LaCAM* is a scalable search-based algorithm\nthat guarantees the eventual finding of optimal solutions for cumulative\ntransition costs. While it has demonstrated remarkable planning success rates,\nsurpassing various state-of-the-art MAPF methods, its initial solution quality\nis far from optimal, and its convergence speed to the optimum is slow. To\novercome these limitations, this paper introduces several improvement\ntechniques, partly drawing inspiration from other MAPF methods. We provide\nempirical evidence that the fusion of these techniques significantly improves\nthe solution quality of LaCAM*, thus further pushing the boundaries of MAPF\nalgorithms."
      }
    },
    "key_map": {
      "2201.09865": "bib.bib19",
      "2409.16275": "bib.bib21",
      "2308.04292": "bib.bib22"
    }
  }
}