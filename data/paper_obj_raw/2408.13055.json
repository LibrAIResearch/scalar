{
  "title": "Atlas Gaussians Diffusion for 3D Generation",
  "abstract": "Using the latent diffusion model has proven effective in developing novel 3D\ngeneration techniques. To harness the latent diffusion model, a key challenge\nis designing a high-fidelity and efficient representation that links the latent\nspace and the 3D space. In this paper, we introduce Atlas Gaussians, a novel\nrepresentation for feed-forward native 3D generation. Atlas Gaussians represent\na shape as the union of local patches, and each patch can decode 3D Gaussians.\nWe parameterize a patch as a sequence of feature vectors and design a learnable\nfunction to decode 3D Gaussians from the feature vectors. In this process, we\nincorporate UV-based sampling, enabling the generation of a sufficiently large,\nand theoretically infinite, number of 3D Gaussian points. The large amount of\n3D Gaussians enables the generation of high-quality details. Moreover, due to\nlocal awareness of the representation, the transformer-based decoding procedure\noperates on a patch level, ensuring efficiency. We train a variational\nautoencoder to learn the Atlas Gaussians representation, and then apply a\nlatent diffusion model on its latent space for learning 3D Generation.\nExperiments show that our approach outperforms the prior arts of feed-forward\nnative 3D generation.",
  "paper_id": "http://arxiv.org/abs/2408.13055v2",
  "markdown_content": "# Atlas Gaussians Diffusion for 3D Generation   with Infinite Number of Points\n\nHaitao Yang1   Yuan Dong2   Hanwen Jiang1   Dejia Xu1   Georgios Pavlakos1   Qixing Huang 1\n\n1The University of Texas at Austin        2Alibaba Group\n\n###### Abstract\n\nUsing the latent diffusion model has proven effective in developing novel 3D generation techniques. To harness the latent diffusion model, a key challenge is designing a high-fidelity and efficient representation that links the latent space and the 3D space.\nIn this paper, we introduce Atlas Gaussians, a novel representation for feed-forward native 3D generation. Atlas Gaussians represent a shape as the union of local patches, and each patch can decode 3D Gaussians. We parameterize a patch as a sequence of feature vectors and design a learnable function to decode 3D Gaussians from the feature vectors. In this process, we incorporate UV-based sampling, enabling the generation of a sufficiently large, and theoretically infinite, number of 3D Gaussian points. The large amount of 3D Gaussians enables high-quality details of generation results. Moreover, due to local awareness of the representation, the transformer-based decoding procedure operates on a patch level, ensuring efficiency.\nWe train a variational autoencoder to learn the Atlas Gaussians representation, and then apply a latent diffusion model on its latent space for learning 3D Generation.\nExperiments show that our approach outperforms the prior arts of feed-forward native 3D generation.\n\n![[Uncaptioned image]](https://ar5iv.org/html/2408.13055/assets/x1.png)\n\nFigure 1:\nWe propose the Atlas Gaussians representation for 3D generation. Our method supports both unconditional (left) and conditional (middle) generation with great diversity. With Atlas Gaussians, we can generate a sufficiently large, and theoretically infinite, number of 3D Gaussian points. To demonstrate this, 100K Gaussian points generated by our method are shown (right). Additionally, we iteratively sample 32 patches of the shape, displaying each set in one of four subfigures (right).\n\n## 1 Introduction\n\n3D generation has become increasingly important across various domains, including virtual reality, gaming, and film production. Recent advances in diffusion models \\[ [32](https://ar5iv.org/html/2408.13055#bib.bib32 \"\"), [91](https://ar5iv.org/html/2408.13055#bib.bib91 \"\")\\] have improved the 3D generation quality, offering superior performance over previous methods, such as variational autoencoders (VAEs) \\[ [46](https://ar5iv.org/html/2408.13055#bib.bib46 \"\"), [68](https://ar5iv.org/html/2408.13055#bib.bib68 \"\")\\] and generative adversarial networks (GANs)\\[ [23](https://ar5iv.org/html/2408.13055#bib.bib23 \"\"), [21](https://ar5iv.org/html/2408.13055#bib.bib21 \"\")\\].\n\nDespite progress, the effectiveness of 3D generation still falls short when compared to 2D generation models \\[ [33](https://ar5iv.org/html/2408.13055#bib.bib33 \"\"), [79](https://ar5iv.org/html/2408.13055#bib.bib79 \"\"), [83](https://ar5iv.org/html/2408.13055#bib.bib83 \"\")\\]. The robust performance in 2D generation is largely due to the effective integration of VAEs with latent diffusion models (LDMs) \\[ [82](https://ar5iv.org/html/2408.13055#bib.bib82 \"\")\\].\nA primary challenge hindering the complete success of this paradigm in 3D generation is the development of a high-fidelity 3D representation that can be efficiently embedded into a low-dimensional latent space. Pioneering efforts have applied diffusion models to various traditional 3D representations, such as point clouds \\[ [112](https://ar5iv.org/html/2408.13055#bib.bib112 \"\"), [120](https://ar5iv.org/html/2408.13055#bib.bib120 \"\"), [63](https://ar5iv.org/html/2408.13055#bib.bib63 \"\")\\], meshes \\[ [60](https://ar5iv.org/html/2408.13055#bib.bib60 \"\")\\], occupancy fields \\[ [118](https://ar5iv.org/html/2408.13055#bib.bib118 \"\"), [114](https://ar5iv.org/html/2408.13055#bib.bib114 \"\")\\] and signed distance functions \\[ [13](https://ar5iv.org/html/2408.13055#bib.bib13 \"\"), [50](https://ar5iv.org/html/2408.13055#bib.bib50 \"\")\\]. However, these approaches often focus solely on modeling geometry without considering the appearance attributes. More recently, a notable attempt \\[ [48](https://ar5iv.org/html/2408.13055#bib.bib48 \"\")\\] has designed a VAE that uses volume rendering techniques \\[ [66](https://ar5iv.org/html/2408.13055#bib.bib66 \"\")\\] to incorporate appearance modeling. Nevertheless, volume rendering presents inherent limitations, including slow rendering speeds and constrained rendering resolutions. To overcome these limitations, we have developed a VAE that leverages the latest 3D Gaussian representation \\[ [45](https://ar5iv.org/html/2408.13055#bib.bib45 \"\")\\], which significantly improves both the quality and speed of rendering.\n\nDesigning a VAE based on 3D Gaussians presents considerable challenges. The first challenge lies in creating an efficient decoder capable of mapping low-dimensional latents to 3D Gaussians. Existing methods for 3D Gaussian decoding predominantly focus on reconstruction tasks and typically lack an information bottleneck design \\[ [97](https://ar5iv.org/html/2408.13055#bib.bib97 \"\"), [109](https://ar5iv.org/html/2408.13055#bib.bib109 \"\")\\], thus failing to provide low-dimensional latent directly. Alternatively, they often require multiple complex and interdependent components \\[ [105](https://ar5iv.org/html/2408.13055#bib.bib105 \"\"), [121](https://ar5iv.org/html/2408.13055#bib.bib121 \"\")\\]. The second challenge involves generating a sufficiently large number of 3D Gaussians efficiently, since high-quality rendering necessitates an adequate quantity of these Gaussians. Some current methods \\[ [105](https://ar5iv.org/html/2408.13055#bib.bib105 \"\"), [121](https://ar5iv.org/html/2408.13055#bib.bib121 \"\")\\] address this by employing additional complex point-upsampling networks to increase the number of 3D Gaussians, which inherently limits the number of Gaussians that can be generated. Other techniques \\[ [97](https://ar5iv.org/html/2408.13055#bib.bib97 \"\"), [109](https://ar5iv.org/html/2408.13055#bib.bib109 \"\")\\] utilize image representations to generate a large number of 3D Gaussians. However, for all these methods, more network parameters are usually required as the number of 3D Gaussians increases.\n\nTo address the challenges of designing VAEs for 3D Gaussians, we propose Atlas Gaussians, a new representation for 3D generation. This representation is inspired by surface parameterization \\[ [20](https://ar5iv.org/html/2408.13055#bib.bib20 \"\")\\], a fundamental technique in many graphics applications where surface attributes are sampled and stored in a 2D texture map. Specifically, Atlas Gaussians model the shape as a union of local patches, with each patch decoding 3D Gaussians via UV-based sampling. By parameterizing 3D Gaussians in the UV space, we can easily generate a sufficiently large, and theoretically infinite, number of 3D Gaussians. Unlike traditional surface parameterization approaches, the UV mapping in Atlas Gaussians are learned end-to-end using a corner-encoding scheme. A significant advantage of Atlas Gaussians is that the sampling process does not require additional network parameters as the number of 3D Gaussians increases.\n\nWe design a transformer-based decoder to map low-dimensional latents to Atlas Gaussians. This decoder achieves geometry and appearance disentanglement by design, facilitating faster convergence and improved representation capabilities.\nLeveraging the local awareness of Atlas Gaussians, we also reduce computational complexity by decomposing the self-attention layers.\nFinally, the latent space learned by our VAE can be applied to existing latent diffusion models efficiently.\n\nNote that in contrast to the major approach in 3D generation that uses the multi-view representation \\[ [100](https://ar5iv.org/html/2408.13055#bib.bib100 \"\"), [61](https://ar5iv.org/html/2408.13055#bib.bib61 \"\"), [59](https://ar5iv.org/html/2408.13055#bib.bib59 \"\"), [86](https://ar5iv.org/html/2408.13055#bib.bib86 \"\")\\], our approach is inherently 3D-based. Therefore, a key advantage is that we do not need to address the challenging multi-view consistency issue associated the multi-view representation.\nWe take inspiration from the literature that 3D-based neural networks learn better 3D features for recognition and outperform multi-view based networks that leverage massive 2D labeled data.\nMoreover, the rendering module of Atlas Gaussians allows representation learning from images.\n\nIn summary, we make the following contributions.\n\n• We propose Atlas Gaussians, a new 3D representation that can efficiently decode a sufficiently large and theoretically infinite number of 3D Gaussians for high-quality 3D generation.\n\n• We design a new transformer-based decoder to map low-dimensional latents to Atlas Gaussians, achieving geometry and appearance disentanglement by design along with efficient computation.\n\n• We pioneer the integration of 3D Gaussians into the VAE + LDM paradigm, demonstrating superior performance on standard 3D generation benchmarks.\n\n## 2 Related work\n\n3D representation. 3D reconstruction and generation benefit from different 3D representations by leveraging their unique properties. These representations include explicit representations \\[ [103](https://ar5iv.org/html/2408.13055#bib.bib103 \"\"), [67](https://ar5iv.org/html/2408.13055#bib.bib67 \"\"), [80](https://ar5iv.org/html/2408.13055#bib.bib80 \"\"), [112](https://ar5iv.org/html/2408.13055#bib.bib112 \"\"), [120](https://ar5iv.org/html/2408.13055#bib.bib120 \"\"), [63](https://ar5iv.org/html/2408.13055#bib.bib63 \"\"), [94](https://ar5iv.org/html/2408.13055#bib.bib94 \"\"), [104](https://ar5iv.org/html/2408.13055#bib.bib104 \"\"), [108](https://ar5iv.org/html/2408.13055#bib.bib108 \"\"), [95](https://ar5iv.org/html/2408.13055#bib.bib95 \"\"), [1](https://ar5iv.org/html/2408.13055#bib.bib1 \"\"), [18](https://ar5iv.org/html/2408.13055#bib.bib18 \"\"), [60](https://ar5iv.org/html/2408.13055#bib.bib60 \"\"), [71](https://ar5iv.org/html/2408.13055#bib.bib71 \"\"), [88](https://ar5iv.org/html/2408.13055#bib.bib88 \"\"), [25](https://ar5iv.org/html/2408.13055#bib.bib25 \"\"), [10](https://ar5iv.org/html/2408.13055#bib.bib10 \"\"), [45](https://ar5iv.org/html/2408.13055#bib.bib45 \"\"), [97](https://ar5iv.org/html/2408.13055#bib.bib97 \"\"), [109](https://ar5iv.org/html/2408.13055#bib.bib109 \"\"), [121](https://ar5iv.org/html/2408.13055#bib.bib121 \"\"), [96](https://ar5iv.org/html/2408.13055#bib.bib96 \"\")\\] and implicit representations \\[ [73](https://ar5iv.org/html/2408.13055#bib.bib73 \"\"), [11](https://ar5iv.org/html/2408.13055#bib.bib11 \"\"), [65](https://ar5iv.org/html/2408.13055#bib.bib65 \"\"), [50](https://ar5iv.org/html/2408.13055#bib.bib50 \"\"), [119](https://ar5iv.org/html/2408.13055#bib.bib119 \"\"), [87](https://ar5iv.org/html/2408.13055#bib.bib87 \"\"), [41](https://ar5iv.org/html/2408.13055#bib.bib41 \"\"), [38](https://ar5iv.org/html/2408.13055#bib.bib38 \"\"), [107](https://ar5iv.org/html/2408.13055#bib.bib107 \"\"), [66](https://ar5iv.org/html/2408.13055#bib.bib66 \"\"), [113](https://ar5iv.org/html/2408.13055#bib.bib113 \"\"), [6](https://ar5iv.org/html/2408.13055#bib.bib6 \"\"), [26](https://ar5iv.org/html/2408.13055#bib.bib26 \"\"), [8](https://ar5iv.org/html/2408.13055#bib.bib8 \"\"), [5](https://ar5iv.org/html/2408.13055#bib.bib5 \"\"), [69](https://ar5iv.org/html/2408.13055#bib.bib69 \"\"), [102](https://ar5iv.org/html/2408.13055#bib.bib102 \"\")\\].\nIn this paper, we focus on 3D Gaussians \\[ [45](https://ar5iv.org/html/2408.13055#bib.bib45 \"\"), [97](https://ar5iv.org/html/2408.13055#bib.bib97 \"\"), [109](https://ar5iv.org/html/2408.13055#bib.bib109 \"\"), [121](https://ar5iv.org/html/2408.13055#bib.bib121 \"\"), [96](https://ar5iv.org/html/2408.13055#bib.bib96 \"\"), [29](https://ar5iv.org/html/2408.13055#bib.bib29 \"\")\\], which possess high-quality rendering procedures that allow learning from image supervisions. However, existing results mainly focus on reconstructing 3D Gaussians. Our goal is to push the state-of-the-art in generative 3D Gaussians.\n\nOur method is also related to the Atlas representation initially proposed by AtlasNet \\[ [25](https://ar5iv.org/html/2408.13055#bib.bib25 \"\")\\] and its subsequent extensions \\[ [16](https://ar5iv.org/html/2408.13055#bib.bib16 \"\"), [55](https://ar5iv.org/html/2408.13055#bib.bib55 \"\"), [19](https://ar5iv.org/html/2408.13055#bib.bib19 \"\")\\]. AtlasNet models the shape as a union of independent MLPs, thus limiting the number of patches to a few dozen. In contrast, our proposed Atlas Gaussians model each patch using a patch center and patch features. This efficient encoding allows us to generate a significantly larger number of patches, providing stronger representation capabilities. Additionally, we use a transformer to learn this representation instead of an MLP, resulting in better scalability.\n\nDiffusion models.\nDiffusion models \\[ [90](https://ar5iv.org/html/2408.13055#bib.bib90 \"\"), [92](https://ar5iv.org/html/2408.13055#bib.bib92 \"\"), [91](https://ar5iv.org/html/2408.13055#bib.bib91 \"\")\\] have been dominant for diverse generation tasks, including image \\[ [33](https://ar5iv.org/html/2408.13055#bib.bib33 \"\"), [115](https://ar5iv.org/html/2408.13055#bib.bib115 \"\"), [75](https://ar5iv.org/html/2408.13055#bib.bib75 \"\"), [82](https://ar5iv.org/html/2408.13055#bib.bib82 \"\")\\], video \\[ [34](https://ar5iv.org/html/2408.13055#bib.bib34 \"\"), [31](https://ar5iv.org/html/2408.13055#bib.bib31 \"\"), [4](https://ar5iv.org/html/2408.13055#bib.bib4 \"\")\\], audio \\[ [37](https://ar5iv.org/html/2408.13055#bib.bib37 \"\"), [47](https://ar5iv.org/html/2408.13055#bib.bib47 \"\"), [54](https://ar5iv.org/html/2408.13055#bib.bib54 \"\")\\], text \\[ [51](https://ar5iv.org/html/2408.13055#bib.bib51 \"\"), [22](https://ar5iv.org/html/2408.13055#bib.bib22 \"\"), [53](https://ar5iv.org/html/2408.13055#bib.bib53 \"\")\\], and motion \\[ [116](https://ar5iv.org/html/2408.13055#bib.bib116 \"\"), [98](https://ar5iv.org/html/2408.13055#bib.bib98 \"\"), [111](https://ar5iv.org/html/2408.13055#bib.bib111 \"\")\\].\nThe success of these models typically follows the VAE + LDM paradigm. While pioneering efforts \\[ [112](https://ar5iv.org/html/2408.13055#bib.bib112 \"\"), [120](https://ar5iv.org/html/2408.13055#bib.bib120 \"\"), [63](https://ar5iv.org/html/2408.13055#bib.bib63 \"\"), [60](https://ar5iv.org/html/2408.13055#bib.bib60 \"\"), [118](https://ar5iv.org/html/2408.13055#bib.bib118 \"\"), [114](https://ar5iv.org/html/2408.13055#bib.bib114 \"\"), [13](https://ar5iv.org/html/2408.13055#bib.bib13 \"\"), [50](https://ar5iv.org/html/2408.13055#bib.bib50 \"\"), [43](https://ar5iv.org/html/2408.13055#bib.bib43 \"\"), [48](https://ar5iv.org/html/2408.13055#bib.bib48 \"\")\\] have attempted to apply this paradigm to 3D, the problem remains unsolved and has not achieved the same level of success. We argue that one of the main reasons is the need for an efficient VAE to represent high-quality 3D content, which is the key contribution of this paper.\n\n3D generation.\n3D generation methods can be classified into two genres. The first is optimization-based methods \\[ [40](https://ar5iv.org/html/2408.13055#bib.bib40 \"\"), [93](https://ar5iv.org/html/2408.13055#bib.bib93 \"\"), [99](https://ar5iv.org/html/2408.13055#bib.bib99 \"\"), [52](https://ar5iv.org/html/2408.13055#bib.bib52 \"\"), [101](https://ar5iv.org/html/2408.13055#bib.bib101 \"\"), [9](https://ar5iv.org/html/2408.13055#bib.bib9 \"\")\\], which are time-consuming due to per-shape optimization. For example, DreamField \\[ [40](https://ar5iv.org/html/2408.13055#bib.bib40 \"\")\\] uses CLIP guidance. DreamFusion \\[ [76](https://ar5iv.org/html/2408.13055#bib.bib76 \"\")\\] and SJC \\[ [99](https://ar5iv.org/html/2408.13055#bib.bib99 \"\")\\] introduce 2D diffusion priors in different formats. Magic3D \\[ [52](https://ar5iv.org/html/2408.13055#bib.bib52 \"\")\\] employs a coarse-to-fine pipeline to improve convergence speed. Prolificdreamer \\[ [101](https://ar5iv.org/html/2408.13055#bib.bib101 \"\")\\] uses variational score distillation to enhance generation fidelity. Fantasia3D \\[ [9](https://ar5iv.org/html/2408.13055#bib.bib9 \"\")\\] disentangles geometry and texture to achieve higher quality generation.\n\nThe second genre involves training a generalizable feed-forward network to output 3D content, which allows for fast 3D generation but often with less details. One direction is to apply existing generative modeling techniques (VAE \\[ [46](https://ar5iv.org/html/2408.13055#bib.bib46 \"\")\\], GAN \\[ [23](https://ar5iv.org/html/2408.13055#bib.bib23 \"\")\\], normalizing flow \\[ [81](https://ar5iv.org/html/2408.13055#bib.bib81 \"\")\\], autoregressive model \\[ [3](https://ar5iv.org/html/2408.13055#bib.bib3 \"\"), [24](https://ar5iv.org/html/2408.13055#bib.bib24 \"\")\\] and diffusion model) directly on various 3D representations. Another direction \\[ [106](https://ar5iv.org/html/2408.13055#bib.bib106 \"\"), [57](https://ar5iv.org/html/2408.13055#bib.bib57 \"\"), [56](https://ar5iv.org/html/2408.13055#bib.bib56 \"\"), [58](https://ar5iv.org/html/2408.13055#bib.bib58 \"\"), [84](https://ar5iv.org/html/2408.13055#bib.bib84 \"\"), [35](https://ar5iv.org/html/2408.13055#bib.bib35 \"\"), [97](https://ar5iv.org/html/2408.13055#bib.bib97 \"\")\\] uses 2D as intermediate representation, integrating 2D diffusion models \\[ [31](https://ar5iv.org/html/2408.13055#bib.bib31 \"\"), [86](https://ar5iv.org/html/2408.13055#bib.bib86 \"\")\\]. For example, Instant3D \\[ [49](https://ar5iv.org/html/2408.13055#bib.bib49 \"\")\\] trains a diffusion model to generate sparse multi-view images and uses a reconstruction model to derive the 3D shapes from the 2D images. VFusion3D \\[ [28](https://ar5iv.org/html/2408.13055#bib.bib28 \"\")\\] and V3D \\[ [12](https://ar5iv.org/html/2408.13055#bib.bib12 \"\")\\] use video diffusion models to improve the consistency between generated images. However, these methods rely on 2D representations and often suffer from multi-view consistency issues.\n\nIn this paper, we push the state-of-the-art in the first direction by developing a novel explicit representation Atlas Gaussians. Our representation is efficient and allows for learning 3D generative models from images.\n\n## 3 Method\n\n\\\\begin{overpic}\\[width=433.62pt\\]{figures/atlas\\_gaussians/atlas\\_gaussians.pdf}\n\\\\vspace{-0.2in}\n\\\\end{overpic}Figure 2: (Left) Atlas Gaussians 𝒜𝒜\\\\mathcal{A} model the shape as a union of patches, where each patch can decode 3D Gaussians. (Right) Each patch 𝒂isubscript𝒂𝑖\\\\boldsymbol{a}\\_{i} is parameterized by patch center 𝒙isubscript𝒙𝑖\\\\boldsymbol{x}\\_{i} and patch features 𝒇isubscript𝒇𝑖\\\\boldsymbol{f}\\_{i} and 𝒉isubscript𝒉𝑖\\\\boldsymbol{h}\\_{i}. The 3D Gaussians are decoded via the UV-based sampling.\n\nIn this section, we first introduce our Atlas Gaussians representation (Sec. [3.1](https://ar5iv.org/html/2408.13055#S3.SS1 \"3.1 Atlas Gaussians Representation ‣ 3 Method ‣ Atlas Gaussians Diffusion for 3D Generation with Infinite Number of Points\")). Then we introduce how we learn a variational autoencoder to connect the 3D space with a latent space (Sec. [3.2](https://ar5iv.org/html/2408.13055#S3.SS2 \"3.2 Stage 1: VAE ‣ 3 Method ‣ Atlas Gaussians Diffusion for 3D Generation with Infinite Number of Points\")). Finally, we introduce how we learn the generation model using latent diffusion in the learned latent space (Sec. [3.3](https://ar5iv.org/html/2408.13055#S3.SS3 \"3.3 Stage 2: latent diffusion model ‣ 3 Method ‣ Atlas Gaussians Diffusion for 3D Generation with Infinite Number of Points\")).\n\n### 3.1 Atlas Gaussians Representation\n\nIn 3D Gaussian Splatting \\[ [45](https://ar5iv.org/html/2408.13055#bib.bib45 \"\")\\], each 3D Gaussian 𝐠𝐠\\\\boldsymbol{\\\\mathrm{g}} can be parameterized with a center position 𝝁∈ℝ3𝝁superscriptℝ3\\\\boldsymbol{\\\\mathrm{\\\\mu}}\\\\in\\\\mathbb{R}^{3}, scale 𝐬∈ℝ3𝐬superscriptℝ3\\\\boldsymbol{\\\\mathrm{s}}\\\\in\\\\mathbb{R}^{3}, rotation quaternion 𝐫∈ℝ4𝐫superscriptℝ4\\\\boldsymbol{\\\\mathrm{r}}\\\\in\\\\mathbb{R}^{4}, opacity o∈ℝoℝ{\\\\mathrm{o}}\\\\in\\\\mathbb{R} and color 𝐜∈ℝ3𝐜superscriptℝ3\\\\boldsymbol{\\\\mathrm{c}}\\\\in\\\\mathbb{R}^{3}. To achieve high-quality rendering results, typically a sufficiently large number of 3D Gaussians are required.\n\nThe key idea of Atlas Gaussians is to represent the shape as a union of M𝑀M local patches 𝒜={𝒂i}i=1M𝒜superscriptsubscriptsubscript𝒂𝑖𝑖1𝑀\\\\mathcal{A}=\\\\{\\\\boldsymbol{a}\\_{i}\\\\}\\_{i=1}^{M}, where each patch 𝒂isubscript𝒂𝑖\\\\boldsymbol{a}\\_{i} can decode 3D Gaussians through UV-based sampling. As shown in Figure [2](https://ar5iv.org/html/2408.13055#S3.F2 \"Figure 2 ‣ 3 Method ‣ Atlas Gaussians Diffusion for 3D Generation with Infinite Number of Points\"), we parameterize each local patch 𝒂i:=(𝒙i,𝒇i,𝒉i)assignsubscript𝒂𝑖subscript𝒙𝑖subscript𝒇𝑖subscript𝒉𝑖\\\\boldsymbol{a}\\_{i}:=(\\\\boldsymbol{x}\\_{i},\\\\boldsymbol{f}\\_{i},\\\\boldsymbol{h}\\_{i}) with patch center 𝒙i∈ℝ3subscript𝒙𝑖superscriptℝ3\\\\boldsymbol{x}\\_{i}\\\\in\\\\mathbb{R}^{3}, the geometry features 𝒇i∈ℝ4×dsubscript𝒇𝑖superscriptℝ4𝑑\\\\boldsymbol{f}\\_{i}\\\\in\\\\mathbb{R}^{4\\\\times d} and the appearance features 𝒉i∈ℝ4×dsubscript𝒉𝑖superscriptℝ4𝑑\\\\boldsymbol{h}\\_{i}\\\\in\\\\mathbb{R}^{4\\\\times d}. More specifically, we parameterize the geometry and appearance features as the features at the four corners of the local patch in the UV space. We denote 𝒇i=(𝒇i​1,𝒇i​2,𝒇i​3,𝒇i​4)subscript𝒇𝑖subscript𝒇𝑖1subscript𝒇𝑖2subscript𝒇𝑖3subscript𝒇𝑖4\\\\boldsymbol{f}\\_{i}=(\\\\boldsymbol{f}\\_{i1},\\\\boldsymbol{f}\\_{i2},\\\\boldsymbol{f}\\_{i3},\\\\boldsymbol{f}\\_{i4}) and 𝒉i=(𝒉i​1,𝒉i​2,𝒉i​3,𝒉i​4)subscript𝒉𝑖subscript𝒉𝑖1subscript𝒉𝑖2subscript𝒉𝑖3subscript𝒉𝑖4\\\\boldsymbol{h}\\_{i}=(\\\\boldsymbol{h}\\_{i1},\\\\boldsymbol{h}\\_{i2},\\\\boldsymbol{h}\\_{i3},\\\\boldsymbol{h}\\_{i4}). This geometry and appearance disentanglement can facilitate better learning \\[ [21](https://ar5iv.org/html/2408.13055#bib.bib21 \"\"), [121](https://ar5iv.org/html/2408.13055#bib.bib121 \"\"), [105](https://ar5iv.org/html/2408.13055#bib.bib105 \"\")\\]. We use the feature 𝒇isubscript𝒇𝑖\\\\boldsymbol{f}\\_{i} to decode Gaussian positions while using 𝒉isubscript𝒉𝑖\\\\boldsymbol{h}\\_{i} to decode the rest of Gaussian attributes. We also assign a 2D coordinate 𝒖i​j∈ℝ2subscript𝒖𝑖𝑗superscriptℝ2\\\\boldsymbol{u}\\_{ij}\\\\in\\\\mathbb{R}^{2} to each feature vector 𝒇i​jsubscript𝒇𝑖𝑗\\\\boldsymbol{f}\\_{ij} and 𝒉i​jsubscript𝒉𝑖𝑗\\\\boldsymbol{h}\\_{ij} as a positional embedding, where 𝒖i​1=(0,0)subscript𝒖𝑖100\\\\boldsymbol{u}\\_{i1}=(0,0), 𝒖i​2=(1,0)subscript𝒖𝑖210\\\\boldsymbol{u}\\_{i2}=(1,0), 𝒖i​3=(1,1)subscript𝒖𝑖311\\\\boldsymbol{u}\\_{i3}=(1,1), 𝒖i​4=(0,1)subscript𝒖𝑖401\\\\boldsymbol{u}\\_{i4}=(0,1), ∀ifor-all𝑖\\\\forall i.\n\nNote that this representation is motivated by the concept of UV-map, in which the four corners describe the corners of the rectangular parameter domain. As we shall discuss later, the features 𝒇isubscript𝒇𝑖\\\\boldsymbol{f}\\_{i} and 𝒉isubscript𝒉𝑖\\\\boldsymbol{h}\\_{i} are learned end-to-end with 3D Gaussians. This approach takes advantage of end-to-end learning, while the specific network design promotes learning better features.\n\nFor generation, we randomly sample query points in the UV space and each point will be decoded as a 3D Gaussian.\nGiven a query point 𝒒i​j∈\\[0,1\\]2subscript𝒒𝑖𝑗superscript012\\\\boldsymbol{q}\\_{ij}\\\\in{\\[0,1\\]}^{2}, we map the 2D coordinate 𝒒i​jsubscript𝒒𝑖𝑗\\\\boldsymbol{q}\\_{ij} to the center of 3D Gaussians as:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | 𝝁i​j=ϕ​(𝒒i​j,𝒖i,𝒇i),subscript𝝁𝑖𝑗italic-ϕsubscript𝒒𝑖𝑗subscript𝒖𝑖subscript𝒇𝑖\\\\boldsymbol{\\\\mathrm{\\\\mu}}\\_{ij}=\\\\phi(\\\\boldsymbol{q}\\_{ij},\\\\boldsymbol{u}\\_{i},\\\\boldsymbol{f}\\_{i}), |  | (1) |\n\nwhere ϕitalic-ϕ\\\\phi is the mapping function, which takes the query point location 𝒒i​jsubscript𝒒𝑖𝑗\\\\boldsymbol{q}\\_{ij}, the pre-defined location of patch feature vectors 𝒖i​jsubscript𝒖𝑖𝑗\\\\boldsymbol{u}\\_{ij}, and the geometry features 𝒇isubscript𝒇𝑖\\\\boldsymbol{f}\\_{i} as inputs.\nWe implement the mapping function using interpolation in the 2D space:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | 𝝁i​j=MLP​(∑k=14w​(𝒒i​j,𝒖i​k,𝒇i​k)⋅𝒇i​k)+𝒙i,subscript𝝁𝑖𝑗MLPsuperscriptsubscript𝑘14⋅𝑤subscript𝒒𝑖𝑗subscript𝒖𝑖𝑘subscript𝒇𝑖𝑘subscript𝒇𝑖𝑘subscript𝒙𝑖\\\\boldsymbol{\\\\mathrm{\\\\mu}}\\_{ij}=\\\\textsc{MLP}(\\\\sum\\_{k=1}^{4}w(\\\\boldsymbol{q}\\_{ij},\\\\boldsymbol{u}\\_{ik},\\\\boldsymbol{f}\\_{ik})\\\\cdot\\\\boldsymbol{f}\\_{ik})+\\\\boldsymbol{x}\\_{i}, |  | (2) |\n\nwhere w𝑤w is the weight function of the four corners and we use an MLP to decode the residual between the Gaussian location and the patch center 𝒙isubscript𝒙𝑖\\\\boldsymbol{x}\\_{i}\n\nOne design choice for w𝑤w is the bilinear interpolation weight function, which has been widely used in feature decoding \\[ [70](https://ar5iv.org/html/2408.13055#bib.bib70 \"\")\\]. However, these linear weights purely based on coordinates have limited representation ability. Inspired by \\[ [114](https://ar5iv.org/html/2408.13055#bib.bib114 \"\")\\], we design a more powerful weight function defined on both coordinates and features:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | w​(𝒒i​j,𝒖i​k,𝒇i​k)=w~​(𝒒i​j,𝒖i​k,𝒇i​k)∑l=14w~​(𝒒i​j,𝒖i​l,𝒇i​l),𝑤subscript𝒒𝑖𝑗subscript𝒖𝑖𝑘subscript𝒇𝑖𝑘~𝑤subscript𝒒𝑖𝑗subscript𝒖𝑖𝑘subscript𝒇𝑖𝑘superscriptsubscript𝑙14~𝑤subscript𝒒𝑖𝑗subscript𝒖𝑖𝑙subscript𝒇𝑖𝑙w(\\\\boldsymbol{q}\\_{ij},\\\\boldsymbol{u}\\_{ik},\\\\boldsymbol{f}\\_{ik})=\\\\frac{\\\\widetilde{w}(\\\\boldsymbol{q}\\_{ij},\\\\boldsymbol{u}\\_{ik},\\\\boldsymbol{f}\\_{ik})}{\\\\sum\\_{l=1}^{4}\\\\widetilde{w}(\\\\boldsymbol{q}\\_{ij},\\\\boldsymbol{u}\\_{il},\\\\boldsymbol{f}\\_{il})}, |  | (3) |\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | and​w~​(𝒒i​j,𝒖i​l,𝒇i​l)=eω2​(𝒒i​j)T​(𝒇i​l+ω2​(𝒖i​l))/d,and~𝑤subscript𝒒𝑖𝑗subscript𝒖𝑖𝑙subscript𝒇𝑖𝑙superscript𝑒subscript𝜔2superscriptsubscript𝒒𝑖𝑗𝑇subscript𝒇𝑖𝑙subscript𝜔2subscript𝒖𝑖𝑙𝑑\\\\text{and}\\ \\\\widetilde{w}(\\\\boldsymbol{q}\\_{ij},\\\\boldsymbol{u}\\_{il},\\\\boldsymbol{f}\\_{il})=e^{\\\\omega\\_{2}(\\\\boldsymbol{q}\\_{ij})^{T}(\\\\boldsymbol{f}\\_{il}+\\\\omega\\_{2}(\\\\boldsymbol{u}\\_{il}))/\\\\sqrt{d}}, |  | (4) |\n\nwhere ω2:ℝ2↦ℝd:subscript𝜔2maps-tosuperscriptℝ2superscriptℝ𝑑\\\\omega\\_{2}:\\\\mathbb{R}^{2}\\\\mapsto\\\\mathbb{R}^{d} is the sinusoidal positional encoding function with MLP projection.\n\nSimilarly, the remaining Gaussian attributes are decoded by the function ψ𝜓\\\\psi:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | (𝐬i​j,𝐫i​j,oi​j,𝐜i​j)=ψ​(𝒒i​j,𝒖i,𝒉i)=MLP​(∑k=14w​(𝒒i​j,𝒖i​k,𝒉i​k)⋅𝒉i​k),subscript𝐬𝑖𝑗subscript𝐫𝑖𝑗subscripto𝑖𝑗subscript𝐜𝑖𝑗𝜓subscript𝒒𝑖𝑗subscript𝒖𝑖subscript𝒉𝑖MLPsuperscriptsubscript𝑘14⋅𝑤subscript𝒒𝑖𝑗subscript𝒖𝑖𝑘subscript𝒉𝑖𝑘subscript𝒉𝑖𝑘(\\\\boldsymbol{\\\\mathrm{s}}\\_{ij},\\\\boldsymbol{\\\\mathrm{r}}\\_{ij},{\\\\mathrm{o}}\\_{ij},\\\\boldsymbol{\\\\mathrm{c}}\\_{ij})=\\\\psi(\\\\boldsymbol{q}\\_{ij},\\\\boldsymbol{u}\\_{i},\\\\boldsymbol{h}\\_{i})=\\\\text{MLP}(\\\\sum\\_{k=1}^{4}w(\\\\boldsymbol{q}\\_{ij},\\\\boldsymbol{u}\\_{ik},\\\\boldsymbol{h}\\_{ik})\\\\cdot\\\\boldsymbol{h}\\_{ik}), |  | (5) |\n\nThe benefits of Atlas Gaussians representation are three-fold. First, through UV-based sampling in a unit square, Atlas Gaussians enable easy generation of a sufficiently large number of 3D Gaussians. They also possess the potential to generate a variable and theoretically infinite number of 3D Gaussians. Second, Atlas Gaussians utilize a non-linear learnable weight function based on the MLP projection of the positional encoding, which has a stronger representation ability than the existing linear interpolation weight. Third, Atlas Gaussians are computation-efficient with low memory overhead. An important property of Atlas Gaussians is that they do not require extra network parameters when scaling up the number of generated 3D Gaussians. We also provide an ablation study in Section [4.4](https://ar5iv.org/html/2408.13055#S4.SS4 \"4.4 Ablation study ‣ 4 Experiments ‣ Atlas Gaussians Diffusion for 3D Generation with Infinite Number of Points\") to validate the nice properties of Atlas Gaussians.\n\n\\\\begin{overpic}\\[width=433.62pt\\]{figures/pipeline/pipeline.pdf}\n\\\\end{overpic}Figure 3: The proposed VAE architecture. CA denotes the cross-attention layer. The latent space defined by 𝒛0subscript𝒛0\\\\boldsymbol{z}\\_{0} is used for latent diffusion.\n\n### 3.2 Stage 1: VAE\n\nWe design a VAE to link the low-dimensional latent space and the 3D space. The overall pipeline is shown in Figure [3](https://ar5iv.org/html/2408.13055#S3.F3 \"Figure 3 ‣ 3.1 Atlas Gaussians Representation ‣ 3 Method ‣ Atlas Gaussians Diffusion for 3D Generation with Infinite Number of Points\").\n\nEncoder.\nThe encoder takes shape information as input and outputs a latent set 𝒛0∈ℝn×d0subscript𝒛0superscriptℝ𝑛subscript𝑑0\\\\boldsymbol{z}\\_{0}\\\\in\\\\mathbb{R}^{n\\\\times d\\_{0}}, which follows the latent set representation in \\[ [114](https://ar5iv.org/html/2408.13055#bib.bib114 \"\")\\]. Specifically, shape information is represented as a set of features 𝒮𝒮\\\\mathcal{S}. We use transformers with cross attention to extract the latent features, as 𝒛=CrossAttn​(𝒛¯,𝒮),𝒛CrossAttn¯𝒛𝒮\\\\boldsymbol{z}=\\\\text{CrossAttn}(\\\\bar{\\\\boldsymbol{z}},\\\\mathcal{S}),\nwhere 𝒛¯¯𝒛\\\\bar{\\\\boldsymbol{z}} is the initialization of the latent features. In this notation, We omit the feed-forward MLP of the transformers for simplicity. Intuitively, the query 𝒛¯¯𝒛\\\\bar{\\\\boldsymbol{z}} of the cross-attention is updated by aggregating information from key/value 𝒮𝒮\\\\mathcal{S}. We further refine the latent features 𝒛𝒛\\\\boldsymbol{z} using transformers with self-attention.\n\nTo obtain shape information 𝒮𝒮\\\\mathcal{S}, we use point cloud 𝒫={𝒑i∈ℝ3}𝒫subscript𝒑𝑖superscriptℝ3\\\\mathcal{P}=\\\\{\\\\boldsymbol{p}\\_{i}\\\\in\\\\mathbb{R}^{3}\\\\} and sparse view RGB images ℐ={𝑰i∈ℝH×W×3}ℐsubscript𝑰𝑖superscriptℝ𝐻𝑊3\\\\mathcal{I}=\\\\{\\\\boldsymbol{I}\\_{i}\\\\in\\\\mathbb{R}^{H\\\\times W\\\\times 3}\\\\}. We encode the location of points into positional embeddings, resulting in features in ℝ\\|𝒫\\|×dsuperscriptℝ𝒫𝑑\\\\mathbb{R}^{\\|\\\\mathcal{P}\\|\\\\times d}. Meanwhile, a ViT network \\[ [17](https://ar5iv.org/html/2408.13055#bib.bib17 \"\"), [72](https://ar5iv.org/html/2408.13055#bib.bib72 \"\")\\] embeds each image into features of shape ℝh×w×dsuperscriptℝℎ𝑤𝑑\\\\mathbb{R}^{h\\\\times w\\\\times d}, resulting in the features of all images in ℝ(\\|𝑰\\|×h×w)×dsuperscriptℝ𝑰ℎ𝑤𝑑\\\\mathbb{R}^{(\\|\\\\boldsymbol{I}\\|\\\\times h\\\\times w)\\\\times d}. We use two transformers with cross-attention to aggregate information from them, respectively. We initialize the latent features 𝒛¯∈ℝn×d¯𝒛superscriptℝ𝑛𝑑\\\\bar{\\\\boldsymbol{z}}\\\\in\\\\mathbb{R}^{n\\\\times d} as the encoding of the points sampled using the farthest point sampling \\[ [114](https://ar5iv.org/html/2408.13055#bib.bib114 \"\")\\]. After the feature aggregation, we use an MLP to map the features to a lower-dimensional space ℝn×d→ℝn×d0→superscriptℝ𝑛𝑑superscriptℝ𝑛subscript𝑑0\\\\mathbb{R}^{n\\\\times d}\\\\rightarrow\\\\mathbb{R}^{n\\\\times d\\_{0}}, facilitating efficient latent diffusion.\n\nNote that attention is invariant to the permutation of features.\nWe also avoid pose-dependent operations \\[ [42](https://ar5iv.org/html/2408.13055#bib.bib42 \"\"), [43](https://ar5iv.org/html/2408.13055#bib.bib43 \"\")\\] in our design to enhance generality and extendability.\n\nDecoder.\nThe decoder recovers patch features 𝒜={(𝒙i,𝒇i,𝒉i)}i=1M𝒜superscriptsubscriptsubscript𝒙𝑖subscript𝒇𝑖subscript𝒉𝑖𝑖1𝑀\\\\mathcal{A}=\\\\{(\\\\boldsymbol{x}\\_{i},\\\\boldsymbol{f}\\_{i},\\\\boldsymbol{h}\\_{i})\\\\}\\_{i=1}^{M} from the latent code 𝒛0subscript𝒛0\\\\boldsymbol{z}\\_{0}. In the decoder, we upsample the latent code, decode the patch centers {𝒙i}i=1Msuperscriptsubscriptsubscript𝒙𝑖𝑖1𝑀\\\\{\\\\boldsymbol{x}\\_{i}\\\\}\\_{i=1}^{M}, and then decode the patch geometry and appearance features {(𝒇i,𝒉i)}i=1Msuperscriptsubscriptsubscript𝒇𝑖subscript𝒉𝑖𝑖1𝑀\\\\{(\\\\boldsymbol{f}\\_{i},\\\\boldsymbol{h}\\_{i})\\\\}\\_{i=1}^{M}.\n\nThe upsampling module is designed to increase both the length and feature dimension of the latent code, from 𝒛0∈ℝn×d0subscript𝒛0superscriptℝ𝑛subscript𝑑0\\\\boldsymbol{z}\\_{0}\\\\in\\\\mathbb{R}^{n\\\\times d\\_{0}} to 𝒛l∈ℝM×dsubscript𝒛𝑙superscriptℝ𝑀𝑑\\\\boldsymbol{z}\\_{l}\\\\in\\\\mathbb{R}^{M\\\\times d}. In detail, we first use a learnable query 𝒚𝒚\\\\boldsymbol{y} to aggregate information from the latent code 𝒛0subscript𝒛0\\\\boldsymbol{z}\\_{0} using transformers with cross-attention. Then, we increase its channel dimension to d𝑑d using self-attention transformers, leading to the characteristic 𝒛1∈ℝn×dsubscript𝒛1superscriptℝ𝑛𝑑\\\\boldsymbol{z}\\_{1}\\\\in\\\\mathbb{R}^{n\\\\times d}. The architecture follows Perceiver-IO \\[ [39](https://ar5iv.org/html/2408.13055#bib.bib39 \"\")\\]. We then use an MLP to increase the feature dimension of 𝒛1subscript𝒛1\\\\boldsymbol{z}\\_{1} into Mn​d𝑀𝑛𝑑\\\\frac{M}{n}d, leading to latent features in ℝn×Mn​dsuperscriptℝ𝑛𝑀𝑛𝑑\\\\mathbb{R}^{n\\\\times\\\\frac{M}{n}d}. We reshape the features into 𝒛2∈ℝM×dsubscript𝒛2superscriptℝ𝑀𝑑\\\\boldsymbol{z}\\_{2}\\\\in\\\\mathbb{R}^{M\\\\times d}, which is a pixel shuffle process \\[ [85](https://ar5iv.org/html/2408.13055#bib.bib85 \"\"), [105](https://ar5iv.org/html/2408.13055#bib.bib105 \"\")\\]. We then use another set of transformers with self-attention to get the output latent features 𝒛lsubscript𝒛𝑙\\\\boldsymbol{z}\\_{l}. This process is summarized as follows:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | 𝒛1=SelfAttn​(CrossAttn​(𝒚,𝒛0)),𝒛2=PixelShuffle​(MLP​(𝒛1)),𝒛l=SelfAttn​(𝒛2).formulae-sequencesubscript𝒛1SelfAttnCrossAttn𝒚subscript𝒛0formulae-sequencesubscript𝒛2PixelShuffleMLPsubscript𝒛1subscript𝒛𝑙SelfAttnsubscript𝒛2\\\\boldsymbol{z}\\_{1}=\\\\text{SelfAttn}(\\\\text{CrossAttn}(\\\\boldsymbol{y},\\\\boldsymbol{z}\\_{0})),\\\\quad\\\\boldsymbol{z}\\_{2}=\\\\text{PixelShuffle}(\\\\text{MLP}(\\\\boldsymbol{z}\\_{1})),\\\\quad\\\\boldsymbol{z}\\_{l}=\\\\text{SelfAttn}(\\\\boldsymbol{z}\\_{2}). |  | (6) |\n\nAgain, we omit the feed-forward MLP in the transformers for simplicity. We then decode the patch centers using transformers with self-attention:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | {𝒙i}i=1M=SelfAttn​(𝒛l).superscriptsubscriptsubscript𝒙𝑖𝑖1𝑀SelfAttnsubscript𝒛𝑙\\\\{\\\\boldsymbol{x}\\_{i}\\\\}\\_{i=1}^{M}=\\\\text{SelfAttn}(\\\\boldsymbol{z}\\_{l}). |  | (7) |\n\nWe use a two-branch module to decode geometry and appearance features {(𝒇i,𝒉i)}i=1Msuperscriptsubscriptsubscript𝒇𝑖subscript𝒉𝑖𝑖1𝑀\\\\{(\\\\boldsymbol{f}\\_{i},\\\\boldsymbol{h}\\_{i})\\\\}\\_{i=1}^{M} from upsampled latent code 𝒛lsubscript𝒛𝑙\\\\boldsymbol{z}\\_{l}. We demonstrate its architecture in Figure [4](https://ar5iv.org/html/2408.13055#S3.F4 \"Figure 4 ‣ 3.2 Stage 1: VAE ‣ 3 Method ‣ Atlas Gaussians Diffusion for 3D Generation with Infinite Number of Points\"). Take the branch for decoding the geometry features {𝒇i}i=1Msuperscriptsubscriptsubscript𝒇𝑖𝑖1𝑀\\\\{\\\\boldsymbol{f}\\_{i}\\\\}\\_{i=1}^{M} as an example. We use another upsampling module to map 𝒛l∈ℝM×dsubscript𝒛𝑙superscriptℝ𝑀𝑑\\\\boldsymbol{z}\\_{l}\\\\in\\\\mathbb{R}^{M\\\\times d} to 𝒛f∈ℝM×β×dsubscript𝒛𝑓superscriptℝ𝑀𝛽𝑑\\\\boldsymbol{z}\\_{f}\\\\in\\\\mathbb{R}^{M\\\\times\\\\beta\\\\times d}, where β=4𝛽4\\\\beta=4, corresponding to the geometry features of the four corners for each patch. We then use transformers with self-attention to refine the upsampled features to get 𝒇isubscript𝒇𝑖\\\\boldsymbol{f}\\_{i}.\n\nSpecifically, we apply computational decomposition to the self-attention layers, as naive self-attention leads to a 𝒪​(β2​M2​d)𝒪superscript𝛽2superscript𝑀2𝑑\\\\mathcal{O}(\\\\beta^{2}M^{2}d) complexity due to the long sequence length of M​β𝑀𝛽M\\\\beta. We apply local self-attention to the features that belong to each local patch, reducing the complexity to 𝒪​(β2​M​d)𝒪superscript𝛽2𝑀𝑑\\\\mathcal{O}(\\\\beta^{2}Md). The features of different local patches are updated independently. This design ensures local awareness of Atlas Gaussians decoding. To further ensure global awareness, we repeat and add the global features to the local patch features.\n\n\\\\begin{overpic}\\[width=130.08731pt\\]{figures/patch\\_feature\\_decoder/patch\\_feature\\_decoder.pdf}\n\\\\end{overpic}Figure 4: In the patch feature decoder, global features are broadcast and added to the local features. SA denotes the self-attention layers.\n\nAfter obtaining the Atlas Gaussians 𝒜={(𝒙i,𝒇i,𝒉i)}i=1M𝒜superscriptsubscriptsubscript𝒙𝑖subscript𝒇𝑖subscript𝒉𝑖𝑖1𝑀\\\\mathcal{A}=\\\\{(\\\\boldsymbol{x}\\_{i},\\\\boldsymbol{f}\\_{i},\\\\boldsymbol{h}\\_{i})\\\\}\\_{i=1}^{M} from the VAE, we can decode 3D Gaussians following Eq. [2](https://ar5iv.org/html/2408.13055#S3.E2 \"In 3.1 Atlas Gaussians Representation ‣ 3 Method ‣ Atlas Gaussians Diffusion for 3D Generation with Infinite Number of Points\") and Eq. [5](https://ar5iv.org/html/2408.13055#S3.E5 \"In 3.1 Atlas Gaussians Representation ‣ 3 Method ‣ Atlas Gaussians Diffusion for 3D Generation with Infinite Number of Points\").\n\nTraining. Similar to existing works \\[ [48](https://ar5iv.org/html/2408.13055#bib.bib48 \"\"), [105](https://ar5iv.org/html/2408.13055#bib.bib105 \"\"), [97](https://ar5iv.org/html/2408.13055#bib.bib97 \"\"), [121](https://ar5iv.org/html/2408.13055#bib.bib121 \"\")\\], we utilize a 3D dataset for supervision. We first regularize the patch center to adhere to the 3D surface geometry:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | ℒcenter=ℒCD​({𝒙i}i=1M,𝒫GT)+ℒEMD​({𝒙i}i=1M,𝒫GT),subscriptℒcentersubscriptℒCDsuperscriptsubscriptsubscript𝒙𝑖𝑖1𝑀subscript𝒫GTsubscriptℒEMDsuperscriptsubscriptsubscript𝒙𝑖𝑖1𝑀subscript𝒫GT\\\\mathcal{L}\\_{\\\\text{center}}=\\\\mathcal{L}\\_{\\\\text{CD}}(\\\\{\\\\boldsymbol{x}\\_{i}\\\\}\\_{i=1}^{M},\\\\mathcal{P}\\_{\\\\text{GT}})+\\\\mathcal{L}\\_{\\\\text{EMD}}(\\\\{\\\\boldsymbol{x}\\_{i}\\\\}\\_{i=1}^{M},\\\\mathcal{P}\\_{\\\\text{GT}}), |  | (8) |\n\nwhere 𝒫GTsubscript𝒫GT\\\\mathcal{P}\\_{\\\\text{GT}} is the ground truth surface point cloud, ℒCDsubscriptℒCD\\\\mathcal{L}\\_{\\\\text{CD}} and ℒEMDsubscriptℒEMD\\\\mathcal{L}\\_{\\\\text{EMD}} are Chamfer Distance (CD) and Earth Mover’s Distance (EMD), respectively.\nSimilarly, we also supervise the centers of all 3D Gaussians with\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | ℒ𝝁​(S)=ℒCD​({𝝁i​j}i=1,j=1M,S,𝒫GT)+ℒEMD​({𝝁i​j}i=1,j=1M,S,𝒫GT),subscriptℒ𝝁𝑆subscriptℒCDsuperscriptsubscriptsubscript𝝁𝑖𝑗formulae-sequence𝑖1𝑗1𝑀𝑆subscript𝒫GTsubscriptℒEMDsuperscriptsubscriptsubscript𝝁𝑖𝑗formulae-sequence𝑖1𝑗1𝑀𝑆subscript𝒫GT\\\\mathcal{L}\\_{\\\\boldsymbol{\\\\mathrm{\\\\mu}}}(S)=\\\\mathcal{L}\\_{\\\\text{CD}}(\\\\{\\\\boldsymbol{\\\\mathrm{\\\\mu}}\\_{ij}\\\\}\\_{i=1,j=1}^{M,S},\\\\mathcal{P}\\_{\\\\text{GT}})+\\\\mathcal{L}\\_{\\\\text{EMD}}(\\\\{\\\\boldsymbol{\\\\mathrm{\\\\mu}}\\_{ij}\\\\}\\_{i=1,j=1}^{M,S},\\\\mathcal{P}\\_{\\\\text{GT}}), |  | (9) |\n\nwhere {𝝁i​j}i=1,j=1M,Ssuperscriptsubscriptsubscript𝝁𝑖𝑗formulae-sequence𝑖1𝑗1𝑀𝑆\\\\{\\\\boldsymbol{\\\\mathrm{\\\\mu}}\\_{ij}\\\\}\\_{i=1,j=1}^{M,S} represents the generated point cloud by sampling S𝑆S points in each of the M𝑀M patches. When computing the loss for supervision, we can generate point clouds with different resolutions by varying S𝑆S, thanks to Atlas Gaussians’ ability to dynamically generate a variable number of 3D Gaussians.\n\nWhile surface points are independent samples of the continuous geometry, 3D Gaussians are interdependent because one 3D Gaussian can affect the attributes of its neighbors during alpha blending. To ensure consistency and achieve deterministic results, during rendering we employ a uniform α×α𝛼𝛼\\\\alpha\\\\times\\\\alpha grid sampling in the UV space instead of random sampling, resulting in N=α2​M𝑁superscript𝛼2𝑀N=\\\\alpha^{2}M 3D Gaussians. We use the differentiable renderer from \\[ [45](https://ar5iv.org/html/2408.13055#bib.bib45 \"\")\\] to render V𝑉V views of RGB, alpha, and depth images, which is supervised by mean square error:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | ℒrender=ℒMSE​(𝑰^rgb,𝑰rgb)+ℒMSE​(𝑰^alpha,𝑰alpha)+ℒMSE​(𝑰^depth,𝑰depth),subscriptℒrendersubscriptℒMSEsubscript^𝑰rgbsubscript𝑰rgbsubscriptℒMSEsubscript^𝑰alphasubscript𝑰alphasubscriptℒMSEsubscript^𝑰depthsubscript𝑰depth\\\\mathcal{L}\\_{\\\\text{render}}=\\\\mathcal{L}\\_{\\\\text{MSE}}(\\\\hat{\\\\boldsymbol{I}}\\_{\\\\text{rgb}},\\\\boldsymbol{I}\\_{\\\\text{rgb}})+\\\\mathcal{L}\\_{\\\\text{MSE}}(\\\\hat{\\\\boldsymbol{I}}\\_{\\\\text{alpha}},\\\\boldsymbol{I}\\_{\\\\text{alpha}})+\\\\mathcal{L}\\_{\\\\text{MSE}}(\\\\hat{\\\\boldsymbol{I}}\\_{\\\\text{depth}},\\\\boldsymbol{I}\\_{\\\\text{depth}}), |  | (10) |\n\nwhere 𝑰^rgbsubscript^𝑰rgb\\\\hat{\\\\boldsymbol{I}}\\_{\\\\text{rgb}}, 𝑰^alphasubscript^𝑰alpha\\\\hat{\\\\boldsymbol{I}}\\_{\\\\text{alpha}}, and 𝑰^depthsubscript^𝑰depth\\\\hat{\\\\boldsymbol{I}}\\_{\\\\text{depth}} are the predictions, 𝑰rgbsubscript𝑰rgb\\\\boldsymbol{I}\\_{\\\\text{rgb}}, 𝑰alphasubscript𝑰alpha\\\\boldsymbol{I}\\_{\\\\text{alpha}}, and 𝑰depthsubscript𝑰depth\\\\boldsymbol{I}\\_{\\\\text{depth}} are the ground truths.\nTo improve the visual fidelity, we also employ the LPIPS loss \\[ [117](https://ar5iv.org/html/2408.13055#bib.bib117 \"\"), [97](https://ar5iv.org/html/2408.13055#bib.bib97 \"\")\\]ℒLPIPS​(𝑰^rgb,𝑰rgb)subscriptℒLPIPSsubscript^𝑰rgbsubscript𝑰rgb\\\\mathcal{L}\\_{\\\\text{LPIPS}}(\\\\hat{\\\\boldsymbol{I}}\\_{\\\\text{rgb}},\\\\boldsymbol{I}\\_{\\\\text{rgb}}). The total loss function for the VAE is:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | ℒtotal=ℒcenter+∑S={1,4}ℒ𝝁​(S)+λr​(ℒrender+ℒLPIPS)+λK​L​ℒKL​(𝒛),subscriptℒtotalsubscriptℒcentersubscript𝑆14subscriptℒ𝝁𝑆subscript𝜆𝑟subscriptℒrendersubscriptℒLPIPSsubscript𝜆𝐾𝐿subscriptℒKL𝒛\\\\mathcal{L}\\_{\\\\text{total}}=\\\\mathcal{L}\\_{\\\\text{center}}+\\\\sum\\_{S=\\\\{1,4\\\\}}\\\\mathcal{L}\\_{\\\\boldsymbol{\\\\mathrm{\\\\mu}}}(S)+\\\\lambda\\_{r}\\\\left(\\\\mathcal{L}\\_{\\\\text{render}}+\\\\mathcal{L}\\_{\\\\text{LPIPS}}\\\\right)+\\\\lambda\\_{KL}\\\\mathcal{L}\\_{\\\\text{KL}}(\\\\boldsymbol{z}), |  | (11) |\n\nwhere ℒKLsubscriptℒKL\\\\mathcal{L}\\_{\\\\text{KL}} is the Kullback–Leibler divergence, λrsubscript𝜆𝑟\\\\lambda\\_{r} and λK​Lsubscript𝜆𝐾𝐿\\\\lambda\\_{KL} are the loss weights.\n\n### 3.3 Stage 2: latent diffusion model\n\nThe proposed VAE provides a low-dimensional latent code that can be mapped to Atlas Gaussians. We employ the EDM \\[ [44](https://ar5iv.org/html/2408.13055#bib.bib44 \"\")\\] framework for latent diffusion. EDM aims to learn a denoising network Dθ​(𝒛;σ,𝒞)subscript𝐷𝜃𝒛𝜎𝒞D\\_{\\\\theta}(\\\\boldsymbol{z};\\\\sigma,\\\\mathcal{C}) to convert the Gaussian distribution to the empirical distribution pdatasubscript𝑝datap\\_{\\\\text{data}} defined by 𝒛𝒛\\\\boldsymbol{z}, where θ𝜃\\\\theta is the network parameters, σ𝜎\\\\sigma is the noise level sampled from a pre-defined distribution ptrainsubscript𝑝trainp\\_{\\\\text{train}}, and 𝒞𝒞\\\\mathcal{C} denotes the optional condition. Dθ​(𝒛;σ,𝒞)subscript𝐷𝜃𝒛𝜎𝒞D\\_{\\\\theta}(\\\\boldsymbol{z};\\\\sigma,\\\\mathcal{C}) is parameterized using a σ𝜎\\\\sigma-dependent skip connection:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | Dθ​(𝒛;σ,𝒞)=cskip​(σ)​𝒛+cout​(σ)​Fθ​(cin​(σ)​𝒛;cnoise​(σ),𝒞),subscript𝐷𝜃𝒛𝜎𝒞subscript𝑐skip𝜎𝒛subscript𝑐out𝜎subscript𝐹𝜃subscript𝑐in𝜎𝒛subscript𝑐noise𝜎𝒞D\\_{\\\\theta}(\\\\boldsymbol{z};\\\\sigma,\\\\mathcal{C})=c\\_{\\\\text{skip}}(\\\\sigma)\\\\boldsymbol{z}+c\\_{\\\\text{out}}(\\\\sigma)F\\_{\\\\theta}\\\\left(c\\_{\\\\text{in}}(\\\\sigma)\\\\boldsymbol{z};c\\_{\\\\text{noise}}(\\\\sigma),\\\\mathcal{C}\\\\right), |  | (12) |\n\nwhere Fθsubscript𝐹𝜃F\\_{\\\\theta} is the network to be trained. The training objective is\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | 𝔼σ,𝒛,𝒏​λ​(σ)​‖Dθ​(𝒛;σ,𝒞)−𝒛‖2,subscript𝔼𝜎𝒛𝒏𝜆𝜎superscriptnormsubscript𝐷𝜃𝒛𝜎𝒞𝒛2\\\\mathbb{E}\\_{\\\\sigma,\\\\boldsymbol{z},\\\\boldsymbol{n}}\\\\lambda(\\\\sigma)\\|\\|D\\_{\\\\theta}(\\\\boldsymbol{z};\\\\sigma,\\\\mathcal{C})-\\\\boldsymbol{z}\\|\\|^{2}, |  | (13) |\n\nwhere σ∼ptrain,𝒛∼pdata,𝒏∼𝒩​(0,σ2​I)formulae-sequencesimilar-to𝜎subscript𝑝trainformulae-sequencesimilar-to𝒛subscript𝑝datasimilar-to𝒏𝒩0superscript𝜎2𝐼\\\\sigma\\\\sim p\\_{\\\\text{train}},\\\\boldsymbol{z}\\\\sim p\\_{\\\\text{data}},\\\\boldsymbol{n}\\\\sim\\\\mathcal{N}(0,\\\\sigma^{2}I). Readers interested in details on cskip​(σ)subscript𝑐skip𝜎c\\_{\\\\text{skip}}(\\\\sigma), cout​(σ)subscript𝑐out𝜎c\\_{\\\\text{out}}(\\\\sigma), cin​(σ)subscript𝑐in𝜎c\\_{\\\\text{in}}(\\\\sigma), cnoise​(σ)subscript𝑐noise𝜎c\\_{\\\\text{noise}}(\\\\sigma), and parameterization of the weight function λ​(σ)𝜆𝜎\\\\lambda(\\\\sigma) may refer to EDM \\[ [44](https://ar5iv.org/html/2408.13055#bib.bib44 \"\")\\].\n\nFollowing \\[ [114](https://ar5iv.org/html/2408.13055#bib.bib114 \"\")\\], our denoising network Dθ​(𝒛;σ,𝒞)subscript𝐷𝜃𝒛𝜎𝒞D\\_{\\\\theta}(\\\\boldsymbol{z};\\\\sigma,\\\\mathcal{C}) consists of a series of blocks, each containing a self-attention layer followed by a cross-attention layer. Each block can be represented as:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | 𝒛(i)=CrossAttn​(SelfAttn​(𝒛(i−1)),𝒞),i=1,…,lformulae-sequencesuperscript𝒛𝑖CrossAttnSelfAttnsuperscript𝒛𝑖1𝒞𝑖1…𝑙\\\\boldsymbol{z}^{(i)}=\\\\text{CrossAttn}\\\\left(\\\\text{SelfAttn}(\\\\boldsymbol{z}^{(i-1)}),\\\\mathcal{C}\\\\right),\\\\quad i=1,\\\\ldots,l |  | (14) |\n\nwhere 𝒛(0)=𝒛superscript𝒛0𝒛\\\\boldsymbol{z}^{(0)}=\\\\boldsymbol{z} is the initial input to the network, l𝑙l is the number of blocks. In unconditional generation, we designate 𝒞𝒞\\\\mathcal{C} as a learnable parameter.\nNote that more advanced architectures \\[ [74](https://ar5iv.org/html/2408.13055#bib.bib74 \"\")\\] could also be employed for the denoising network.\n\n## 4 Experiments\n\nWe first introduce our experiment setup, and then show the results for both unconditional and conditional generation.\n\n### 4.1 Experimental setup\n\nFollowing most existing methods \\[ [6](https://ar5iv.org/html/2408.13055#bib.bib6 \"\"), [21](https://ar5iv.org/html/2408.13055#bib.bib21 \"\"), [69](https://ar5iv.org/html/2408.13055#bib.bib69 \"\"), [2](https://ar5iv.org/html/2408.13055#bib.bib2 \"\"), [8](https://ar5iv.org/html/2408.13055#bib.bib8 \"\"), [5](https://ar5iv.org/html/2408.13055#bib.bib5 \"\"), [48](https://ar5iv.org/html/2408.13055#bib.bib48 \"\")\\], we benchmark unconditional single-category 3D generation on ShapeNet \\[ [7](https://ar5iv.org/html/2408.13055#bib.bib7 \"\")\\]. We use the training split from SRN \\[ [89](https://ar5iv.org/html/2408.13055#bib.bib89 \"\")\\], which comprises 4612, 2151, and 3033 shapes in the categories Chair, Car, and Plane, respectively. We render 76 views for each shape using Blender \\[ [14](https://ar5iv.org/html/2408.13055#bib.bib14 \"\")\\] with the same intrinsic matrix as \\[ [5](https://ar5iv.org/html/2408.13055#bib.bib5 \"\"), [48](https://ar5iv.org/html/2408.13055#bib.bib48 \"\")\\]. Fréchet Inception Distance (FID@50K) and Kernel Inception Distance (KID@50K) are used for evaluation.\nIn addition, we experiment with text-conditioned 3D generation on Objaverse \\[ [15](https://ar5iv.org/html/2408.13055#bib.bib15 \"\")\\]. We use the renderings from G-buffer Objaverse \\[ [77](https://ar5iv.org/html/2408.13055#bib.bib77 \"\")\\] and the captions from Cap3D \\[ [64](https://ar5iv.org/html/2408.13055#bib.bib64 \"\")\\]. Due to limited computational resources, we select a subset with around 6K 3D shapes.\nPlease refer to Appendix [A](https://ar5iv.org/html/2408.13055#A1 \"Appendix A Implementation details ‣ Atlas Gaussians Diffusion for 3D Generation with Infinite Number of Points\") for implementation details.\n\n### 4.2 Unconditional 3D generation\n\nTable [1](https://ar5iv.org/html/2408.13055#S4.T1 \"Table 1 ‣ 4.2 Unconditional 3D generation ‣ 4 Experiments ‣ Atlas Gaussians Diffusion for 3D Generation with Infinite Number of Points\") presents the quantitative comparisons between our method and baseline approaches. Our method outperforms all baseline approaches, including EG3D \\[ [6](https://ar5iv.org/html/2408.13055#bib.bib6 \"\")\\], GET3D \\[ [21](https://ar5iv.org/html/2408.13055#bib.bib21 \"\")\\], DiffRF \\[ [69](https://ar5iv.org/html/2408.13055#bib.bib69 \"\")\\], RenderDiffusion \\[ [2](https://ar5iv.org/html/2408.13055#bib.bib2 \"\")\\], and SSDNeRF \\[ [8](https://ar5iv.org/html/2408.13055#bib.bib8 \"\")\\]. Our approach also outperforms concurrent work LN3Diff \\[ [48](https://ar5iv.org/html/2408.13055#bib.bib48 \"\")\\], which utilizes the triplane representation for 3D shapes. Our results demonstrate significant improvements over LN3Diff, particularly in the ShapeNet Chair category, which features greater geometric, structural, and textural complexity. In the other two categories, our method achieves better average performance, further highlighting the robustness and efficacy of our approach. We also include the qualitative comparison in Figure [5](https://ar5iv.org/html/2408.13055#S4.F5 \"Figure 5 ‣ 4.2 Unconditional 3D generation ‣ 4 Experiments ‣ Atlas Gaussians Diffusion for 3D Generation with Infinite Number of Points\").\n\n\\\\begin{overpic}\\[width=429.28616pt\\]{figures/fig\\_shapenet/shapenet\\_small.pdf}\n\\\\put(-3.0,1.0){\\\\footnotesize{\\\\rotatebox{90.0}{\\\\footnotesize{Ours}}}}\n\\\\put(-3.0,8.0){{\\\\rotatebox{90.0}{\\\\footnotesize{LN3Diff}}}}\n\\\\put(-3.0,19.5){\\\\footnotesize{\\\\rotatebox{90.0}{\\\\footnotesize{Ours}}}}\n\\\\put(-3.0,26.5){{\\\\rotatebox{90.0}{\\\\footnotesize{LN3Diff}}}}\n\\\\put(-3.0,40.0){\\\\footnotesize{\\\\rotatebox{90.0}{\\\\footnotesize{Ours}}}}\n\\\\put(-3.0,47.0){{\\\\rotatebox{90.0}{\\\\footnotesize{LN3Diff}}}}\n\\\\end{overpic}Figure 5: The comparison between LN3Diff \\[ [48](https://ar5iv.org/html/2408.13055#bib.bib48 \"\")\\] and our method on three ShapeNet categories.Table 1: Evaluation of single-category unconditional generation on ShapeNet. LN3Diff\\* is evaluated using the generated results provided by the authors.\n\nMethodChairCarPlaneFID@50KKID@50K(%)FID@50KKID@50K(%)FID@50KKID@50K(%)EG3D \\[ [6](https://ar5iv.org/html/2408.13055#bib.bib6 \"\")\\]26.091.133.331.414.470.5GET3D \\[ [21](https://ar5iv.org/html/2408.13055#bib.bib21 \"\")\\]35.331.541.411.826.801.7DiffRF \\[ [69](https://ar5iv.org/html/2408.13055#bib.bib69 \"\")\\]99.374.975.095.1101.796.5RenderDiffusion \\[ [2](https://ar5iv.org/html/2408.13055#bib.bib2 \"\")\\]53.306.446.504.143.505.9SSDNeRF \\[ [8](https://ar5iv.org/html/2408.13055#bib.bib8 \"\")\\]65.043.047.722.821.011.0LN3Diff \\[ [48](https://ar5iv.org/html/2408.13055#bib.bib48 \"\")\\]16.900.4717.600.498.840.36Ours9.900.3512.150.458.090.21\n\n### 4.3 Conditional 3D generation\n\nWe evaluate our methods and baseline approaches \\[ [97](https://ar5iv.org/html/2408.13055#bib.bib97 \"\"), [43](https://ar5iv.org/html/2408.13055#bib.bib43 \"\"), [48](https://ar5iv.org/html/2408.13055#bib.bib48 \"\")\\] on the text-conditioned 3D generation on Objaverse. We experiment with the text prompt split used in \\[ [48](https://ar5iv.org/html/2408.13055#bib.bib48 \"\")\\]. As shown in Figure [6](https://ar5iv.org/html/2408.13055#S4.F6 \"Figure 6 ‣ 4.3 Conditional 3D generation ‣ 4 Experiments ‣ Atlas Gaussians Diffusion for 3D Generation with Infinite Number of Points\"), the image-based generalizable 3D reconstruction method \\[ [97](https://ar5iv.org/html/2408.13055#bib.bib97 \"\")\\] sometimes produces shapes with severe artifacts. This issue arises because the method relies on a multi-view generation network, which often suffers from multi-view inconsistency. In contrast, our method learns directly from 3D data, enabling the generation of consistent novel views.\nAdditionally, our method generates higher-quality 3D shapes compared to Shap-E and LN3Diff, which also utilize the VAE + LDM paradigm. However, these methods rely on volume rendering during training, which is usually limited to low resolution. Instead, our method uses the more efficient representation of 3D Gaussians. Thanks to our proposed Atlas Gaussians representation, which can decode a sufficiently large number of 3D Gaussians, our generated shapes exhibit more detailed features.\nWe also evaluate the generated 3D content using the CLIP score \\[ [78](https://ar5iv.org/html/2408.13055#bib.bib78 \"\"), [30](https://ar5iv.org/html/2408.13055#bib.bib30 \"\")\\] and profile the inference time of each method. As shown in Table [2](https://ar5iv.org/html/2408.13055#S4.T2 \"Table 2 ‣ 4.3 Conditional 3D generation ‣ 4 Experiments ‣ Atlas Gaussians Diffusion for 3D Generation with Infinite Number of Points\"), our method achieves the highest score and the lowest inference time. This performance is attributed to our effective and efficient decoder design that links the low-dimensional latent space with the 3D space. Please refer to Appendix [B](https://ar5iv.org/html/2408.13055#A2 \"Appendix B More results of text-conditioned 3D generation ‣ Atlas Gaussians Diffusion for 3D Generation with Infinite Number of Points\") for more results.\n\n\\\\begin{overpic}\\[width=433.62pt\\]{figures/fig\\_objaverse/objaverse.pdf}\n\\\\end{overpic}Figure 6: Comparison of text-conditioned 3D generation between baseline approaches on Objaverse. From left to right: LGM \\[ [97](https://ar5iv.org/html/2408.13055#bib.bib97 \"\")\\], Shap-E \\[ [43](https://ar5iv.org/html/2408.13055#bib.bib43 \"\")\\], LN3Diff \\[ [48](https://ar5iv.org/html/2408.13055#bib.bib48 \"\")\\], and our method.Table 2: Evaluation of text-conditioned 3D generation on Objaverse.\n\nLGM \\[ [97](https://ar5iv.org/html/2408.13055#bib.bib97 \"\")\\]Shap-E \\[ [43](https://ar5iv.org/html/2408.13055#bib.bib43 \"\")\\]LN3Diff \\[ [48](https://ar5iv.org/html/2408.13055#bib.bib48 \"\")\\]OursCLIP Score (ViT-B/32)29.6428.6127.0030.08Inference Time (GPU)6 s (TITAN V)33 s (TITAN V)7.5 s (V 100)3.5 s (TITAN V)\n\nTable 3: Scale up the number of 3D Gaussians on the Objaverse dataset.\n\n#3DGSPSNR↑↑\\\\uparrowLPIPS↓↓\\\\downarrow#Params↓↓\\\\downarrowTime per Epoch↓↓\\\\downarrow8,19225.890.069141.76M10.2 min32,76826.710.058141.76M10.6 min100,35227.020.053141.76M11.2 min\n\nTable 4: Ablation study on network design evaluated on ShapeNet with PSNR.\n\nAtlas Gaussians (Full)26.56(a) linear weights26.13(b) no disentangle25.77(c) no global feature26.18\n\n### 4.4 Ablation study\n\nThis section presents an ablation study on different components of our network.\n\nNumber of 3D Gaussians.\nAtlas Gaussians support easy modification of the numbers of 3D Gaussians by varying the number of points sampled for each patch. With the total number of 3D Gaussians given by N=α2​M𝑁superscript𝛼2𝑀N=\\\\alpha^{2}M, we fix the number of patches M𝑀M and vary α𝛼\\\\alpha. We experiment with different values of α𝛼\\\\alpha (2, 4, and 7), resulting in 8192, 32768, and 100352 3D Gaussians, respectively. We then evaluated the rendering quality of the VAE on a validation set to assess the impact of the number of 3D Gaussians.\nAs shown in Table [4](https://ar5iv.org/html/2408.13055#S4.T4 \"Table 4 ‣ 4.3 Conditional 3D generation ‣ 4 Experiments ‣ Atlas Gaussians Diffusion for 3D Generation with Infinite Number of Points\"), both the PSNR and LPIPS improve consistently as more 3D Gaussians are generated. A significant observation is that the network parameters remain unchanged despite the increase in the number of 3D Gaussians, attributable to our proposed Atlas Gaussians representation. Furthermore, the computational overhead, including the cost of decoding and rendering additional 3D Gaussians, remains small.\n\nLearned weights for feature decoding.\nIn Table [4](https://ar5iv.org/html/2408.13055#S4.T4 \"Table 4 ‣ 4.3 Conditional 3D generation ‣ 4 Experiments ‣ Atlas Gaussians Diffusion for 3D Generation with Infinite Number of Points\"), we ablate the VAE network design on the ShapeNet validation set using the PSNR metric. The table shows that replacing our learned weight function with bilinear interpolation weights leads to a performance drop for the VAE. This indicates that our learned nonlinear weights have stronger representation capabilities than linear weights.\n\nDisentangle geometry and texture.\nAtlas Gaussians can achieve geometry and appearance disentanglement by design. To validate the effectiveness of this design, we experimented with another network version where a single set of features is shared for both geometry and appearance. As shown in Table [4](https://ar5iv.org/html/2408.13055#S4.T4 \"Table 4 ‣ 4.3 Conditional 3D generation ‣ 4 Experiments ‣ Atlas Gaussians Diffusion for 3D Generation with Infinite Number of Points\"), performance decreases considerably with this shared feature approach. This shows that our disentangled design facilitates better learning.\n\nUsing global features.\nAs shown in Table [4](https://ar5iv.org/html/2408.13055#S4.T4 \"Table 4 ‣ 4.3 Conditional 3D generation ‣ 4 Experiments ‣ Atlas Gaussians Diffusion for 3D Generation with Infinite Number of Points\"), removing the global feature from 𝒛lsubscript𝒛𝑙\\\\boldsymbol{z}\\_{l} in the patch feature decoder leads to a performance drop. This outcome is expected, as the global features provide essential context that complements the local features.\n\n## 5 Conclusion\n\nThis paper introduces Atlas Gaussians, a new representation for feed-forward 3D generation. Atlas Gaussians enable the efficient generation of a sufficiently large and theoretically infinite number of 3D Gaussians, which is crucial for high-quality 3D generation. We also designed a transformer-based decoder to link the low-dimensional latent space with the 3D space. With these innovations, we pioneer the integration of 3D Gaussians into the VAE + LDM paradigm, achieving superior performance and producing high-fidelity 3D content.\n\nLimitations and Future Work.\nOur method relies on a 3D dataset to train the VAE. A promising direction for future research is to explore training the VAE using in-the-wild real-world images. We plan to train our approach on large-scale data, similar to LRM \\[ [35](https://ar5iv.org/html/2408.13055#bib.bib35 \"\")\\], to fully explore the representation power of Atlas Gaussians.\n\nAdditionally, our method uses the vanilla 3D Gaussian representation, which is known to be challenging for extracting highly accurate geometry. Incorporating recent advancements \\[ [36](https://ar5iv.org/html/2408.13055#bib.bib36 \"\"), [110](https://ar5iv.org/html/2408.13055#bib.bib110 \"\"), [27](https://ar5iv.org/html/2408.13055#bib.bib27 \"\")\\] in 3D Gaussian techniques can benefit both geometry and appearance.\n\nBroader Impacts. In this paper, we propose a new representation for high-quality 3D generation, which may enhance productivity across several industries. However, if not used properly, it has the potential to be applied to generate deceptive or malicious 3D content.\n\nAcknowledgements. We sincerely thank Yushi Lan for his invaluable assistance in the evaluation.\n\n## References\n\n- \\[1\\]\nPanos Achlioptas, Olga Diamanti, Ioannis Mitliagkas, and Leonidas J. Guibas.\nLearning representations and generative models for 3d point clouds.\nIn Jennifer G. Dy and Andreas Krause, editors, Proceedings of the 35th International Conference on Machine Learning, ICML 2018, Stockholmsmässan, Stockholm, Sweden, July 10-15, 2018, volume 80 of Proceedings of Machine Learning Research, pages 40–49. PMLR, 2018.\n\n- \\[2\\]\nTitas Anciukevičius, Zexiang Xu, Matthew Fisher, Paul Henderson, Hakan Bilen, Niloy J. Mitra, and Paul Guerrero.\nRenderdiffusion: Image diffusion for 3d reconstruction, inpainting and generation.\nIn Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR), pages 12608–12618, June 2023.\n\n- \\[3\\]\nYoshua Bengio, Réjean Ducharme, and Pascal Vincent.\nA neural probabilistic language model.\nIn T. Leen, T. Dietterich, and V. Tresp, editors, Advances in Neural Information Processing Systems, volume 13. MIT Press, 2000.\n\n- \\[4\\]\nAndreas Blattmann, Tim Dockhorn, Sumith Kulal, Daniel Mendelevitch, Maciej Kilian, Dominik Lorenz, Yam Levi, Zion English, Vikram Voleti, Adam Letts, et al.\nStable video diffusion: Scaling latent video diffusion models to large datasets.\narXiv preprint arXiv:2311.15127, 2023.\n\n- \\[5\\]\nZiang Cao, Fangzhou Hong, Tong Wu, Liang Pan, and Ziwei Liu.\nLarge-vocabulary 3d diffusion model with transformer.\nIn The Twelfth International Conference on Learning Representations, 2024.\n\n- \\[6\\]\nEric R. Chan, Connor Z. Lin, Matthew A. Chan, Koki Nagano, Boxiao Pan, Shalini De Mello, Orazio Gallo, Leonidas J. Guibas, Jonathan Tremblay, Sameh Khamis, Tero Karras, and Gordon Wetzstein.\nEfficient geometry-aware 3d generative adversarial networks.\nIn Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR), pages 16123–16133, June 2022.\n\n- \\[7\\]\nAngel X. Chang, Thomas A. Funkhouser, Leonidas J. Guibas, Pat Hanrahan, Qi-Xing Huang, Zimo Li, Silvio Savarese, Manolis Savva, Shuran Song, Hao Su, Jianxiong Xiao, L. Yi, and Fisher Yu.\nShapenet: An information-rich 3d model repository.\nArXiv, abs/1512.03012, 2015.\n\n- \\[8\\]\nHansheng Chen, Jiatao Gu, Anpei Chen, Wei Tian, Zhuowen Tu, Lingjie Liu, and Hao Su.\nSingle-stage diffusion nerf: A unified approach to 3d generation and reconstruction.\nIn Proceedings of the IEEE/CVF International Conference on Computer Vision (ICCV), pages 2416–2425, October 2023.\n\n- \\[9\\]\nRui Chen, Yongwei Chen, Ningxin Jiao, and Kui Jia.\nFantasia3d: Disentangling geometry and appearance for high-quality text-to-3d content creation.\nIn Proceedings of the IEEE/CVF International Conference on Computer Vision, pages 22246–22256, 2023.\n\n- \\[10\\]\nZhiqin Chen, Andrea Tagliasacchi, and Hao Zhang.\nBsp-net: Generating compact meshes via binary space partitioning.\nProceedings of IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2020.\n\n- \\[11\\]\nZhiqin Chen and Hao Zhang.\nLearning implicit fields for generative shape modeling.\nProceedings of IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2019.\n\n- \\[12\\]\nZilong Chen, Yikai Wang, Feng Wang, Zhengyi Wang, and Huaping Liu.\nV3d: Video diffusion models are effective 3d generators.\narXiv preprint arXiv:2403.06738, 2024.\n\n- \\[13\\]\nYen-Chi Cheng, Hsin-Ying Lee, Sergey Tulyakov, Alexander G Schwing, and Liang-Yan Gui.\nSdfusion: Multimodal 3d shape completion, reconstruction, and generation.\nIn Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition, pages 4456–4465, 2023.\n\n- \\[14\\]\nBlender Online Community.\nBlender - a 3D modelling and rendering package.\nBlender Foundation, Stichting Blender Foundation, Amsterdam, 2018.\n\n- \\[15\\]\nMatt Deitke, Dustin Schwenk, Jordi Salvador, Luca Weihs, Oscar Michel, Eli VanderBilt, Ludwig Schmidt, Kiana Ehsani, Aniruddha Kembhavi, and Ali Farhadi.\nObjaverse: A universe of annotated 3d objects.\narXiv preprint arXiv:2212.08051, 2022.\n\n- \\[16\\]\nTheo Deprelle, Thibault Groueix, Matthew Fisher, Vladimir Kim, Bryan Russell, and Mathieu Aubry.\nLearning elementary structures for 3d shape generation and matching.\nIn H. Wallach, H. Larochelle, A. Beygelzimer, F. d'Alché-Buc, E. Fox, and R. Garnett, editors, Advances in Neural Information Processing Systems, volume 32. Curran Associates, Inc., 2019.\n\n- \\[17\\]\nAlexey Dosovitskiy, Lucas Beyer, Alexander Kolesnikov, Dirk Weissenborn, Xiaohua Zhai, Thomas Unterthiner, Mostafa Dehghani, Matthias Minderer, Georg Heigold, Sylvain Gelly, Jakob Uszkoreit, and Neil Houlsby.\nAn image is worth 16x16 words: Transformers for image recognition at scale.\nIn International Conference on Learning Representations, 2021.\n\n- \\[18\\]\nHaoqiang Fan, Hao Su, and Leonidas J. Guibas.\nA point set generation network for 3d object reconstruction from a single image.\nIn Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR), July 2017.\n\n- \\[19\\]\nWanquan Feng, Jin Li, Hongrui Cai, Xiaonan Luo, and Juyong Zhang.\nNeural points: Point cloud representation with neural fields for arbitrary upsampling.\n2022.\n\n- \\[20\\]\nMichael S. Floater and Kai Hormann.\nSurface parameterization: a tutorial and survey.\nIn Advances in Multiresolution for Geometric Modelling, 2005.\n\n- \\[21\\]\nJun Gao, Tianchang Shen, Zian Wang, Wenzheng Chen, Kangxue Yin, Daiqing Li, Or Litany, Zan Gojcic, and Sanja Fidler.\nGET3d: A generative model of high quality 3d textured shapes learned from images.\nIn Advances in Neural Information Processing Systems, 2022.\n\n- \\[22\\]\nShansan Gong, Mukai Li, Jiangtao Feng, Zhiyong Wu, and LingPeng Kong.\nDiffuseq: Sequence to sequence text generation with diffusion models.\narXiv preprint arXiv:2210.08933, 2022.\n\n- \\[23\\]\nIan Goodfellow, Jean Pouget-Abadie, Mehdi Mirza, Bing Xu, David Warde-Farley, Sherjil Ozair, Aaron Courville, and Yoshua Bengio.\nGenerative adversarial nets.\nIn Z. Ghahramani, M. Welling, C. Cortes, N. Lawrence, and K.Q. Weinberger, editors, Advances in Neural Information Processing Systems, volume 27. Curran Associates, Inc., 2014.\n\n- \\[24\\]\nAlex Graves.\nGenerating sequences with recurrent neural networks.\nArXiv, abs/1308.0850, 2013.\n\n- \\[25\\]\nThibault Groueix, Matthew Fisher, Vladimir G. Kim, Bryan C. Russell, and Mathieu Aubry.\nA papier-mâché approach to learning 3d surface generation.\nIn Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR), June 2018.\n\n- \\[26\\]\nJiatao Gu, Alex Trevithick, Kai-En Lin, Joshua M Susskind, Christian Theobalt, Lingjie Liu, and Ravi Ramamoorthi.\nNerfdiff: Single-image view synthesis with nerf-guided distillation from 3d-aware diffusion.\nIn International Conference on Machine Learning, pages 11808–11826. PMLR, 2023.\n\n- \\[27\\]\nAntoine Guédon and Vincent Lepetit.\nSugar: Surface-aligned gaussian splatting for efficient 3d mesh reconstruction and high-quality mesh rendering.\narXiv preprint arXiv:2311.12775, 2023.\n\n- \\[28\\]\nJunlin Han, Filippos Kokkinos, and Philip Torr.\nVfusion3d: Learning scalable 3d generative models from video diffusion models.\narXiv preprint arXiv:2403.12034, 2024.\n\n- \\[29\\]\nXianglong He, Junyi Chen, Sida Peng, Di Huang, Yangguang Li, Xiaoshui Huang, Chun Yuan, Wanli Ouyang, and Tong He.\nGvgen: Text-to-3d generation with volumetric representation, 2024.\n\n- \\[30\\]\nJack Hessel, Ari Holtzman, Maxwell Forbes, Ronan Le Bras, and Yejin Choi.\nCLIPScore: a reference-free evaluation metric for image captioning.\nIn EMNLP, 2021.\n\n- \\[31\\]\nJonathan Ho, William Chan, Chitwan Saharia, Jay Whang, Ruiqi Gao, Alexey Gritsenko, Diederik P Kingma, Ben Poole, Mohammad Norouzi, David J Fleet, et al.\nImagen video: High definition video generation with diffusion models.\narXiv preprint arXiv:2210.02303, 2022.\n\n- \\[32\\]\nJonathan Ho, Ajay Jain, and Pieter Abbeel.\nDenoising diffusion probabilistic models.\narXiv preprint arxiv:2006.11239, 2020.\n\n- \\[33\\]\nJonathan Ho and Tim Salimans.\nClassifier-free diffusion guidance.\narXiv preprint arXiv:2207.12598, 2022.\n\n- \\[34\\]\nJonathan Ho, Tim Salimans, Alexey Gritsenko, William Chan, Mohammad Norouzi, and David J Fleet.\nVideo diffusion models.\nAdvances in Neural Information Processing Systems, 35:8633–8646, 2022.\n\n- \\[35\\]\nYicong Hong, Kai Zhang, Jiuxiang Gu, Sai Bi, Yang Zhou, Difan Liu, Feng Liu, Kalyan Sunkavalli, Trung Bui, and Hao Tan.\nLRM: Large reconstruction model for single image to 3d.\nIn The Twelfth International Conference on Learning Representations, 2024.\n\n- \\[36\\]\nBinbin Huang, Zehao Yu, Anpei Chen, Andreas Geiger, and Shenghua Gao.\n2d gaussian splatting for geometrically accurate radiance fields.\nSIGGRAPH, 2024.\n\n- \\[37\\]\nRongjie Huang, Jiawei Huang, Dongchao Yang, Yi Ren, Luping Liu, Mingze Li, Zhenhui Ye, Jinglin Liu, Xiang Yin, and Zhou Zhao.\nMake-an-audio: Text-to-audio generation with prompt-enhanced diffusion models.\nIn International Conference on Machine Learning, pages 13916–13932. PMLR, 2023.\n\n- \\[38\\]\nKa-Hei Hui, Ruihui Li, Jingyu Hu, and Chi-Wing Fu.\nNeural wavelet-domain diffusion for 3d shape generation.\nDecember 2022.\n\n- \\[39\\]\nAndrew Jaegle, Sebastian Borgeaud, Jean-Baptiste Alayrac, Carl Doersch, Catalin Ionescu, David Ding, Skanda Koppula, Daniel Zoran, Andrew Brock, Evan Shelhamer, et al.\nPerceiver io: A general architecture for structured inputs & outputs.\narXiv preprint arXiv:2107.14795, 2021.\n\n- \\[40\\]\nAjay Jain, Ben Mildenhall, Jonathan T Barron, Pieter Abbeel, and Ben Poole.\nZero-shot text-guided object generation with dream fields.\nIn Proceedings of the IEEE/CVF conference on computer vision and pattern recognition, pages 867–876, 2022.\n\n- \\[41\\]\nHanwen Jiang, Zhenyu Jiang, Kristen Grauman, and Yuke Zhu.\nFew-view object reconstruction with unknown categories and camera poses.\narXiv preprint arXiv:2212.04492, 2022.\n\n- \\[42\\]\nHanwen Jiang, Zhenyu Jiang, Yue Zhao, and Qixing Huang.\nLEAP: Liberate sparse-view 3d modeling from camera poses.\nIn The Twelfth International Conference on Learning Representations, 2024.\n\n- \\[43\\]\nHeewoo Jun and Alex Nichol.\nShap-e: Generating conditional 3d implicit functions.\nArXiv, abs/2305.02463, 2023.\n\n- \\[44\\]\nTero Karras, Miika Aittala, Timo Aila, and Samuli Laine.\nElucidating the design space of diffusion-based generative models.\nIn Alice H. Oh, Alekh Agarwal, Danielle Belgrave, and Kyunghyun Cho, editors, Advances in Neural Information Processing Systems, 2022.\n\n- \\[45\\]\nBernhard Kerbl, Georgios Kopanas, Thomas Leimkühler, and George Drettakis.\n3d gaussian splatting for real-time radiance field rendering.\nACM Transactions on Graphics, 42(4), July 2023.\n\n- \\[46\\]\nDiederik P. Kingma and Max Welling.\nAuto-encoding variational bayes.\nCoRR, abs/1312.6114, 2013.\n\n- \\[47\\]\nZhifeng Kong, Wei Ping, Jiaji Huang, Kexin Zhao, and Bryan Catanzaro.\nDiffwave: A versatile diffusion model for audio synthesis.\narXiv preprint arXiv:2009.09761, 2020.\n\n- \\[48\\]\nYushi Lan, Fangzhou Hong, Shuai Yang, Shangchen Zhou, Xuyi Meng, Bo Dai, Xingang Pan, and Chen Change Loy.\nLn3diff: Scalable latent neural fields diffusion for speedy 3d generation, 2024.\n\n- \\[49\\]\nJiahao Li, Hao Tan, Kai Zhang, Zexiang Xu, Fujun Luan, Yinghao Xu, Yicong Hong, Kalyan Sunkavalli, Greg Shakhnarovich, and Sai Bi.\nInstant3d: Fast text-to-3d with sparse-view generation and large reconstruction model.\narXiv preprint arXiv:2311.06214, 2023.\n\n- \\[50\\]\nMuheng Li, Yueqi Duan, Jie Zhou, and Jiwen Lu.\nDiffusion-sdf: Text-to-shape via voxelized diffusion.\nIn Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition, pages 12642–12651, 2023.\n\n- \\[51\\]\nXiang Li, John Thickstun, Ishaan Gulrajani, Percy S Liang, and Tatsunori B Hashimoto.\nDiffusion-lm improves controllable text generation.\nAdvances in Neural Information Processing Systems, 35:4328–4343, 2022.\n\n- \\[52\\]\nChen-Hsuan Lin, Jun Gao, Luming Tang, Towaki Takikawa, Xiaohui Zeng, Xun Huang, Karsten Kreis, Sanja Fidler, Ming-Yu Liu, and Tsung-Yi Lin.\nMagic3d: High-resolution text-to-3d content creation.\nIn Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition, pages 300–309, 2023.\n\n- \\[53\\]\nZhenghao Lin, Yeyun Gong, Yelong Shen, Tong Wu, Zhihao Fan, Chen Lin, Nan Duan, and Weizhu Chen.\nText generation with diffusion language models: A pre-training approach with continuous paragraph denoise.\nIn International Conference on Machine Learning, pages 21051–21064. PMLR, 2023.\n\n- \\[54\\]\nHaohe Liu, Zehua Chen, Yi Yuan, Xinhao Mei, Xubo Liu, Danilo Mandic, Wenwu Wang, and Mark D Plumbley.\nAudioldm: Text-to-audio generation with latent diffusion models.\narXiv preprint arXiv:2301.12503, 2023.\n\n- \\[55\\]\nMinghua Liu, Lu Sheng, Sheng Yang, Jing Shao, and Shi-Min Hu.\nMorphing and sampling network for dense point cloud completion.\narXiv preprint arXiv:1912.00280, 2019.\n\n- \\[56\\]\nMinghua Liu, Ruoxi Shi, Linghao Chen, Zhuoyang Zhang, Chao Xu, Xinyue Wei, Hansheng Chen, Chong Zeng, Jiayuan Gu, and Hao Su.\nOne-2-3-45++: Fast single image to 3d objects with consistent multi-view generation and 3d diffusion.\narXiv preprint arXiv:2311.07885, 2023.\n\n- \\[57\\]\nMinghua Liu, Chao Xu, Haian Jin, Linghao Chen, Mukund Varma T, Zexiang Xu, and Hao Su.\nOne-2-3-45: Any single image to 3d mesh in 45 seconds without per-shape optimization.\nAdvances in Neural Information Processing Systems, 36, 2024.\n\n- \\[58\\]\nRuoshi Liu, Rundi Wu, Basile Van Hoorick, Pavel Tokmakov, Sergey Zakharov, and Carl Vondrick.\nZero-1-to-3: Zero-shot one image to 3d object, 2023.\n\n- \\[59\\]\nYuan Liu, Cheng Lin, Zijiao Zeng, Xiaoxiao Long, Lingjie Liu, Taku Komura, and Wenping Wang.\nSyncdreamer: Generating multiview-consistent images from a single-view image.\narXiv preprint arXiv:2309.03453, 2023.\n\n- \\[60\\]\nZhen Liu, Yao Feng, Michael J Black, Derek Nowrouzezahrai, Liam Paull, and Weiyang Liu.\nMeshdiffusion: Score-based generative 3d mesh modeling.\narXiv preprint arXiv:2303.08133, 2023.\n\n- \\[61\\]\nXiaoxiao Long, Yuan-Chen Guo, Cheng Lin, Yuan Liu, Zhiyang Dou, Lingjie Liu, Yuexin Ma, Song-Hai Zhang, Marc Habermann, Christian Theobalt, et al.\nWonder3d: Single image to 3d using cross-domain diffusion.\narXiv preprint arXiv:2310.15008, 2023.\n\n- \\[62\\]\nIlya Loshchilov and Frank Hutter.\nDecoupled weight decay regularization.\nIn International Conference on Learning Representations, 2019.\n\n- \\[63\\]\nShitong Luo and Wei Hu.\nDiffusion probabilistic models for 3d point cloud generation.\nIn Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition, pages 2837–2845, 2021.\n\n- \\[64\\]\nTiange Luo, Chris Rockwell, Honglak Lee, and Justin Johnson.\nScalable 3d captioning with pretrained models.\narXiv preprint arXiv:2306.07279, 2023.\n\n- \\[65\\]\nLars Mescheder, Michael Oechsle, Michael Niemeyer, Sebastian Nowozin, and Andreas Geiger.\nOccupancy networks: Learning 3d reconstruction in function space.\nIn Proceedings IEEE Conf. on Computer Vision and Pattern Recognition (CVPR), 2019.\n\n- \\[66\\]\nBen Mildenhall, Pratul P. Srinivasan, Matthew Tancik, Jonathan T. Barron, Ravi Ramamoorthi, and Ren Ng.\nNerf: Representing scenes as neural radiance fields for view synthesis.\nIn ECCV, 2020.\n\n- \\[67\\]\nParitosh Mittal, Yen-Chi Cheng, Maneesh Singh, and Shubham Tulsiani.\nAutosdf: Shape priors for 3d completion, reconstruction and generation.\nIn Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition, pages 306–315, 2022.\n\n- \\[68\\]\nKaichun Mo, Paul Guerrero, Li Yi, Hao Su, Peter Wonka, Niloy Mitra, and Leonidas Guibas.\nStructurenet: Hierarchical graph networks for 3d shape generation.\nACM Transactions on Graphics (TOG), Siggraph Asia 2019, 38(6):Article 242, 2019.\n\n- \\[69\\]\nNorman Müller, Yawar Siddiqui, Lorenzo Porzi, Samuel Rota Bulò, Peter Kontschieder, and Matthias Nießner.\nDiffrf: Rendering-guided 3d radiance field diffusion.\nIn Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR), pages 4328–4338, June 2023.\n\n- \\[70\\]\nThomas Müller, Alex Evans, Christoph Schied, and Alexander Keller.\nInstant neural graphics primitives with a multiresolution hash encoding.\nACM Trans. Graph., 41(4):102:1–102:15, July 2022.\n\n- \\[71\\]\nCharlie Nash, Yaroslav Ganin, S. M. Ali Eslami, and Peter W. Battaglia.\nPolygen: An autoregressive generative model of 3d meshes.\nICML, 2020.\n\n- \\[72\\]\nMaxime Oquab, Timothée Darcet, Théo Moutakanni, Huy V. Vo, Marc Szafraniec, Vasil Khalidov, Pierre Fernandez, Daniel HAZIZA, Francisco Massa, Alaaeldin El-Nouby, Mido Assran, Nicolas Ballas, Wojciech Galuba, Russell Howes, Po-Yao Huang, Shang-Wen Li, Ishan Misra, Michael Rabbat, Vasu Sharma, Gabriel Synnaeve, Hu Xu, Herve Jegou, Julien Mairal, Patrick Labatut, Armand Joulin, and Piotr Bojanowski.\nDINOv2: Learning robust visual features without supervision.\nTransactions on Machine Learning Research, 2024.\n\n- \\[73\\]\nJeong Joon Park, Peter Florence, Julian Straub, Richard Newcombe, and Steven Lovegrove.\nDeepsdf: Learning continuous signed distance functions for shape representation.\nIn The IEEE Conference on Computer Vision and Pattern Recognition (CVPR), June 2019.\n\n- \\[74\\]\nWilliam Peebles and Saining Xie.\nScalable diffusion models with transformers.\narXiv preprint arXiv:2212.09748, 2022.\n\n- \\[75\\]\nDustin Podell, Zion English, Kyle Lacey, Andreas Blattmann, Tim Dockhorn, Jonas Müller, Joe Penna, and Robin Rombach.\nSdxl: Improving latent diffusion models for high-resolution image synthesis.\narXiv preprint arXiv:2307.01952, 2023.\n\n- \\[76\\]\nBen Poole, Ajay Jain, Jonathan T Barron, and Ben Mildenhall.\nDreamfusion: Text-to-3d using 2d diffusion.\narXiv preprint arXiv:2209.14988, 2022.\n\n- \\[77\\]\nLingteng Qiu, Guanying Chen, Xiaodong Gu, Qi zuo, Mutian Xu, Yushuang Wu, Weihao Yuan, Zilong Dong, Liefeng Bo, and Xiaoguang Han.\nRichdreamer: A generalizable normal-depth diffusion model for detail richness in text-to-3d.\narXiv preprint arXiv:2311.16918, 2023.\n\n- \\[78\\]\nAlec Radford, Jong Wook Kim, Chris Hallacy, Aditya Ramesh, Gabriel Goh, Sandhini Agarwal, Girish Sastry, Amanda Askell, Pamela Mishkin, Jack Clark, Gretchen Krueger, and Ilya Sutskever.\nLearning transferable visual models from natural language supervision.\nIn Marina Meila and Tong Zhang, editors, Proceedings of the 38th International Conference on Machine Learning, volume 139 of Proceedings of Machine Learning Research, pages 8748–8763. PMLR, 18–24 Jul 2021.\n\n- \\[79\\]\nAditya Ramesh, Prafulla Dhariwal, Alex Nichol, Casey Chu, and Mark Chen.\nHierarchical text-conditional image generation with clip latents.\narXiv preprint arXiv:2204.06125, 1(2):3, 2022.\n\n- \\[80\\]\nXuanchi Ren, Jiahui Huang, Xiaohui Zeng, Ken Museth, Sanja Fidler, and Francis Williams.\nXcube: Large-scale 3d generative modeling using sparse voxel hierarchies.\nIn Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition, 2024.\n\n- \\[81\\]\nDanilo Rezende and Shakir Mohamed.\nVariational inference with normalizing flows.\nIn Francis Bach and David Blei, editors, Proceedings of the 32nd International Conference on Machine Learning, volume 37 of Proceedings of Machine Learning Research, pages 1530–1538, Lille, France, 07–09 Jul 2015. PMLR.\n\n- \\[82\\]\nRobin Rombach, Andreas Blattmann, Dominik Lorenz, Patrick Esser, and Björn Ommer.\nHigh-resolution image synthesis with latent diffusion models.\nIn Proceedings of the IEEE/CVF conference on computer vision and pattern recognition, pages 10684–10695, 2022.\n\n- \\[83\\]\nChitwan Saharia, William Chan, Saurabh Saxena, Lala Li, Jay Whang, Emily L Denton, Kamyar Ghasemipour, Raphael Gontijo Lopes, Burcu Karagol Ayan, Tim Salimans, et al.\nPhotorealistic text-to-image diffusion models with deep language understanding.\nAdvances in neural information processing systems, 35:36479–36494, 2022.\n\n- \\[84\\]\nRuoxi Shi, Hansheng Chen, Zhuoyang Zhang, Minghua Liu, Chao Xu, Xinyue Wei, Linghao Chen, Chong Zeng, and Hao Su.\nZero123++: a single image to consistent multi-view diffusion base model, 2023.\n\n- \\[85\\]\nWenzhe Shi, Jose Caballero, Ferenc Huszar, Johannes Totz, Andrew P. Aitken, Rob Bishop, Daniel Rueckert, and Zehan Wang.\nReal-time single image and video super-resolution using an efficient sub-pixel convolutional neural network.\nIn Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR), June 2016.\n\n- \\[86\\]\nYichun Shi, Peng Wang, Jianglong Ye, Mai Long, Kejie Li, and Xiao Yang.\nMvdream: Multi-view diffusion for 3d generation.\narXiv preprint arXiv:2308.16512, 2023.\n\n- \\[87\\]\nJ. Ryan Shue, Eric Ryan Chan, Ryan Po, Zachary Ankner, Jiajun Wu, and Gordon Wetzstein.\n3d neural field generation using triplane diffusion.\nIn Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR), pages 20875–20886, June 2023.\n\n- \\[88\\]\nYawar Siddiqui, Antonio Alliegro, Alexey Artemov, Tatiana Tommasi, Daniele Sirigatti, Vladislav Rosov, Angela Dai, and Matthias Nießner.\nMeshgpt: Generating triangle meshes with decoder-only transformers.\narXiv preprint arXiv:2311.15475, 2023.\n\n- \\[89\\]\nVincent Sitzmann, Michael Zollhöfer, and Gordon Wetzstein.\nScene representation networks: Continuous 3d-structure-aware neural scene representations.\nIn Advances in Neural Information Processing Systems, 2019.\n\n- \\[90\\]\nJascha Sohl-Dickstein, Eric Weiss, Niru Maheswaranathan, and Surya Ganguli.\nDeep unsupervised learning using nonequilibrium thermodynamics.\nIn Proceedings of the 32nd International Conference on Machine Learning, volume 37 of Proceedings of Machine Learning Research, pages 2256–2265, Lille, France, 07–09 Jul 2015. PMLR.\n\n- \\[91\\]\nJiaming Song, Chenlin Meng, and Stefano Ermon.\nDenoising diffusion implicit models.\narXiv:2010.02502, October 2020.\n\n- \\[92\\]\nYang Song, Jascha Sohl-Dickstein, Diederik P Kingma, Abhishek Kumar, Stefano Ermon, and Ben Poole.\nScore-based generative modeling through stochastic differential equations.\nIn International Conference on Learning Representations, 2021.\n\n- \\[93\\]\nJingxiang Sun, Bo Zhang, Ruizhi Shao, Lizhen Wang, Wen Liu, Zhenda Xie, and Yebin Liu.\nDreamcraft3d: Hierarchical 3d generation with bootstrapped diffusion prior.\narXiv preprint arXiv:2310.16818, 2023.\n\n- \\[94\\]\nYongbin Sun, Yue Wang, Ziwei Liu, Joshua Siegel, and Sanjay Sarma.\nPointgrow: Autoregressively learned point cloud generation with self-attention.\nIn Proceedings of the IEEE/CVF Winter Conference on Applications of Computer Vision, pages 61–70, 2020.\n\n- \\[95\\]\nYongbin Sun, Yue Wang, Ziwei Liu, Joshua E Siegel, and Sanjay E Sarma.\nPointgrow: Autoregressively learned point cloud generation with self-attention.\nIn Winter Conference on Applications of Computer Vision, 2020.\n\n- \\[96\\]\nStanislaw Szymanowicz, Christian Rupprecht, and Andrea Vedaldi.\nSplatter image: Ultra-fast single-view 3d reconstruction.\nIn The IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR), 2024.\n\n- \\[97\\]\nJiaxiang Tang, Zhaoxi Chen, Xiaokang Chen, Tengfei Wang, Gang Zeng, and Ziwei Liu.\nLgm: Large multi-view gaussian model for high-resolution 3d content creation.\narXiv preprint arXiv:2402.05054, 2024.\n\n- \\[98\\]\nGuy Tevet, Sigal Raab, Brian Gordon, Yonatan Shafir, Daniel Cohen-Or, and Amit H Bermano.\nHuman motion diffusion model.\narXiv preprint arXiv:2209.14916, 2022.\n\n- \\[99\\]\nHaochen Wang, Xiaodan Du, Jiahao Li, Raymond A Yeh, and Greg Shakhnarovich.\nScore jacobian chaining: Lifting pretrained 2d diffusion models for 3d generation.\nIn Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition, pages 12619–12629, 2023.\n\n- \\[100\\]\nPeng Wang and Yichun Shi.\nImagedream: Image-prompt multi-view diffusion for 3d generation.\narXiv preprint arXiv:2312.02201, 2023.\n\n- \\[101\\]\nZhengyi Wang, Cheng Lu, Yikai Wang, Fan Bao, Chongxuan Li, Hang Su, and Jun Zhu.\nProlificdreamer: High-fidelity and diverse text-to-3d generation with variational score distillation.\nAdvances in Neural Information Processing Systems, 36, 2024.\n\n- \\[102\\]\nDaniel Watson, William Chan, Ricardo Martin Brualla, Jonathan Ho, Andrea Tagliasacchi, and Mohammad Norouzi.\nNovel view synthesis with diffusion models.\nIn The Eleventh International Conference on Learning Representations, 2023.\n\n- \\[103\\]\nJiajun Wu, Chengkai Zhang, Tianfan Xue, Bill Freeman, and Josh Tenenbaum.\nLearning a probabilistic latent space of object shapes via 3d generative-adversarial modeling.\nAdvances in neural information processing systems, 29, 2016.\n\n- \\[104\\]\nJianwen Xie, Yifei Xu, Zilong Zheng, Ruiqi Gao, Wenguan Wang, Zhu Song-Chun, and Ying Nian Wu.\nGenerative pointnet: Deep energy-based learning on unordered point sets for 3d generation, reconstruction and classification.\nIn The IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2021.\n\n- \\[105\\]\nDejia Xu, Ye Yuan, Morteza Mardani, Sifei Liu, Jiaming Song, Zhangyang Wang, and Arash Vahdat.\nAgg: Amortized generative 3d gaussians for single image to 3d.\narXiv preprint 2401.04099, 2024.\n\n- \\[106\\]\nJiale Xu, Weihao Cheng, Yiming Gao, Xintao Wang, Shenghua Gao, and Ying Shan.\nInstantmesh: Efficient 3d mesh generation from a single image with sparse-view large reconstruction models.\narXiv preprint arXiv:2404.07191, 2024.\n\n- \\[107\\]\nXingguang Yan, Liqiang Lin, Niloy J. Mitra, Dani Lischinski, Danny Cohen-Or, and Hui Huang.\nShapeformer: Transformer-based shape completion via sparse representation.\nIn Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition, 2022.\n\n- \\[108\\]\nGuandao Yang, Xun Huang, Zekun Hao, Ming-Yu Liu, Serge Belongie, and Bharath Hariharan.\nPointflow: 3d point cloud generation with continuous normalizing flows.\nIn Proceedings of the IEEE/CVF International Conference on Computer Vision (ICCV), October 2019.\n\n- \\[109\\]\nXu Yinghao, Shi Zifan, Yifan Wang, Chen Hansheng, Yang Ceyuan, Peng Sida, Shen Yujun, and Wetzstein Gordon.\nGrm: Large gaussian reconstruction model for efficient 3d reconstruction and generation, 2024.\n\n- \\[110\\]\nZehao Yu, Torsten Sattler, and Andreas Geiger.\nGaussian opacity fields: Efficient high-quality compact surface reconstruction in unbounded scenes.\narXiv preprint arXiv:2404.10772, 2024.\n\n- \\[111\\]\nYe Yuan, Jiaming Song, Umar Iqbal, Arash Vahdat, and Jan Kautz.\nPhysdiff: Physics-guided human motion diffusion model.\nIn Proceedings of the IEEE/CVF International Conference on Computer Vision, pages 16010–16021, 2023.\n\n- \\[112\\]\nXiaohui Zeng, Arash Vahdat, Francis Williams, Zan Gojcic, Or Litany, Sanja Fidler, and Karsten Kreis.\nLion: Latent point diffusion models for 3d shape generation.\nIn Advances in Neural Information Processing Systems (NeurIPS), 2022.\n\n- \\[113\\]\nBiao Zhang, Matthias Nießner, and Peter Wonka.\n3DILG: Irregular latent grids for 3d generative modeling.\nIn Alice H. Oh, Alekh Agarwal, Danielle Belgrave, and Kyunghyun Cho, editors, Advances in Neural Information Processing Systems, 2022.\n\n- \\[114\\]\nBiao Zhang, Jiapeng Tang, Matthias Nießner, and Peter Wonka.\n3dshape2vecset: A 3d shape representation for neural fields and generative diffusion models.\nACM Trans. Graph., 42(4), jul 2023.\n\n- \\[115\\]\nLvmin Zhang, Anyi Rao, and Maneesh Agrawala.\nAdding conditional control to text-to-image diffusion models.\nIn Proceedings of the IEEE/CVF International Conference on Computer Vision, pages 3836–3847, 2023.\n\n- \\[116\\]\nMingyuan Zhang, Zhongang Cai, Liang Pan, Fangzhou Hong, Xinying Guo, Lei Yang, and Ziwei Liu.\nMotiondiffuse: Text-driven human motion generation with diffusion model.\nIEEE Transactions on Pattern Analysis and Machine Intelligence, 2024.\n\n- \\[117\\]\nRichard Zhang, Phillip Isola, Alexei A. Efros, Eli Shechtman, and Oliver Wang.\nThe unreasonable effectiveness of deep features as a perceptual metric.\nIn Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR), June 2018.\n\n- \\[118\\]\nXin-Yang Zheng, Hao Pan, Peng-Shuai Wang, Xin Tong, Yang Liu, and Heung-Yeung Shum.\nLocally attentional sdf diffusion for controllable 3d shape generation.\nACM Transactions on Graphics (TOG), 42(4):1–13, 2023.\n\n- \\[119\\]\nXinyang Zheng, Yang Liu, Pengshuai Wang, and Xin Tong.\nSdf-stylegan: Implicit sdf-based stylegan for 3d shape generation.\nIn Computer Graphics Forum, volume 41, pages 52–63. Wiley Online Library, 2022.\n\n- \\[120\\]\nLinqi Zhou, Yilun Du, and Jiajun Wu.\n3d shape generation and completion through point-voxel diffusion.\nIn Proceedings of the IEEE/CVF international conference on computer vision, pages 5826–5835, 2021.\n\n- \\[121\\]\nZi-Xin Zou, Zhipeng Yu, Yuan-Chen Guo, Yangguang Li, Ding Liang, Yan-Pei Cao, and Song-Hai Zhang.\nTriplane meets gaussian splatting: Fast and generalizable single-view 3d reconstruction with transformers.\narXiv preprint arXiv:2312.09147, 2023.\n\n\n## Appendix A Implementation details\n\nThe VAE training consists of two stages. In the first stage, λrsubscript𝜆𝑟\\\\lambda\\_{r} in equation [11](https://ar5iv.org/html/2408.13055#S3.E11 \"In 3.2 Stage 1: VAE ‣ 3 Method ‣ Atlas Gaussians Diffusion for 3D Generation with Infinite Number of Points\") is set to 0. Rendering occurs only in the second stage with λrsubscript𝜆𝑟\\\\lambda\\_{r} set to 1.\n\nIn both stages, λK​Lsubscript𝜆𝐾𝐿\\\\lambda\\_{KL} maintains 1​e−41superscript𝑒41e^{-4}. we utilize a sparse point cloud of 2048 points and 4 input views, each of size 224×224224224224\\\\times 224. M=2048𝑀2048M=2048 patches are used in all experiments. For the latent, n=512𝑛512n=512, d=512𝑑512d=512. We set d0subscript𝑑0d\\_{0} to 64, 4, and 4 for the ShapeNet Chair, Plane, and Car categories, respectively. We set d0subscript𝑑0d\\_{0} to 16 in Objaverse. In ShapeNet, α𝛼\\\\alpha is set to 4, resulting in N=32768𝑁32768N=32768 3D Gaussians. In Objaverse, α=7𝛼7\\\\alpha=7. Due to the real-time rendering capabilities of the 3D Gaussians, we are able to produce an output image of size 512×512512512512\\\\times 512. We use the EMD implementation from \\[ [55](https://ar5iv.org/html/2408.13055#bib.bib55 \"\")\\], which supports fast and efficient computation even with up to 8192 points. All networks are trained on 8 Tesla V100 GPUs for 1000 epochs using the AdamW optimizer \\[ [62](https://ar5iv.org/html/2408.13055#bib.bib62 \"\")\\] with the one-cycle policy. Our VAE is trained using mixed precision (fp16) and supports a batch size of 8 per GPU. Notably, the model does not require the latest A100 GPUs for training. For instance, when trained on the ShapeNet dataset, it requires approximately 22GB of memory per GPU, making it accessible to a wide range of laboratories. Furthermore, the training process is completed in less than 30 hours.\n\nFor the latent diffusion model, we set l=12𝑙12l=12 for ShapeNet and l=24𝑙24l=24 for Objaverse. The final latents are obtained via 40 denoising steps.\n\n## Appendix B More results of text-conditioned 3D generation\n\nIn Figure [7](https://ar5iv.org/html/2408.13055#A2.F7 \"Figure 7 ‣ Appendix B More results of text-conditioned 3D generation ‣ Atlas Gaussians Diffusion for 3D Generation with Infinite Number of Points\"), we provide more results of text-conditioned 3D generation using our method.\n\n\\\\begin{overpic}\\[width=433.62pt\\]{figures/supp\\_objaverse/supp\\_objaverse.pdf}\n\\\\end{overpic}Figure 7: More results of text-conditioned 3D generation using our method.\n\n[◄](https://ar5iv.org/html/2408.13054) [![ar5iv homepage](https://ar5iv.org/assets/ar5iv.png)](https://ar5iv.org/) [Feeling\\\\\n\\\\\nlucky?](https://ar5iv.org/feeling_lucky) [Conversion\\\\\n\\\\\nreport](https://ar5iv.org/log/2408.13055) [Report\\\\\n\\\\\nan issue](https://github.com/dginev/ar5iv/issues/new?template=improve-article--arxiv-id-.md&title=Improve+article+2408.13055) [View original\\\\\n\\\\\non arXiv](https://arxiv.org/abs/2408.13055) [►](https://ar5iv.org/html/2408.13056)",
  "sections": {
    "1 Introduction": {
      "content": "3D generation has become increasingly important across various domains, including virtual reality, gaming, and film production. Recent advances in diffusion models \\[ [32], [91]\\] have improved the 3D generation quality, offering superior performance over previous methods, such as variational autoencoders (VAEs) \\[ [46], [68]\\] and generative adversarial networks (GANs)\\[ [23], [21]\\].\n\nDespite progress, the effectiveness of 3D generation still falls short when compared to 2D generation models \\[ [33], [79], [83]\\]. The robust performance in 2D generation is largely due to the effective integration of VAEs with latent diffusion models (LDMs) \\[ [82]\\].\nA primary challenge hindering the complete success of this paradigm in 3D generation is the development of a high-fidelity 3D representation that can be efficiently embedded into a low-dimensional latent space. Pioneering efforts have applied diffusion models to various traditional 3D representations, such as point clouds \\[ [112], [120], [63]\\], meshes \\[ [60]\\], occupancy fields \\[ [118], [114]\\] and signed distance functions \\[ [13], [50]\\]. However, these approaches often focus solely on modeling geometry without considering the appearance attributes. More recently, a notable attempt \\[ [48]\\] has designed a VAE that uses volume rendering techniques \\[ [66]\\] to incorporate appearance modeling. Nevertheless, volume rendering presents inherent limitations, including slow rendering speeds and constrained rendering resolutions. To overcome these limitations, we have developed a VAE that leverages the latest 3D Gaussian representation \\[ [45]\\], which significantly improves both the quality and speed of rendering.\n\nDesigning a VAE based on 3D Gaussians presents considerable challenges. The first challenge lies in creating an efficient decoder capable of mapping low-dimensional latents to 3D Gaussians. Existing methods for 3D Gaussian decoding predominantly focus on reconstruction tasks and typically lack an information bottleneck design \\[ [97], [109]\\], thus failing to provide low-dimensional latent directly. Alternatively, they often require multiple complex and interdependent components \\[ [105], [121]\\]. The second challenge involves generating a sufficiently large number of 3D Gaussians efficiently, since high-quality rendering necessitates an adequate quantity of these Gaussians. Some current methods \\[ [105], [121]\\] address this by employing additional complex point-upsampling networks to increase the number of 3D Gaussians, which inherently limits the number of Gaussians that can be generated. Other techniques \\[ [97], [109]\\] utilize image representations to generate a large number of 3D Gaussians. However, for all these methods, more network parameters are usually required as the number of 3D Gaussians increases.\n\nTo address the challenges of designing VAEs for 3D Gaussians, we propose Atlas Gaussians, a new representation for 3D generation. This representation is inspired by surface parameterization \\[ [20]\\], a fundamental technique in many graphics applications where surface attributes are sampled and stored in a 2D texture map. Specifically, Atlas Gaussians model the shape as a union of local patches, with each patch decoding 3D Gaussians via UV-based sampling. By parameterizing 3D Gaussians in the UV space, we can easily generate a sufficiently large, and theoretically infinite, number of 3D Gaussians. Unlike traditional surface parameterization approaches, the UV mapping in Atlas Gaussians are learned end-to-end using a corner-encoding scheme. A significant advantage of Atlas Gaussians is that the sampling process does not require additional network parameters as the number of 3D Gaussians increases.\n\nWe design a transformer-based decoder to map low-dimensional latents to Atlas Gaussians. This decoder achieves geometry and appearance disentanglement by design, facilitating faster convergence and improved representation capabilities.\nLeveraging the local awareness of Atlas Gaussians, we also reduce computational complexity by decomposing the self-attention layers.\nFinally, the latent space learned by our VAE can be applied to existing latent diffusion models efficiently.\n\nNote that in contrast to the major approach in 3D generation that uses the multi-view representation \\[ [100], [61], [59], [86]\\], our approach is inherently 3D-based. Therefore, a key advantage is that we do not need to address the challenging multi-view consistency issue associated the multi-view representation.\nWe take inspiration from the literature that 3D-based neural networks learn better 3D features for recognition and outperform multi-view based networks that leverage massive 2D labeled data.\nMoreover, the rendering module of Atlas Gaussians allows representation learning from images.\n\nIn summary, we make the following contributions.\n\n• We propose Atlas Gaussians, a new 3D representation that can efficiently decode a sufficiently large and theoretically infinite number of 3D Gaussians for high-quality 3D generation.\n\n• We design a new transformer-based decoder to map low-dimensional latents to Atlas Gaussians, achieving geometry and appearance disentanglement by design along with efficient computation.\n\n• We pioneer the integration of 3D Gaussians into the VAE + LDM paradigm, demonstrating superior performance on standard 3D generation benchmarks.",
      "citations": [
        {
          "start_pos": 167,
          "end_pos": 171,
          "text": "[32]",
          "paper_id": "bib.bib32",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 173,
          "end_pos": 177,
          "text": "[91]",
          "paper_id": "bib.bib91",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 317,
          "end_pos": 321,
          "text": "[46]",
          "paper_id": "bib.bib46",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 323,
          "end_pos": 327,
          "text": "[68]",
          "paper_id": "bib.bib68",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 375,
          "end_pos": 379,
          "text": "[23]",
          "paper_id": "bib.bib23",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 381,
          "end_pos": 385,
          "text": "[21]",
          "paper_id": "bib.bib21",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 502,
          "end_pos": 506,
          "text": "[33]",
          "paper_id": "bib.bib33",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 508,
          "end_pos": 512,
          "text": "[79]",
          "paper_id": "bib.bib79",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 514,
          "end_pos": 518,
          "text": "[83]",
          "paper_id": "bib.bib83",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 653,
          "end_pos": 657,
          "text": "[82]",
          "paper_id": "bib.bib82",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 988,
          "end_pos": 993,
          "text": "[112]",
          "paper_id": "bib.bib112",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib120",
            "bib.bib118",
            "bib.bib114"
          ]
        },
        {
          "start_pos": 995,
          "end_pos": 1000,
          "text": "[120]",
          "paper_id": "bib.bib120",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib112",
            "bib.bib118",
            "bib.bib114"
          ]
        },
        {
          "start_pos": 1002,
          "end_pos": 1006,
          "text": "[63]",
          "paper_id": "bib.bib63",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1020,
          "end_pos": 1024,
          "text": "[60]",
          "paper_id": "bib.bib60",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1048,
          "end_pos": 1053,
          "text": "[118]",
          "paper_id": "bib.bib118",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib114",
            "bib.bib120",
            "bib.bib112"
          ]
        },
        {
          "start_pos": 1055,
          "end_pos": 1060,
          "text": "[114]",
          "paper_id": "bib.bib114",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib118",
            "bib.bib120",
            "bib.bib112"
          ]
        },
        {
          "start_pos": 1096,
          "end_pos": 1100,
          "text": "[13]",
          "paper_id": "bib.bib13",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1102,
          "end_pos": 1106,
          "text": "[50]",
          "paper_id": "bib.bib50",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1259,
          "end_pos": 1263,
          "text": "[48]",
          "paper_id": "bib.bib48",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1326,
          "end_pos": 1330,
          "text": "[66]",
          "paper_id": "bib.bib66",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1613,
          "end_pos": 1617,
          "text": "[45]",
          "paper_id": "bib.bib45",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 2023,
          "end_pos": 2027,
          "text": "[97]",
          "paper_id": "bib.bib97",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 2029,
          "end_pos": 2034,
          "text": "[109]",
          "paper_id": "bib.bib109",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib105",
            "bib.bib121",
            "bib.bib114"
          ]
        },
        {
          "start_pos": 2179,
          "end_pos": 2184,
          "text": "[105]",
          "paper_id": "bib.bib105",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib121",
            "bib.bib109",
            "bib.bib114"
          ]
        },
        {
          "start_pos": 2186,
          "end_pos": 2191,
          "text": "[121]",
          "paper_id": "bib.bib121",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib105",
            "bib.bib109",
            "bib.bib114"
          ]
        },
        {
          "start_pos": 2400,
          "end_pos": 2405,
          "text": "[105]",
          "paper_id": "bib.bib105",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib121",
            "bib.bib109",
            "bib.bib114"
          ]
        },
        {
          "start_pos": 2407,
          "end_pos": 2412,
          "text": "[121]",
          "paper_id": "bib.bib121",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib105",
            "bib.bib109",
            "bib.bib114"
          ]
        },
        {
          "start_pos": 2617,
          "end_pos": 2621,
          "text": "[97]",
          "paper_id": "bib.bib97",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 2623,
          "end_pos": 2628,
          "text": "[109]",
          "paper_id": "bib.bib109",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib121",
            "bib.bib105",
            "bib.bib114"
          ]
        },
        {
          "start_pos": 3017,
          "end_pos": 3021,
          "text": "[20]",
          "paper_id": "bib.bib20",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 4318,
          "end_pos": 4323,
          "text": "[100]",
          "paper_id": "bib.bib100",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 4325,
          "end_pos": 4329,
          "text": "[61]",
          "paper_id": "bib.bib61",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 4331,
          "end_pos": 4335,
          "text": "[59]",
          "paper_id": "bib.bib59",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 4337,
          "end_pos": 4341,
          "text": "[86]",
          "paper_id": "bib.bib86",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        }
      ]
    },
    "2 Related work": {
      "content": "3D representation. 3D reconstruction and generation benefit from different 3D representations by leveraging their unique properties. These representations include explicit representations \\[ [103], [67], [80], [112], [120], [63], [94], [104], [108], [95], [1], [18], [60], [71], [88], [25], [10], [45], [97], [109], [121], [96]\\] and implicit representations \\[ [73], [11], [65], [50], [119], [87], [41], [38], [107], [66], [113], [6], [26], [8], [5], [69], [102]\\].\nIn this paper, we focus on 3D Gaussians \\[ [45], [97], [109], [121], [96], [29]\\], which possess high-quality rendering procedures that allow learning from image supervisions. However, existing results mainly focus on reconstructing 3D Gaussians. Our goal is to push the state-of-the-art in generative 3D Gaussians.\n\nOur method is also related to the Atlas representation initially proposed by AtlasNet \\[ [25]\\] and its subsequent extensions \\[ [16], [55], [19]\\]. AtlasNet models the shape as a union of independent MLPs, thus limiting the number of patches to a few dozen. In contrast, our proposed Atlas Gaussians model each patch using a patch center and patch features. This efficient encoding allows us to generate a significantly larger number of patches, providing stronger representation capabilities. Additionally, we use a transformer to learn this representation instead of an MLP, resulting in better scalability.\n\nDiffusion models.\nDiffusion models \\[ [90], [92], [91]\\] have been dominant for diverse generation tasks, including image \\[ [33], [115], [75], [82]\\], video \\[ [34], [31], [4]\\], audio \\[ [37], [47], [54]\\], text \\[ [51], [22], [53]\\], and motion \\[ [116], [98], [111]\\].\nThe success of these models typically follows the VAE + LDM paradigm. While pioneering efforts \\[ [112], [120], [63], [60], [118], [114], [13], [50], [43], [48]\\] have attempted to apply this paradigm to 3D, the problem remains unsolved and has not achieved the same level of success. We argue that one of the main reasons is the need for an efficient VAE to represent high-quality 3D content, which is the key contribution of this paper.\n\n3D generation.\n3D generation methods can be classified into two genres. The first is optimization-based methods \\[ [40], [93], [99], [52], [101], [9]\\], which are time-consuming due to per-shape optimization. For example, DreamField \\[ [40]\\] uses CLIP guidance. DreamFusion \\[ [76]\\] and SJC \\[ [99]\\] introduce 2D diffusion priors in different formats. Magic3D \\[ [52]\\] employs a coarse-to-fine pipeline to improve convergence speed. Prolificdreamer \\[ [101]\\] uses variational score distillation to enhance generation fidelity. Fantasia3D \\[ [9]\\] disentangles geometry and texture to achieve higher quality generation.\n\nThe second genre involves training a generalizable feed-forward network to output 3D content, which allows for fast 3D generation but often with less details. One direction is to apply existing generative modeling techniques (VAE \\[ [46]\\], GAN \\[ [23]\\], normalizing flow \\[ [81]\\], autoregressive model \\[ [3], [24]\\] and diffusion model) directly on various 3D representations. Another direction \\[ [106], [57], [56], [58], [84], [35], [97]\\] uses 2D as intermediate representation, integrating 2D diffusion models \\[ [31], [86]\\]. For example, Instant3D \\[ [49]\\] trains a diffusion model to generate sparse multi-view images and uses a reconstruction model to derive the 3D shapes from the 2D images. VFusion3D \\[ [28]\\] and V3D \\[ [12]\\] use video diffusion models to improve the consistency between generated images. However, these methods rely on 2D representations and often suffer from multi-view consistency issues.\n\nIn this paper, we push the state-of-the-art in the first direction by developing a novel explicit representation Atlas Gaussians. Our representation is efficient and allows for learning 3D generative models from images.",
      "citations": [
        {
          "start_pos": 191,
          "end_pos": 196,
          "text": "[103]",
          "paper_id": "bib.bib103",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib112",
            "bib.bib120",
            "bib.bib108"
          ]
        },
        {
          "start_pos": 198,
          "end_pos": 202,
          "text": "[67]",
          "paper_id": "bib.bib67",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 204,
          "end_pos": 208,
          "text": "[80]",
          "paper_id": "bib.bib80",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 210,
          "end_pos": 215,
          "text": "[112]",
          "paper_id": "bib.bib112",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib120",
            "bib.bib103",
            "bib.bib108"
          ]
        },
        {
          "start_pos": 217,
          "end_pos": 222,
          "text": "[120]",
          "paper_id": "bib.bib120",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib112",
            "bib.bib103",
            "bib.bib108"
          ]
        },
        {
          "start_pos": 224,
          "end_pos": 228,
          "text": "[63]",
          "paper_id": "bib.bib63",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 230,
          "end_pos": 234,
          "text": "[94]",
          "paper_id": "bib.bib94",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 236,
          "end_pos": 241,
          "text": "[104]",
          "paper_id": "bib.bib104",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 243,
          "end_pos": 248,
          "text": "[108]",
          "paper_id": "bib.bib108",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib120",
            "bib.bib112",
            "bib.bib103"
          ]
        },
        {
          "start_pos": 250,
          "end_pos": 254,
          "text": "[95]",
          "paper_id": "bib.bib95",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 256,
          "end_pos": 259,
          "text": "[1]",
          "paper_id": "bib.bib1",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 261,
          "end_pos": 265,
          "text": "[18]",
          "paper_id": "bib.bib18",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 267,
          "end_pos": 271,
          "text": "[60]",
          "paper_id": "bib.bib60",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 273,
          "end_pos": 277,
          "text": "[71]",
          "paper_id": "bib.bib71",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 279,
          "end_pos": 283,
          "text": "[88]",
          "paper_id": "bib.bib88",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 285,
          "end_pos": 289,
          "text": "[25]",
          "paper_id": "bib.bib25",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 291,
          "end_pos": 295,
          "text": "[10]",
          "paper_id": "bib.bib10",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 297,
          "end_pos": 301,
          "text": "[45]",
          "paper_id": "bib.bib45",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 303,
          "end_pos": 307,
          "text": "[97]",
          "paper_id": "bib.bib97",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 309,
          "end_pos": 314,
          "text": "[109]",
          "paper_id": "bib.bib109",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib121",
            "bib.bib11",
            "bib.bib108"
          ]
        },
        {
          "start_pos": 316,
          "end_pos": 321,
          "text": "[121]",
          "paper_id": "bib.bib121",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib109",
            "bib.bib11",
            "bib.bib119"
          ]
        },
        {
          "start_pos": 323,
          "end_pos": 327,
          "text": "[96]",
          "paper_id": "bib.bib96",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 362,
          "end_pos": 366,
          "text": "[73]",
          "paper_id": "bib.bib73",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 368,
          "end_pos": 372,
          "text": "[11]",
          "paper_id": "bib.bib11",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib119",
            "bib.bib107",
            "bib.bib121"
          ]
        },
        {
          "start_pos": 374,
          "end_pos": 378,
          "text": "[65]",
          "paper_id": "bib.bib65",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 380,
          "end_pos": 384,
          "text": "[50]",
          "paper_id": "bib.bib50",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 386,
          "end_pos": 391,
          "text": "[119]",
          "paper_id": "bib.bib119",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib11",
            "bib.bib107",
            "bib.bib113"
          ]
        },
        {
          "start_pos": 393,
          "end_pos": 397,
          "text": "[87]",
          "paper_id": "bib.bib87",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 399,
          "end_pos": 403,
          "text": "[41]",
          "paper_id": "bib.bib41",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 405,
          "end_pos": 409,
          "text": "[38]",
          "paper_id": "bib.bib38",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 411,
          "end_pos": 416,
          "text": "[107]",
          "paper_id": "bib.bib107",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib113",
            "bib.bib119",
            "bib.bib11"
          ]
        },
        {
          "start_pos": 418,
          "end_pos": 422,
          "text": "[66]",
          "paper_id": "bib.bib66",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 424,
          "end_pos": 429,
          "text": "[113]",
          "paper_id": "bib.bib113",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib107",
            "bib.bib102",
            "bib.bib119"
          ]
        },
        {
          "start_pos": 431,
          "end_pos": 434,
          "text": "[6]",
          "paper_id": "bib.bib6",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 436,
          "end_pos": 440,
          "text": "[26]",
          "paper_id": "bib.bib26",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 442,
          "end_pos": 445,
          "text": "[8]",
          "paper_id": "bib.bib8",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 447,
          "end_pos": 450,
          "text": "[5]",
          "paper_id": "bib.bib5",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 452,
          "end_pos": 456,
          "text": "[69]",
          "paper_id": "bib.bib69",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 458,
          "end_pos": 463,
          "text": "[102]",
          "paper_id": "bib.bib102",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib113",
            "bib.bib107",
            "bib.bib109"
          ]
        },
        {
          "start_pos": 510,
          "end_pos": 514,
          "text": "[45]",
          "paper_id": "bib.bib45",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 516,
          "end_pos": 520,
          "text": "[97]",
          "paper_id": "bib.bib97",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 522,
          "end_pos": 527,
          "text": "[109]",
          "paper_id": "bib.bib109",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib121",
            "bib.bib102",
            "bib.bib113"
          ]
        },
        {
          "start_pos": 529,
          "end_pos": 534,
          "text": "[121]",
          "paper_id": "bib.bib121",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib109",
            "bib.bib102",
            "bib.bib113"
          ]
        },
        {
          "start_pos": 536,
          "end_pos": 540,
          "text": "[96]",
          "paper_id": "bib.bib96",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 542,
          "end_pos": 546,
          "text": "[29]",
          "paper_id": "bib.bib29",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 873,
          "end_pos": 877,
          "text": "[25]",
          "paper_id": "bib.bib25",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 913,
          "end_pos": 917,
          "text": "[16]",
          "paper_id": "bib.bib16",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 919,
          "end_pos": 923,
          "text": "[55]",
          "paper_id": "bib.bib55",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 925,
          "end_pos": 929,
          "text": "[19]",
          "paper_id": "bib.bib19",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1434,
          "end_pos": 1438,
          "text": "[90]",
          "paper_id": "bib.bib90",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1440,
          "end_pos": 1444,
          "text": "[92]",
          "paper_id": "bib.bib92",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1446,
          "end_pos": 1450,
          "text": "[91]",
          "paper_id": "bib.bib91",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1521,
          "end_pos": 1525,
          "text": "[33]",
          "paper_id": "bib.bib33",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1527,
          "end_pos": 1532,
          "text": "[115]",
          "paper_id": "bib.bib115",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib116",
            "bib.bib111",
            "bib.bib112"
          ]
        },
        {
          "start_pos": 1534,
          "end_pos": 1538,
          "text": "[75]",
          "paper_id": "bib.bib75",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1540,
          "end_pos": 1544,
          "text": "[82]",
          "paper_id": "bib.bib82",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1557,
          "end_pos": 1561,
          "text": "[34]",
          "paper_id": "bib.bib34",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1563,
          "end_pos": 1567,
          "text": "[31]",
          "paper_id": "bib.bib31",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1569,
          "end_pos": 1572,
          "text": "[4]",
          "paper_id": "bib.bib4",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1585,
          "end_pos": 1589,
          "text": "[37]",
          "paper_id": "bib.bib37",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1591,
          "end_pos": 1595,
          "text": "[47]",
          "paper_id": "bib.bib47",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1597,
          "end_pos": 1601,
          "text": "[54]",
          "paper_id": "bib.bib54",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1613,
          "end_pos": 1617,
          "text": "[51]",
          "paper_id": "bib.bib51",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1619,
          "end_pos": 1623,
          "text": "[22]",
          "paper_id": "bib.bib22",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1625,
          "end_pos": 1629,
          "text": "[53]",
          "paper_id": "bib.bib53",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1647,
          "end_pos": 1652,
          "text": "[116]",
          "paper_id": "bib.bib116",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib111",
            "bib.bib115",
            "bib.bib112"
          ]
        },
        {
          "start_pos": 1654,
          "end_pos": 1658,
          "text": "[98]",
          "paper_id": "bib.bib98",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1660,
          "end_pos": 1665,
          "text": "[111]",
          "paper_id": "bib.bib111",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib116",
            "bib.bib112",
            "bib.bib120"
          ]
        },
        {
          "start_pos": 1767,
          "end_pos": 1772,
          "text": "[112]",
          "paper_id": "bib.bib112",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib120",
            "bib.bib118",
            "bib.bib114"
          ]
        },
        {
          "start_pos": 1774,
          "end_pos": 1779,
          "text": "[120]",
          "paper_id": "bib.bib120",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib112",
            "bib.bib118",
            "bib.bib114"
          ]
        },
        {
          "start_pos": 1781,
          "end_pos": 1785,
          "text": "[63]",
          "paper_id": "bib.bib63",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1787,
          "end_pos": 1791,
          "text": "[60]",
          "paper_id": "bib.bib60",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1793,
          "end_pos": 1798,
          "text": "[118]",
          "paper_id": "bib.bib118",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib114",
            "bib.bib120",
            "bib.bib112"
          ]
        },
        {
          "start_pos": 1800,
          "end_pos": 1805,
          "text": "[114]",
          "paper_id": "bib.bib114",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib118",
            "bib.bib120",
            "bib.bib112"
          ]
        },
        {
          "start_pos": 1807,
          "end_pos": 1811,
          "text": "[13]",
          "paper_id": "bib.bib13",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1813,
          "end_pos": 1817,
          "text": "[50]",
          "paper_id": "bib.bib50",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1819,
          "end_pos": 1823,
          "text": "[43]",
          "paper_id": "bib.bib43",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1825,
          "end_pos": 1829,
          "text": "[48]",
          "paper_id": "bib.bib48",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 2224,
          "end_pos": 2228,
          "text": "[40]",
          "paper_id": "bib.bib40",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 2230,
          "end_pos": 2234,
          "text": "[93]",
          "paper_id": "bib.bib93",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 2236,
          "end_pos": 2240,
          "text": "[99]",
          "paper_id": "bib.bib99",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 2242,
          "end_pos": 2246,
          "text": "[52]",
          "paper_id": "bib.bib52",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 2248,
          "end_pos": 2253,
          "text": "[101]",
          "paper_id": "bib.bib101",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 2255,
          "end_pos": 2258,
          "text": "[9]",
          "paper_id": "bib.bib9",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib114",
            "bib.bib118",
            "bib.bib120"
          ]
        },
        {
          "start_pos": 2345,
          "end_pos": 2349,
          "text": "[40]",
          "paper_id": "bib.bib40",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 2387,
          "end_pos": 2391,
          "text": "[76]",
          "paper_id": "bib.bib76",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 2405,
          "end_pos": 2409,
          "text": "[99]",
          "paper_id": "bib.bib99",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 2475,
          "end_pos": 2479,
          "text": "[52]",
          "paper_id": "bib.bib52",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 2565,
          "end_pos": 2570,
          "text": "[101]",
          "paper_id": "bib.bib101",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 2655,
          "end_pos": 2658,
          "text": "[9]",
          "paper_id": "bib.bib9",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib106",
            "bib.bib12",
            "bib.bib114"
          ]
        },
        {
          "start_pos": 2967,
          "end_pos": 2971,
          "text": "[46]",
          "paper_id": "bib.bib46",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 2982,
          "end_pos": 2986,
          "text": "[23]",
          "paper_id": "bib.bib23",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 3010,
          "end_pos": 3014,
          "text": "[81]",
          "paper_id": "bib.bib81",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 3042,
          "end_pos": 3045,
          "text": "[3]",
          "paper_id": "bib.bib3",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 3047,
          "end_pos": 3051,
          "text": "[24]",
          "paper_id": "bib.bib24",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 3136,
          "end_pos": 3141,
          "text": "[106]",
          "paper_id": "bib.bib106",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib12",
            "bib.bib9",
            "bib.bib114"
          ]
        },
        {
          "start_pos": 3143,
          "end_pos": 3147,
          "text": "[57]",
          "paper_id": "bib.bib57",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 3149,
          "end_pos": 3153,
          "text": "[56]",
          "paper_id": "bib.bib56",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 3155,
          "end_pos": 3159,
          "text": "[58]",
          "paper_id": "bib.bib58",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 3161,
          "end_pos": 3165,
          "text": "[84]",
          "paper_id": "bib.bib84",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 3167,
          "end_pos": 3171,
          "text": "[35]",
          "paper_id": "bib.bib35",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 3173,
          "end_pos": 3177,
          "text": "[97]",
          "paper_id": "bib.bib97",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 3255,
          "end_pos": 3259,
          "text": "[31]",
          "paper_id": "bib.bib31",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 3261,
          "end_pos": 3265,
          "text": "[86]",
          "paper_id": "bib.bib86",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 3295,
          "end_pos": 3299,
          "text": "[49]",
          "paper_id": "bib.bib49",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 3453,
          "end_pos": 3457,
          "text": "[28]",
          "paper_id": "bib.bib28",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 3471,
          "end_pos": 3475,
          "text": "[12]",
          "paper_id": "bib.bib12",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib106",
            "bib.bib9",
            "bib.bib114"
          ]
        }
      ]
    },
    "3 Method": {
      "content": "\\\\begin{overpic}\\[width=433.62pt\\]{figures/atlas\\_gaussians/atlas\\_gaussians.pdf}\n\\\\vspace{-0.2in}\n\\\\end{overpic}Figure 2: (Left) Atlas Gaussians 𝒜𝒜\\\\mathcal{A} model the shape as a union of patches, where each patch can decode 3D Gaussians. (Right) Each patch 𝒂isubscript𝒂𝑖\\\\boldsymbol{a}\\_{i} is parameterized by patch center 𝒙isubscript𝒙𝑖\\\\boldsymbol{x}\\_{i} and patch features 𝒇isubscript𝒇𝑖\\\\boldsymbol{f}\\_{i} and 𝒉isubscript𝒉𝑖\\\\boldsymbol{h}\\_{i}. The 3D Gaussians are decoded via the UV-based sampling.\n\nIn this section, we first introduce our Atlas Gaussians representation (Sec. [3.1]Atlas Gaussians Representation ‣ 3 Method ‣ Atlas Gaussians Diffusion for 3D Generation with Infinite Number of Points\")). Then we introduce how we learn a variational autoencoder to connect the 3D space with a latent space (Sec. [3.2]Stage 1: VAE ‣ 3 Method ‣ Atlas Gaussians Diffusion for 3D Generation with Infinite Number of Points\")). Finally, we introduce how we learn the generation model using latent diffusion in the learned latent space (Sec. [3.3]Stage 2: latent diffusion model ‣ 3 Method ‣ Atlas Gaussians Diffusion for 3D Generation with Infinite Number of Points\")).\n\n### 3.1 Atlas Gaussians Representation\n\nIn 3D Gaussian Splatting \\[ [45]\\], each 3D Gaussian 𝐠𝐠\\\\boldsymbol{\\\\mathrm{g}} can be parameterized with a center position 𝝁∈ℝ3𝝁superscriptℝ3\\\\boldsymbol{\\\\mathrm{\\\\mu}}\\\\in\\\\mathbb{R}^{3}, scale 𝐬∈ℝ3𝐬superscriptℝ3\\\\boldsymbol{\\\\mathrm{s}}\\\\in\\\\mathbb{R}^{3}, rotation quaternion 𝐫∈ℝ4𝐫superscriptℝ4\\\\boldsymbol{\\\\mathrm{r}}\\\\in\\\\mathbb{R}^{4}, opacity o∈ℝoℝ{\\\\mathrm{o}}\\\\in\\\\mathbb{R} and color 𝐜∈ℝ3𝐜superscriptℝ3\\\\boldsymbol{\\\\mathrm{c}}\\\\in\\\\mathbb{R}^{3}. To achieve high-quality rendering results, typically a sufficiently large number of 3D Gaussians are required.\n\nThe key idea of Atlas Gaussians is to represent the shape as a union of M𝑀M local patches 𝒜={𝒂i}i=1M𝒜superscriptsubscriptsubscript𝒂𝑖𝑖1𝑀\\\\mathcal{A}=\\\\{\\\\boldsymbol{a}\\_{i}\\\\}\\_{i=1}^{M}, where each patch 𝒂isubscript𝒂𝑖\\\\boldsymbol{a}\\_{i} can decode 3D Gaussians through UV-based sampling. As shown in Figure [2], [121], [105]\\]. We use the feature 𝒇isubscript𝒇𝑖\\\\boldsymbol{f}\\_{i} to decode Gaussian positions while using 𝒉isubscript𝒉𝑖\\\\boldsymbol{h}\\_{i} to decode the rest of Gaussian attributes. We also assign a 2D coordinate 𝒖i​j∈ℝ2subscript𝒖𝑖𝑗superscriptℝ2\\\\boldsymbol{u}\\_{ij}\\\\in\\\\mathbb{R}^{2} to each feature vector 𝒇i​jsubscript𝒇𝑖𝑗\\\\boldsymbol{f}\\_{ij} and 𝒉i​jsubscript𝒉𝑖𝑗\\\\boldsymbol{h}\\_{ij} as a positional embedding, where 𝒖i​1=(0,0)subscript𝒖𝑖100\\\\boldsymbol{u}\\_{i1}=(0,0), 𝒖i​2=(1,0)subscript𝒖𝑖210\\\\boldsymbol{u}\\_{i2}=(1,0), 𝒖i​3=(1,1)subscript𝒖𝑖311\\\\boldsymbol{u}\\_{i3}=(1,1), 𝒖i​4=(0,1)subscript𝒖𝑖401\\\\boldsymbol{u}\\_{i4}=(0,1), ∀ifor-all𝑖\\\\forall i.\n\nNote that this representation is motivated by the concept of UV-map, in which the four corners describe the corners of the rectangular parameter domain. As we shall discuss later, the features 𝒇isubscript𝒇𝑖\\\\boldsymbol{f}\\_{i} and 𝒉isubscript𝒉𝑖\\\\boldsymbol{h}\\_{i} are learned end-to-end with 3D Gaussians. This approach takes advantage of end-to-end learning, while the specific network design promotes learning better features.\n\nFor generation, we randomly sample query points in the UV space and each point will be decoded as a 3D Gaussian.\nGiven a query point 𝒒i​j∈\\[0,1\\]2subscript𝒒𝑖𝑗superscript012\\\\boldsymbol{q}\\_{ij}\\\\in{\\[0,1\\]}^{2}, we map the 2D coordinate 𝒒i​jsubscript𝒒𝑖𝑗\\\\boldsymbol{q}\\_{ij} to the center of 3D Gaussians as:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | 𝝁i​j=ϕ​(𝒒i​j,𝒖i,𝒇i),subscript𝝁𝑖𝑗italic-ϕsubscript𝒒𝑖𝑗subscript𝒖𝑖subscript𝒇𝑖\\\\boldsymbol{\\\\mathrm{\\\\mu}}\\_{ij}=\\\\phi(\\\\boldsymbol{q}\\_{ij},\\\\boldsymbol{u}\\_{i},\\\\boldsymbol{f}\\_{i}), |  | (1) |\n\nwhere ϕitalic-ϕ\\\\phi is the mapping function, which takes the query point location 𝒒i​jsubscript𝒒𝑖𝑗\\\\boldsymbol{q}\\_{ij}, the pre-defined location of patch feature vectors 𝒖i​jsubscript𝒖𝑖𝑗\\\\boldsymbol{u}\\_{ij}, and the geometry features 𝒇isubscript𝒇𝑖\\\\boldsymbol{f}\\_{i} as inputs.\nWe implement the mapping function using interpolation in the 2D space:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | 𝝁i​j=MLP​(∑k=14w​(𝒒i​j,𝒖i​k,𝒇i​k)⋅𝒇i​k)+𝒙i,subscript𝝁𝑖𝑗MLPsuperscriptsubscript𝑘14⋅𝑤subscript𝒒𝑖𝑗subscript𝒖𝑖𝑘subscript𝒇𝑖𝑘subscript𝒇𝑖𝑘subscript𝒙𝑖\\\\boldsymbol{\\\\mathrm{\\\\mu}}\\_{ij}=\\\\textsc{MLP}(\\\\sum\\_{k=1}^{4}w(\\\\boldsymbol{q}\\_{ij},\\\\boldsymbol{u}\\_{ik},\\\\boldsymbol{f}\\_{ik})\\\\cdot\\\\boldsymbol{f}\\_{ik})+\\\\boldsymbol{x}\\_{i}, |  | (2) |\n\nwhere w𝑤w is the weight function of the four corners and we use an MLP to decode the residual between the Gaussian location and the patch center 𝒙isubscript𝒙𝑖\\\\boldsymbol{x}\\_{i}\n\nOne design choice for w𝑤w is the bilinear interpolation weight function, which has been widely used in feature decoding \\[ [70]\\]. However, these linear weights purely based on coordinates have limited representation ability. Inspired by \\[ [114]\\], we design a more powerful weight function defined on both coordinates and features:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | w​(𝒒i​j,𝒖i​k,𝒇i​k)=w~​(𝒒i​j,𝒖i​k,𝒇i​k)∑l=14w~​(𝒒i​j,𝒖i​l,𝒇i​l),𝑤subscript𝒒𝑖𝑗subscript𝒖𝑖𝑘subscript𝒇𝑖𝑘~𝑤subscript𝒒𝑖𝑗subscript𝒖𝑖𝑘subscript𝒇𝑖𝑘superscriptsubscript𝑙14~𝑤subscript𝒒𝑖𝑗subscript𝒖𝑖𝑙subscript𝒇𝑖𝑙w(\\\\boldsymbol{q}\\_{ij},\\\\boldsymbol{u}\\_{ik},\\\\boldsymbol{f}\\_{ik})=\\\\frac{\\\\widetilde{w}(\\\\boldsymbol{q}\\_{ij},\\\\boldsymbol{u}\\_{ik},\\\\boldsymbol{f}\\_{ik})}{\\\\sum\\_{l=1}^{4}\\\\widetilde{w}(\\\\boldsymbol{q}\\_{ij},\\\\boldsymbol{u}\\_{il},\\\\boldsymbol{f}\\_{il})}, |  | (3) |\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | and​w~​(𝒒i​j,𝒖i​l,𝒇i​l)=eω2​(𝒒i​j)T​(𝒇i​l+ω2​(𝒖i​l))/d,and~𝑤subscript𝒒𝑖𝑗subscript𝒖𝑖𝑙subscript𝒇𝑖𝑙superscript𝑒subscript𝜔2superscriptsubscript𝒒𝑖𝑗𝑇subscript𝒇𝑖𝑙subscript𝜔2subscript𝒖𝑖𝑙𝑑\\\\text{and}\\ \\\\widetilde{w}(\\\\boldsymbol{q}\\_{ij},\\\\boldsymbol{u}\\_{il},\\\\boldsymbol{f}\\_{il})=e^{\\\\omega\\_{2}(\\\\boldsymbol{q}\\_{ij})^{T}(\\\\boldsymbol{f}\\_{il}+\\\\omega\\_{2}(\\\\boldsymbol{u}\\_{il}))/\\\\sqrt{d}}, |  | (4) |\n\nwhere ω2:ℝ2↦ℝd:subscript𝜔2maps-tosuperscriptℝ2superscriptℝ𝑑\\\\omega\\_{2}:\\\\mathbb{R}^{2}\\\\mapsto\\\\mathbb{R}^{d} is the sinusoidal positional encoding function with MLP projection.\n\nSimilarly, the remaining Gaussian attributes are decoded by the function ψ𝜓\\\\psi:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | (𝐬i​j,𝐫i​j,oi​j,𝐜i​j)=ψ​(𝒒i​j,𝒖i,𝒉i)=MLP​(∑k=14w​(𝒒i​j,𝒖i​k,𝒉i​k)⋅𝒉i​k),subscript𝐬𝑖𝑗subscript𝐫𝑖𝑗subscripto𝑖𝑗subscript𝐜𝑖𝑗𝜓subscript𝒒𝑖𝑗subscript𝒖𝑖subscript𝒉𝑖MLPsuperscriptsubscript𝑘14⋅𝑤subscript𝒒𝑖𝑗subscript𝒖𝑖𝑘subscript𝒉𝑖𝑘subscript𝒉𝑖𝑘(\\\\boldsymbol{\\\\mathrm{s}}\\_{ij},\\\\boldsymbol{\\\\mathrm{r}}\\_{ij},{\\\\mathrm{o}}\\_{ij},\\\\boldsymbol{\\\\mathrm{c}}\\_{ij})=\\\\psi(\\\\boldsymbol{q}\\_{ij},\\\\boldsymbol{u}\\_{i},\\\\boldsymbol{h}\\_{i})=\\\\text{MLP}(\\\\sum\\_{k=1}^{4}w(\\\\boldsymbol{q}\\_{ij},\\\\boldsymbol{u}\\_{ik},\\\\boldsymbol{h}\\_{ik})\\\\cdot\\\\boldsymbol{h}\\_{ik}), |  | (5) |\n\nThe benefits of Atlas Gaussians representation are three-fold. First, through UV-based sampling in a unit square, Atlas Gaussians enable easy generation of a sufficiently large number of 3D Gaussians. They also possess the potential to generate a variable and theoretically infinite number of 3D Gaussians. Second, Atlas Gaussians utilize a non-linear learnable weight function based on the MLP projection of the positional encoding, which has a stronger representation ability than the existing linear interpolation weight. Third, Atlas Gaussians are computation-efficient with low memory overhead. An important property of Atlas Gaussians is that they do not require extra network parameters when scaling up the number of generated 3D Gaussians. We also provide an ablation study in Section [4.4]Ablation study ‣ 4 Experiments ‣ Atlas Gaussians Diffusion for 3D Generation with Infinite Number of Points\") to validate the nice properties of Atlas Gaussians.\n\n\\\\begin{overpic}\\[width=433.62pt\\]{figures/pipeline/pipeline.pdf}\n\\\\end{overpic}Figure 3: The proposed VAE architecture. CA denotes the cross-attention layer. The latent space defined by 𝒛0subscript𝒛0\\\\boldsymbol{z}\\_{0} is used for latent diffusion.\n\n### 3.2 Stage 1: VAE\n\nWe design a VAE to link the low-dimensional latent space and the 3D space. The overall pipeline is shown in Figure [3]Figure 3 ‣ 3.1 Atlas Gaussians Representation ‣ 3 Method ‣ Atlas Gaussians Diffusion for 3D Generation with Infinite Number of Points\").\n\nEncoder.\nThe encoder takes shape information as input and outputs a latent set 𝒛0∈ℝn×d0subscript𝒛0superscriptℝ𝑛subscript𝑑0\\\\boldsymbol{z}\\_{0}\\\\in\\\\mathbb{R}^{n\\\\times d\\_{0}}, which follows the latent set representation in \\[ [114]\\]. Specifically, shape information is represented as a set of features 𝒮𝒮\\\\mathcal{S}. We use transformers with cross attention to extract the latent features, as 𝒛=CrossAttn​(𝒛¯,𝒮),𝒛CrossAttn¯𝒛𝒮\\\\boldsymbol{z}=\\\\text{CrossAttn}(\\\\bar{\\\\boldsymbol{z}},\\\\mathcal{S}),\nwhere 𝒛¯¯𝒛\\\\bar{\\\\boldsymbol{z}} is the initialization of the latent features. In this notation, We omit the feed-forward MLP of the transformers for simplicity. Intuitively, the query 𝒛¯¯𝒛\\\\bar{\\\\boldsymbol{z}} of the cross-attention is updated by aggregating information from key/value 𝒮𝒮\\\\mathcal{S}. We further refine the latent features 𝒛𝒛\\\\boldsymbol{z} using transformers with self-attention.\n\nTo obtain shape information 𝒮𝒮\\\\mathcal{S}, we use point cloud 𝒫={𝒑i∈ℝ3}𝒫subscript𝒑𝑖superscriptℝ3\\\\mathcal{P}=\\\\{\\\\boldsymbol{p}\\_{i}\\\\in\\\\mathbb{R}^{3}\\\\} and sparse view RGB images ℐ={𝑰i∈ℝH×W×3}ℐsubscript𝑰𝑖superscriptℝ𝐻𝑊3\\\\mathcal{I}=\\\\{\\\\boldsymbol{I}\\_{i}\\\\in\\\\mathbb{R}^{H\\\\times W\\\\times 3}\\\\}. We encode the location of points into positional embeddings, resulting in features in ℝ\\|𝒫\\|×dsuperscriptℝ𝒫𝑑\\\\mathbb{R}^{\\|\\\\mathcal{P}\\|\\\\times d}. Meanwhile, a ViT network \\[ [17], [72]\\] embeds each image into features of shape ℝh×w×dsuperscriptℝℎ𝑤𝑑\\\\mathbb{R}^{h\\\\times w\\\\times d}, resulting in the features of all images in ℝ(\\|𝑰\\|×h×w)×dsuperscriptℝ𝑰ℎ𝑤𝑑\\\\mathbb{R}^{(\\|\\\\boldsymbol{I}\\|\\\\times h\\\\times w)\\\\times d}. We use two transformers with cross-attention to aggregate information from them, respectively. We initialize the latent features 𝒛¯∈ℝn×d¯𝒛superscriptℝ𝑛𝑑\\\\bar{\\\\boldsymbol{z}}\\\\in\\\\mathbb{R}^{n\\\\times d} as the encoding of the points sampled using the farthest point sampling \\[ [114]\\]. After the feature aggregation, we use an MLP to map the features to a lower-dimensional space ℝn×d→ℝn×d0→superscriptℝ𝑛𝑑superscriptℝ𝑛subscript𝑑0\\\\mathbb{R}^{n\\\\times d}\\\\rightarrow\\\\mathbb{R}^{n\\\\times d\\_{0}}, facilitating efficient latent diffusion.\n\nNote that attention is invariant to the permutation of features.\nWe also avoid pose-dependent operations \\[ [42], [43]\\] in our design to enhance generality and extendability.\n\nDecoder.\nThe decoder recovers patch features 𝒜={(𝒙i,𝒇i,𝒉i)}i=1M𝒜superscriptsubscriptsubscript𝒙𝑖subscript𝒇𝑖subscript𝒉𝑖𝑖1𝑀\\\\mathcal{A}=\\\\{(\\\\boldsymbol{x}\\_{i},\\\\boldsymbol{f}\\_{i},\\\\boldsymbol{h}\\_{i})\\\\}\\_{i=1}^{M} from the latent code 𝒛0subscript𝒛0\\\\boldsymbol{z}\\_{0}. In the decoder, we upsample the latent code, decode the patch centers {𝒙i}i=1Msuperscriptsubscriptsubscript𝒙𝑖𝑖1𝑀\\\\{\\\\boldsymbol{x}\\_{i}\\\\}\\_{i=1}^{M}, and then decode the patch geometry and appearance features {(𝒇i,𝒉i)}i=1Msuperscriptsubscriptsubscript𝒇𝑖subscript𝒉𝑖𝑖1𝑀\\\\{(\\\\boldsymbol{f}\\_{i},\\\\boldsymbol{h}\\_{i})\\\\}\\_{i=1}^{M}.\n\nThe upsampling module is designed to increase both the length and feature dimension of the latent code, from 𝒛0∈ℝn×d0subscript𝒛0superscriptℝ𝑛subscript𝑑0\\\\boldsymbol{z}\\_{0}\\\\in\\\\mathbb{R}^{n\\\\times d\\_{0}} to 𝒛l∈ℝM×dsubscript𝒛𝑙superscriptℝ𝑀𝑑\\\\boldsymbol{z}\\_{l}\\\\in\\\\mathbb{R}^{M\\\\times d}. In detail, we first use a learnable query 𝒚𝒚\\\\boldsymbol{y} to aggregate information from the latent code 𝒛0subscript𝒛0\\\\boldsymbol{z}\\_{0} using transformers with cross-attention. Then, we increase its channel dimension to d𝑑d using self-attention transformers, leading to the characteristic 𝒛1∈ℝn×dsubscript𝒛1superscriptℝ𝑛𝑑\\\\boldsymbol{z}\\_{1}\\\\in\\\\mathbb{R}^{n\\\\times d}. The architecture follows Perceiver-IO \\[ [39]\\]. We then use an MLP to increase the feature dimension of 𝒛1subscript𝒛1\\\\boldsymbol{z}\\_{1} into Mn​d𝑀𝑛𝑑\\\\frac{M}{n}d, leading to latent features in ℝn×Mn​dsuperscriptℝ𝑛𝑀𝑛𝑑\\\\mathbb{R}^{n\\\\times\\\\frac{M}{n}d}. We reshape the features into 𝒛2∈ℝM×dsubscript𝒛2superscriptℝ𝑀𝑑\\\\boldsymbol{z}\\_{2}\\\\in\\\\mathbb{R}^{M\\\\times d}, which is a pixel shuffle process \\[ [85], [105]\\]. We then use another set of transformers with self-attention to get the output latent features 𝒛lsubscript𝒛𝑙\\\\boldsymbol{z}\\_{l}. This process is summarized as follows:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | 𝒛1=SelfAttn​(CrossAttn​(𝒚,𝒛0)),𝒛2=PixelShuffle​(MLP​(𝒛1)),𝒛l=SelfAttn​(𝒛2).formulae-sequencesubscript𝒛1SelfAttnCrossAttn𝒚subscript𝒛0formulae-sequencesubscript𝒛2PixelShuffleMLPsubscript𝒛1subscript𝒛𝑙SelfAttnsubscript𝒛2\\\\boldsymbol{z}\\_{1}=\\\\text{SelfAttn}(\\\\text{CrossAttn}(\\\\boldsymbol{y},\\\\boldsymbol{z}\\_{0})),\\\\quad\\\\boldsymbol{z}\\_{2}=\\\\text{PixelShuffle}(\\\\text{MLP}(\\\\boldsymbol{z}\\_{1})),\\\\quad\\\\boldsymbol{z}\\_{l}=\\\\text{SelfAttn}(\\\\boldsymbol{z}\\_{2}). |  | (6) |\n\nAgain, we omit the feed-forward MLP in the transformers for simplicity. We then decode the patch centers using transformers with self-attention:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | {𝒙i}i=1M=SelfAttn​(𝒛l).superscriptsubscriptsubscript𝒙𝑖𝑖1𝑀SelfAttnsubscript𝒛𝑙\\\\{\\\\boldsymbol{x}\\_{i}\\\\}\\_{i=1}^{M}=\\\\text{SelfAttn}(\\\\boldsymbol{z}\\_{l}). |  | (7) |\n\nWe use a two-branch module to decode geometry and appearance features {(𝒇i,𝒉i)}i=1Msuperscriptsubscriptsubscript𝒇𝑖subscript𝒉𝑖𝑖1𝑀\\\\{(\\\\boldsymbol{f}\\_{i},\\\\boldsymbol{h}\\_{i})\\\\}\\_{i=1}^{M} from upsampled latent code 𝒛lsubscript𝒛𝑙\\\\boldsymbol{z}\\_{l}. We demonstrate its architecture in Figure [4]Figure 4 ‣ 3.2 Stage 1: VAE ‣ 3 Method ‣ Atlas Gaussians Diffusion for 3D Generation with Infinite Number of Points\"). Take the branch for decoding the geometry features {𝒇i}i=1Msuperscriptsubscriptsubscript𝒇𝑖𝑖1𝑀\\\\{\\\\boldsymbol{f}\\_{i}\\\\}\\_{i=1}^{M} as an example. We use another upsampling module to map 𝒛l∈ℝM×dsubscript𝒛𝑙superscriptℝ𝑀𝑑\\\\boldsymbol{z}\\_{l}\\\\in\\\\mathbb{R}^{M\\\\times d} to 𝒛f∈ℝM×β×dsubscript𝒛𝑓superscriptℝ𝑀𝛽𝑑\\\\boldsymbol{z}\\_{f}\\\\in\\\\mathbb{R}^{M\\\\times\\\\beta\\\\times d}, where β=4𝛽4\\\\beta=4, corresponding to the geometry features of the four corners for each patch. We then use transformers with self-attention to refine the upsampled features to get 𝒇isubscript𝒇𝑖\\\\boldsymbol{f}\\_{i}.\n\nSpecifically, we apply computational decomposition to the self-attention layers, as naive self-attention leads to a 𝒪​(β2​M2​d)𝒪superscript𝛽2superscript𝑀2𝑑\\\\mathcal{O}(\\\\beta^{2}M^{2}d) complexity due to the long sequence length of M​β𝑀𝛽M\\\\beta. We apply local self-attention to the features that belong to each local patch, reducing the complexity to 𝒪​(β2​M​d)𝒪superscript𝛽2𝑀𝑑\\\\mathcal{O}(\\\\beta^{2}Md). The features of different local patches are updated independently. This design ensures local awareness of Atlas Gaussians decoding. To further ensure global awareness, we repeat and add the global features to the local patch features.\n\n\\\\begin{overpic}\\[width=130.08731pt\\]{figures/patch\\_feature\\_decoder/patch\\_feature\\_decoder.pdf}\n\\\\end{overpic}Figure 4: In the patch feature decoder, global features are broadcast and added to the local features. SA denotes the self-attention layers.\n\nAfter obtaining the Atlas Gaussians 𝒜={(𝒙i,𝒇i,𝒉i)}i=1M𝒜superscriptsubscriptsubscript𝒙𝑖subscript𝒇𝑖subscript𝒉𝑖𝑖1𝑀\\\\mathcal{A}=\\\\{(\\\\boldsymbol{x}\\_{i},\\\\boldsymbol{f}\\_{i},\\\\boldsymbol{h}\\_{i})\\\\}\\_{i=1}^{M} from the VAE, we can decode 3D Gaussians following Eq. [2]In 3.1 Atlas Gaussians Representation ‣ 3 Method ‣ Atlas Gaussians Diffusion for 3D Generation with Infinite Number of Points\") and Eq. [5]In 3.1 Atlas Gaussians Representation ‣ 3 Method ‣ Atlas Gaussians Diffusion for 3D Generation with Infinite Number of Points\").\n\nTraining. Similar to existing works \\[ [48], [105], [97], [121]\\], we utilize a 3D dataset for supervision. We first regularize the patch center to adhere to the 3D surface geometry:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | ℒcenter=ℒCD​({𝒙i}i=1M,𝒫GT)+ℒEMD​({𝒙i}i=1M,𝒫GT),subscriptℒcentersubscriptℒCDsuperscriptsubscriptsubscript𝒙𝑖𝑖1𝑀subscript𝒫GTsubscriptℒEMDsuperscriptsubscriptsubscript𝒙𝑖𝑖1𝑀subscript𝒫GT\\\\mathcal{L}\\_{\\\\text{center}}=\\\\mathcal{L}\\_{\\\\text{CD}}(\\\\{\\\\boldsymbol{x}\\_{i}\\\\}\\_{i=1}^{M},\\\\mathcal{P}\\_{\\\\text{GT}})+\\\\mathcal{L}\\_{\\\\text{EMD}}(\\\\{\\\\boldsymbol{x}\\_{i}\\\\}\\_{i=1}^{M},\\\\mathcal{P}\\_{\\\\text{GT}}), |  | (8) |\n\nwhere 𝒫GTsubscript𝒫GT\\\\mathcal{P}\\_{\\\\text{GT}} is the ground truth surface point cloud, ℒCDsubscriptℒCD\\\\mathcal{L}\\_{\\\\text{CD}} and ℒEMDsubscriptℒEMD\\\\mathcal{L}\\_{\\\\text{EMD}} are Chamfer Distance (CD) and Earth Mover’s Distance (EMD), respectively.\nSimilarly, we also supervise the centers of all 3D Gaussians with\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | ℒ𝝁​(S)=ℒCD​({𝝁i​j}i=1,j=1M,S,𝒫GT)+ℒEMD​({𝝁i​j}i=1,j=1M,S,𝒫GT),subscriptℒ𝝁𝑆subscriptℒCDsuperscriptsubscriptsubscript𝝁𝑖𝑗formulae-sequence𝑖1𝑗1𝑀𝑆subscript𝒫GTsubscriptℒEMDsuperscriptsubscriptsubscript𝝁𝑖𝑗formulae-sequence𝑖1𝑗1𝑀𝑆subscript𝒫GT\\\\mathcal{L}\\_{\\\\boldsymbol{\\\\mathrm{\\\\mu}}}(S)=\\\\mathcal{L}\\_{\\\\text{CD}}(\\\\{\\\\boldsymbol{\\\\mathrm{\\\\mu}}\\_{ij}\\\\}\\_{i=1,j=1}^{M,S},\\\\mathcal{P}\\_{\\\\text{GT}})+\\\\mathcal{L}\\_{\\\\text{EMD}}(\\\\{\\\\boldsymbol{\\\\mathrm{\\\\mu}}\\_{ij}\\\\}\\_{i=1,j=1}^{M,S},\\\\mathcal{P}\\_{\\\\text{GT}}), |  | (9) |\n\nwhere {𝝁i​j}i=1,j=1M,Ssuperscriptsubscriptsubscript𝝁𝑖𝑗formulae-sequence𝑖1𝑗1𝑀𝑆\\\\{\\\\boldsymbol{\\\\mathrm{\\\\mu}}\\_{ij}\\\\}\\_{i=1,j=1}^{M,S} represents the generated point cloud by sampling S𝑆S points in each of the M𝑀M patches. When computing the loss for supervision, we can generate point clouds with different resolutions by varying S𝑆S, thanks to Atlas Gaussians’ ability to dynamically generate a variable number of 3D Gaussians.\n\nWhile surface points are independent samples of the continuous geometry, 3D Gaussians are interdependent because one 3D Gaussian can affect the attributes of its neighbors during alpha blending. To ensure consistency and achieve deterministic results, during rendering we employ a uniform α×α𝛼𝛼\\\\alpha\\\\times\\\\alpha grid sampling in the UV space instead of random sampling, resulting in N=α2​M𝑁superscript𝛼2𝑀N=\\\\alpha^{2}M 3D Gaussians. We use the differentiable renderer from \\[ [45]\\] to render V𝑉V views of RGB, alpha, and depth images, which is supervised by mean square error:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | ℒrender=ℒMSE​(𝑰^rgb,𝑰rgb)+ℒMSE​(𝑰^alpha,𝑰alpha)+ℒMSE​(𝑰^depth,𝑰depth),subscriptℒrendersubscriptℒMSEsubscript^𝑰rgbsubscript𝑰rgbsubscriptℒMSEsubscript^𝑰alphasubscript𝑰alphasubscriptℒMSEsubscript^𝑰depthsubscript𝑰depth\\\\mathcal{L}\\_{\\\\text{render}}=\\\\mathcal{L}\\_{\\\\text{MSE}}(\\\\hat{\\\\boldsymbol{I}}\\_{\\\\text{rgb}},\\\\boldsymbol{I}\\_{\\\\text{rgb}})+\\\\mathcal{L}\\_{\\\\text{MSE}}(\\\\hat{\\\\boldsymbol{I}}\\_{\\\\text{alpha}},\\\\boldsymbol{I}\\_{\\\\text{alpha}})+\\\\mathcal{L}\\_{\\\\text{MSE}}(\\\\hat{\\\\boldsymbol{I}}\\_{\\\\text{depth}},\\\\boldsymbol{I}\\_{\\\\text{depth}}), |  | (10) |\n\nwhere 𝑰^rgbsubscript^𝑰rgb\\\\hat{\\\\boldsymbol{I}}\\_{\\\\text{rgb}}, 𝑰^alphasubscript^𝑰alpha\\\\hat{\\\\boldsymbol{I}}\\_{\\\\text{alpha}}, and 𝑰^depthsubscript^𝑰depth\\\\hat{\\\\boldsymbol{I}}\\_{\\\\text{depth}} are the predictions, 𝑰rgbsubscript𝑰rgb\\\\boldsymbol{I}\\_{\\\\text{rgb}}, 𝑰alphasubscript𝑰alpha\\\\boldsymbol{I}\\_{\\\\text{alpha}}, and 𝑰depthsubscript𝑰depth\\\\boldsymbol{I}\\_{\\\\text{depth}} are the ground truths.\nTo improve the visual fidelity, we also employ the LPIPS loss \\[ [117], [97]\\]ℒLPIPS​(𝑰^rgb,𝑰rgb)subscriptℒLPIPSsubscript^𝑰rgbsubscript𝑰rgb\\\\mathcal{L}\\_{\\\\text{LPIPS}}(\\\\hat{\\\\boldsymbol{I}}\\_{\\\\text{rgb}},\\\\boldsymbol{I}\\_{\\\\text{rgb}}). The total loss function for the VAE is:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | ℒtotal=ℒcenter+∑S={1,4}ℒ𝝁​(S)+λr​(ℒrender+ℒLPIPS)+λK​L​ℒKL​(𝒛),subscriptℒtotalsubscriptℒcentersubscript𝑆14subscriptℒ𝝁𝑆subscript𝜆𝑟subscriptℒrendersubscriptℒLPIPSsubscript𝜆𝐾𝐿subscriptℒKL𝒛\\\\mathcal{L}\\_{\\\\text{total}}=\\\\mathcal{L}\\_{\\\\text{center}}+\\\\sum\\_{S=\\\\{1,4\\\\}}\\\\mathcal{L}\\_{\\\\boldsymbol{\\\\mathrm{\\\\mu}}}(S)+\\\\lambda\\_{r}\\\\left(\\\\mathcal{L}\\_{\\\\text{render}}+\\\\mathcal{L}\\_{\\\\text{LPIPS}}\\\\right)+\\\\lambda\\_{KL}\\\\mathcal{L}\\_{\\\\text{KL}}(\\\\boldsymbol{z}), |  | (11) |\n\nwhere ℒKLsubscriptℒKL\\\\mathcal{L}\\_{\\\\text{KL}} is the Kullback–Leibler divergence, λrsubscript𝜆𝑟\\\\lambda\\_{r} and λK​Lsubscript𝜆𝐾𝐿\\\\lambda\\_{KL} are the loss weights.\n\n### 3.3 Stage 2: latent diffusion model\n\nThe proposed VAE provides a low-dimensional latent code that can be mapped to Atlas Gaussians. We employ the EDM \\[ [44]\\] framework for latent diffusion. EDM aims to learn a denoising network Dθ​(𝒛;σ,𝒞)subscript𝐷𝜃𝒛𝜎𝒞D\\_{\\\\theta}(\\\\boldsymbol{z};\\\\sigma,\\\\mathcal{C}) to convert the Gaussian distribution to the empirical distribution pdatasubscript𝑝datap\\_{\\\\text{data}} defined by 𝒛𝒛\\\\boldsymbol{z}, where θ𝜃\\\\theta is the network parameters, σ𝜎\\\\sigma is the noise level sampled from a pre-defined distribution ptrainsubscript𝑝trainp\\_{\\\\text{train}}, and 𝒞𝒞\\\\mathcal{C} denotes the optional condition. Dθ​(𝒛;σ,𝒞)subscript𝐷𝜃𝒛𝜎𝒞D\\_{\\\\theta}(\\\\boldsymbol{z};\\\\sigma,\\\\mathcal{C}) is parameterized using a σ𝜎\\\\sigma-dependent skip connection:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | Dθ​(𝒛;σ,𝒞)=cskip​(σ)​𝒛+cout​(σ)​Fθ​(cin​(σ)​𝒛;cnoise​(σ),𝒞),subscript𝐷𝜃𝒛𝜎𝒞subscript𝑐skip𝜎𝒛subscript𝑐out𝜎subscript𝐹𝜃subscript𝑐in𝜎𝒛subscript𝑐noise𝜎𝒞D\\_{\\\\theta}(\\\\boldsymbol{z};\\\\sigma,\\\\mathcal{C})=c\\_{\\\\text{skip}}(\\\\sigma)\\\\boldsymbol{z}+c\\_{\\\\text{out}}(\\\\sigma)F\\_{\\\\theta}\\\\left(c\\_{\\\\text{in}}(\\\\sigma)\\\\boldsymbol{z};c\\_{\\\\text{noise}}(\\\\sigma),\\\\mathcal{C}\\\\right), |  | (12) |\n\nwhere Fθsubscript𝐹𝜃F\\_{\\\\theta} is the network to be trained. The training objective is\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | 𝔼σ,𝒛,𝒏​λ​(σ)​‖Dθ​(𝒛;σ,𝒞)−𝒛‖2,subscript𝔼𝜎𝒛𝒏𝜆𝜎superscriptnormsubscript𝐷𝜃𝒛𝜎𝒞𝒛2\\\\mathbb{E}\\_{\\\\sigma,\\\\boldsymbol{z},\\\\boldsymbol{n}}\\\\lambda(\\\\sigma)\\|\\|D\\_{\\\\theta}(\\\\boldsymbol{z};\\\\sigma,\\\\mathcal{C})-\\\\boldsymbol{z}\\|\\|^{2}, |  | (13) |\n\nwhere σ∼ptrain,𝒛∼pdata,𝒏∼𝒩​(0,σ2​I)formulae-sequencesimilar-to𝜎subscript𝑝trainformulae-sequencesimilar-to𝒛subscript𝑝datasimilar-to𝒏𝒩0superscript𝜎2𝐼\\\\sigma\\\\sim p\\_{\\\\text{train}},\\\\boldsymbol{z}\\\\sim p\\_{\\\\text{data}},\\\\boldsymbol{n}\\\\sim\\\\mathcal{N}(0,\\\\sigma^{2}I). Readers interested in details on cskip​(σ)subscript𝑐skip𝜎c\\_{\\\\text{skip}}(\\\\sigma), cout​(σ)subscript𝑐out𝜎c\\_{\\\\text{out}}(\\\\sigma), cin​(σ)subscript𝑐in𝜎c\\_{\\\\text{in}}(\\\\sigma), cnoise​(σ)subscript𝑐noise𝜎c\\_{\\\\text{noise}}(\\\\sigma), and parameterization of the weight function λ​(σ)𝜆𝜎\\\\lambda(\\\\sigma) may refer to EDM \\[ [44]\\].\n\nFollowing \\[ [114]\\], our denoising network Dθ​(𝒛;σ,𝒞)subscript𝐷𝜃𝒛𝜎𝒞D\\_{\\\\theta}(\\\\boldsymbol{z};\\\\sigma,\\\\mathcal{C}) consists of a series of blocks, each containing a self-attention layer followed by a cross-attention layer. Each block can be represented as:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | 𝒛(i)=CrossAttn​(SelfAttn​(𝒛(i−1)),𝒞),i=1,…,lformulae-sequencesuperscript𝒛𝑖CrossAttnSelfAttnsuperscript𝒛𝑖1𝒞𝑖1…𝑙\\\\boldsymbol{z}^{(i)}=\\\\text{CrossAttn}\\\\left(\\\\text{SelfAttn}(\\\\boldsymbol{z}^{(i-1)}),\\\\mathcal{C}\\\\right),\\\\quad i=1,\\\\ldots,l |  | (14) |\n\nwhere 𝒛(0)=𝒛superscript𝒛0𝒛\\\\boldsymbol{z}^{(0)}=\\\\boldsymbol{z} is the initial input to the network, l𝑙l is the number of blocks. In unconditional generation, we designate 𝒞𝒞\\\\mathcal{C} as a learnable parameter.\nNote that more advanced architectures \\[ [74]\\] could also be employed for the denoising network.",
      "citations": [
        {
          "start_pos": 1244,
          "end_pos": 1248,
          "text": "[45]",
          "paper_id": "bib.bib45",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 2091,
          "end_pos": 2101,
          "text": "Figure [2]",
          "paper_id": "bib.bib21",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 2103,
          "end_pos": 2108,
          "text": "[121]",
          "paper_id": "bib.bib121",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib105",
            "bib.bib114",
            "bib.bib117"
          ]
        },
        {
          "start_pos": 2110,
          "end_pos": 2115,
          "text": "[105]",
          "paper_id": "bib.bib105",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib121",
            "bib.bib114",
            "bib.bib117"
          ]
        },
        {
          "start_pos": 4808,
          "end_pos": 4812,
          "text": "[70]",
          "paper_id": "bib.bib70",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 4926,
          "end_pos": 4931,
          "text": "[114]",
          "paper_id": "bib.bib114",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib105",
            "bib.bib121",
            "bib.bib117"
          ]
        },
        {
          "start_pos": 8600,
          "end_pos": 8605,
          "text": "[114]",
          "paper_id": "bib.bib114",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib105",
            "bib.bib121",
            "bib.bib117"
          ]
        },
        {
          "start_pos": 9752,
          "end_pos": 9756,
          "text": "[17]",
          "paper_id": "bib.bib17",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 9758,
          "end_pos": 9762,
          "text": "[72]",
          "paper_id": "bib.bib72",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 10277,
          "end_pos": 10282,
          "text": "[114]",
          "paper_id": "bib.bib114",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib105",
            "bib.bib121",
            "bib.bib117"
          ]
        },
        {
          "start_pos": 10646,
          "end_pos": 10650,
          "text": "[42]",
          "paper_id": "bib.bib42",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 10652,
          "end_pos": 10656,
          "text": "[43]",
          "paper_id": "bib.bib43",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 12024,
          "end_pos": 12028,
          "text": "[39]",
          "paper_id": "bib.bib39",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 12386,
          "end_pos": 12390,
          "text": "[85]",
          "paper_id": "bib.bib85",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 12392,
          "end_pos": 12397,
          "text": "[105]",
          "paper_id": "bib.bib105",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib114",
            "bib.bib121",
            "bib.bib117"
          ]
        },
        {
          "start_pos": 15938,
          "end_pos": 15942,
          "text": "[48]",
          "paper_id": "bib.bib48",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 15944,
          "end_pos": 15949,
          "text": "[105]",
          "paper_id": "bib.bib105",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib121",
            "bib.bib117",
            "bib.bib114"
          ]
        },
        {
          "start_pos": 15951,
          "end_pos": 15955,
          "text": "[97]",
          "paper_id": "bib.bib97",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 15957,
          "end_pos": 15962,
          "text": "[121]",
          "paper_id": "bib.bib121",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib105",
            "bib.bib117",
            "bib.bib114"
          ]
        },
        {
          "start_pos": 18361,
          "end_pos": 18365,
          "text": "[45]",
          "paper_id": "bib.bib45",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 19548,
          "end_pos": 19553,
          "text": "[117]",
          "paper_id": "bib.bib117",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib114",
            "bib.bib121",
            "bib.bib105"
          ]
        },
        {
          "start_pos": 19555,
          "end_pos": 19559,
          "text": "[97]",
          "paper_id": "bib.bib97",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 20622,
          "end_pos": 20626,
          "text": "[44]",
          "paper_id": "bib.bib44",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 22670,
          "end_pos": 22674,
          "text": "[44]",
          "paper_id": "bib.bib44",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 22692,
          "end_pos": 22697,
          "text": "[114]",
          "paper_id": "bib.bib114",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib117",
            "bib.bib121",
            "bib.bib105"
          ]
        },
        {
          "start_pos": 23505,
          "end_pos": 23509,
          "text": "[74]",
          "paper_id": "bib.bib74",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        }
      ]
    },
    "4 Experiments": {
      "content": "We first introduce our experiment setup, and then show the results for both unconditional and conditional generation.\n\n### 4.1 Experimental setup\n\nFollowing most existing methods \\[ [6], [21], [69], [2], [8], [5], [48]\\], we benchmark unconditional single-category 3D generation on ShapeNet \\[ [7]\\]. We use the training split from SRN \\[ [89]\\], which comprises 4612, 2151, and 3033 shapes in the categories Chair, Car, and Plane, respectively. We render 76 views for each shape using Blender \\[ [14]\\] with the same intrinsic matrix as \\[ [5], [48]\\]. Fréchet Inception Distance (FID@50K) and Kernel Inception Distance (KID@50K) are used for evaluation.\nIn addition, we experiment with text-conditioned 3D generation on Objaverse \\[ [15]\\]. We use the renderings from G-buffer Objaverse \\[ [77]\\] and the captions from Cap3D \\[ [64]\\]. Due to limited computational resources, we select a subset with around 6K 3D shapes.\nPlease refer to Appendix [A]Appendix A Implementation details ‣ Atlas Gaussians Diffusion for 3D Generation with Infinite Number of Points\") for implementation details.\n\n### 4.2 Unconditional 3D generation\n\nTable [1]\\], GET3D \\[ [21]\\], DiffRF \\[ [69]\\], RenderDiffusion \\[ [2]\\], and SSDNeRF \\[ [8]\\]. Our approach also outperforms concurrent work LN3Diff \\[ [48]\\], which utilizes the triplane representation for 3D shapes. Our results demonstrate significant improvements over LN3Diff, particularly in the ShapeNet Chair category, which features greater geometric, structural, and textural complexity. In the other two categories, our method achieves better average performance, further highlighting the robustness and efficacy of our approach. We also include the qualitative comparison in Figure [5]Figure 5 ‣ 4.2 Unconditional 3D generation ‣ 4 Experiments ‣ Atlas Gaussians Diffusion for 3D Generation with Infinite Number of Points\").\n\n\\\\begin{overpic}\\[width=429.28616pt\\]{figures/fig\\_shapenet/shapenet\\_small.pdf}\n\\\\put(-3.0,1.0){\\\\footnotesize{\\\\rotatebox{90.0}{\\\\footnotesize{Ours}}}}\n\\\\put(-3.0,8.0){{\\\\rotatebox{90.0}{\\\\footnotesize{LN3Diff}}}}\n\\\\put(-3.0,19.5){\\\\footnotesize{\\\\rotatebox{90.0}{\\\\footnotesize{Ours}}}}\n\\\\put(-3.0,26.5){{\\\\rotatebox{90.0}{\\\\footnotesize{LN3Diff}}}}\n\\\\put(-3.0,40.0){\\\\footnotesize{\\\\rotatebox{90.0}{\\\\footnotesize{Ours}}}}\n\\\\put(-3.0,47.0){{\\\\rotatebox{90.0}{\\\\footnotesize{LN3Diff}}}}\n\\\\end{overpic}Figure 5: The comparison between LN3Diff \\[ [48]\\] and our method on three ShapeNet categories.Table 1: Evaluation of single-category unconditional generation on ShapeNet. LN3Diff\\* is evaluated using the generated results provided by the authors.\n\nMethodChairCarPlaneFID@50KKID@50K(%)FID@50KKID@50K(%)FID@50KKID@50K(%)EG3D \\[ [6]\\]26.091.133.331.414.470.5GET3D \\[ [21]\\]35.331.541.411.826.801.7DiffRF \\[ [69]\\]99.374.975.095.1101.796.5RenderDiffusion \\[ [2]\\]53.306.446.504.143.505.9SSDNeRF \\[ [8]\\]65.043.047.722.821.011.0LN3Diff \\[ [48]\\]16.900.4717.600.498.840.36Ours9.900.3512.150.458.090.21\n\n### 4.3 Conditional 3D generation\n\nWe evaluate our methods and baseline approaches \\[ [97], [43], [48]\\] on the text-conditioned 3D generation on Objaverse. We experiment with the text prompt split used in \\[ [48]\\]. As shown in Figure [6]\\] sometimes produces shapes with severe artifacts. This issue arises because the method relies on a multi-view generation network, which often suffers from multi-view inconsistency. In contrast, our method learns directly from 3D data, enabling the generation of consistent novel views.\nAdditionally, our method generates higher-quality 3D shapes compared to Shap-E and LN3Diff, which also utilize the VAE + LDM paradigm. However, these methods rely on volume rendering during training, which is usually limited to low resolution. Instead, our method uses the more efficient representation of 3D Gaussians. Thanks to our proposed Atlas Gaussians representation, which can decode a sufficiently large number of 3D Gaussians, our generated shapes exhibit more detailed features.\nWe also evaluate the generated 3D content using the CLIP score \\[ [78], [30]\\] and profile the inference time of each method. As shown in Table [2]Table 2 ‣ 4.3 Conditional 3D generation ‣ 4 Experiments ‣ Atlas Gaussians Diffusion for 3D Generation with Infinite Number of Points\"), our method achieves the highest score and the lowest inference time. This performance is attributed to our effective and efficient decoder design that links the low-dimensional latent space with the 3D space. Please refer to Appendix [B]Appendix B More results of text-conditioned 3D generation ‣ Atlas Gaussians Diffusion for 3D Generation with Infinite Number of Points\") for more results.\n\n\\\\begin{overpic}\\[width=433.62pt\\]{figures/fig\\_objaverse/objaverse.pdf}\n\\\\end{overpic}Figure 6: Comparison of text-conditioned 3D generation between baseline approaches on Objaverse. From left to right: LGM \\[ [97]\\], Shap-E \\[ [43]\\], LN3Diff \\[ [48]\\], and our method.Table 2: Evaluation of text-conditioned 3D generation on Objaverse.\n\nLGM \\[ [97]\\]Shap-E \\[ [43]\\]LN3Diff \\[ [48]\\]OursCLIP Score (ViT-B/32)29.6428.6127.0030.08Inference Time (GPU)6 s (TITAN V)33 s (TITAN V)7.5 s (V 100)3.5 s (TITAN V)\n\nTable 3: Scale up the number of 3D Gaussians on the Objaverse dataset.\n\n#3DGSPSNR↑↑\\\\uparrowLPIPS↓↓\\\\downarrow#Params↓↓\\\\downarrowTime per Epoch↓↓\\\\downarrow8,19225.890.069141.76M10.2 min32,76826.710.058141.76M10.6 min100,35227.020.053141.76M11.2 min\n\nTable 4: Ablation study on network design evaluated on ShapeNet with PSNR.\n\nAtlas Gaussians (Full)26.56(a) linear weights26.13(b) no disentangle25.77(c) no global feature26.18\n\n### 4.4 Ablation study\n\nThis section presents an ablation study on different components of our network.\n\nNumber of 3D Gaussians.\nAtlas Gaussians support easy modification of the numbers of 3D Gaussians by varying the number of points sampled for each patch. With the total number of 3D Gaussians given by N=α2​M𝑁superscript𝛼2𝑀N=\\\\alpha^{2}M, we fix the number of patches M𝑀M and vary α𝛼\\\\alpha. We experiment with different values of α𝛼\\\\alpha (2, 4, and 7), resulting in 8192, 32768, and 100352 3D Gaussians, respectively. We then evaluated the rendering quality of the VAE on a validation set to assess the impact of the number of 3D Gaussians.\nAs shown in Table [4]Table 4 ‣ 4.3 Conditional 3D generation ‣ 4 Experiments ‣ Atlas Gaussians Diffusion for 3D Generation with Infinite Number of Points\"), both the PSNR and LPIPS improve consistently as more 3D Gaussians are generated. A significant observation is that the network parameters remain unchanged despite the increase in the number of 3D Gaussians, attributable to our proposed Atlas Gaussians representation. Furthermore, the computational overhead, including the cost of decoding and rendering additional 3D Gaussians, remains small.\n\nLearned weights for feature decoding.\nIn Table [4]Table 4 ‣ 4.3 Conditional 3D generation ‣ 4 Experiments ‣ Atlas Gaussians Diffusion for 3D Generation with Infinite Number of Points\"), we ablate the VAE network design on the ShapeNet validation set using the PSNR metric. The table shows that replacing our learned weight function with bilinear interpolation weights leads to a performance drop for the VAE. This indicates that our learned nonlinear weights have stronger representation capabilities than linear weights.\n\nDisentangle geometry and texture.\nAtlas Gaussians can achieve geometry and appearance disentanglement by design. To validate the effectiveness of this design, we experimented with another network version where a single set of features is shared for both geometry and appearance. As shown in Table [4]Table 4 ‣ 4.3 Conditional 3D generation ‣ 4 Experiments ‣ Atlas Gaussians Diffusion for 3D Generation with Infinite Number of Points\"), performance decreases considerably with this shared feature approach. This shows that our disentangled design facilitates better learning.\n\nUsing global features.\nAs shown in Table [4]Table 4 ‣ 4.3 Conditional 3D generation ‣ 4 Experiments ‣ Atlas Gaussians Diffusion for 3D Generation with Infinite Number of Points\"), removing the global feature from 𝒛lsubscript𝒛𝑙\\\\boldsymbol{z}\\_{l} in the patch feature decoder leads to a performance drop. This outcome is expected, as the global features provide essential context that complements the local features.",
      "citations": [
        {
          "start_pos": 182,
          "end_pos": 185,
          "text": "[6]",
          "paper_id": "bib.bib6",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 187,
          "end_pos": 191,
          "text": "[21]",
          "paper_id": "bib.bib21",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 193,
          "end_pos": 197,
          "text": "[69]",
          "paper_id": "bib.bib69",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 199,
          "end_pos": 202,
          "text": "[2]",
          "paper_id": "bib.bib2",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 204,
          "end_pos": 207,
          "text": "[8]",
          "paper_id": "bib.bib8",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 209,
          "end_pos": 212,
          "text": "[5]",
          "paper_id": "bib.bib5",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 214,
          "end_pos": 218,
          "text": "[48]",
          "paper_id": "bib.bib48",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 294,
          "end_pos": 297,
          "text": "[7]",
          "paper_id": "bib.bib7",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 339,
          "end_pos": 343,
          "text": "[89]",
          "paper_id": "bib.bib89",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 497,
          "end_pos": 501,
          "text": "[14]",
          "paper_id": "bib.bib14",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 541,
          "end_pos": 544,
          "text": "[5]",
          "paper_id": "bib.bib5",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 546,
          "end_pos": 550,
          "text": "[48]",
          "paper_id": "bib.bib48",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 735,
          "end_pos": 739,
          "text": "[15]",
          "paper_id": "bib.bib15",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib121",
            "bib.bib109",
            "bib.bib112"
          ]
        },
        {
          "start_pos": 792,
          "end_pos": 796,
          "text": "[77]",
          "paper_id": "bib.bib77",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 830,
          "end_pos": 834,
          "text": "[64]",
          "paper_id": "bib.bib64",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1130,
          "end_pos": 1139,
          "text": "Table [1]",
          "paper_id": "bib.bib6",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1152,
          "end_pos": 1156,
          "text": "[21]",
          "paper_id": "bib.bib21",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1170,
          "end_pos": 1174,
          "text": "[69]",
          "paper_id": "bib.bib69",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1197,
          "end_pos": 1200,
          "text": "[2]",
          "paper_id": "bib.bib2",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1219,
          "end_pos": 1222,
          "text": "[8]",
          "paper_id": "bib.bib8",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1283,
          "end_pos": 1287,
          "text": "[48]",
          "paper_id": "bib.bib48",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 2415,
          "end_pos": 2419,
          "text": "[48]",
          "paper_id": "bib.bib48",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 2698,
          "end_pos": 2701,
          "text": "[6]",
          "paper_id": "bib.bib6",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 2736,
          "end_pos": 2740,
          "text": "[21]",
          "paper_id": "bib.bib21",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 2776,
          "end_pos": 2780,
          "text": "[69]",
          "paper_id": "bib.bib69",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 2826,
          "end_pos": 2829,
          "text": "[2]",
          "paper_id": "bib.bib2",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 2866,
          "end_pos": 2869,
          "text": "[8]",
          "paper_id": "bib.bib8",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 2906,
          "end_pos": 2910,
          "text": "[48]",
          "paper_id": "bib.bib48",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 3055,
          "end_pos": 3059,
          "text": "[97]",
          "paper_id": "bib.bib97",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 3061,
          "end_pos": 3065,
          "text": "[43]",
          "paper_id": "bib.bib43",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 3067,
          "end_pos": 3071,
          "text": "[48]",
          "paper_id": "bib.bib48",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 3178,
          "end_pos": 3182,
          "text": "[48]",
          "paper_id": "bib.bib48",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 3198,
          "end_pos": 3208,
          "text": "Figure [6]",
          "paper_id": "bib.bib97",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 4052,
          "end_pos": 4056,
          "text": "[78]",
          "paper_id": "bib.bib78",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 4058,
          "end_pos": 4062,
          "text": "[30]",
          "paper_id": "bib.bib30",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 4873,
          "end_pos": 4877,
          "text": "[97]",
          "paper_id": "bib.bib97",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 4891,
          "end_pos": 4895,
          "text": "[43]",
          "paper_id": "bib.bib43",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 4910,
          "end_pos": 4914,
          "text": "[48]",
          "paper_id": "bib.bib48",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 5009,
          "end_pos": 5013,
          "text": "[97]",
          "paper_id": "bib.bib97",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 5025,
          "end_pos": 5029,
          "text": "[43]",
          "paper_id": "bib.bib43",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 5042,
          "end_pos": 5046,
          "text": "[48]",
          "paper_id": "bib.bib48",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        }
      ]
    },
    "5 Conclusion": {
      "content": "This paper introduces Atlas Gaussians, a new representation for feed-forward 3D generation. Atlas Gaussians enable the efficient generation of a sufficiently large and theoretically infinite number of 3D Gaussians, which is crucial for high-quality 3D generation. We also designed a transformer-based decoder to link the low-dimensional latent space with the 3D space. With these innovations, we pioneer the integration of 3D Gaussians into the VAE + LDM paradigm, achieving superior performance and producing high-fidelity 3D content.\n\nLimitations and Future Work.\nOur method relies on a 3D dataset to train the VAE. A promising direction for future research is to explore training the VAE using in-the-wild real-world images. We plan to train our approach on large-scale data, similar to LRM \\[ [35]\\], to fully explore the representation power of Atlas Gaussians.\n\nAdditionally, our method uses the vanilla 3D Gaussian representation, which is known to be challenging for extracting highly accurate geometry. Incorporating recent advancements \\[ [36], [110], [27]\\] in 3D Gaussian techniques can benefit both geometry and appearance.\n\nBroader Impacts. In this paper, we propose a new representation for high-quality 3D generation, which may enhance productivity across several industries. However, if not used properly, it has the potential to be applied to generate deceptive or malicious 3D content.\n\nAcknowledgements. We sincerely thank Yushi Lan for his invaluable assistance in the evaluation.",
      "citations": [
        {
          "start_pos": 797,
          "end_pos": 801,
          "text": "[35]",
          "paper_id": "bib.bib35",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1049,
          "end_pos": 1053,
          "text": "[36]",
          "paper_id": "bib.bib36",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        },
        {
          "start_pos": 1055,
          "end_pos": 1060,
          "text": "[110]",
          "paper_id": "bib.bib110",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": [
            "bib.bib114",
            "bib.bib118",
            "bib.bib120"
          ]
        },
        {
          "start_pos": 1062,
          "end_pos": 1066,
          "text": "[27]",
          "paper_id": "bib.bib27",
          "single_citation": null,
          "citation_type": null,
          "nearest_citations": null
        }
      ]
    }
  },
  "references": {
    "data": {
      "bib.bib9": {
        "id": "bib.bib9",
        "citation": "[9]",
        "authors": "",
        "year": "",
        "title": "Fantasia3d: Disentangling geometry and appearance for high-quality text-to-3d content creation.",
        "venue": "",
        "pages": "",
        "url": "",
        "arxiv_id": "2303.13873",
        "doi": null,
        "sections": {
          "1 Introduction": {
            "content": "Automatic 3D content creation \\[ [43]), [18]), [33]), [44])\\] powered by large language models has drawn significant attention recently, due to its convenience to entertaining and gaming industries, virtual/augmented reality, and robotic applications.\nThe traditional process of creating 3D assets typically involves multiple, labor-intensive stages, including geometry modeling, shape baking, UV mapping, material creation, and texturing, as described in \\[ [15])\\], where different software tools and the expertise of skilled artists are often required. Imperfections would also accumulate across these stages, resulting in low-quality 3D assets. It is thus desirable to automate such a process, and ideally to generate high-quality 3D assets that have geometrically fair surfaces, rich materials and textures, and support photorealistic rendering under arbitrary views.\n\nIn this work, we focus on automatic 3D content creation given text prompts encoded by large language models, i.e., the text-to-3D tasks \\[ [18]), [33])\\]. Text-to-3D is inspired by the tremendous success of text-to-image research \\[ [34]), [36]), [30]), [35])\\]. To enable 3D generation, most existing methods \\[ [33]), [23])\\] rely on the implicit scene modeling of Neural Radiance Field (NeRF) \\[ [25]), [4]), [27])\\], and learn the NeRFs by back-propagating the supervision signals from image diffusion models. However, NeRF modeling is less effective for surface recovery \\[ [43]), [46])\\], since it couples the learning of surface geometry with that of pixel colors via volume rendering. Consequently, 3D creation based on NeRF modeling is less effective for recovery of both the fine surface and its material and texture. In the meanwhile, explicit and hybrid scene representations \\[ [43]), [46]), [38])\\] are proposed to improve over NeRF by modeling the surface explicitly and performing view synthesis via surface rendering.\n\nIn this work, we are motivated to use 3D scene representations that are more amenable to the generation of high-quality 3D assets given text prompts. We present an automatic text-to-3D method called Fantasia3D. Key to Fantasia3D is a disentangled learning of geometry and appearance models, such that both a fine surface and a rich material/texture can be generated. To enable such a disentangled learning, we use the hybrid scene representation of DMTet\\[ [38])\\], which maintains a deformable tetrahedral grid and a differentiable mesh extraction layer; deformation can thus be learned through the layer to explicitly control the shape generation. For geometry learning, we technically propose to encode a rendered normal map, and use shape encoding of the normal as the input of a pre-trained, image diffusion model; this is in contrast different from existing methods that commonly encode rendered color images. For appearance modeling, we introduce, for the first time, the spatially varying Bidirectional\nReflectance Distribution Function (BRDF) into the text-to-3D task, thus enabling material learning that supports photorealistic rendering of the learned surface. We implement the geometry model and the BRDF appearance model as simple MLPs. Both models are learned through the pre-trained image diffusion model, using a loss of Score Distillation Sampling (SDS) \\[ [33])\\]. We use the pre-trained stable diffusion \\[ [35]), [40])\\] as the image generation model in this work.\n\nWe note that except for text prompts, our method can also be triggered with additional inputs of users’ preferences, such as a customized 3D shape or a generic 3D shape of a certain object category; this is flexible for users to better control what content is to be generated. In addition, given the disentangled generation of geometry and appearance, it is convenient for our method to support relighting, editing, and physical simulation of the generated 3D assets. We conduct thorough experiments to verify the efficacy of our proposed methods. Results show that our proposed Fantasia3D outperforms existing methods for high-quality and diverse 3D content creation. We summarize our technical contributions as follows.\n\n- •\n\n\nWe propose a novel method, termed Fantasia3D, for high-quality text-to-3D content creation. Our method disentangles the modeling and learning of geometry and appearance, and thus enables both a fine recovery of geometry and photorealistc rendering of per-view images.\n\n- •\n\n\nFor geometry learning, we use a hybrid representation of DMTet, which supports learning surface deformation via a differentiable mesh extraction; we propose to render and encode the surface normal extracted from DMTet as the input of the pre-trained image diffusion model, which enables more subtle control of shape generation.\n\n- •\n\n\nFor appearance modeling, to the best of our knowledge, we are the first to introduce the full BRDF learning into text-to-3D content creation, facilitated by our proposed geometry-appearance disentangled framework. BRDF modeling promises high-quality 3D generation via photorealistic rendering.\n\n\n![Refer to caption]Figure 2: Results of our method. The upper portion of this figure showcases\nthe generation results obtained from solely text prompts. The lower portion showcases user-guided generation results given guiding meshes with the corresponding textual descriptions.![Refer to caption]Figure 3: Overview of our method. Our method can generate disentangled geometry and appearance given a text prompt (cf. figure (a)), which are produced by (b) geometry modeling and (c) appearance modeling, respectively. (b) We employ DMTet as our 3D geometry representation, which is initialized as a 3D ellipsoid here. To optimize the parameters of DMTet, we render the normal map (and the object mask in the early training phase) of the extracted mesh from DMTet as the shape encoding of stable diffusion \\[ [35]), [40])\\]. (c) For appearance modeling, we introduce the spatially-varying Bidirectional Reflectance Distribution Function (BRDF) modeling into text-to-3D generation, and learn to predict three components (namely, kdsubscript𝑘𝑑k\\_{d}, kr​msubscript𝑘𝑟𝑚k\\_{rm}, and knsubscript𝑘𝑛k\\_{n}) of the appearance. Both geometry and appearance modeling are supervised by Score Distillation Sampling (SDS) loss \\[ [33])\\].",
            "citations": null
          },
          "2 Related work": {
            "content": "Text-to-3D content creation. Motivated by the desire to generate high-quality 3D content from simple semantics such as text prompts, text-to-3D has drawn considerable attention in recent years \\[ [33]), [13]), [18])\\]. Existing methods either use pre-trained 2D text-to-image models \\[ [35]), [3]), [36])\\], together with score distillation sampling \\[ [33])\\], to generate 3D geometries \\[ [18])\\] or synthesize novel views \\[ [33])\\], or train a text-conditioned 3D generative model from scratch \\[ [39]), [49]), [17]), [29])\\]. These methods generate 3D geometries with little exploration of generating high-quality lighting and surface materials. On the other hand, TANGO \\[ [8])\\] is able to generate high-quality surface materials given text prompts; unfortunately, the method requires as input a 3D surface mesh. Our proposed method addresses the shortcomings of the above methods, and is able to generate both high-quality surface geometries and their corresponding materials, both of which are crucial for photorealistic rendering of the generated 3D content. Our method thus, for the first time, closes the loop of object-level text-to-3D content creation.\n\nSurface material estimation. The estimation of surface materials is a long-standing challenge in computer vision and graphics research. Earlier methods \\[ [2]), [45])\\] focus on recovering physically based materials under known lighting conditions, whose usefulness is, however, limited in real-world scenarios. Subsequent methods \\[ [12]), [11]), [5]), [1])\\] try to estimate materials under natural lighting conditions, assuming the availability of complete geometry information. More recently, the joint reconstruction of geometry and materials is proposed given calibrated multi-view images \\[ [6]), [7]), [19]), [48])\\]. Alternative to these methods, we explore the novel creation of surface materials and geometries from trained language models.",
            "citations": null
          },
          "3 Preliminary": {
            "content": "In this section, we present a few preliminaries that are necessary for presenting our proposed method in Section [4]The Proposed Method ‣ Fantasia3D: Disentangling Geometry and Appearance for High-quality Text-to-3D Content Creation\").\n\n### 3.1 Score distillation sampling\n\nDreamFusion \\[ [33])\\] presents a method that optimizes 3D scene parameters and synthesizes novel views from textual descriptions, by employing a pre-trained 2D diffusion model. The scene is represented as a differentiable image parameterization \\[ [26])\\], where a differentiable generator g𝑔g renders 2D images x=g​(θ)𝑥𝑔𝜃x=g(\\\\theta) from a modified Mip-NeRF \\[ [4])\\] parameterized as θ𝜃\\\\theta. DreamFusion leverages a diffusion model ϕitalic-ϕ\\\\phi (Imagen \\[ [36])\\] in this instance) to provide a score function ϵ^ϕ​(xt;y,t)subscript^italic-ϵitalic-ϕsubscript𝑥𝑡𝑦𝑡\\\\hat{\\\\epsilon}\\_{\\\\phi}(x\\_{t};y,t), which predicts the sampled noise ϵitalic-ϵ\\\\epsilon given the noisy image xtsubscript𝑥𝑡x\\_{t}, text-embedding y𝑦y, and noise level t𝑡t. This score function guides the direction of the gradient for updating the scene parameters θ𝜃\\\\theta, and the gradient is calculated by Score Distillation Sampling (SDS):\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | ▽θℒSDS​(ϕ,x)=𝔼t,ϵ​\\[w​(t)​(ϵ^ϕ​(xt;y,t)−ϵ)​∂x∂θ\\],subscript▽𝜃subscriptℒSDSitalic-ϕ𝑥subscript𝔼𝑡italic-ϵdelimited-\\[\\]𝑤𝑡subscript^italic-ϵitalic-ϕsubscript𝑥𝑡𝑦𝑡italic-ϵ𝑥𝜃\\\\bigtriangledown\\_{\\\\theta}\\\\mathcal{L}\\_{\\\\text{SDS}}(\\\\phi,x)=\\\\mathbb{E}\\_{t,\\\\epsilon}\\\\left\\[w(t)(\\\\hat{\\\\epsilon}\\_{\\\\phi}(x\\_{t};y,t)-\\\\epsilon)\\\\frac{\\\\partial x}{\\\\partial\\\\theta}\\\\right\\], |  | (1) |\n\nwhile w​(t)𝑤𝑡w(t) is a weighting function. Since Imagen is not publicly accessible, in this work, we use the released latent space diffusion model of Stable Diffusion \\[ [35]), [40])\\] as our guidance model, and revise the SDS loss ( [1]In 3.1 Score distillation sampling ‣ 3 Preliminary ‣ Fantasia3D: Disentangling Geometry and Appearance for High-quality Text-to-3D Content Creation\")) accordingly. Details are given in Section [4.2]Geometry modeling ‣ 4 The Proposed Method ‣ Fantasia3D: Disentangling Geometry and Appearance for High-quality Text-to-3D Content Creation\").\n\n### 3.2 DMTet\n\nImplicit surface representations \\[ [25]), [31]), [22])\\] are popularly used in novel view synthesis and 3D reconstruction, due to their capabilities to represent complex scenes. However, surfaces of lower quality may be obtained \\[ [28])\\] by extracting explicit meshes from these implicit representations using marching cubes \\[ [20])\\]. Instead, Shen et al. \\[ [38])\\] propose a hybrid representation, termed DMTet, that has two key features, i.e., a deformable tetrahedral grid and a differentiable Marching Tetrahedral (MT) layer. The deformable tetrahedral grid (VT,T)subscript𝑉𝑇𝑇(V\\_{T},T) has vertices VTsubscript𝑉𝑇V\\_{T} in the tetrahedral grid T𝑇T. For each vertex vi∈VTsubscript𝑣𝑖subscript𝑉𝑇v\\_{i}\\\\in V\\_{T}, the proposed method predicts the Signed Distance Function (SDF) value s​(vi)𝑠subscript𝑣𝑖s(v\\_{i}) and a position offset △​vi△subscript𝑣𝑖\\\\triangle v\\_{i} by:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | (s​(vi),△​vi)=Ψ​(vi;ψ),𝑠subscript𝑣𝑖△subscript𝑣𝑖Ψsubscript𝑣𝑖𝜓(s(v\\_{i}),\\\\triangle v\\_{i})=\\\\Psi(v\\_{i};\\\\psi), |  | (2) |\n\nwhere ψ𝜓\\\\psi is the parameters of a network ΨΨ\\\\Psi, enabling the extraction of explicit meshes through MT layer during each iteration of training. In this work, We use DMTet as our geometry representation and render the mesh extracted from MT layer iteratively by a differentiable renderer\\[ [16]), [28])\\].",
            "citations": null
          },
          "4 The Proposed Method": {
            "content": "In this section, we present our proposed method of Fantasia3D for high-quality text-to-3D object generation, by disentangling the modeling and learning of geometry and appearance.\nFor geometry modeling, we rely on the hybrid surface representation of DMTet, and parameterize the 3D geometry as an MLP ΨΨ\\\\Psi that learns to predict the SDF value and position offset for each vertex in the deformable tetrahedral grid of DMTet; in contrast to previous methods, we propose to use the rendered normal map (and the object mask in the early training phase) of the extracted mesh from DMTet as the input of shape encoding. For appearance modeling, we introduce, for the first time, the full Bidirectional\nReflectance Distribution Function (BRDF) modeling into text-to-3D generation, and learn an MLP ΓΓ\\\\Gamma that predicts parameters of surface material and supports high-quality 3D generation via photorealistic rendering.\nGiven the disentangled modeling of ΨΨ\\\\Psi and ΓΓ\\\\Gamma, the whole pipeline is learned with SDS supervision, and the gradients are back-propagated through the pre-trained stable diffusion model.\nOur pipeline is initialized either as a 3D ellipsoid or as a customized 3D model provided by users. Fig. [3]Figure 3 ‣ 1 Introduction ‣ Fantasia3D: Disentangling Geometry and Appearance for High-quality Text-to-3D Content Creation\") gives an illustration of our proposed method.\nIn contrast, previous methods couple the geometry and appearance learning, and are suboptimal in terms of leveraging the powerful pre-trained 2D image diffusion models via SDS loss.\nDetails of the proposed Fantasia3D are presented as follows.\n\n### 4.1 DMTet initialization\n\nWe adopt DMTet as our 3D scene representation, which is parameterized as the MLP network ΨΨ\\\\Psi. For each vertex vi∈VTsubscript𝑣𝑖subscript𝑉𝑇v\\_{i}\\\\in V\\_{T} of the tetrahedral grid (VT,T)subscript𝑉𝑇𝑇(V\\_{T},T), ΨΨ\\\\Psi is trained to predict the SDF value s​(vi)𝑠subscript𝑣𝑖s(v\\_{i}) and the deformation offset △​vi△subscript𝑣𝑖\\\\triangle v\\_{i}. A triangular mesh can be extracted from (VT,T)subscript𝑉𝑇𝑇(V\\_{T},T) using the MT layer, whose procedure is also differentiable w.r.t. the parameters of ΨΨ\\\\Psi.\nWe initialize DMTet either as a 3D ellipsoid or as a customized 3D model provided by users; the latter choice is useful when the text-to-3D task is to be conditioned on users’ preferences. In either case, we initialize ΨΨ\\\\Psi by the following fitting procedure. We sample a point set {pi∈ℝ3}subscript𝑝𝑖superscriptℝ3\\\\{p\\_{i}\\\\in\\\\mathbb{R}^{3}\\\\} whose points are in close proximity to the initialized 3D ellipsoid or customized model, and compute their SDF values, resulting in {S​D​F​(pi)}𝑆𝐷𝐹subscript𝑝𝑖\\\\{SDF(p\\_{i})\\\\}; we use the following loss to optimize the parameters ψ𝜓\\\\psi of ΨΨ\\\\Psi:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | ℒSDF=∑pi∈P‖s​(pi;ψ)−S​D​F​(pi)‖22.subscriptℒSDFsubscriptsubscript𝑝𝑖𝑃superscriptsubscriptnorm𝑠subscript𝑝𝑖𝜓𝑆𝐷𝐹subscript𝑝𝑖22\\\\mathcal{L}\\_{\\\\text{SDF}}=\\\\sum\\_{p\\_{i}\\\\in P}\\\\left\\\\\\|s(p\\_{i};\\\\psi)-SDF(p\\_{i})\\\\right\\\\\\|\\_{2}^{2}. |  | (3) |\n\n### 4.2 Geometry modeling\n\nPrevious text-to-3D methods \\[ [33]), [13])\\] commonly use NeRF \\[ [25]), [4])\\] as the implicit scene representation, which couples the geometry with color/appearance and use volume rendering for view synthesis. Since NeRF modeling is less effective for surface reconstruction \\[ [43]), [46])\\], these methods are consequently less effective to generate high-quality 3D surfaces by back-propagating the supervision of SDS loss through pre-trained text-to-image models. As a remedy, the method \\[ [18])\\] uses a second stage of the refined generation that is based on scene modeling of explicit surfaces.\n\nIn this work, we propose to decouple the generation of geometry from that of appearance, based on the hybrid scene representation of DMTet, which enables photorealistic surface rendering to make better use of the powerful pre-trained text-to-image models. More specifically, given the current DMTet with MLP parameters ψ𝜓\\\\psi, we generate a normal map n𝑛n, together with an object mask o𝑜o, as:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | (n,o)=gn​(ψ,c),𝑛𝑜subscript𝑔𝑛𝜓𝑐(n,o)=g\\_{n}(\\\\psi,c), |  | (4) |\n\nwhere gnsubscript𝑔𝑛g\\_{n} is a differentiable render ( _e.g_., nvidiffrast \\[ [16])\\]), and c𝑐c is a sampled camera pose. We randomly sample the camera poses in the spherical coordinate system to ensure that the camera poses are distributed uniformly on the sphere.\nWe propose to use the generated n𝑛n (and o𝑜o) as the input of shape encoding to connect with stable diffusion. To update ψ𝜓\\\\psi, we again employ SDS loss that computes the gradient w.r.t. ψ𝜓\\\\psi as:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | ▽ψℒSDS​(ϕ,n~)=𝔼​\\[w​(t)​(ϵ^ϕ​(ztn~;y,t)−ϵ)​∂n~∂ψ​∂zn~∂n~\\],subscript▽𝜓subscriptℒSDSitalic-ϕ~𝑛𝔼delimited-\\[\\]𝑤𝑡subscript^italic-ϵitalic-ϕsuperscriptsubscript𝑧𝑡~𝑛𝑦𝑡italic-ϵ~𝑛𝜓superscript𝑧~𝑛~𝑛\\\\bigtriangledown\\_{\\\\psi}\\\\mathcal{L}\\_{\\\\text{SDS}}(\\\\phi,\\\\tilde{n})=\\\\mathbb{E}\\\\left\\[w(t)(\\\\hat{\\\\epsilon}\\_{\\\\phi}(z\\_{t}^{\\\\tilde{n}};y,t)-\\\\epsilon)\\\\frac{\\\\partial\\\\tilde{n}}{\\\\partial\\\\psi}\\\\frac{{\\\\partial z^{\\\\tilde{n}}}}{\\\\partial\\\\tilde{n}}\\\\right\\], |  | (5) |\n\nwhere ϕitalic-ϕ\\\\phi parameterizes the pre-trained stable diffusion model, n~~𝑛\\\\tilde{n} denotes concatenation of the normal n𝑛n with the mask o𝑜o, zn~superscript𝑧~𝑛z^{\\\\tilde{n}} is the latent code of n~~𝑛\\\\tilde{n} via shape encoding, ϵ^ϕ​(ztn~;y,t)subscript^italic-ϵitalic-ϕsuperscriptsubscript𝑧𝑡~𝑛𝑦𝑡\\\\hat{\\\\epsilon}\\_{\\\\phi}(z\\_{t}^{\\\\tilde{n}};y,t) is the predicted noise given text embedding y𝑦y and noise level t𝑡t, and ϵitalic-ϵ\\\\epsilon is the noise added in ztn~superscriptsubscript𝑧𝑡~𝑛z\\_{t}^{\\\\tilde{n}}.\nIn practice, we utilize a coarse-to-fine strategy to model the geometry. During the early phase of training, we use the downsampled n~~𝑛\\\\tilde{n} as the latent code, which is inspired by \\[ [23])\\], to rapidly update ΨΨ\\\\Psi and attain a coarse shape. However, a domain gap exists between n~~𝑛\\\\tilde{n} and the latent space data distribution learned by the VAE encoder in the stable diffusion, which may lead to a mismatch of the generated geometry from the textual description. To mitigate this discrepancy, we implement a data augmentation technique by introducing random rotations to n~~𝑛\\\\tilde{n}. Our experimental observations reveal that this technique enhances the alignment between the generated geometry and the provided textual description. In the later phase of training, aiming to capture finer geometric details with greater precision, we encode the high-resolution normal n𝑛n (without the mask o𝑜o) to derive znsuperscript𝑧𝑛z^{n}, using the pre-trained image encoder in stable diffusion.\n\n![Refer to caption]Figure 4: Three components of the material model, namely the diffuse term kdsubscript𝑘𝑑k\\_{d}, the roughness and metallic term kr​msubscript𝑘𝑟𝑚k\\_{rm}, and the normal variation term knsubscript𝑘𝑛k\\_{n}. ![Refer to caption]Figure 5: A comparison of UV edge padding (cf. the left column) and original texturing (cf. the right column). UV edge padding removes the white seams that appear in the right rendering.\n\n### 4.3 Appearance modeling\n\nGiven a learned DMTet with geometry parameters ψ𝜓\\\\psi, we aim for photorealistic surface rendering to better leverage the powerful image diffusion model. This is achieved by introducing into text-to-3D generation the Physically-Based Rendering (PBR) material model. As illustrated in Fig. [4]Figure 4 ‣ 4.2 Geometry modeling ‣ 4 The Proposed Method ‣ Fantasia3D: Disentangling Geometry and Appearance for High-quality Text-to-3D Content Creation\"), the material model we use \\[ [21])\\] comprises three components, namely the diffuse term kd∈ℝ3subscript𝑘𝑑superscriptℝ3k\\_{d}\\\\in\\\\mathbb{R}^{3}, the roughness and metallic term kr​m∈ℝ2subscript𝑘𝑟𝑚superscriptℝ2k\\_{rm}\\\\in\\\\mathbb{R}^{2}, and the normal variation term kn∈ℝ3subscript𝑘𝑛superscriptℝ3k\\_{n}\\\\in\\\\mathbb{R}^{3}. The kdsubscript𝑘𝑑k\\_{d} term denotes the diffuse value, while the kr​msubscript𝑘𝑟𝑚k\\_{rm} term encompasses the roughness r𝑟r and metalness m𝑚m; the roughness r𝑟r serves as a metric for measuring the extent of specular reflection and a parameter of the GGX \\[ [42])\\] normal distribution function in the rendering equation. The metalness parameter m𝑚m and diffuse value kdsubscript𝑘𝑑k\\_{d} can be used to compute the specular term kssubscript𝑘𝑠k\\_{s} using ks=(1−m)⋅0.04+m⋅kdsubscript𝑘𝑠⋅1𝑚0.04⋅𝑚subscript𝑘𝑑k\\_{s}=(1-m)\\\\cdot 0.04+m\\\\cdot k\\_{d}. Furthermore, we use a normal variation knsubscript𝑘𝑛k\\_{n} in tangent space to enhance the surface lighting effect and introduce additional geometric variations.\n\nWe use an MLP ΓΓ\\\\Gamma as our parameterized material model. ΓΓ\\\\Gamma is learned to predict spatially varying material parameters, which are subsequently used to render the surface extracted from DMTet. More specifically, for any point p∈ℝ3𝑝superscriptℝ3p\\\\in\\\\mathbb{R}^{3} on the surface, we use hash-grid positional encoding \\[ [27])\\], and generate the diffuse term kdsubscript𝑘𝑑k\\_{d}, the specular term kr​msubscript𝑘𝑟𝑚k\\_{rm}, and the tangent space normal knsubscript𝑘𝑛k\\_{n} as:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | (kd,kr​m,kn)=Γ​(β​(p);γ),subscript𝑘𝑑subscript𝑘𝑟𝑚subscript𝑘𝑛Γ𝛽𝑝𝛾(k\\_{d},k\\_{rm},k\\_{n})=\\\\Gamma(\\\\beta(p);\\\\gamma), |  | (6) |\n\nwhere β𝛽\\\\beta is the positional encoding of p𝑝p, and γ𝛾\\\\gamma parameterizes the MLP ΓΓ\\\\Gamma.\nThe basic rendering equation suggests that each image pixel at a specific viewing direction can be rendered as\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | L​(p,ω)=∫ΩLi​(p,ωi)​f​(p,ωi,ω)​(ωi⋅np)​dωi,𝐿𝑝𝜔subscriptΩsubscript𝐿𝑖𝑝subscript𝜔𝑖𝑓𝑝subscript𝜔𝑖𝜔⋅subscript𝜔𝑖subscript𝑛𝑝differential-dsubscript𝜔𝑖L(p,\\\\omega)=\\\\int\\_{\\\\Omega}L\\_{i}(p,\\\\omega\\_{i})f(p,\\\\omega\\_{i},\\\\omega)(\\\\omega\\_{i}\\\\cdot n\\_{p})\\\\mathrm{d}\\\\omega\\_{i}, |  | (7) |\n\nwhere L𝐿L is the rendered pixel color along the direction ω𝜔\\\\omega from the surface point p𝑝p, Ω={ωi:ωi⋅np≥0}Ωconditional-setsubscript𝜔𝑖⋅subscript𝜔𝑖subscript𝑛𝑝0\\\\Omega=\\\\left\\\\{\\\\mathbf{\\\\omega}\\_{i}:\\\\mathbf{\\\\omega}\\_{i}\\\\cdot n\\_{p}\\\\geq 0\\\\right\\\\} denotes a hemisphere with the incident direction ωisubscript𝜔𝑖\\\\omega\\_{i} and surface normal npsubscript𝑛𝑝n\\_{p} at p𝑝p, Lisubscript𝐿𝑖L\\_{i} is the incident light that is represented by an off-the-shelf environment map \\[ [32])\\], and f𝑓f is the BRDF determined by the material parameters (kd,kr​m,kn)subscript𝑘𝑑subscript𝑘𝑟𝑚subscript𝑘𝑛(k\\_{d},k\\_{rm},k\\_{n}) predicted by ( [6]In 4.3 Appearance modeling ‣ 4 The Proposed Method ‣ Fantasia3D: Disentangling Geometry and Appearance for High-quality Text-to-3D Content Creation\")).\nWe note that L𝐿L is the summation of diffuse intensity Ldsubscript𝐿𝑑L\\_{d} and specular intensity Lssubscript𝐿𝑠L\\_{s}, and the two terms can be computed as follows:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | L​(p,ω)=Ld​(p)+Ls​(p,ω),Ld​(p)=kd​(1−m)​∫ΩLi​(p,ωi)​(ωi⋅np)​dωi,Ls​(p,ω)=∫ΩD​F​G4​(ω⋅np)​(ωi⋅np)​Li​(p,ωi)​(ωi⋅np)​dωi,formulae-sequence𝐿𝑝𝜔subscript𝐿𝑑𝑝subscript𝐿𝑠𝑝𝜔formulae-sequencesubscript𝐿𝑑𝑝subscript𝑘𝑑1𝑚subscriptΩsubscript𝐿𝑖𝑝subscript𝜔𝑖⋅subscript𝜔𝑖subscript𝑛𝑝differential-dsubscript𝜔𝑖subscript𝐿𝑠𝑝𝜔subscriptΩ𝐷𝐹𝐺4⋅𝜔subscript𝑛𝑝⋅subscript𝜔𝑖subscript𝑛𝑝subscript𝐿𝑖𝑝subscript𝜔𝑖⋅subscript𝜔𝑖subscript𝑛𝑝differential-dsubscript𝜔𝑖\\\\begin{split}L(p,\\\\omega)=L\\_{d}(p)+L\\_{s}(p,\\\\omega),\\\\\\<br>L\\_{d}(p)=k\\_{d}(1-m)\\\\int\\_{\\\\Omega}L\\_{i}(p,\\\\omega\\_{i})(\\\\omega\\_{i}\\\\cdot n\\_{p})\\\\mathrm{d}\\\\omega\\_{i},\\\\\\<br>L\\_{s}(p,\\\\omega)=\\\\int\\_{\\\\Omega}\\\\frac{DFG}{4(\\\\omega\\\\cdot n\\_{p})(\\\\omega\\_{i}\\\\cdot n\\_{p})}L\\_{i}(p,\\\\omega\\_{i})(\\\\omega\\_{i}\\\\cdot n\\_{p})\\\\mathrm{d}\\\\omega\\_{i},\\\\end{split} |  | (8) |\n\nwhere F𝐹F, G𝐺G, and D𝐷D represent the Fresnel term, the shadowing-mask term, and the GGX distribution of normal, respectively. Following \\[ [28])\\], the hemisphere integration can be calculated using the split-sum method.\n\nBy aggregating the rendered pixel colors along the direction ω𝜔\\\\omega (i.e., camera pose), we have the rendered image x={L​(p,ω)}𝑥𝐿𝑝𝜔x=\\\\{L(p,\\\\omega)\\\\} that connects with the image encoder of the pre-trained stable diffusion model. We update the parameters γ𝛾\\\\gamma by computing the gradient of the SDS loss w.r.t. γ𝛾\\\\gamma:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | ▽γℒSDS​(ϕ,x)=𝔼​\\[w​(t)​(ϵ^ϕ​(ztx;y,t)−ϵ)​∂x∂γ​∂zx∂x\\].subscript▽𝛾subscriptℒSDSitalic-ϕ𝑥𝔼delimited-\\[\\]𝑤𝑡subscript^italic-ϵitalic-ϕsuperscriptsubscript𝑧𝑡𝑥𝑦𝑡italic-ϵ𝑥𝛾superscript𝑧𝑥𝑥\\\\bigtriangledown\\_{\\\\gamma}\\\\mathcal{L}\\_{\\\\text{SDS}}(\\\\phi,x)=\\\\mathbb{E}\\\\left\\[w(t)(\\\\hat{\\\\epsilon}\\_{\\\\phi}(z\\_{t}^{x};y,t)-\\\\epsilon)\\\\frac{\\\\partial x}{\\\\partial\\\\gamma}\\\\frac{{\\\\partial z^{x}}}{\\\\partial x}\\\\right\\]. |  | (9) |\n\nNotations in ( [9]In 4.3 Appearance modeling ‣ 4 The Proposed Method ‣ Fantasia3D: Disentangling Geometry and Appearance for High-quality Text-to-3D Content Creation\")) are similarly defined as those in ( [5]In 4.2 Geometry modeling ‣ 4 The Proposed Method ‣ Fantasia3D: Disentangling Geometry and Appearance for High-quality Text-to-3D Content Creation\")).\n\nTexturing. Given the trained ΓΓ\\\\Gamma, we proceed by sampling the generated appearance as 2D texture maps, in accordance with the UV map generated by the xatlas \\[ [47])\\]. Note that texture seams would emerge by direct incorporation of the sampled 2D textures into graphics engines (e.g., Blender \\[ [10])\\]). We instead employ the UV edge padding technique \\[ [9])\\], which involves expanding the boundaries of UV islands and filling empty regions. As illustrated in Fig. [5]Figure 5 ‣ 4.2 Geometry modeling ‣ 4 The Proposed Method ‣ Fantasia3D: Disentangling Geometry and Appearance for High-quality Text-to-3D Content Creation\"), this padding technique removes background pixels in the texture map and also removes the seams in the resulting renderings.\n\nImplementation Details. We implement the network ΨΨ\\\\Psi as a three-layer MLP with 32 hidden units, and implement ΓΓ\\\\Gamma as a two-layer MLP with 32 hidden units. Our method is optimized on 8 Nvidia RTX 3090 GPUs for about 15 minutes for learning ΨΨ\\\\Psi and about 16 minutes for learning ΓΓ\\\\Gamma, respectively, where we use AdamW optimizer with the respective learning rates of 1×10−31superscript1031\\\\times 10^{-3} and 1×10−21superscript1021\\\\times 10^{-2}. For each iteration, we uniformly sample 24 camera poses for the rendering of normal maps and colored images. More details of our implementation are available in the supplemental material. In geometry modeling, we set ω​(t)=σ2𝜔𝑡superscript𝜎2\\\\omega(t)=\\\\sigma^{2} during the early phase and then transition to w​(t)=σ2​1−σ2𝑤𝑡superscript𝜎21superscript𝜎2w(t)=\\\\sigma^{2}\\\\sqrt{1-\\\\sigma^{2}} as we progress to the later phase. In appearance modeling, we apply w​(t)=σ2​1−σ2𝑤𝑡superscript𝜎21superscript𝜎2w(t)=\\\\sigma^{2}\\\\sqrt{1-\\\\sigma^{2}} during the early phase, followed by a shift to 1/σ21superscript𝜎21/\\\\sigma^{2} as we enter the later phase. This approach mitigates the issue related to over-saturated color within the appearance modeling.",
            "citations": null
          },
          "5 Experiments": {
            "content": "In this section, we present comprehensive experiments to evaluate the efficacy of our proposed method for text-to-3D content creation. We first conduct ablation studies in Section [5.1]Ablation studies ‣ 5 Experiments ‣ Fantasia3D: Disentangling Geometry and Appearance for High-quality Text-to-3D Content Creation\") that verify the importance of our key design of disentangling geometry and appearance for text-to-3D generation. In Section [5.2]Zero-shot generation ‣ 5 Experiments ‣ Fantasia3D: Disentangling Geometry and Appearance for High-quality Text-to-3D Content Creation\"), we show the efficacy of our method for the generation of 3D models with PBR materials from arbitrary text prompts, where we also compare with two recent state-of-the-art methods (namely, Magic3D \\[ [18])\\] and DreamFusion \\[ [33])\\]). In Section [5.3]User-guided generation ‣ 5 Experiments ‣ Fantasia3D: Disentangling Geometry and Appearance for High-quality Text-to-3D Content Creation\"), we present our results under the setting of user-guided generation and compare them with Latent-NeRF \\[ [23])\\]. We finally demonstrate in Section [5.4]Scene editing and simulation ‣ 5 Experiments ‣ Fantasia3D: Disentangling Geometry and Appearance for High-quality Text-to-3D Content Creation\") that the 3D assets generated by our method are readily compatible with popular graphics engines such as Blender \\[ [10])\\], thus facilitating relighting, editing, and physical simulation of the resulting 3D models.\n\n![Refer to caption]Figure 6: Ablation studies of our method. The text prompt is ”a highly detailed stone bust of Theodoros Kolokotronis”. Please refer to Section [5.1]Ablation studies ‣ 5 Experiments ‣ Fantasia3D: Disentangling Geometry and Appearance for High-quality Text-to-3D Content Creation\") for specific settings of individual columns. Please refer to the video results in the supplemental materials for better comparisons.![Refer to caption]Figure 7: Comparison of zero-shot generation. Since DreamFusion and Magic3D do not have released codes, their results are obtained by downloading from their project pages. More results and comparisons are available in the supplemental materials.\n\n### 5.1 Ablation studies\n\nWe use an example text prompt of “a highly detailed stone bust of Theodoros Kolokotronis” for the ablation studies. Results of alternative settings are given in Fig. [6]Figure 6 ‣ 5 Experiments ‣ Fantasia3D: Disentangling Geometry and Appearance for High-quality Text-to-3D Content Creation\"). As the reference, the first two columns show the geometry and appearance results of our Fantasia3D rendered from the front and back views.\nTo verify the effectiveness of the disentangled design in Fantasia3D, we also conduct experiments as follows: in each iteration, we render shaded images of the mesh extracted from DMTet, and learn to update the parameters of a network responsible for both the geometry and material, using the gradient computed by SDS loss. Results in the second two columns show that such an entangled learning fails to generate plausible results.\nPrevious methods (e.g., DreamFusion \\[ [33])\\] and Magic3D \\[ [18])\\]) couple the geometry and appearance generation together, following NeRF \\[ [25])\\]. Our adoption of the disentangled representation is mainly motivated by the difference of problem nature for generating surface geometry and appearance. In fact, when dealing with finer recovery of surface geometry from multi-view images, methods (e.g., VolSDF \\[ [46])\\], nvdiffrec \\[ [28])\\], etc) that explicitly take the surface modeling into account triumph; our disentangled representation enjoys the benefit similar to these methods. The disentangled representation also enables us to include the BRDF material representation in the appearance modeling, achieving better photo-realistic\nrendering by the BRDF physical prior.\n\nTo investigate how shape encoding of the normal map plays role in Fantasia3D, we replace the normal map with an image that is shaded on the mesh extracted from DMTet using fixed material parameters; results in the third two columns become weird with twisted geometries. This is indeed one of the key factors that makes the success of Fantasia3D. Our initial hypothesis is that shape information contained in normal and mask images could be beneficial to geometry learning, and as such, we further observe that the value range of normal maps is normalized in (-1, 1), which aligns with the data range required for latent space diffusion; our empirical studies verify our hypothesis. Our hypothesis is further corroborated by observing that the LAION-5B \\[ [37])\\] dataset used for training Stable Diffusion contains normals\n(referring to [website]\nfor retrieval of normal data in LAION-5B \\[ [37])\\]), which allows Stable Diffusion to handle the optimization of normal maps effectively. To deal with rough and coarse geometry in the early stage of learning, we use the concatenated 64 ×\\\\times 64 ×\\\\times 4 (normal, mask) images for better convergence. As the learning progresses, it becomes essential to render the 512 ×\\\\times 512 ×\\\\times 3 high-resolution normal images for capturing finer geometry details, and we choose to use normal images only in the later stage. This strategy strikes an accuracy-efficiency balance throughout the geometry optimization process.\n\nFinally, we replace the full BRDF in Fantasia3D with a simple diffuse color rendering; the results in the last two columns become less realistic and are short of reflection effects when rendered from different views.\n\n### 5.2 Zero-shot generation\n\nIn this section, we evaluate our method for generating 3D assets from solely natural language descriptions (i.e., the setting of zero-shot generation), by comparing with two state-of-the-art methods, namely DreamFusion \\[ [33])\\] and Magic3D \\[ [18])\\].\nFig. [7]Figure 7 ‣ 5 Experiments ‣ Fantasia3D: Disentangling Geometry and Appearance for High-quality Text-to-3D Content Creation\") gives the comparative results given the same text prompts. Since DreamFusion and Magic3D do not have released codes, their results are obtained by downloading from their project pages. Comparing our method with Magic3D, we observe that our results are more photorealistic with competitive geometries. We consistently outperform DreamFusion in both appearance and geometry generation. Notably, our method also offers the convenience of easy geometry extraction and editing, as demonstrated in [5.4]Scene editing and simulation ‣ 5 Experiments ‣ Fantasia3D: Disentangling Geometry and Appearance for High-quality Text-to-3D Content Creation\"), which are less obvious from DreamFusion or Magic3D. More of our results are given in the top half of Fig. [2]Figure 2 ‣ 1 Introduction ‣ Fantasia3D: Disentangling Geometry and Appearance for High-quality Text-to-3D Content Creation\") and Fig. [8]Figure 8 ‣ 5.2 Zero-shot generation ‣ 5 Experiments ‣ Fantasia3D: Disentangling Geometry and Appearance for High-quality Text-to-3D Content Creation\"). Furthermore, we compare our appearance modeling stage with several mesh stylization methods, namely Text2mesh \\[ [24])\\], CLIP-Mesh \\[ [14])\\] and Latent-NeRF \\[ [23])\\]. Fig. [9]Figure 9 ‣ 5.2 Zero-shot generation ‣ 5 Experiments ‣ Fantasia3D: Disentangling Geometry and Appearance for High-quality Text-to-3D Content Creation\") shows that our method excels in generating more\nrealistic appearances, outperforming the other competitors. We present additional results and comparisons in the supplemental materials.\n\n![Refer to caption]Figure 8: Geometries beyond genus-zero ones.DMTet can deform to any topologies, which enables Fantasia3D to generate complex geometries, including those beyond genus-zero ones.![Refer to caption]Figure 9: Comparison of Texturing. We compare the appearance stage of Fantasia3D with three text-driven texturing methods, using the geometry generated by the geometry stage of\nFantasia3D. ![Refer to caption]Figure 10: Comparison of user-guided generation. The top row shows the input meshes provided by users, the bottom row gives the input text prompts, and the middle two rows show the results from the comparative methods.\n\n### 5.3 User-guided generation\n\nIn addition to zero-shot generation, our method is flexible to accept a customized 3D model as the initialization, alternative to a 3D ellipsoid, thereby facilitating user-guided asset generation. As shown in the lower half of Fig. [2]Figure 2 ‣ 1 Introduction ‣ Fantasia3D: Disentangling Geometry and Appearance for High-quality Text-to-3D Content Creation\"), our method is able to generate rich details in both the geometry and appearance when provided with low-quality 3D models for initialization. The three meshes used in the experiments are from Text2Mesh \\[ [24])\\], Latent-NeRF \\[ [23])\\], and the creation of Stable DreamFusion \\[ [41])\\], respectively. We also compare with the state-of-the-art approach of Latent-NeRF \\[ [23])\\] under this user-guided generation setting; results are given in Fig. [10]Figure 10 ‣ 5.2 Zero-shot generation ‣ 5 Experiments ‣ Fantasia3D: Disentangling Geometry and Appearance for High-quality Text-to-3D Content Creation\"). Our method outperforms Latent-NeRF \\[ [23])\\] in both the geometry and texture generation when given the same input meshes and text prompts.\n\n![Refer to caption]Figure 11: Scene Editing. Three generated objects, namely crown, tiger, and ice cream, are imported into the Cornell Box scene. The scene is then rendered using the Cycles path tracer in Blender, producing natural shadows and reflectance effects.![Refer to caption]Figure 12: Relighting. Our generated Iron Man model is relit using different lighting setups in Blender, producing diverse reflectance effects on the armor.\n\n### 5.4 Scene editing and simulation\n\nGiven the disentangled design, our method produces high-quality generation of both the surface and appearance, and is compatible with popular graphics engines for scene editing and physical simulation. In Figure [1]Figure 1 ‣ Fantasia3D: Disentangling Geometry and Appearance for High-quality Text-to-3D Content Creation\"), we import into Blender a stone statue generated by our method from the text prompt of ”a highly detailed stone bust of Theodoros Kolokotronis”, where soft body and cloth simulations are performed along with material editing. Given the high quality of the generated surface geometry (e.g., no holes on the surface), the simulations are of high-level physical accuracy, as shown in the accompanying supplemental video. Moreover, we showcase the ability to modify the material of the statue by replacing it with another wood material downloaded from the Internet \\[ [32])\\], which poses a challenge for comparative methods such as DreamFusion \\[ [33])\\]. Additionally, in Fig. [11]Figure 11 ‣ 5.3 User-guided generation ‣ 5 Experiments ‣ Fantasia3D: Disentangling Geometry and Appearance for High-quality Text-to-3D Content Creation\"), by importing generated ice cream, tiger, and crown into the Cornell Box, we demonstrate the plausible physical interaction between our generated results and the scene, with natural shadows being cast. Finally, Fig. [12]Figure 12 ‣ 5.3 User-guided generation ‣ 5 Experiments ‣ Fantasia3D: Disentangling Geometry and Appearance for High-quality Text-to-3D Content Creation\") illustrates the replacement of the HDR environment map to produce diverse lighting and corresponding reflectance effects on the generated iron man.",
            "citations": null
          },
          "6 Limitations": {
            "content": "While Fantasia3D demonstrates promising advancements in the realm of generating photorealistic 3D assets from text prompts, several limitations remain.\nFor instance, while our method successfully produces loose visual effects, it remains a significant challenge to generate corresponding loose geometries, such as hair, fur, and grass, solely based on text prompts. Additionally, our method primarily emphasizes object generation, thereby lacking the capacity to generate complete scenes with background from text prompts. Consequently, our future research endeavors will be dedicated to addressing these limitations by focusing on the generation of complete scenes and intricate loose geometries.",
            "citations": null
          },
          "7 Conclusion": {
            "content": "In this paper, we present Fantasia3D, a new method for automatic text-to-3D generation. Fantasia3D uses disentangled modeling and learning of geometry and appearance, and is able to generate both the fine surface and rich material/texture. Fantasia3D is based on the hybrid scene representation of DMTet. For geometry learning, we propose to encode a rendered normal map, and use shape encoding of the normal as the input of the pre-trained, stable diffusion model. For appearance modeling, we introduce the spatially varying BRDF into the text-to-3D task, thus enabling material learning that supports photorealistic rendering of the learned surface. Expect for text prompts, our method can be triggered with a customized 3D shape as well; this is flexible for users to better control what content is to be generated. Our method is also convenient to support relighting, editing, and physical simulation of the generated 3D assets. Our method is based on pre-trained image diffusion models (i.e., the stable diffusion). In future research, we are interested in learning 3D diffusion directly from the large language models.\n\n\\\\justify\n\nAcknowledgements. This work is supported in part by Program for Guangdong Introducing Innovative and Entrepreneurial Teams (No.: 2017ZT07X183) and Guangdong R&D key project of China (No.: 2019B010155001).",
            "citations": null
          }
        },
        "abstract": "Automatic 3D content creation has achieved rapid progress recently due to the\navailability of pre-trained, large language models and image diffusion models,\nforming the emerging topic of text-to-3D content creation. Existing text-to-3D\nmethods commonly use implicit scene representations, which couple the geometry\nand appearance via volume rendering and are suboptimal in terms of recovering\nfiner geometries and achieving photorealistic rendering; consequently, they are\nless effective for generating high-quality 3D assets. In this work, we propose\na new method of Fantasia3D for high-quality text-to-3D content creation. Key to\nFantasia3D is the disentangled modeling and learning of geometry and\nappearance. For geometry learning, we rely on a hybrid scene representation,\nand propose to encode surface normal extracted from the representation as the\ninput of the image diffusion model. For appearance modeling, we introduce the\nspatially varying bidirectional reflectance distribution function (BRDF) into\nthe text-to-3D task, and learn the surface material for photorealistic\nrendering of the generated surface. Our disentangled framework is more\ncompatible with popular graphics engines, supporting relighting, editing, and\nphysical simulation of the generated 3D assets. We conduct thorough experiments\nthat show the advantages of our method over existing ones under different\ntext-to-3D task settings. Project page and source codes:\nhttps://fantasia3d.github.io/."
      },
      "bib.bib11": {
        "id": "bib.bib11",
        "citation": "[11]",
        "authors": "",
        "year": "",
        "title": "Learning implicit fields for generative shape modeling.",
        "venue": "",
        "pages": "",
        "url": "",
        "arxiv_id": "1812.02822",
        "doi": null,
        "sections": {
          "1 Introduction": {
            "content": "Unlike images and video, 3D shapes are not confined to one standard representation. Up to date, deep neural networks for 3D shape analysis and synthesis have been developed for voxel grids \\[ [19]), [48])\\], multi-view images \\[ [42])\\], point clouds \\[ [1]), [35])\\], and integrated surface patches \\[ [17])\\]. Specific to generative modeling of 3D shapes, despite the many progresses made, the shapes produced by state-of-the-art methods still fall far short in terms of visual quality. This is reflected by a combination of issues including low-resolution outputs, overly smoothed or discontinuous surfaces, as well as a variety of topological noise and irregularities.\n\n![Refer to caption]Figure 1: 3D shapes generated by IM-GAN, our implicit field generative adversarial network, which was trained on 643superscript64364^{3} or 1283superscript1283128^{3} voxelized shapes. The output shapes are sampled at 5123superscript5123512^{3} resolution and rendered after Marching Cubes.\n\nIn this paper, we explore the use of implicit fields for learning deep models of shapes and introduce an implicit field decoder for shape generation, aimed at improving the visual quality of the generated models, as shown in Figure [1]Figure 1 ‣ 1 Introduction ‣ Learning Implicit Fields for Generative Shape Modeling\"). An implicit field assigns a value to each point (x,y,z)𝑥𝑦𝑧(x,y,z). A shape is represented by all points assigned to a specific value and is typically rendered via iso-surface extraction such as Marching Cubes. Our implicit field decoder, or simply implicit decoder, is trained to perform this assignment task, by means of a binary classifier, and it has a very simple architecture; see Figure [2]Figure 2 ‣ 1 Introduction ‣ Learning Implicit Fields for Generative Shape Modeling\"). Specifically, it takes a point coordinate (x,y,z)𝑥𝑦𝑧(x,y,z), along with a feature vector encoding a shape, and outputs a value which indicates whether the point is outside the shape or not. In a typical application setup, our decoder, which is coined IM-NET, would follow an encoder which outputs the shape feature vectors and then return an implicit field to define an output shape.\n\nSeveral novel features of IM-NET impact the visual quality of the generated shapes.\nFirst, the decoder output can be sampled at any resolution and is not limited by the\nresolution of the training shapes; see Figure [1]Figure 1 ‣ 1 Introduction ‣ Learning Implicit Fields for Generative Shape Modeling\").\nMore importantly, we concatenate point coordinates with shape features, feeding both as\ninput to our implicit decoder, which learns the inside/outside status of any point\nrelative to a shape. In contrast, a classical convolution/deconvolution-based neural network (CNN)\noperating on voxelized shapes is typically trained to predict voxels relative to the extent of the\nbounding volume of a shape. Such a network learns voxel distributions over the volume, while\nIM-NET learns shape boundaries; this is well exemplified in Figure [3]Figure 3 ‣ 1 Introduction ‣ Learning Implicit Fields for Generative Shape Modeling\") (top). Experiments show that\nshapes generated by our network possess higher surface quality than results from previous methods, as shown in Figure [1]Figure 1 ‣ 1 Introduction ‣ Learning Implicit Fields for Generative Shape Modeling\") and results in Section [4]Results and evaluation ‣ Learning Implicit Fields for Generative Shape Modeling\").\n\n![Refer to caption]Figure 2: Network structure of our implicit decoder, IM-NET. The network takes as input a feature vector extracted by a shape encoder, as well as a 3D or 2D point coordinate, and it returns a value indicating the inside/outside status of the point relative to the shape. The encoder can be a CNN or use PointNET \\[ [35])\\], depending on the application.\n\nIn addition, shape evolution is a direct result of changing the assignments of point coordinates to their inside/outside status and such assignments are precisely what our network, IM-NET, learns. In contrast, convolution kernels compute voxels as weighted averages, where the kernel windows are not “shape-aware”. Thus a CNN-based decoder typically evolves shape geometries by means of intensity variations; see Figure [3]Figure 3 ‣ 1 Introduction ‣ Learning Implicit Fields for Generative Shape Modeling\") (bottom). As a result, our network produces cleaner interpolation results than previous works, even when there are topological changes; see Figure [5]Figure 5 ‣ 4.3 3D shape generation and interpolation ‣ 4 Results and evaluation ‣ Learning Implicit Fields for Generative Shape Modeling\").\n\nWe embed IM-NET into several contemporary analysis and synthesis frameworks,\nincluding autoencoders (AEs), variational autoencoders (VAEs), and generative adversarial networks (GANs),\nby replacing the decoders employed by current approaches with ours, leading to IM-AEs and IM-GANs. This allows assessing the capabilities of our novel decoder for tasks such as shape representation learning, 2D or 3D shape generation, shape interpolation, as well as single-view 3D shape reconstruction. Extensive experiments and comparative studies, both quantitative and qualitative, demonstrate the superiority of our network over previous works, particularly in terms of visual quality.\n\n![Refer to caption]Figure 3: CNN-based decoder vs. our implicit decoder. We trained two autoencoders with CNN decoder (AECNNsubscriptAECNN\\\\text{AE}\\_{\\\\text{CNN}}) and our implicit decoder (AEIMsubscriptAEIM\\\\text{AE}\\_{\\\\text{IM}}), respectively, on a synthesized dataset of letter A’s on white background. The two models have the same CNN encoder. (a) and (b) show the sampled images during AE training. (c) and (d) show interpolation sequences produced by the two trained AEs. See more comparisons in the supplementary material.",
            "citations": null
          },
          "2 Related work": {
            "content": "There have been a variety of 3D shape representations for deep learning of shapes, such as voxel grids \\[ [10]), [15]), [30]), [48]), [49])\\], octrees \\[ [19]), [38]), [43]), [46]), [47])\\], multi-view images \\[ [4]), [31]), [42])\\], point clouds \\[ [1]), [13]), [14]), [35]), [36]), [50]), [51])\\], geometry images \\[ [40]), [41])\\], deformable mesh/patches \\[ [17]), [41]), [45]), [50])\\], and part-based structural graphs \\[ [29]), [52])\\]. To the best of our knowledge, our work is the first to introduce a deep network for learning implicit fields for generative shape modeling 111Also see \\[ [23]), [33])\\] for concurrent works that propose similar ideas..\n\nWith remarkable progress made on generative modeling of images using VAEs \\[ [26])\\], GANs \\[ [3]), [16]), [37])\\], autoregressive networks \\[ [44])\\], and flow-based models \\[ [25])\\], there have been considerably fewer works on generative models of 3D shapes. Girdhar et al. \\[ [15])\\] learned an embedding space of 3D voxel shapes for 3D shape inference from images and shape generation. Wu et al. \\[ [48])\\] extended GANs from images to voxels and their 3DGAN was trained to generate 3D voxel shapes from latent vectors. Achlioptas et al. \\[ [1])\\] proposed a latent-GAN workflow that first trains an autoencoder with a compact bottleneck layer to learn a latent representation of point clouds, then trains a plain GAN on the latent code. Common issues with these methods include limited model resolution, uneven and noisy shape surfaces, and inability to produce smooth shape interpolation.\n\nRecently, Li et al. \\[ [29])\\] introduced a part-based autoencoder for 3D shape structures, i.e., a hierarchical organization of part bounding boxes. The autoencoder is tuned with an adversarial loss to become generative. Then a separate network is trained to fill in part geometries within the confines of the part bounding boxes. Their method can produce cleaner 3D shapes and interpolation results, mainly owing to the decoupling of structure and geometry generation. However, their network has to be trained by segmented shapes with structural hierarchies. In contrast, our implicit encoder is trained on unstructured voxel shapes.\n\nThe output of our decoder IM-NET can be sampled at resolutions higher than that of the training shapes, however, it is not designed for the purpose of\n(voxel) super-resolution. There have been works on single image super-resolution using deep networks, _e.g_., \\[ [12]), [27])\\],\nwhich are trained with low- and high-resolution image pairs. Progressive training \\[ [24])\\] is another technique to improve image quality, and we adopt it in our work\nto reduce training times.\n\nMost learning-based methods for single-view 3D reconstruction encode input images with deep convolutional networks, then use an appropriate decoder to reconstruct 3D shapes depending on the shape representations. The most commonly used representations are voxels \\[ [10]), [15]), [49])\\] and point clouds \\[ [13]), [14])\\]. Voxels are natural extensions of image pixels, which allow migrating state-of-the-art techniques from image processing to shape processing. However, voxel representations are usually constrained by GPU memory size, resulting in low-resolution results. Octree representations attempt to fix the memory issues by predicting surfaces in a coarse-to-fine manner \\[ [19]), [47])\\].\n\nThe recent work by Huang et al. \\[ [22])\\] also trains a network to perform binary classification, like IM-NET. However, the key distinction is that our network assigns inside/outside based on spatial point coordinates. Hence, it learns shape boundaries and effectively, an implicit function that is Lipschitz continuous over point coordinates, i.e., it maps close-by points to similar output values. Moreover, IM-NET can input an arbitrary 3D point and learn a continuous implicit field without discretization. In contrast, their network operates on convolutional features computed over discretized images and learns the inside/outside assignment based on multi-scale image features\nat a point x𝑥x.\n\nPoint clouds can be lightweight on the decoder side by producing few thousand points. However, these points do not provide any surface or topological information and pose a reconstruction challenge. In Deep Marching Cubes, Liao et al. \\[ [30])\\] proposed a differentiable formulation of marching cubes to train an end-to-end 3D CNN model for mesh reconstruction from point clouds. However, the resulting mesh still shares common issues with other CNN-based networks, _e.g_., low resolution (323superscript32332^{3}) and topological noise.\n\nSome other works \\[ [17]), [41])\\] deform a surface template ( _e.g_., square patches or a sphere) onto a target shape. But many shapes cannot be well-represented by a single patch, while outputs from multi-patch integrations often contain visual artifacts due to gaps, foldovers, and overlaps.\nIn Pixel2Mesh, Wang et al. \\[ [45])\\] used a graph-based CNN \\[ [39])\\] to progressively deform an ellipsoid template to fit an image. The end-to-end network directly generates meshes but the results tend to be overly smoothed, capturing only low-frequency features while restricted to sphere topology.",
            "citations": null
          },
          "3 Implicit decoder and shape generation": {
            "content": "An implicit field is defined by a continuous function over 2D/3D space. Then a mesh surface can be reconstructed by finding the zero-isosurface of the field with methods such as Marching Cubes \\[ [32])\\]. In our work, we consider using neural networks to describe a shape in such an implicit way. For a closed shape, we define the inside/outside field ℱℱ\\\\mathcal{F} of the shape by taking the sign of its signed distance field:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | ℱ​(p)={0if point p is outside the shape,1otherwise.ℱ𝑝cases0if point p is outside the shape,1otherwise.\\\\displaystyle\\\\mathcal{F}(p)=\\\\left\\\\{\\\\begin{array}\\[\\]{ll}0&\\\\textrm{if point $p$ is outside the shape,}\\\\\\<br>1&\\\\textrm{otherwise.}\\\\end{array}\\\\right. |  | (3) |\n\nAssume the in-out field is restricted in a unit 3D space, we attempt to find a parameterization fθ​(p)subscript𝑓𝜃𝑝f\\_{\\\\theta}(p) with parameters θ𝜃\\\\theta that maps a point p∈\\[0,1\\]3𝑝superscript013p\\\\in\\[0,1\\]^{3} to ℱ​(p)ℱ𝑝\\\\mathcal{F}(p). This is essentially a binary classification problem, which has been studied very well. Multi-layer perceptrons (MLPs) with rectified linear unit (ReLU) nonlinearities are ideal candidates for such tasks. With sufficient hidden units, MLP family is able to approximate the field ℱℱ\\\\mathcal{F} within any precision. This is a direct consequence of the universal approximation theorem \\[ [21])\\]. Notice that using MLPs also gives us a representation which is continuous across space, so that the mesh can be recovered by taking the k𝑘k-isosurface of the approximated field, where k𝑘k is an appropriate threshold.\n\n### 3.1 Data preparation\n\nThe training of such implicit model needs point-value pairs. It is natural to first voxelize or rasterize the shape for the sake of convenience and uniform sampling. For 3D shapes, we use the same technique as in Hierarchical Surface Prediction (HSP) \\[ [19])\\] to get the voxel models in different resolutions (163superscript16316^{3}, 323superscript32332^{3}, 643superscript64364^{3}, 1283superscript1283128^{3}). We sample points on each resolution in order to train the model progressively.\n\nA naive sampling would take the center of each voxel and produce n3superscript𝑛3n^{3} points. A more efficient approach when dealing with shapes is to sample more points near shape surfaces and neglect most points far away, leading to roughly O​(n2)𝑂superscript𝑛2O(n^{2}) points. To compensate for the density change, we assign a weight wpsubscript𝑤𝑝w\\_{p} to each sampled point p𝑝p, representing the inverse of the sampling density near p𝑝p. The implementation of such a sampling method is flexible and varies according to resolution and shape category; more details can be found in the supplementary material.\nMost 2D shapes are already rasterized into images. For simplicity, we apply the naive sampling approach for images with an appropriate threshold to determine whether a pixel belongs to the shape.\n\n### 3.2 Network structure of IM-NET\n\nOur model is illustrated in Figure [2]Figure 2 ‣ 1 Introduction ‣ Learning Implicit Fields for Generative Shape Modeling\"). The skip connections (copy and concatenate) in the model can make the learning progress faster in the experiments. They can be removed when the feature vector is long, so as to prevent the model from becoming too large. The loss function is a weighted mean squared error between ground truth labels and predicted labels for each point. Let S𝑆S be a set of points sampled from the target shape, we have:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | ℒ​(θ)=∑p∈S\\|fθ​(p)−ℱ​(p)\\|2⋅wp∑p∈Swpℒ𝜃subscript𝑝𝑆⋅superscriptsubscript𝑓𝜃𝑝ℱ𝑝2subscript𝑤𝑝subscript𝑝𝑆subscript𝑤𝑝\\\\mathcal{L}(\\\\theta)=\\\\frac{\\\\sum\\_{p\\\\in S}{\\|f\\_{\\\\theta}(p)-\\\\mathcal{F}(p)\\|^{2}\\\\cdot w\\_{p}}}{\\\\sum\\_{p\\\\in S}{w\\_{p}}} |  | (4) |\n\n### 3.3 Shape generation and other applications\n\nOur implicit field decoder, IM-NET, can be embedded into different shape analysis and synthesis frameworks to support various applications. In this paper, we demonstrate shape autoencoding, 2D and 3D shape generation, and single-view 3D reconstruction. Due to page limit, the models are briefly introduced here. Detailed structures and hyperparameters can be found in the supplementary material.\n\nFor auto-encoding 3D shapes, we used a 3D CNN as encoder to extract 128128128-dimensional features from 643superscript64364^{3} voxel models. We adopt progressive training techniques, to first train our model on 163superscript16316^{3} resolution data, then increase the resolution gradually. Notice that the structure of the model does not change when switching between training data at different resolutions, thus higher-resolution models can be trained with pre-trained weights on low-resolution data. In the experiments, progressive training can stabilize training process and significantly reduce training time.\n\nFor 3D shape generation, we employed latent-GANs \\[ [1]), [2])\\] on feature vectors learned by a 3D autoencoder. We did not apply traditional GANs trained on voxel grids since the training set is considerably smaller compared to the size of the output. Therefore, the pre-trained AE would serve as a means for dimensionality reduction, and the latent-GAN was trained on high-level features of the original shapes. We used two hidden fully-connected layers for both the generator and the discriminator, and the Wasserstein GAN loss with gradient penalty \\[ [3]), [18])\\]. In generative models for 2D shapes, we used the same structure as in the 3D case, except the encoder was 2D CNN and the decoder took a 2D point as input. We did not apply progressive training for 2D shapes since it is unnecessary when the images are small.\n\nFor single-view 3D reconstruction (SVR), we used the ResNET \\[ [20])\\] encoder to obtain 128128128-D features from 1282superscript1282128^{2} images. We followed the idea from AtlasNET \\[ [17])\\] to first train an autoencoder, then fix the parameters of the implicit decoder when training SVR. In our experiments, we adopted a more radical approach by only training the ResNET encoder to minimize the mean squared loss between the predicted feature vectors and the ground truth. This performed better than training the image-to-shape translator directly, since one shape can have many different views, leading to ambiguity. Pre-trained decoders provide strong priors that can not only reduce such ambiguity, but also shorten training time, since the decoder was trained on unambiguous data in the autoencoder phase and encoder training was independently from the decoder in SVR phase.\n\nWe reconstructed the 3D meshes by Marching Cubes, and 2D images by sampling a grid of points then optionally applying thresholding to obtain binarized shapes.",
            "citations": null
          },
          "4 Results and evaluation": {
            "content": "In this section, we show qualitative and quantitative results on various tasks using our implicit decoder, IM-NET, and compare them with state-of-the-art approaches. We used the dataset provided by \\[ [19])\\], which contains 2563superscript2563256^{3}-voxelized and flood-filled 3D models from ShapeNet Core dataset (v1) \\[ [8])\\], and the corresponding rendered views. To compare with other methods that output point clouds, we first used Marching Cubes to obtain meshes from the 2563superscript2563256^{3}-voxelized models, then used Poisson-disk Sampling \\[ [11])\\] to obtain 10000 points. This gave us point clouds with only points on the surfaces of the meshes. We evaluated our method, and others, on five representative categories: plane, car, chair, rifle, and table.\nThese categories contain 4,045, 7,497, 6,778, 2,373, and 8,509 3D shapes, respectively.\n\n### 4.1 Quality metrics\n\nIn our experiments, both qualitative (via visual examination) and quantitative evaluations are provided.\nSpecific to shapes, most evaluation metrics for encoding and reconstruction are based on point-wise\ndistances, _e.g_., chamfer distance (CD), or global alignment,\n_e.g_., mean squared error (MSE) and intersection over union (IoU) on voxels. However, these may not be the best\nvisual similarity or quality metrics. For example, slightly adjusting the angles between the legs of\na chair and its seat may be barely perceptible, compared to removing one shape part, yet the latter could lead to a lower CD or IoU.\nPast works, _e.g_., \\[ [34])\\], have shown that low-frequency displacements ( _e.g_., bending a leg) in\nshapes are less noticeable than high-frequency errors over local surface characteristics such as\nnormals and curvatures. Metrics such as MSE, CD, and IoU do not account for visual quality of\nthe object surfaces.\n\nA less frequently used visual similarity metric in the computer vision community, the light field descriptor (LFD) \\[ [9])\\],\nhas been widely adopted in computer graphics. Inspired by human vision system, LFD\nconsiders a set of rendered views of a 3D shape from various camera angles. Each projected image is then\nencoded using Zernike moments and Fourier descriptors for similarity comparisons.\n\n### 4.2 Auto-encoding 3D shapes\n\n|  | Plane | Car | Chair | Rifle | Table |\n| --- | --- | --- | --- | --- | --- |\n| CNN64-MSE | 1.47 | 4.37 | 7.76 | 1.62 | 5.80 |\n| IM64-MSE | 2.14 | 4.99 | 11.43 | 1.91 | 10.67 |\n| CNN64-IoU | 86.07 | 90.73 | 74.22 | 78.37 | 84.67 |\n| IM64-IoU | 78.77 | 89.26 | 65.65 | 72.88 | 71.44 |\n| CNN64-CD | 3.51 | 5.31 | 7.34 | 3.48 | 7.45 |\n| IM64-CD | 4.22 | 5.28 | 8.96 | 3.78 | 12.05 |\n| IM256-CD | 4.23 | 5.44 | 9.05 | 3.77 | 11.54 |\n| CNN64-LFD | 3,375 | 1,323 | 2,555 | 3,515 | 1,824 |\n| IM64-LFD | 3,371 | 1,190 | 2,515 | 3,714 | 2,370 |\n| IM256-LFD | 3,236 | 1,147 | 2,453 | 3,602 | 2,201 |\n\nTable 1: 3D reconstruction errors. CNN and IM represent CNN-AE and IM-AE, respectively, with 646464 and 256256256 indicating sampling resolutions. The mean is taken over the first 100 shapes in each tested category. MSE is multiplied by 103superscript10310^{3}, IoU by 102superscript10210^{2}, and CD by 104superscript10410^{4}. LFD is rounded to integers. Better-performing numbers are shown in boldface.![Refer to caption]Figure 4: Visual results for 3D reconstruction. Each column presents one example from one category. IM-AE64 is sampled on 643superscript64364^{3} resolution and IM-AE256 on 2563superscript2563256^{3}. All results are rendered using the same Marching Cubes setup.\n\nWe first compare IM-NET with CNN decoders. For each category, we sorted the shapes by name and used the first 80% as training set and the rest for testing. We trained one model with our implicit decoder (IM-AE) and another with 3D CNN decoder (CNN-AE) on each category. The 3D CNN decoder is symmetric to the 3D CNN encoder (details can be found in the supplementary material). Both models had the same encoder structure and were trained on 643superscript64364^{3} resolution for the same number of epochs between 200 and 400, depending on the size of the dataset.\n\nTable [1]Table 1 ‣ 4.2 Auto-encoding 3D shapes ‣ 4 Results and evaluation ‣ Learning Implicit Fields for Generative Shape Modeling\") evaluates reconstruction results using several common evaluation metrics: MSE, IoU, symmetric Chamfer distance (CD), and LFD. MSE and IoU were computed against the ground truth 643superscript64364^{3} voxel models. For CD and LFD, we obtained meshes from the output voxel models by Marching Cubes with threshold 0.5. We sampled 2,048 points from the vertices for each output mesh and compare against ground truth point clouds to compute CD. Note that CNN-AE has fixed output size (643superscript64364^{3}), yet our implicit model can be up-sampled to arbitrarily high resolution by adjusting the sampling grid size. In Table [1]Table 1 ‣ 4.2 Auto-encoding 3D shapes ‣ 4 Results and evaluation ‣ Learning Implicit Fields for Generative Shape Modeling\"), IM256 is the same IM-AE model but sampled at 2563superscript2563256^{3}.\n\nAlthough CNN-AE beats IM-AE in nearly all five categories in terms of MSE, IOU, and CD, visual examination clearly reveals that IM-AE produces better results, as shown in Figure [4]Figure 4 ‣ 4.2 Auto-encoding 3D shapes ‣ 4 Results and evaluation ‣ Learning Implicit Fields for Generative Shape Modeling\"); more such results are available in the supplementary material. This validates that LFD is a better visual similarity metric for 3D shapes. On one hand, the movement of some parts, for example, table boards, may cause significant MSE, IOU and CD changes, but bring little visual changes; on the other hand, legs are usually thin, so that missing one leg may cause minor MSE, IOU and CD changes, but can bring significant visual changes. As remarked above, MSE, IOU and CD do not capture well surface quality: a smooth but not exactly aligned surface might have poorer evaluation results than an aligned jagged surface. The situation is better when using LFD. However, since LFD only renders the silhouette of the shape without lighting, it can only capture surface condition on the edge of the silhouette. We expect better evaluation metrics to be proposed in the future, and for the following experiments, we use LFD as our primary evaluation metric.\n\nNote that in the table example in Figure [4]Figure 4 ‣ 4.2 Auto-encoding 3D shapes ‣ 4 Results and evaluation ‣ Learning Implicit Fields for Generative Shape Modeling\"), a 643superscript64364^{3} resolution represents an under-sampling, while going up to 2563superscript2563256^{3} reveals more details. This indicates that our generative model is able to generate a table board thinner than the resolution of the training data, which shows that the model learned the implicit field from the whole shape in the space rather than merely learning voxel distributions.\n\n### 4.3 3D shape generation and interpolation\n\n![Refer to caption]Figure 5: 3D shape interpolation results. 3DGAN, CNN-GAN, and IM-GAN are sampled at 643superscript64364^{3} resolution to show the smoothness of the surface is not just a matter of sampling resolution. Notice that the morphing sequence of IM-GAN not only consists of smooth part movements (legs, board), but also handles topology changes.\n\n|  |  | Plane | Car | Chair | Rifle | Table | Average w/o planes | Average |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| COV-LFD (%) | 3DGAN \\[ [48])\\] |  | 12.13 | 25.07 | 62.32 | 18.80 | 29.58 |  |\n| PC-GAN \\[ [1])\\] | 73.55 | 61.40 | 70.06 | 61.47 | 77.50 | 67.61 | 68.80 |\n|  | CNN-GAN | 69.22 | 73.00 | 77.73 | 61.26 | 83.73 | 73.93 | 72.99 |\n|  | IM-GAN | 70.33 | 69.33 | 75.44 | 65.26 | 86.43 | 74.12 | 73.36 |\n| MMD-LFD | 3DGAN \\[ [48])\\] |  | 1,993 | 4,365 | 4,476 | 5,208 | 4,010 |  |\n| PC-GAN \\[ [1])\\] | 3,737 | 1,360 | 3,143 | 3,891 | 2,822 | 2,804 | 2,991 |\n|  | CNN-GAN | 3,745 | 1,288 | 3,012 | 3,819 | 2,594 | 2,678 | 2,892 |\n|  | IM-GAN | 3,689 | 1,287 | 2,893 | 3,760 | 2,527 | 2,617 | 2,831 |\n\nTable 2: Quantitative evaluation of 3D shape generation. LFD is rounded to integers. See texts for explanation of the metrics.![Refer to caption]Figure 6: 3D shape generation results. One generated shape from each category is shown for each model; more results are available in the supplementary material. Since the trained models of 3DGAN did not include plane category, we fill the blank with another car. The ball-pivoting method \\[ [7])\\] was used for mesh reconstruction (c) from PC-GAN results (b).\n\nNext, we assess and evaluate improvements made by our implicit decoder for generative modeling of 3D shapes. We trained latent-GANs on both CNN-AE and IM-AE to obtain CNN-GAN and IM-GAN. We also compared our results with two state-of-the-art methods, 3DGAN \\[ [48])\\] and the generative model for point clouds in \\[ [1])\\] (PC-GAN). For 3DGAN, we used the trained models made available online by the authors. PC-GAN was trained using latent WGAN \\[ [1])\\]. The autoencoder of PC-GAN was trained on our aforementioned point cloud data for 400 epochs for each category. PC-GAN, CNN-GAN, and IM-GAN were trained on the training split of the dataset for 10,000 epochs. 3DGAN was not trained using train/test split \\[ [48])\\].\n\nTo compare the generative schemes, we adopted the evaluation metrics from \\[ [1])\\], but replaced CD or EMD by LFD. Suppose that we have a testing set G𝐺G and a sample set A𝐴A, for each shape in A𝐴A, we find its closest neighbor in G𝐺G using LFD, say g𝑔g, and mark g𝑔g as “matched”. In the end, we calculate the percentage of G𝐺G marked as “matched” to obtain the coverage score (COV-LFD) that roughly represents the diversity of the generated shapes. However, a random set may have a high coverage, since matched shapes need not be close. Therefore, we match every shape in G𝐺G to the one in A𝐴A with the minimum distance and compute the mean distances in the matching as Minimum Matching Distance (MMD-LFD). Ideally, a good generative model would have higher COV-LFD and lower MMD-LFD values.\n\nWe first sampled shapes using the subject generative model to obtain A𝐴A, where the number of sampled shapes is five times the number of shapes in the testing split (G𝐺G) of that category. For PC-GAN, we employed the ball-pivoting method \\[ [7])\\] to reconstruct the shape surface, while for all the other generative models, we used Marching Cubes. IM-GAN was sampled at 643superscript64364^{3} in quantitative evaluation.\n\nQuantitative and qualitative evaluations are shown in Table [2]Table 2 ‣ 4.3 3D shape generation and interpolation ‣ 4 Results and evaluation ‣ Learning Implicit Fields for Generative Shape Modeling\") and Figure [6]Figure 6 ‣ 4.3 3D shape generation and interpolation ‣ 4 Results and evaluation ‣ Learning Implicit Fields for Generative Shape Modeling\"), respectively. Overall, IM-GAN performs better on both COV-LFD and MMD-LFD. More importantly, IM-GAN generates shapes with better visual quality compared to other methods, in particular, with smoother and more coherent surfaces. 3DGAN appears to suffer from mode collapse on several categories, leading to lower coverage. Point clouds generated by PC-GAN are recognizable but lack detailed features; high-quality reconstruction from only 2048 generated points would be challenging. In addition, as shown in Figure [5]Figure 5 ‣ 4.3 3D shape generation and interpolation ‣ 4 Results and evaluation ‣ Learning Implicit Fields for Generative Shape Modeling\"), IM-GAN exhibits superior capability in 3D shape interpolation. As usual for the latent generative models, the interpolation is carried out by a linear interpolation between two latent codes; in-between 3D shapes are then generated from the intermediate codes.\n\nWe trained the IM-GAN further with 1283superscript1283128^{3} resolution data on category plane, car and rifle. Figure [1]Figure 1 ‣ 1 Introduction ‣ Learning Implicit Fields for Generative Shape Modeling\") shows some results sampled at 5123superscript5123512^{3}. We also include, in the supplementary material, videos showing interpolation results of IM-GAN sampled at 2563superscript2563256^{3}, and comparisons between interpolations in IM-AE and IM-GAN latent spaces.\n\n### 4.4 2D shape generation and interpolation\n\n|  | DCGAN \\[ [37])\\] | CNN-GAN | IM-GAN | VAE \\[ [26])\\] | VAEIM | WGAN \\[ [18])\\] | WGANIM | Oracle |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| COV-CD (%) | 3.9 | 82.7 | 75.2 | 72.1 | 74.9 | 86.5 | 84.7 | 88.4 |\n| MMD-CD | 0.846 | 0.155 | 0.151 | 0.145 | 0.14 | 0.158 | 0.149 | 0.137 |\n| PWE (nat) | -282.83 | -8.07 | -6.16 | 17.39 | 30.6 | -24.54 | -4.17 | 18.99 |\n| PWE-nb (nat) | -230.47 | 130.93 | 128.38 | 304.57 | 318.07 | 97.32 | 93.1 | 241.19 |\n| IS \\[ [28])\\] | 3.26 | 8.79 | 9.36 | 9.09 | 9.42 | 8.9 | 9.22 | 9.8 |\n| IS-nb | 3.26 | 8.8 | 9.39 | 7.58 | 8.28 | 8.95 | 9.22 | 9.88 |\n\nTable 3: Quantitative evaluation for 2D shape generation. Oracle is the results obtained by using the training set as the sample set. The metrics without suffix “-nb” are evaluated using binarized images. PWE and IS are the higher the better. The better results in each subgroup (latent-GAN, VAE, WGAN) are bolded, and the best results over all models are underlined.![Refer to caption]Figure 7: Visual results for 2D shape generation. The first part of each row presents an interpolation between 9 and 6, except for DCGAN since it failed to generate number 6 or 9. The second part of each row shows some generated samples. The sampled images are not binarized. More samples and binarized images can be found in the supplementary material.\n\nTo evaluate IM-GAN for 2D shape generation, we conducted our experiments on the MNIST dataset since hand-written digits are naturally 2D shapes. We compared our results against DCGAN \\[ [37])\\], VAE \\[ [26])\\], and WGAN with gradient penalty \\[ [3]), [18])\\]. We also included the 2D version of CNN-GAN. In addition, we substituted the CNN decoders of VAE and WGAN with our implicit decoders, to obtain VAEIM and WGANIM. We trained all models on 5,000 binarized images from the training split of MNIST dataset for 1,000 epochs. The training set contains a smaller-than-usual amount of images, so that we can better observe the different features learned by CNN models and implicit models. The autoencoders of IM-GAN and CNN-GAN were pre-trained for 200 epochs. We replace LFD with chamfer distance in 2D images to obtain COV-CD and MMD-CD for evaluation. We also report the inception score for MNIST (IS) \\[ [28])\\] and the log-likelihood produced by Parzen-window estimate (PWE) \\[ [5]), [6]), [16])\\]. For COV-CD and MMD-CD, we sampled 5,000 images from the subject models and compared against 1,000 ground truth images from the testing split. For IS and PWE, we sampled 10,000 images and used the entire testing split.\n\nQuantitative and qualitative evaluations are shown in Table [3]Table 3 ‣ 4.4 2D shape generation and interpolation ‣ 4 Results and evaluation ‣ Learning Implicit Fields for Generative Shape Modeling\") and Figure [7]Figure 7 ‣ 4.4 2D shape generation and interpolation ‣ 4 Results and evaluation ‣ Learning Implicit Fields for Generative Shape Modeling\"), respectively. Models equipped with our implicit decoders generally perform better. Due to inadequate training samples, DCGAN suffers from mode collapse, suggesting that the WGAN loss is preferred to extract true features with smaller training sets. VAEs have better performance over GANs when the output images are binarized, since VAEs tend to produce blurry results. For interpolation, CNN based methods tend to make old parts disappear and then new parts appear. This phenomenon is especially apparent in CNN-GAN and VAE. The implicit model usually warps the shape, but can also carry the “disappear and appear” trick. In visual comparison, IM-GAN and WGANIM output cleaner and more recognizable “in-between” digits. One can find missing or redundant parts in the samples produced by CNN based methods, which are vestiges of the “disappear and appear” phenomenon.\n\n### 4.5 Single-view 3D reconstruction (SVR)\n\n|  | Plane | Car | Chair | Rifle | Table |\n| --- | --- | --- | --- | --- | --- |\n| HSP | 6,307 | 2,009 | 4,255 | 6,360 | 3,765 |\n| AtlasNet25 | 4,877 | 1,667 | 3,244 | 6,507 | 2,725 |\n| AtlasNetO | 5,208 | 1,751 | 4,124 | 6,117 | 3,909 |\n| IM-SVR | 4,743 | 1,658 | 3,321 | 5,067 | 2,918 |\n\nTable 4: Quantitative evaluation for SVR using LFD. The means are taken over the first 100 shapes in the testing set for each category and rounded to integers. AtlasNet25 is AtlasNet with 25 patches (28,9002890028,900 mesh vertices in total) and AtlasNetO (7,44674467,446 vertices) is with one sphere. IM-SVR and HSP were both reconstructed at 2563superscript2563256^{3} resolution. ![Refer to caption]Figure 8: Visual results for single-view 3D reconstruction. See caption of Table [4]Table 4 ‣ 4.5 Single-view 3D reconstruction (SVR) ‣ 4 Results and evaluation ‣ Learning Implicit Fields for Generative Shape Modeling\") for output model settings.\n\nWe compare our approach with two state-of-the-art SVR methods, HSP \\[ [19])\\], an octree-based method that uses 3D CNN decoders to generate 2563superscript2563256^{3} voxels, and AtlasNet \\[ [17])\\], which warps surface patches onto target shapes. For AtlasNet, we tested two setups for the initial surfaces, 25 patches or a sphere, and denote them by AtlasNet25 and AtlasNetO, respectively. For all methods, we trained individual models for each category, and used grayscale images as inputs.\n\nWe used the train/test split in \\[ [19])\\] to utilize the pre-trained models of HSP, since HSP requires quite a long time to converge. For HSP, we used the trained models made available online by the authors, and continued training for at most 2 days for each category and used the ones with the lowest testing loss. For AtlasNet, we trained the autoencoder part for 400 epochs and SVR part for 400 epochs and used the ones with the lowest testing loss. For our method, we trained IM-AE for 200-400 epochs on 643superscript64364^{3} resolution, and IM-SVR for 1,000-2,000 epochs. The number of epochs depends on the size of the dataset. We did not train AtlasNet with such number of epochs since its testing loss had stopped dropping. Since IM-SVR was trained to map an image into a latent code, we did not have a good evaluation metric for testing errors. Therefore, we tested the last five saved checkpoints and report the best results.\n\nQuantitative and qualitative evaluations are shown in Table [4]Table 4 ‣ 4.5 Single-view 3D reconstruction (SVR) ‣ 4 Results and evaluation ‣ Learning Implicit Fields for Generative Shape Modeling\") and Figure [8]Figure 8 ‣ 4.5 Single-view 3D reconstruction (SVR) ‣ 4 Results and evaluation ‣ Learning Implicit Fields for Generative Shape Modeling\"), respectively. IM-SVR outputs were sampled at 2563superscript2563256^{3} resolution, same as HSP. Output mesh settings for AtlasNet are from the authors’ code. Though IM-SVR seems to have similar quantitative results with AtlasNet25, please keep in mind that LFD only captures the silhouette of the shape. AtlasNet25 represents shapes well yet clear artifacts can be observed since the shapes are made of patches and there is no measure to prevent slits, foldovers or overlapped surfaces. AtlasNetO can generate cleaner shapes than AtlasNet25, but the topology is pre-assigned to be equivalent to a sphere, thus AtlasNetO can hardly reconstruct shapes with holes. HSP can produce smooth surfaces but failed to recover most details. We show the comparisons of the first 16 shapes in the testing set for each category in the supplementary material, and also provide the evaluation results by chamfer distance to further verify that CD may not be an ideal evaluation metric for visual quality.",
            "citations": null
          },
          "5 Conclusion, limitation, and future work": {
            "content": "We introduced a simple and generic implicit field decoder to learn shape boundaries. The new decoder IM-NET can be easily plugged into contemporary deep neural networks for a variety of applications including shape auto-encoding, generation, interpolation, and single-view reconstruction. Extensive experiments demonstrate that IM-NET leads to cleaner closed meshes with superior visual quality and better handling of shape topology during interpolation.\n\nA key merit of our implicit encoder is the inclusion of point coordinates as part of the input feature, but this comes as the cost of longer training time, since the decoder needs to be applied on each point in the training set. In practice, CNN-AE is typically 30 times faster than IM-AE on 643superscript64364^{3} data without progressive training. Even with progressive training, IM-AE training took about a day or two and CNN-AE is still 15 times faster. When retrieving generated shapes, CNN only needs one shot to obtain the voxel model, while our method needs to pass every point in the voxel grid to the network to obtain its value, therefore the time required to generate a sample depends on the sampling resolution. While AtlasNet also employed MLP as decoder, AtlasNet25 is 5 times faster than ours in training, since AtlasNet only needs to generate points on the surface of a shape yet ours need to generate points in the whole field.\n\nOur implicit decoder does lead to cleaner surface boundaries, allowing both part movement and topology changes during interpolation. However, we do not yet know how to regulate such topological evolutions to ensure a meaningful morph between highly dissimilar shapes, e.g., those from different categories. We reiterate that currently, our network is only trained per shape category; we leave multi-category generalization for future work. At last, while our method is able to generate shapes with greater visual quality than existing alternatives, it does appear to introduce more low-frequency errors (e.g., global thinning/thickening).\n\nIn future work, we also plan to generalize IM-NET. First, using MLPs to decode may be too simple and inefficient; it is possible to improve the decoder structure to make the model size smaller for faster inference. Second, besides inside/outside signs, it is possible to train our decoder to output other attributes, e.g., color, texture, surface normal, signed distance, or deformation fields, for new applications. Finally, IM-NET has shown signs of understanding shape parts, suggesting its potential utility for learning part segmentation and correspondence.\n\nAcknowledgment. We thank Matt Fisher, Daniel Cohen-Or, and the anonymous reviewers for their comments, and Kangxue Yin and Ali Mahdavi-Amiri for proofreading. The research is supported by NSERC and an Adobe gift fund.",
            "citations": null
          }
        },
        "abstract": "We advocate the use of implicit fields for learning generative models of\nshapes and introduce an implicit field decoder, called IM-NET, for shape\ngeneration, aimed at improving the visual quality of the generated shapes. An\nimplicit field assigns a value to each point in 3D space, so that a shape can\nbe extracted as an iso-surface. IM-NET is trained to perform this assignment by\nmeans of a binary classifier. Specifically, it takes a point coordinate, along\nwith a feature vector encoding a shape, and outputs a value which indicates\nwhether the point is outside the shape or not. By replacing conventional\ndecoders by our implicit decoder for representation learning (via IM-AE) and\nshape generation (via IM-GAN), we demonstrate superior results for tasks such\nas generative shape modeling, interpolation, and single-view 3D reconstruction,\nparticularly in terms of visual quality. Code and supplementary material are\navailable at https://github.com/czq142857/implicit-decoder."
      },
      "bib.bib12": {
        "id": "bib.bib12",
        "citation": "[12]",
        "authors": "",
        "year": "",
        "title": "V3d: Video diffusion models are effective 3d generators.",
        "venue": "",
        "pages": "",
        "url": "",
        "arxiv_id": "2403.06738",
        "doi": null,
        "sections": {
          "1 Introduction": {
            "content": "With the advancement of diffusion-based image generation, automatic 3D generation has also made remarkable progress recently.\nApproaches based on Score Distillation Sampling \\[ [67])\\] have achieved tremendous success in the field of 3D generation by extracting priors directly from text-to-image diffusion models \\[ [99]), [44]), [14]), [58]), [18])\\].\nHowever, such optimization-based methods are relatively slow and suffer from mode collapse \\[ [93]), [99])\\] and the Janus problem \\[ [1]), [78])\\].\n\nSubsequent efforts have proposed various alternative pathways to address these issues, mainly including directly mapping images into 3D representations \\[ [117]), [85]), [30]), [40]), [32]), [63])\\] (such as Triplane NeRF \\[ [8])\\] or 3DGS \\[ [35])\\]), or first generating consistent multi-view images then conducting 3D reconstruction to obtain the underlying 3D model \\[ [52]), [50]), [48])\\].\nWith the increase in 3D data size and model capacity, these methods have reduced the generation time from hours to minutes.\nHowever, the training process of these models still exhibits certain limitations;\nMethods that directly map to 3D representations require training on 3D datasets, making it impractical to leverage higher-quality image data and large-scale pre-trained image diffusion models.\nMeanwhile, approaches based on multi-view generation face difficulties in directly generating a sufficient number of images for reconstruction due to the requirement of memory-consuming cross-attention or intermediate 3D structure to ensure consistency across views.\n\nRecently, video diffusion models have attracted significant attention due to their remarkable ability to generate intricate scenes and complex dynamics with great spatio-temporal consistency \\[ [4]), [5]), [7]), [25]), [13]), [109]), [2]), [24])\\]. Many videos incorporate changes in perspectives which provide natural observations of 3D objects from different views \\[ [43])\\], enabling the diffusion models to perceive the physical 3D world \\[ [7])\\].\nCurrent multi-view generation methods are based on image diffusion models, which can only generate a few views (less than 6). In contrast, video diffusion models can generate hundreds of frames, which is adequate for downstream 3D tasks.\nThese advancements give us the possibility to generate consistent multi-view images using video diffusion models and then reconstruct underlying 3D assets to achieve high-quality 3D generation.\nHowever, reconstruction from multi-views imposes significant demands on consistency which is difficult for current video diffusion models.\nIn this paper, we aim to fully unleash the potential of video diffusion models to perceive the 3D world and inject the geometrical consistency prior to make the diffusion model an effective multi-view generator.\nIn light of this, we propose V3D, a novel approach for 3D generation with video diffusion models. Specifically, we propose to fine-tune video diffusion models on 3D datasets with additional conditions to generate novel views in both object-centric and scene-level scenarios. For object-centric 3D generation, we fine-tune the base video diffusion model on 360​°360°360\\\\degree orbit videos of synthetic 3D objects with the front view as a condition.\nWe find that our fine-tuned model can generate reliable multi-views for 3D reconstruction. However, there still exists inconsistency in some details which may diminish the reconstruction quality. To address this, we adopt perceptual loss instead of pixel-wise loss as the reconstruction objective. We employ Gaussian Splatting as the 3D representation due to its reconstruction and rendering efficiency. To further accelerate the reconstruction, we propose a space-carving initialization method for Gaussians, which involves unprojecting multi-view object masks back to 3D space to roughly position the Gaussians on the object’s surface, eliminating the invalid optimizations on empty spaces.\nConsidering the demands of real-world applications, we also propose a novel mesh extraction method that initially extracts the surface using SDF and subsequently refines the appearance on generated views with image-level loss.\nFurthermore, we demonstrate the effectiveness of our approach in scene-level 3D generation. To achieve precise camera path control and accommodate multi-view input, we integrate a PixelNeRF encoder to enhance the video diffusion model with robust 3D signals. Combined with auxiliary loss and fine-tuning on real-world posed videos, we extend the video diffusion model to generate novel views on an arbitrary camera path given sparse view input.\nOur contributions are:\n\n- •\n\n\nWe propose V3D, a framework that first employs a video diffusion model to generate consistent multi-view frames, then reconstructs the underlying 3D content.\nBy fine-tuning on 3D datasets, we successfully boost the ability of geometrical consistency of video diffusion models. Our framework is generally applicable to both object and scene generation.\n\n- •\n\n\nWe design a reconstruction pipeline tailored for video diffusion outputs to generate high-quality 3D Gaussians or textured meshes. With our designed efficient initialization and refinement, V3D can reconstruct delicate 3D assets within 3 minutes.\n\n- •\n\n\nWe conduct experiments to validate the effectiveness of V3D. Both object-centric and scene-level experiments show that our method achieves state-of-the-art performance in reconstruction quality and multi-view consistency.",
            "citations": null
          },
          "2 Related Work": {
            "content": "### 2.1 3D Generation\n\nEarly efforts in 3D generation focus on per-scene optimization methods based on CLIP \\[ [70]), [73]), [31]), [59]), [17]), [92]), [36])\\]. DreamFusion \\[ [67])\\], the pioneer work, leverages stronger diffusion prior by introducing Score Distillation Sampling that minimizes the difference between rendered images from the underlying 3D assets and the diffusion prior. Subsequent methods have further achieved substantial improvements of this paradigm in quality \\[ [99]), [14]), [44]), [114])\\], optimization speed \\[ [86]), [58])\\], alleviating the Janus problem \\[ [1]), [78]), [18]), [80]), [42])\\], and have expanded their applications to generative tasks such as editing \\[ [16]), [29]), [116]), [65]), [98])\\], texture generation \\[ [108]), [14]), [58])\\], and single image-to-3D \\[ [95]), [69]), [87]), [82])\\]. Despite great success has been achieved, optimization-based methods still suffer from slow generation speed and low success rates. To overcome these challenges, researchers have explored some non-optimization paradigms. One stream involves first generating consistent multi-view images, and then utilizing reconstruction methods to obtain the corresponding 3D model \\[ [48]), [47]), [89]), [88])\\]. SyncDreamer \\[ [50])\\] combines explicit voxels and 3D convolution with a diffusion model to enhance the consistency of generated multi-views. Wonder3D \\[ [52])\\] fine-tunes image diffusion models to generate sparse views with corresponding normal maps and utilizes a NeuS \\[ [94])\\] to reconstruct the underlying geometry. Direct2.5 \\[ [55])\\] adopts a remeshing-based technique to recover geometry from generated sparse normal maps. Another line of research involves directly mapping sparse-views into 3D representations \\[ [83]), [51]), [84]), [104]), [11]), [105]), [97]), [103]), [68]), [81])\\]. LRM \\[ [30])\\], PF-LRM \\[ [40])\\], and Instant3D \\[ [41])\\] adopt a huge transformer to directly predict triplanes from single or sparse views. TriplaneGaussian \\[ [117])\\] and LGM \\[ [85])\\] instead map sparse views into more memory-efficient 3D Gaussian Splatting which supports much higher resolution for supervision. Our concurrent work IM-3D \\[ [56])\\] also explores the capability of video diffusion models in object-centric multi-view generation, we further extend this paradigm in scene-level novel view synthesis and achieve better performance.\n\n### 2.2 Generative Models for Novel View Synthesis\n\nWhile NeRF \\[ [60])\\] and 3D Gaussian Splatting \\[ [35])\\] have shown impressive performance in novel view synthesis with a sufficient number of inputs, reconstruction from sparse views requires additional priors due to the incomplete information provided. Early work mainly focuses on using regression-based \\[ [96]), [106]), [72]), [12]), [21]), [28]), [90]), [91]), [111])\\] or GAN-based \\[ [8]), [9]), [22]), [23]), [27]), [62]), [64]), [77]), [113])\\] methods for generalizable scene reconstruction. However, due to the lack of high-quality data and the limited model capacity, the generated novel views are often blurry and exhibit poor generalization ability. Subsequent work further integrates diffusion priors to achieve better scene-level novel view synthesis \\[ [100]), [33])\\]. SparseFusion \\[ [112])\\] proposes view-conditioned diffusion with epipolar feature transformer to synthesize novel views with sparse inputs. GeNVS \\[ [10])\\] utilizes a PixelNeRF encoder to incorporate geometry information and exploits an auto-aggressive generation strategy to enhance multi-view consistency. ZeroNVS \\[ [74])\\] extends Zero-1-to-3 \\[ [49])\\] to unbounded scenes and resolves the scale ambiguity with better camera pose conditioning. ReconFusion \\[ [102])\\] proposes to fine-tune image diffusion models to condition on multi-view input and utilizes a novel sample loss to reconstruct the 3D scene from sparse posed inputs. We draw inspiration from ReconFusion and GeNVS, adopting PixelNeRF-based conditioner to accommodate any number of input images and provide precise camera path control in scene-level generation.",
            "citations": null
          },
          "3 Approach": {
            "content": "### 3.1 Overall Structure\n\n![Refer to caption]Figure 2: Overview of the proposed V3D.\n\nAs demonstrated in [Fig.2]In 3.1 Overall Structure ‣ 3 Approach ‣ V3D: Video Diffusion Models are Effective 3D Generators\"), the core insight of V3D lies in conceptualizing dense multi-view synthesis as video generation, thus leveraging the structure and powerful priors of the large-scale pre-trained video diffusion model to facilitate consistent multi-view generation.\nFor object-centric image-to-3D, we fine-tune the base video diffusion model on 360​°360°360\\\\degree orbit videos of synthetic 3D objects rendered on fixed circular camera poses ( [Sec.3.2]Dense View Prediction as Video Generation ‣ 3 Approach ‣ V3D: Video Diffusion Models are Effective 3D Generators\")) and design a reconstruction and mesh extraction pipeline that is tailored for generated multi-views ( [Sec.3.3]Robust 3D Reconstruction and Mesh Extraction ‣ 3 Approach ‣ V3D: Video Diffusion Models are Effective 3D Generators\")).\nFor scene-level novel view synthesis, we enhance the base video diffusion model by incorporating a PixelNeRF encoder, enabling it to precisely control camera poses of generated frames and seamlessly adapt to any number of input images ( [Sec.3.4]Scene-level Novel View Synthesis ‣ 3 Approach ‣ V3D: Video Diffusion Models are Effective 3D Generators\")).\nThe detailed V3D methodology is presented as follows.\n\n### 3.2 Dense View Prediction as Video Generation\n\nPrevious multi-view generation models \\[ [15]), [101]), [89])\\] often extend from image diffusion models, incorporating multi-view cross attention (e.g. Wonder3D \\[ [52])\\] and Zero123-XL \\[ [79])\\]) or intermediate 3D representations (e.g. SyncDreamer \\[ [50])\\] with 3D voxels and Viewset Diffusion \\[ [84])\\] and DMV3D \\[ [104])\\] with triplane NeRF) to enhance the consistency of generated images across different views.\nThe former tends to involve a limited number of views due to the use of cross-attention with quadratic complexity, whereas the latter often results in low image resolution due to memory-consuming 3D representations and volume rendering.\nTo overcome these drawbacks, V3D adopts a fundamentally distinct approach to generate dense multi-view images given a single view.\nInspired by Stable Video Diffusion (SVD) \\[ [4])\\], we interpret continuous multi-view images rotating around an object as a video, thereby treating multi-view generation as a form of image-to-video generation with the front view as the condition.\nThis approach capitalizes on the comprehensive understanding of the 3D world offered by large-scale pre-trained video diffusion models to address the scarcity of 3D data and harnesses the inherent network architecture of video diffusion models to effectively produce an adequate number of multi-view images.\n\n#### 3.2.1 Conditioning.\n\nSimilar to SVD, we provide high-level semantic information of the front view by injecting the corresponding CLIP embedding into the diffusion U-Net via cross-attention and prompt the diffusion model low-level information by concatenating its latent along the channel dimension of the input.\nTo better adapt to image-to-3D, we removed irrelevant conditions including motion bucket ID and FPS ID, and opted not to condition on elevation angle. Instead, we randomly rotate the object in elevation to make the generation model compatible with inputs with non-zero elevation.\nOur modification to the conditioning arises from experimental evidence suggesting that it is not feasible to perfectly constrain the elevation of generated multi-view images to a specified angle. The misalignment between the camera poses of the video and those used for reconstruction could lead to significant damage to the final outcomes.\n\n#### 3.2.2 Data.\n\nWe fine-tune the base video diffusion model on the Objaverse dataset \\[ [19])\\] for object-centric image-to-3D.\nIt is well-established that the Objaverse dataset contains quite many low-quality 3D objects \\[ [52]), [47])\\] which may significantly degenerate the model performance \\[ [49])\\].\nWe, therefore, start by manually curating a subset with higher quality, comprising approximately 290k synthetic 3D triangle meshes. We then construct a 360​°360°360\\\\degree orbit video dataset by rendering synthetic 3D objects in this filtered subset on N=18𝑁18N=18 fixed camera poses. Specifically, for each object, we normalize the mesh to unit length, fix the camera distance to 2, set the elevation to 0, and uniformly move the camera on the azimuth N𝑁N times (from 0 to 2​π2𝜋2\\\\pi) to generate a smooth orbit video at 512 resolution.\n\n#### 3.2.3 Training.\n\nWe follow SVD to adopt the commonly used EDM \\[ [34])\\] framework with the simplified diffusion loss for fine-tuning.\nFor the noise distribution used in training, we inspired by \\[ [46]), [79])\\], adopt a relatively large noise distribution with Pmean=1.5subscript𝑃mean1.5P\\_{\\\\text{mean}}=1.5 and Pstd=2.0subscript𝑃std2.0P\\_{\\\\text{std}}=2.0.\nTo enable classifier-free guidance, we randomly set the latent and the CLIP embedding of the front view to zero independently with a probability of 20%.\nTo speed up training and save GPU VRAM, we preprocess and store the latent and CLIP embedding of all video frames beforehand. During training, we load these tensors directly from the disk instead of computing them on the fly. We fine-tuned the base diffusion model for 22.5k steps, taking about one day. More detailed training settings are provided in the supplemental material.\n\n### 3.3 Robust 3D Reconstruction and Mesh Extraction\n\nAfter obtaining dense views of an object using the fine-tuned video diffusion model, our next step is to reconstruct the underlying 3D object from these views. While the obtained multi-view images are of high resolution and satisfactory consistency, it’s challenging to ensure strict pixel-to-pixel alignment between different views. In this case, directly applying pixel-wise loss for 3D reconstruction often leads to artifacts such as floaters or blurry textures \\[ [3]), [66]), [45])\\]. In response, we propose using image-level perceptual loss to resolve inconsistencies among multiple input images. To support image-level loss, we opt for 3D Gaussian Splatting due to its fast training speed and great memory efficiency that enables rendering the full image with minimal cost. We adopt LPIPS \\[ [110])\\] as the perceptual loss and combine it with the original loss for 3DGS, i.e.\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | ℒrecon​(I,Igt)=MSE​(I,Igt)+λs​D-SSIM​(I,Igt)+λl​LPIPS​(I,Igt)subscriptℒrecon𝐼superscript𝐼gtMSE𝐼superscript𝐼gtsubscript𝜆𝑠D-SSIM𝐼superscript𝐼gtsubscript𝜆𝑙LPIPS𝐼superscript𝐼gt\\\\mathcal{L}\\_{\\\\text{recon}}(I,I^{\\\\text{gt}})=\\\\text{MSE}(I,I^{\\\\text{gt}})+\\\\lambda\\_{s}\\\\text{D-SSIM}(I,I^{\\\\text{gt}})+\\\\lambda\\_{l}\\\\text{LPIPS}(I,I^{\\\\text{gt}}) |  | (1) |\n\nwhere I𝐼I and Igtsuperscript𝐼gtI^{\\\\text{gt}} represent the rendered images and the ground truth images (our generated views), λssubscript𝜆𝑠\\\\lambda\\_{s} and λlsubscript𝜆𝑙\\\\lambda\\_{l} refer to the loss weights.\n\n#### 3.3.1 Initialization.\n\nInitialization is crucial for 3D Gaussian Splatting to achieve promising results \\[ [35]), [115])\\].\nDue to no sparse point cloud available in object-centric reconstruction, the original 3DGS initializes the Gaussians with Gaussian-blob and removes unnecessary Gaussians by resetting opacities.\nThis requires many optimization iterations to eliminate the floaters, and artifacts may occur when the input images are not perfectly consistent.\nTo accelerate the reconstruction, we propose to initialize the Gaussians by space carving \\[ [38]), [55])\\]. Concretely, we first segment the foreground of the generated frames with an off-the-shelf background removal model to obtain an object mask for each view. An occupancy grid is then established by projecting voxels onto image planes to determine whether the projected pixel belongs to the object and aggregating the results of all projections under all views. Finally, we exploit marching cubes \\[ [54])\\] to obtain a surface according to this occupancy grid and uniformly sample Ninitsubscript𝑁initN\\_{\\\\text{init}} points on the surface as the initializing positions of the Gaussians.\n\n#### 3.3.2 Mesh Extraction.\n\nFor the demand of real-world applications, we also propose a mesh extraction pipeline for generated views.\nSimilar to \\[ [52]), [88]), [50])\\], we adopt NeuS \\[ [94])\\] with multi-resolution hash grid \\[ [61])\\] for fast surface reconstruction.\nWhile V3D can generate a considerable number of views, it remains modest compared to the typical use cases of NeuS, which commonly involve more than 40 posed images \\[ [94]), [53])\\]. Therefore we adopt a normal smooth loss and a sparse regularization loss to ensure a reasonable geometry.\nBesides, since our generated images are not perfectly consistent and it is not feasible for NeuS to exploit image-level loss due to the high render cost, the textures of the mesh extracted by NeuS are often blurry.\nTo address this, we further refine the texture of the NeuS extracted mesh with generated multi-views using LPIPS loss while keeping the geometry unchanged, which greatly reduces the rendering cost and enhances the quality of final outputs. Owing to the great efficiency of differentiable mesh rendering \\[ [39])\\], this refinement process can be completed within 15 seconds.\n\n![Refer to caption]Figure 3: Qualitative comparison between the proposed V3D and state-of-the-art 3DGS-based image-to-3D methods (LGM \\[ [85])\\] and TriplaneGaussian \\[ [117])\\]) and optimization-based methods (Magic123 \\[ [69])\\] and ImageDream \\[ [95])\\]). The corresponding 360​°360°360\\\\degree videos are demonstrated in the supplemental video.\n\n### 3.4 Scene-level Novel View Synthesis\n\nIn addition to object-centric generation, we further extend video diffusion to scene-level novel view synthesis. Unlike generating views of objects, novel view synthesis entails generating images along a given camera path, which requires precise control over camera poses and accommodating multiple input images.\n\n#### 3.4.1 Conditioning.\n\nPrevious approaches, such as Zero-1-to-3 \\[ [49])\\], incorporate camera poses into image diffusion by introducing camera embeddings. However, this method did not explicitly utilize 3D information, thus making it challenging to ensure consistency across multiple views and precise control over camera pose \\[ [48]), [102])\\].\nTo better incorporate 3D prior into video diffusion and precisely control the poses of generated frames, we draw inspiration from GeNVS \\[ [10])\\] and ReconFusion \\[ [102])\\], integrating a PixelNeRF \\[ [106])\\] feature encoder into video diffusion models.\nSpecifically, given a set of posed images as condition πcond,Icond={(Ii,πi)}isubscript𝜋condsubscript𝐼condsubscriptsubscript𝐼𝑖subscript𝜋𝑖𝑖\\\\pi\\_{\\\\text{cond}},I\\_{\\\\text{cond}}=\\\\{(I\\_{i},\\\\pi\\_{i})\\\\}\\_{i}, we adopt a PixelNeRF to render the feature map of the target camera poses {π}𝜋\\\\{\\\\pi\\\\} by:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | f=PixelNeRF​({π}\\|πcond,Icond),𝑓PixelNeRFconditional𝜋subscript𝜋condsubscript𝐼condf=\\\\text{PixelNeRF}(\\\\{\\\\pi\\\\}\\|\\\\pi\\_{\\\\text{cond}},I\\_{\\\\text{cond}}), |  | (2) |\n\nwhere {π}𝜋\\\\{\\\\pi\\\\} refers to the camera poses of the frames we want to generate.\nWe then concatenate this feature map to the input of the U-Net to explicitly encode relative camera pose information. This approach seamlessly supports an arbitrary number of images as input. Other conditionings are similar to those of object-centric generation, except that the number of CLIP image embedding has been increased from one to multiple.\n\n#### 3.4.2 Data.\n\nFor scene-level novel view synthesis, we fine-tune the base video diffusion model on MVImgNet \\[ [107])\\] which consists of 219k posed real-world video clips. To make the videos from MVImgNet compatible with the input size of the video diffusion, we obtain the object masks with an off-the-shelf background removal tool, then crop, recenter the image, and adjust the principal points and focal lengths according to the foreground mask.\n\n#### 3.4.3 Training.\n\nExcept for the simplified diffusion loss used in video diffusion models, we follow ReconFusion \\[ [102])\\] to regulate the parameters of the PixelNeRF encoder with a down-sampled photometric loss:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | ℒPixelNeRF=𝔼​∥fRGB​(π\\|xcond,πcond)−x↓∥subscriptℒPixelNeRF𝔼delimited-∥∥subscript𝑓RGBconditional𝜋subscript𝑥condsubscript𝜋condsubscript𝑥↓\\\\mathcal{L}\\_{\\\\text{PixelNeRF}}=\\\\mathbb{E}\\\\lVert f\\_{\\\\text{RGB}}(\\\\pi\\|x\\_{\\\\text{cond}},\\\\pi\\_{\\\\text{cond}})-x\\_{\\\\downarrow}\\\\rVert |  | (3) |\n\nwhere fRGBsubscript𝑓RGBf\\_{\\\\text{RGB}} refers to another color branch of the PixelNeRF encoder that predicts a downsampled image and x↓subscript𝑥↓x\\_{\\\\downarrow} refers to the downsampled target frames. We experimentally found this loss crucial to avoid local minima, as illustrated in \\[ [102])\\].\nWe follow InstructPix2Pix \\[ [6])\\], initializing the newly added input channels for the PixelNeRF feature in the first layer of the diffusion U-Net with zero to best keep the pre-trained priors. For input views conditioning, we randomly select 1 to 4 images as input and set the conditions to zeros independently with a probability of 20%. We present more training details of the scene-level model in the supplemental material.",
            "citations": null
          },
          "4 Experiments": {
            "content": "In this section, we present our experiments on validating the effectiveness of the proposed approach in both object-centric and scene-level 3D generation. Specifically, we quantitatively and qualitatively compare V3D with previous state-of-the-art methods in image-to-3D and novel view synthesis. Additionally, we conduct several ablation studies to evaluate the importance of model designs, including noise distribution, number of fine-tuning steps, pre-training prior, and camera conditioning. The detailed results are shown as follows.\n\n![Refer to caption]Figure 4: Qualitative comparison of generated views between the proposed V3D and state-of-the-art multi-view generation methods, including SyncDreamer \\[ [50])\\] and Wonder3D \\[ [52])\\]. The corresponding 360​°360°360\\\\degree videos are shown in the supplemental video.\n\n### 4.1 Object-centric 3D Generation\n\n#### 4.1.1 Qualitative Comparisons.\n\nWe evaluate the performance of the proposed V3D on image-to-3D and compare the results with state-of-the-art methods. The upper part of [Fig.3]In 3.3.2 Mesh Extraction. ‣ 3.3 Robust 3D Reconstruction and Mesh Extraction ‣ 3 Approach ‣ V3D: Video Diffusion Models are Effective 3D Generators\") demonstrates qualitative comparisons between our approach with 3DGS-based methods TriplaneGaussian \\[ [117])\\] and LGM \\[ [85])\\]. Our approach demonstrates impressive quality improvement, while TriplaneGaussian and LGM tend to generate a much more blurry appearance due to the limited number of Gaussians they can produce. The lower part of [Fig.3]In 3.3.2 Mesh Extraction. ‣ 3.3 Robust 3D Reconstruction and Mesh Extraction ‣ 3 Approach ‣ V3D: Video Diffusion Models are Effective 3D Generators\") presents a comparison between state-of-the-art SDS-based methods, including Magic123 \\[ [69])\\] and ImageDream \\[ [95])\\]. V3D outperforms in both front-view alignment and fidelity. In contrast, objects generated by Magic123 exhibit inaccurate geometry and blurry backface, while ImageDream tends to generate assets with over-saturated textures. Importantly, our method achieves these results within 3 minutes, making significant acceleration compared to optimization-based methods which require more than 30 minutes.\n[Fig.4]In 4 Experiments ‣ V3D: Video Diffusion Models are Effective 3D Generators\") illustrates comparisons on multi-view generation with SyncDreamer \\[ [50])\\] and Wonder3D \\[ [52])\\], where our approach consistently achieves superior results with a higher resolution of 512 and much finer details. SyncDreamer tends to generate multi-view images that are simple in geometry and with over-saturated texture. We attribute this to the significant difference in structure between SyncDreamer and the original Stable Diffusion, thus failing to fully leverage the information from image pre-training.\nAs for Wonder3D, our model triples the number of generated multi-views and doubles the resolution, achieving significant improvements in both texture quality and multi-view consistency.\n\n#### 4.1.2 Quantitative Comparisons.\n\nFor qualitative comparisons, we conduct a user study to evaluate the generated 3D assets with human ratings. Specifically, we ask 58 volunteers to evaluate objects generated by V3D and other methods under 30 condition images by watching the rendered 360​°360°360\\\\degree spiral videos, and choose the best method in (a) Alignment: how well does the 3D asset align with the condition image; (b) Fidelity: how realistic is the generated object. [Tab.2]In 4.1.2 Quantitative Comparisons. ‣ 4.1 Object-centric 3D Generation ‣ 4 Experiments ‣ V3D: Video Diffusion Models are Effective 3D Generators\") demonstrates the win rate of each method in the two criteria. V3D is regarded as the most convincing model of all, and it significantly outperforms other competitors in both image alignment and fidelity.\n\nTable 1: User study results. We collect 58 anonymous preference results on image alignment and fidelity.\n\n| Approach | Alignment | Fidelity |\n| --- | --- | --- |\n| SyncDreamer \\[ [50])\\] | 10.34 | 5.17 |\n| Wonder3D \\[ [52])\\] | 17.24 | 12.07 |\n| TriplaneGaussian \\[ [117])\\] | 6.90 | 3.45 |\n| LGM \\[ [85])\\] | 13.79 | 24.14 |\n| Ours | 51.72 | 55.17 |\n\nTable 2: Quantitative comparison of dense multi-view synthesis on Google Scanned Objects dataset \\[ [20])\\].\n\n| Approach | PSNR↑↑\\\\shortuparrow | SSIM↑↑\\\\shortuparrow | LPIPS↓↓\\\\shortdownarrow |\n| --- | --- | --- | --- |\n| RealFusion \\[ [57])\\] | 15.26 | 0.722 | 0.283 |\n| Zero-1-to-3 \\[ [49])\\] | 18.93 | 0.779 | 0.166 |\n| SyncDreamer \\[ [50])\\] | 20.05 | 0.798 | 0.146 |\n| MVDiffusion++ \\[ [88])\\] | 21.45 | 0.844 | 0.129 |\n| Ours | 22.08 | 0.882 | 0.102 |\n\n### 4.2 Novel View Synthesis\n\nFor scene-level novel view synthesis, we test the performance of the proposed V3D on the 10-category subset of the CO3D dataset. To align with the settings of previous methods, we fine-tune V3D on videos in each category for only one epoch (denoted as “fine-tuned”). The results are shown in [Tab.3]In 4.2.1 Qualitative Comparisons. ‣ 4.2 Novel View Synthesis ‣ 4 Experiments ‣ V3D: Video Diffusion Models are Effective 3D Generators\"). Our approach achieves consistently better performance in terms of image metrics against previous state-of-the-art novel view synthesizers by a clear margin, demonstrating the effectiveness of utilizing pre-trained video diffusion models in scene-level novel view synthesis. Besides, V3D shows impressive generalization ability as the zero-shot version of V3D (only trained on MVImgNet) beats most of the competitors.\n\n#### 4.2.1 Qualitative Comparisons.\n\nWe show in [Fig.5]In 4.2.1 Qualitative Comparisons. ‣ 4.2 Novel View Synthesis ‣ 4 Experiments ‣ V3D: Video Diffusion Models are Effective 3D Generators\") qualitative comparisons on generated multi-views between SparseFusion \\[ [112])\\] on the hydrant subset of the CO3D dataset \\[ [71])\\]. For better comparison, we use COLMAP \\[ [75]), [76])\\] to perform multi-view stereo reconstruction given camera poses and showcased, in [Fig.5]In 4.2.1 Qualitative Comparisons. ‣ 4.2 Novel View Synthesis ‣ 4 Experiments ‣ V3D: Video Diffusion Models are Effective 3D Generators\"), the number of points in the obtained point cloud and the Chamfer distance between the one reconstructed from ground truth images.\nThe point clouds reconstructed from V3D generated images contain more points and are closer to the point clouds reconstructed from real images. This indicates a significant advantage of our method in terms of both reconstruction quality and multi-view consistency.\n\nTable 3: Quantitative comparison on 10-category subset of CO3D dataset \\[ [71])\\]. We follow SparseFusion \\[ [112])\\], benchmark view synthesis results with 2, 3, and 6 input views. The best result is highlighted in bold, while the second-best result is underscored.\n\n|  | 2 Views | 3 Views | 6 Views |\n|  | PSNR↑↑\\\\shortuparrow | SSIM ↑↑\\\\shortuparrow | LPIPS ↓↓\\\\shortdownarrow | PSNR ↑↑\\\\shortuparrow | SSIM ↑↑\\\\shortuparrow | LPIPS ↓↓\\\\shortdownarrow | PSNR ↑↑\\\\shortuparrow | SSIM ↑↑\\\\shortuparrow | LPIPS ↓↓\\\\shortdownarrow |\n| PixelNeRF \\[ [106])\\] | 19.52 | 0.667 | 0.327 | 20.67 | 0.712 | 0.293 | 22.47 | 0.776 | 0.241 |\n| NerFormer \\[ [71])\\] | 17.88 | 0.598 | 0.382 | 18.54 | 0.618 | 0.367 | 19.99 | 0.661 | 0.332 |\n| ViewFormer \\[ [37])\\] | 18.37 | 0.697 | 0.282 | 18.91 | 0.704 | 0.275 | 19.72 | 0.717 | 0.266 |\n| EFT \\[ [26]), [112])\\] | 20.85 | 0.680 | 0.289 | 22.71 | 0.747 | 0.262 | 24.57 | 0.804 | 0.210 |\n| VLDM \\[ [112])\\] | 19.55 | 0.711 | 0.247 | 20.85 | 0.737 | 0.225 | 22.35 | 0.768 | 0.201 |\n| SparseFusion \\[ [112])\\] | 21.34 | 0.752 | 0.225 | 22.35 | 0.766 | 0.216 | 23.74 | 0.791 | 0.200 |\n| Ours(w. camera emb.) | 18.27 | 0.598 | 0.303 | 18.83 | 0.605 | 0.273 | - | - | - |\n| Ours(w. Plücker emb.) | 20.11 | 0.714 | 0.277 | 20.39 | 0.727 | 0.223 | - | - | - |\n| Ours(w/o. pre-training) | 16.20 | 0.544 | 0.333 | 16.76 | 0.576 | 0.303 | - | - | - |\n| Ours (zero-shot) | 20.64 | 0.734 | 0.213 | 22.04 | 0.805 | 0.141 | 23.94 | 0.851 | 0.126 |\n| Ours (fine-tuned) | 22.19 | 0.790 | 0.093 | 23.31 | 0.860 | 0.082 | 24.70 | 0.890 | 0.074 |\n\n![Refer to caption]Figure 5: Qualitative comparison on scene-level novel view synthesis with SparseFusion on hydrant subset of CO3D dataset. We reconstruct a sparse point cloud using COLMAP and report the number of points and Chamfer distance against the point cloud extracted with ground truth images.\n\n### 4.3 Ablations\n\n![Refer to caption]Figure 6: Ablations study. We show that the number of fine-tuning steps, large-scale pre-training, and stronger noise distribution are crucial for achieving promising results.\n\n#### 4.3.1 Pre-training.\n\nTo demonstrate the impact of large-scale video pre-training, we trained a variant of the model from scratch on the constructed Objaverse 360​°360°360\\\\degree orbit video for 45k steps, which, apart from the initialized weights of the diffusion U-Net, is identical to the full model. As shown in [Fig.6]In 4.3 Ablations ‣ 4 Experiments ‣ V3D: Video Diffusion Models are Effective 3D Generators\"), this from-scratched variant completely failed to generate multi-view images even with doubled training steps compared to the full model, demonstrating the significant importance of adopting large-scale video pre-training.\n\n#### 4.3.2 Number of Fine-tuning Steps.\n\nTo illustrate the impact of the Objaverse dataset on the pre-trained model, we fine-tune the base model with different training steps, as shown in the top part of [Fig.6]In 4.3 Ablations ‣ 4 Experiments ‣ V3D: Video Diffusion Models are Effective 3D Generators\"). Due to the considerably lower complexity of renders from Objaverse objects, excessive fine-tuning steps can yield overly simplistic textures in the generated frames, while an inadequate number of fine-tuning steps may lead to strange and inaccurate geometries.\n\n#### 4.3.3 Noise Distribution.\n\nTo validate the necessity of adopting a large noise distribution during training, we fine-tune the base diffusion model with a smaller noise schedule (Pmean=0.7subscript𝑃mean0.7P\\_{\\\\text{mean}}=0.7 and Pstd=1.6subscript𝑃std1.6P\\_{\\\\text{std}}=1.6), which is used in the image-to-video pre-training in Stable Video Diffusion. As demonstrated in the lower part of [Fig.6]In 4.3 Ablations ‣ 4 Experiments ‣ V3D: Video Diffusion Models are Effective 3D Generators\"), the model trained with a smaller noise distribution tends to generate geometric structures that are unreasonable (the pistol) or degenerated (the cartoon-style astronaut).\nWe attribute this phenomenon to the strong image signal we exploited and the relatively simple nature of the synthetic Objaverse dataset, indicating the need to shift the noise distribution towards stronger noise.\n\n#### 4.3.4 Camera Conditioning.\n\nTo assess the impact of the approach of camera conditioning, we introduce two variants that condition on camera poses by commonly used learnable camera embedding or the Plücker ray embedding. For a fair comparison, for both variants, we additionally concatenate the multi-view images used as conditions into the input of the diffusion U-Net and similarly set the weights of added channels to zero to minimize the gap. As shown in [Tab.3]In 4.2.1 Qualitative Comparisons. ‣ 4.2 Novel View Synthesis ‣ 4 Experiments ‣ V3D: Video Diffusion Models are Effective 3D Generators\"), either camera embedding or Plücker embedding provides accurate 3D information and results in a significant degeneration in model performance.",
            "citations": null
          },
          "5 Limitations and Conclusion": {
            "content": "#### 5.0.1 Limitations.\n\nAlthough achieves state-of-the-art performance in 3D generation, V3D would produce unsatisfying results for some complex objects or scenes, such as inconsistency among multiple views or unreasonable geometries. Concrete failure cases and analyses are discussed in the supplemental material.\n\n#### 5.0.2 Conclusion.\n\nIn this paper, we propose V3D, a novel method for generating consistent multi-view images with image-to-video diffusion models. By fine-tuning the base video diffusion model on 3D datasets, we extend video diffusion models to effective 3D generators. Specifically, for object-centric 3D generation, we fine-tune the video diffusion on synthesizing 360​°360°360\\\\degree videos of 3D objects to predict dense views given a single image. To obtain the underlying 3D asset from generated views, we propose a tailored reconstruction pipeline with designed initialization and texture refinement, enabling the reconstruction of high-quality 3D Gaussians or delicate textured meshes within 3 minutes.\nWe further extend our framework to scene-level novel view synthesis, achieving precise control over the camera path with great multi-view consistency.\nWe conduct extensive experiments to validate the effectiveness of the proposed approach, illustrating its remarkable performance in generating consistent multi-views and generalization ability. We hope our method can serve as an efficient and powerful approach for high-quality 3D generation and could pave the way for more extensive applications of video diffusion models in 3D tasks.",
            "citations": null
          }
        },
        "abstract": "Automatic 3D generation has recently attracted widespread attention. Recent\nmethods have greatly accelerated the generation speed, but usually produce\nless-detailed objects due to limited model capacity or 3D data. Motivated by\nrecent advancements in video diffusion models, we introduce V3D, which\nleverages the world simulation capacity of pre-trained video diffusion models\nto facilitate 3D generation. To fully unleash the potential of video diffusion\nto perceive the 3D world, we further introduce geometrical consistency prior\nand extend the video diffusion model to a multi-view consistent 3D generator.\nBenefiting from this, the state-of-the-art video diffusion model could be\nfine-tuned to generate 360degree orbit frames surrounding an object given a\nsingle image. With our tailored reconstruction pipelines, we can generate\nhigh-quality meshes or 3D Gaussians within 3 minutes. Furthermore, our method\ncan be extended to scene-level novel view synthesis, achieving precise control\nover the camera path with sparse input views. Extensive experiments demonstrate\nthe superior performance of the proposed approach, especially in terms of\ngeneration quality and multi-view consistency. Our code is available at\nhttps://github.com/heheyas/V3D"
      },
      "bib.bib15": {
        "id": "bib.bib15",
        "citation": "[15]",
        "authors": "",
        "year": "",
        "title": "Objaverse: A universe of annotated 3d objects.",
        "venue": "",
        "pages": "",
        "url": "",
        "arxiv_id": "2212.08051",
        "doi": null,
        "sections": {
          "1 Introduction": {
            "content": "Massive datasets have enabled and driven rapid progress in AI. Language corpora on the web led to large language models like GPT-3 \\[ [4])\\]; paired image and text datasets like Conceptual Captions \\[ [68])\\] led to vision-and-language pretrained models like VilBERT \\[ [45])\\]; YouTube video datasets led to video capable models like Merlot-Reserve \\[ [87])\\]; and massive multimodal datasets like WebImageText \\[ [70])\\] and LAION \\[ [67]), [66])\\] led to models like CLIP \\[ [60])\\] and StableDiffusion \\[ [64])\\]. These leaps in dataset scale and diversity were triggered by moving from manually curated datasets to harnessing the power of the web and its creative content.\n\nIn contrast to the datasets described above, the size of the datasets we are feeding to our, data-hungry, deep learning models in many other areas of research is simply not comparable. For instance, the number of 3D assets used in training generative 3D models is, maximally, on the order of thousands \\[ [24])\\] and the simulators used to train embodied AI models typically have only between a few dozen to a thousand unique scenes \\[ [39]), [72]), [63]), [42])\\]. The startling advances brought about by developing large-scale datasets for images, videos, and natural language, demand that an equivalent dataset be built for 3D assets.\n\nWe present Objaverse 1.0, a large scale corpus of high-quality, richly annotated, 3D objects; see Fig. [1]Figure 1 ‣ Objaverse: A Universe of Annotated 3D Objects\"). Objects in our dataset are free to use111Creative Commons license and sourced from Sketchfab, a leading online platform for managing, viewing, and distributing 3D models. In total, Objaverse contains over 800K 3D assets designed by over 100K artists which makes this data large and diversely sourced.\nAssets not only belong to varied categories like animals, humans, and vehicles, but also include interiors and exteriors of large spaces that can be used, _e.g_., to train embodied agents. Objaverse is a universe of rich 3D data with detailed metadata that can support many different annotations to enable new applications.\nWith this remarkable increase in scale, we see an incredible opportunity for Objaverse to impact research progress across domains. In this work, we provide promising results to answer three questions.\n\nCan 3D vision benefit from a large-scale dataset?\nFirst, as a 3D asset resource, Objaverse can support the exciting field of 3D generative modeling. We use data extracted from Objaverse to train generative models for single and multiple categories using GET3D \\[ [24])\\] and find that we are able to generate high-quality objects and, moreover, that our generated objects are found by human annotators to be more diverse than those generated by a model trained on ShapeNet objects in 91% of cases.\n\nCan the diversity of 3D models help improve classical 2D vision task performance?\nTo answer this question, we use the diversity of Objaverse to improve the performance of long tail instance segmentation models. Instance segmentation data can be expensive to obtain owing to the cost of annotating contours around objects. The recent LVIS dataset contains annotations for 1,230 categories but the task remains very challenging for present day models, particularly on tail categories that have few examples. We show that increasing the volume of data by leveraging a simple Copy+Paste augmentation method with Objaverse assets can improve the performance of state-of-the-art segmentation methods.\n\nWe also use Objaverse to build a benchmark for evaluating the robustness of state-of-the-art visual classification models to perspective shifts. We render objects in Objaverse from random orientations, which is how one might expect to see them in the real world and test the ability of CLIP-style visual backbones to correctly classify these images. Our experiments show that current state-of-the-art models’ performance degrades dramatically in this setting when viewing objects from arbitrary views.\nObjaverse allows us to build benchmarks to test (and potentially train) for orientation robustness for a long tail distribution of asset categories. Building such benchmarks is made uniquely possible by the scale and diversity of 3D assets in Objaverse. This would simply not be feasible to create in the real world nor can they be generated from existing 2D images.\n\n![Refer to caption]\n\n| Dataset | \\# Objects | \\# Classes |\n| --- | --- | --- |\n| YCB \\[ [5])\\] | 77 | 5 |\n| BigBIRD \\[ [69])\\] | 125 | – |\n| KIT \\[ [35])\\] | 219 | 145 |\n| IKEA \\[ [43])\\] | 219 | 11 |\n| Pix3D \\[ [71])\\] | 395 | 9 |\n| GSO \\[ [19])\\] | 1K | 17 |\n| EGAD \\[ [51])\\] | 2K | – |\n| PhotoShape \\[ [53])\\] | 5K | 1 |\n| ABO \\[ [12])\\] | 8K | 63 |\n| 3D-Future \\[ [22])\\] | 10K | 34 |\n| ShapeNet \\[ [7])\\] | 51K | 55 |\n| Objaverse | 818K | 21K |\n\nFigure 2: Comparison between Objaverse and existing 3D object datasets. (Left:) Visual comparison of instances from Objaverse and ShapeNet for the categories of Car, Bed, Vase, and Bag. Objaverse instances are substantially more diverse since objects can come from many 3D content creation platforms, whereas ShapeNet models look more similar and all come from SketchUp, a 3D modeling platform built for simple architectural modeling. (Right:) Scale comparison table between existing 3D object datasets.\n\nCan a large-scale 3D dataset help us train embodied agents performant embodied agents?\n\nWe use assets in Objaverse to populate procedurally generated simulated environments in ProcTHOR \\[ [17])\\] that are used to train Embodied AI agents.\nThis results in an orders of magnitude increase in the number of unique assets available for use in ProcTHOR scenes (previously limited to AI2-THOR’s \\[ [39])\\] asset library of a few thousand unique instances each assigned to one of 108 object categories).\nUsing Objaverse populated scenes enables open vocabulary object navigation from any text description. In this paper, we provide quantitative results for navigating to 1.1K semantic object categories, roughly a 50x increase.\n\nThese findings represent just a small fraction of what can be accomplished using Objaverse. We are excited to see how the research community will leverage Objaverse to enable fast and exciting progress in 2D and 3D computer vision applications and beyond.",
            "citations": null
          },
          "2 Related Work": {
            "content": "Large scale datasets.\nScaling the size and scope of training datasets has widely been demonstrated to be an effective avenue of improvement for model performance. In computer vision, the adoption of early large scale datasets such as Imagenet\\[ [65]), [18])\\] and MS-COCO\\[ [44])\\] has dramatically accelerated progress on a variety of tasks including classification, object detection, captioning, and more. Ever since, the diversity and scale of datasets have continued to grow. YFCC100M is a dataset of 99.2M images and 800K videos\\[ [77])\\]. OpenImages\\[ [40])\\] is a large scale dataset of 9M images that contains labeled subsets bounding boxes, visual relationships, segmentation masks, localized narratives, and categorical annotations. Massive web-scraped datasets containing image-text pairs such as Conceptual Captions\\[ [68])\\], WIT\\[ [70])\\], and LAION\\[ [67]), [66])\\] have seen increased popularity recently as they have been used to train impressive models for vision-language representation learning\\[ [60]), [29]), [32])\\], text-to-image generation\\[ [62]), [61]), [64]), [32])\\], and vision-language multitasking\\[ [10]), [73]), [79]), [9])\\].\n\n3D datasets.\nCurrent large-scale 2D image datasets offer three crucial components that benefit learning: scale, diversity, and realism. Ideally, models that reason about 3D objects should have access to datasets that meet these same criteria. However, of the numerous 3D object datasets that currently exist, none are able to excel in all three categories to the same degree as their 2D counterparts.\nDatasets such as KIT\\[ [35])\\], YCB\\[ [5])\\], BigBIRD\\[ [69])\\], IKEA\\[ [43])\\], and Pix3D\\[ [71])\\] provide image-calibrated models over a diverse set of household objects, but severely lack in scale with only a few hundred objects at most. EGAD\\[ [51])\\] procedurally generates 2K objects for grasping, but produces objects that are not that realistic or diverse. Slightly larger datasets of photo-realistic objects include GSO\\[ [19])\\], PhotoShape\\[ [53])\\], ABO\\[ [12])\\] and 3D-Future\\[ [22])\\], and ShapeNet\\[ [7])\\] with object counts in the tens of thousands, see Fig. [2]Figure 2 ‣ 1 Introduction ‣ Objaverse: A Universe of Annotated 3D Objects\") for comparisons between Objaverse and these datasets. Datasets for CAD models, such as ModelNet\\[ [83])\\] and DeepCAD\\[ [82])\\], and ABC\\[ [38])\\] do not include textures or materials, which limits their ability to represent objects that could plausibly be found in the real world. Datasets of scanned 3D objects and environments are valuable for real-world understanding\\[ [14]), [15]), [11]), [41])\\], but are quite small and limited. In addition to containing numerous artist designed objects, Objaverse contains many scanned assets, making it a useful source of data for learning from real-world distributions.\n\nWhile rapid progress has been made in developing datasets that combine image and text, in contrast, only a few datasets that pair language and 3D data exist. Text2Shape\\[ [8])\\] released a dataset of 15,038 chairs and tables from ShapeNet each with around 5 text captions, giving 75,344 total text-shape pairs. ShapeGlot\\[ [1])\\] released the CiC (Chairs in Context) dataset which contains 4,511 chairs from ShapeNet along with 78,789 descriptive utterances generated from a referential game. Due to the small scale and limited diversity of these datasets, current SoTA text-to-3D models\\[ [47]), [57]), [31])\\] forgo the use of 3D datasets entirely and instead rely on 2D image-text supervision.",
            "citations": null
          },
          "3 Objaverse": {
            "content": "Objaverse is a massive annotated 3D dataset that can be used to enable research in a wide range of areas across computer vision.\nThe objects are sourced from Sketchfab, an online 3D marketplace where users can upload and share models for both free and commercial use. Objects selected for Objaverse have a distributable Creative Commons license and were obtained using Sketchfab’s public API. Aside from licensing consideration, models marked as restricted due to objectionable or adult thematic content were excluded from the dataset.\n\n![Refer to caption](a)Breakdown of high-level Objaverse categories\n\n![Refer to caption](b)Word cloud of Objaverse metadata tags.\n\n![Refer to caption](c)Objaverse-LVIS category occurrence distribution.\n\n![Refer to caption](d)Objaverse tag occurrence distribution.\n\nFigure 3: Objaverse statistics. (a) All 18 high-level categories present in Objaverse’s metadata with their corresponding number of occurrences. The relative share of most popular categories are evenly split, with a small number of less frequently categories. (b) A sample of several thousand popular object tags found in Objaverse log-scaled by their frequency. (c) A histogram of fine-grained Objaverse-LVIS categories with representative members from several bins highlighted.\n(d) A histogram of Objaverse tags with representative members from several bins highlighted (note y-axis log scale). Tags from the low-occurrence side of the distribution correspond to unique objects that, taken individually, are rarely seen in the world. Frequently used tags like ”furniture” and ”car” reflect their real-world normalcy, but the high frequency of assets like ”sword” diverge from their real-world counterparts.\n\nModel metadata.Objaverse objects inherit a set of foundational annotations supplied by their creator when uploaded to Sketchfab. Figure [4]Figure 4 ‣ 3 Objaverse ‣ Objaverse: A Universe of Annotated 3D Objects\") shows an example of the metadata available for each model. The metadata includes a name, assignments to a set of fixed categories, a set of unrestricted tags, and a natural language description.\n\nObjaverse-LVIS.\nWhile Objaverse metadata contains a great deal of information about objects, Sketchfab’s existing categorization scheme covers only 18 categories, too coarse for most applications. Object names, categories, and tags provide multiple potential categorizations at varying levels of specificity and with some inherent noise. However, for many existing computer vision tasks, it is useful to assign objects to a single category drawn from a predetermined set of the right size and level of semantic granularity.\n\nWe choose the categories from the LVIS dataset \\[ [26])\\] for categorizing a long-tail subset of objects in Objaverse. We construct a 47K LVIS categorized object subset, called Objaverse-LVIS, comprised of objects uniquely assigned to one of 1156 LVIS categories. We perform these assignments by first selecting 500 candidate objects per category using a combination of predictions from a CLIP classification model and candidates suggested by terms in their metadata. This combined pool contains objects visually resembling the target category (from the CLIP features of their thumbnail images) that might have missing metadata, as well as visually unusual instances of a category that are accurately named or tagged. These 250k candidate objects were then manually filtered and their assigned categories verified by crowdworkers. Since we only presented 500 object candidates per class, many popular categories, such as chair or car, have substantially more objects that could be included in Objaverse-LVIS with future annotations.\n\nAnimated objects and rigged characters.Objaverse includes 44K animated objects and over 63K objects self-categorized as characters. Examples of animations include fridge doors opening, animals running, and the hands on a clock moving. Rigged characters can be set up for animation and rendering, and may often come annotated with bone mappings. The vast scale of animations available in Objaverse can support a wide range of research in temporal 3D learning, such as building text-based animation generative models \\[ [76])\\], representing object changes over time with NERFs \\[ [59]), [54])\\], and temporal self-supervised learning via. future frame prediction \\[ [87]), [30])\\].\n\n![Refer to caption]Figure 4: An example of metadata available for each object in Objaverse. Each uploaded object has a 3D model, user-selected rendered thumbnail image, name, description, tags, category, and stats, among additional metadata.![Refer to caption]Figure 5: Highlights of the visual diversity of objects that appear in Objaverse, including animated objects, rigged (body-part annotated) characters, models separatable into parts, exterior environments, interior environments, and a wide range visual styles.\n\nArticulated objects. Decomposing 3D objects into parts has led to a flurry of research in the past few years, including work in learning robotic grasping policies \\[ [86]), [84])\\], 3D semantic segmentation \\[ [50])\\], and shape generation \\[ [49])\\]. Since many objects in Objaverse were uploaded by artists, the objects often come separated into parts. Figure [5]Figure 5 ‣ 3 Objaverse ‣ Objaverse: A Universe of Annotated 3D Objects\") shows an example, where a chair is separated by its backrest, wheels, and legs, among many smaller parts.\n\nExteriors. Photogrammetry and NERF advances have enabled the commercialization of capturing high-quality 3D objects of large exteriors by taking pictures  \\[ [75]), [85])\\]. In Objaverse, there are a large number of scanned buildings, cities, and stadiums. Figure [5]Figure 5 ‣ 3 Objaverse ‣ Objaverse: A Universe of Annotated 3D Objects\") shows an example of a 3D object of NYC’s skyline captured through a scan.\n\nObjaverse-Interiors. There are 16K+ interior scenes in Objaverse, including houses, classrooms, and offices. The scenes often have multiple floors, many types of rooms, and are densely populated with objects from human input. Objects in the scenes are separable into parts, which allows them to be usable for interactive robotics, embodied AI, and scene synthesis. To put the scale of Objaverse-Interiors in perspective, the number of scenes in Objaverse-Interiors is significantly larger than the 400 or so existing hand-built interactive embodied AI scenes \\[ [39]), [23]), [42]), [72])\\].\n\nVisual styles. Objects in the world can be constructed in many styles and often differ in style based on the time-period, geographic location, and artist’s style. Objaverse objects cover a vast set of visual styles, including 3D scans, 3D modeled objects from virtually any platform, point clouds, and photo-realism via physically based rendering (PBR) \\[ [56])\\].\nMoreover, instances of objects often appear with many styles, which is critical for training and evaluating robust computer vision models \\[ [60])\\]. Figure [5]Figure 5 ‣ 3 Objaverse ‣ Objaverse: A Universe of Annotated 3D Objects\") shows examples of chairs in Objaverse in many different styles, including Gothic, modern, Victorian, cartoon, and abstract.\n\nStatistics.Objaverse 1.0 includes 818K 3D objects, designed by 160K artists. There are >{>}2.35M tags on the objects, with >{>}170K of them being unique. We estimate that the objects have coverage for nearly 21K WordNet entities \\[ [48])\\] (see appendix for details). Objects were uploaded between 2012 and 2022, with over 200K objects uploaded uploaded just in 2021. Figure [3]Figure 3 ‣ 3 Objaverse ‣ Objaverse: A Universe of Annotated 3D Objects\") visualizes several statistics of the dataset, including the breakdown of objects into their self-assigned Sketchfab categories, a word cloud over the tags, a frequency plot of the tags, and the number of objects in Objaverse-LVIS categories.",
            "citations": null
          },
          "4 Applications": {
            "content": "In this section, we present 4 initial distinct applications of Objaverse, including 3D generative modeling, instance segmentation with CP3D, open-vocabulary ObjectNav, and analyze robustness in computer vision models.\n\n### 4.1 3D Generative Modeling\n\n![Refer to caption]\n\n(a)Comparison of _Bag_ s generated with Objaverse and ShapeNet.\n\n![Refer to caption]\n\n(b)_Shoe_ and _Fruit&Veg._ generations.\n\n![Refer to caption]\n\n(c)_Fruit&Veg._ interpolation.\n\nFigure 6: (a) Example GET3D _Bag_ object generations using Objaverse and ShapeNet models for training. (b) Additional _Shoe_ and _Fruit&Veg_ generations from Objaverse models. (c) models generated when interpolating between two, randomly sampled, latent encodings with our trained Fruit&Veg. model; what appears to be a pumpkin smoothly transforms into a mushroom.\n\n3D generative modeling has shown much improvement recently with models such as GET3D \\[ [24])\\] delivering impressive high quality results with rich geometric details. GET3D is trained to generate 3D textured meshes for a category and produces impressive 3D objects for categories like _Car_, _Chair_, and _Motorcycle_ using data from ShapeNet \\[ [7])\\]. Objaverse contains 3D models for many diverse categories including tail categories which are not represented in other datasets. It also contains diverse and realistic object instances per category. This scale and diversity can be used to train large vocabulary and high quality 3D generative models. In this work, we showcase the potential of this data as follows. We choose three categories of objects, _Shoe_, _Bag_, and _Fruit&Veg_, and subsample objects from Objaverse to create three separate datasets containing, respectively, 143 shoes, 816 bags, and 571 fruits & vegetables (116 apples, 112 gourds, 92 mushrooms, 68 bananas, 52 oranges, 52 pears, 31 potatoes 24 lemons, and 24 pineapples). For comparison, we also train a GET3D model on the set of 83 bags from the ShapeNet dataset. Fig. [6]Figure 6 ‣ 4.1 3D Generative Modeling ‣ 4 Applications ‣ Objaverse: A Universe of Annotated 3D Objects\") shows a collection of 3D objects generated by our trained GET3D models. Qualitatively, the 3D-meshes generated by the Objaverse-trained models are high-quality and diverse, especially when compared to the generations from the ShapeNet-trained model. To quantify this observation, we asked crowdworkers to rate the diversity of _Bag_ generations produced by the Objaverse and ShapeNet trained models. When shown collections of nine randomly sampled generations from both models, workers rated the collection generated from the Objaverse trained model as more diverse in appearance 91% of the time.\n\nOur fruits and vegetables, composed of 9 varieties produces perhaps the highest quality output, a promising signal that can inspire future work in text-to-3D generation.\n\n### 4.2 Instance Segmentation with CP3D\n\n![Refer to caption]\n\nFigure 7: An illustration of 3DCP (3D copy-paste) for segmentation augmentation. We render 3D objects from multiple views and paste them over LVIS training images.\n\n| Method | AP | APr | APc | APf |\n| --- | --- | --- | --- | --- |\n| RFS \\[ [26])\\] | 23.7 | 13.3 | 23.0 | 29.0 |\n| EQLv2 \\[ [74])\\] | 25.5 | 17.7 | 24.3 | 30.2 |\n| LOCE \\[ [21])\\] | 26.6 | 18.5 | 26.2 | 30.7 |\n| NorCal with RFS \\[ [52])\\] | 25.2 | 19.3 | 24.2 | 29.0 |\n| Seesaw \\[ [78])\\] | 26.4 | 19.5 | 26.1 | 29.7 |\n| GOL \\[ [3])\\] | 27.7 | 21.4 | 27.7 | 30.4 |\n| GOL + 3DCP | 28.3 | 21.8 | 28.3 | 31.1 |\n\nTable 1: Comparison of our approach (GOL+3DCP) against SoTA Mask-RCNN ResNet-50 models on LVIS. We report results for APr, APc, and APf which measure AP for categories that are rare (appear in 1-10 images), common (appear in 11-100 images), and frequent (appear in >>100 images), respectively![Refer to caption]Figure 8: An existing ProcTHOR scene (left) and a semantically similar ProcTHOR generatable scene with Objaverse objects (right).\n\nA key advantage of using simulated data for computer vision is that it is much cheaper to obtain expert annotations. Annotated Objaverse objects can be rendered into images, allowing them to serve as a rich source of additional data that can be used to enhance model performance on 2D computer vision tasks. As a proof-of-concept demonstrating the effectiveness of this approach, we use segmented data from Objaverse objects as auxiliary labels for training models on the LVIS dataset for Large Scale Instance Segmentation \\[ [26])\\]. The LVIS dataset contains instance segmentation masks for 1200 object categories that occur throughout a set of 164k images. Recognition is especially challenging in this task due to the long tail of the object category distribution in this dataset. LVIS categories only contain an average 9 instances across the dataset, so training on simulated data is a promising approach for overcoming the challenges of learning in this low-sample regime.\n\nUsing the LVIS-annotated subset of Objaverse, we introduce 3DCP: an enhancement to the simple, but effective, copy-and-paste technique of\\[ [25])\\]. Figure [7]Figure 7 ‣ 4.2 Instance Segmentation with CP3D ‣ 4 Applications ‣ Objaverse: A Universe of Annotated 3D Objects\") shows an example of the setup for 3DCP. Here, we render different views of 3D objects and paste them on-top of existing LVIS images. We render 5 distinct views of each object and cache them for use throughout training. During training, an image is selected for the copy-paste augmentation with 0.5 probability, and once selected, 1-3 images of randomly chosen LVIS-annotated Objaverse objects are pasted onto the selected training image. The segmentation masks of the selected objects are added to the training image’s annotation as well. Object images and masks are randomly scaled and translated before being pasted. We use this strategy to finetune the pretrained ResNet-50 Mask-RCNN \\[ [27]), [28])\\] of \\[ [3])\\]. As shown in Tab. [1]Table 1 ‣ 4.2 Instance Segmentation with CP3D ‣ 4 Applications ‣ Objaverse: A Universe of Annotated 3D Objects\"), simply finetuning this model for 24 epochs yields performance gains across several metrics.\n\n### 4.3 Open-Vocabulary ObjectNav\n\nIn this section, we introduce open-vocabulary ObjectNav, a new task propelled by the vast diversity of objects that appear in Objaverse. Here, an agent is placed at a random starting location inside of a home and tasked to navigate to a target object provided from a text description ( _e.g_. _“Raspberry Pi Pico”_). To facilitate this task, we procedurally generate 10K new homes in ProcTHOR \\[ [17])\\] fully populated with objects from Objaverse-LVIS. Until now, ObjectNav tasks have focused on training agents to navigate to 20 or so target objects provided their category label \\[ [16]), [63]), [17])\\], and existing interactive embodied AI simulations, including ProcTHOR, only include around 2K total objects across around 100 object types \\[ [42]), [17]), [72])\\]. In this work, we take a large step to massively scale the number of target objects used in ObjectNav (20 →→\\\\to OpenVocab), the number of objects available in simulation (2K →→\\\\to 36K), and the number of object types of the objects (100 →→\\\\to 1.1K).\n\nObject placement. To make the placement of objects in the houses more natural, we use the Objaverse-LVIS subset and annotate placement constraints for each object category. Specifically, we annotate if objects of a given category typically appears on the floor, on-top of a surface, or on a wall. If instances of the object category may appear on the floor, we also annotate whether it may appear in the middle of the scene ( _e.g_. a clutter object like a basketball) or on the edge of the scene ( _e.g_. a toilet or a fridge). For objects placed on the floor, we also to automatically detect flat regions on top of the object’s mesh to place surface object types. The annotations are used by ProcTHOR for sampling objects to place in a scene. We also filter out Objaverse-LVIS objects that do not appear inside of homes, such as a jet plane. Structural objects, like doors and windows, are inherited from ProcTHOR as they would require additional cleanup.\n\nObject size correction. Objects in Sketchfab may be uploaded at unnatural scales ( _e.g_. a plant being as large as a tower). We therefore scale the objects to be of a reasonable size for them to look natural in a house. Here, for each object category, we annotate the maximum bounding box dimension length that every instance of the object category should be scaled to. For example, we annotate the maximum bounding box dimension for bookcase to be 2 meters\nand fork to be 0.18 meters. If a 3D modeled bookcase then has a bounding box of 20m×\\\\times6m×\\\\times3m, we shrink each side by a factor of max⁡(20,6,3)/2=5206325\\\\max(20,6,3)/2=5.\n\nPreprocessing for AI2-THOR. We add support to AI2-THOR for loading objects on the fly at runtime. Previously, all objects had to be stored in a Unity build, but such an approach is impractical when working with orders of magnitude more object data. For each object, we compress it with Blender \\[ [13])\\] by joining all of its meshes together, decimate the joined mesh such that it has at most 5K vertices, and bake all the UV texture maps into a single texture map. We then generate colliders using V-HACD \\[ [46])\\] to support rigid-body interactions.\n\nApproach.\nGiven procedural houses populated with Objaverse-LVIS, the task is to navigate to the proximity of a chosen target object and invoke a task-completion action when the target object is in sight, given an open-vocabulary description formed with the template “a {name} {category}”. The name is the object name given by its creator, which is often descriptive. We filter each by whether it is detected as being written in English by a language detector \\[ [34]), [33])\\], and fall back to a class-only description for non-English name. Examples of the possible expressions include _“a victorian-monobike motorcycle”_, _“a unicorn pony”_, or _“a dino ghost lizard”_. The agent, similar to the ones in \\[ [36])\\], observes an RGB egocentric view of the environment, pre-processed by the visual branch of a frozen ResNet-50 CLIP model \\[ [60])\\] – the target description is pre-processed by the corresponding text branch. We train the agent with DD-PPO \\[ [81])\\] and evaluate on houses with floor plans, objects, and descriptions unseen in training. We use the AllenAct \\[ [80])\\] framework to train our agent. Our trained agent achieves a success rate of 19.9%, for a random policy success of 5.1%. For more details about the experiment refer to the appendix.\n\n### 4.4 Analyzing Robustness\n\n![Refer to caption]Figure 9: Examples of objects rendered from random orientations and their 0-shot classification categories with the CLIP ViT-B/32.\n\nA persistent bias present in many image datasets, _e.g_. ImageNet \\[ [65])\\], is that the subjects of interest are generally photographed from a forward-facing, canonical, orientation. When, for example, taking a photograph of a television, few would choose to take this photograph crouched on the floor behind the television. This impact of this bias was studied by Alcorn _et al_.\\[ [2])\\] who find that modern computer vision systems are highly susceptible to deviations from canonical poses. This is more than a theoretical problem: computer vision systems deployed in the real world will frequently encounter objects in non-canonical orientations and in many applications, _e.g_. autonomous driving, it will be safety critical that they behave well.\n\nGiven the above, we adopt the experimental design of Alcorn _et al_. and design, using Objaverse assets, a benchmark for evaluating the robustness of state-of-the-art computer vision classification models to orientation shifts. In particular, for each object in our Objaverse-LVIS subset, we render 12 images of the object from random orientations rendered upon a background with RGB values equalling the mean RGB values from ImageNet; see Fig. [9]Figure 9 ‣ 4.4 Analyzing Robustness ‣ 4 Applications ‣ Objaverse: A Universe of Annotated 3D Objects\") for examples. This ability to, at scale, render objects from random viewpoints is a practical impossibility in the real world but is made trivial when using 3D assets. We then evaluate several modern open-domain image-classification networks (constrained to the ≈1,200absent1200{\\\\approx}1{,}200LVIS categories) on these images and report 4 metrics for each model. These metrics include:\n\n|     |     |     |     |     |     |\n| --- | --- | --- | --- | --- | --- |\n|  | Random Rotation | Any Rotation |  |\n| Model | Top-1 | Top-5 | Top-1 | Top-5 | ΔΔ\\\\DeltaTop-1 |\n| OpenAI-400M \\[ [60])\\] |  |  |  |  |  |\n| RN50 | 21.4% | 45.0% | 43.9% | 70.8% | 22.5% |\n| ViT-L/14 | 29.1% | 54.5% | 52.3% | 77.2% | 23.2% |\n| LAION-400M \\[ [67])\\] |  |  |  |  |  |\n| ViT-B/32 | 24.1% | 48.5% | 46.9% | 74.2% | 22.8% |\n| ViT-L/14 | 30.6% | 56.8% | 50.5% | 77.0% | 19.9% |\n| LAION-2B \\[ [66])\\] |  |  |  |  |  |\n| ViT-B/32 | 27.0% | 51.8% | 50.3% | 76.1% | 23.3% |\n| ViT-L/14 | 32.9% | 59.2% | 52.1% | 78.0% | 19.2% |\n| ViT-H/14 | 32.3% | 58.8% | 50.1% | 77.3% | 17.8% |\n\nTable 2: Evaluating 0-shot CLIP classification models on our rotational robustness benchmark. ΔΔ\\\\DeltaTop-1 denotes the difference between _Top-1 Any Rotation_ and _Top-1 Random Rotation_. Models are strongly overfit to standard views of objects.\n\n∙∙\\\\bullet _Top-1 Random Rotation_ – the frequency with which a model correctly classifies an image as belonging to the respective LVIS category.\n\n∙∙\\\\bullet _Top-1 Any Rotation_ – the frequency with which a model classifies an image correctly from at least one of the 12 random orientations.\n\nThis second metric is diagnostic and serves to represent a model’s performance when shown an object from a canonical pose. We also have _Top-5_ variants of the above metric where the correct category need only be in the top 5 predictions from the model.\nWe report our results in Tab. [2]Table 2 ‣ 4.4 Analyzing Robustness ‣ 4 Applications ‣ Objaverse: A Universe of Annotated 3D Objects\") in which we evaluate a variety of performant pretrained models. Comparing the gap in performance between the _Top-k𝑘k Random Rotation_ and _Top-k𝑘k Any Rotation_ metrics we find that model performance dramatically degrades when viewing objects from unusual orientations.",
            "citations": null
          },
          "5 Conclusion": {
            "content": "We present Objaverse, a next-generation 3D asset library containing 818K high-quality, diverse, 3D models with paired text descriptions, titles, and tags. As a small glimpse of the potential uses of Objaverse, we present four experimental studies showing how Objaverse can be used to power (1) generative 3D models with clear future applications to text-to-3D generation, (2) improvements to classical computer vision tasks such as instance segmentation, (3) the creation of novel embodied AI tasks like Open Vocabulary Object Navigation, and (4) quantifying the rotational robustness of vision models on renderings of objects. We hope to see Objaverse enable a new universe of new applications for computer vision.",
            "citations": null
          }
        },
        "abstract": "Massive data corpora like WebText, Wikipedia, Conceptual Captions,\nWebImageText, and LAION have propelled recent dramatic progress in AI. Large\nneural models trained on such datasets produce impressive results and top many\nof today's benchmarks. A notable omission within this family of large-scale\ndatasets is 3D data. Despite considerable interest and potential applications\nin 3D vision, datasets of high-fidelity 3D models continue to be mid-sized with\nlimited diversity of object categories. Addressing this gap, we present\nObjaverse 1.0, a large dataset of objects with 800K+ (and growing) 3D models\nwith descriptive captions, tags, and animations. Objaverse improves upon\npresent day 3D repositories in terms of scale, number of categories, and in the\nvisual diversity of instances within a category. We demonstrate the large\npotential of Objaverse via four diverse applications: training generative 3D\nmodels, improving tail category segmentation on the LVIS benchmark, training\nopen-vocabulary object-navigation models for Embodied AI, and creating a new\nbenchmark for robustness analysis of vision models. Objaverse can open new\ndirections for research and enable new applications across the field of AI."
      },
      "bib.bib102": {
        "id": "bib.bib102",
        "citation": "[102]",
        "authors": "",
        "year": "",
        "title": "Novel view synthesis with diffusion models.",
        "venue": "",
        "pages": "",
        "url": "https://arxiv.org/abs/2210.04628",
        "arxiv_id": "2210.04628",
        "doi": null,
        "sections": {
          "1 Introduction": {
            "content": "Diffusion Probabilistic Models (DPMs) (Sohl-Dickstein et al., [2015]); Song & Ermon, [2019]); Ho et al., [2020])), also known as simply diffusion models, have recently emerged as a powerful family of generative models, achieving state-of-the-art performance on audio and image synthesis (Chen et al., [2020]); Dhariwal & Nichol, [2021])), while admitting better training stability over adversarial approaches (Goodfellow et al., [2014])), as well as likelihood computation, which enables further applications such as compression and density estimation (Song et al., [2021]); Kingma et al., [2021])). Diffusion models have achieved impressive empirical results in a variety of image-to-image translation tasks not limited to text-to-image, super-resolution, inpainting, colorization, uncropping, and artifact removal (Song et al., [2020]); Saharia et al., [2021a]); Ramesh et al., [2022]); Saharia et al., [2022])).\n\nOne particular image-to-image translation problem where diffusion models have not been investigated is novel view synthesis, where, given a set of images of a given 3D scene, the task is to infer how the scene looks from novel viewpoints.\nBefore the recent emergence of Scene Representation Networks (SRN) (Sitzmann et al., [2019])) and Neural Radiance Fields (NeRF) (Mildenhall et al., [2020])), state-of-the-art approaches to novel view synthesis were typically built on generative models (Sun et al., [2018])) or more classical techniques on interpolation or disparity estimation (Park et al., [2017]); Zhou et al., [2018])). Today, these models have been outperformed by NeRF-class models (Yu et al., [2021]); Niemeyer et al., [2021]); Jang & Agapito, [2021])), where 3D consistency is guaranteed by construction, as images are generated by volume rendering of a single underlying 3D representation (a.k.a. “geometry-aware” models).\n\nStill, these approaches feature different limitations.\nHeavily regularized NeRFs for novel view synthesis with few images such as RegNeRF (Niemeyer et al., [2021])) produce undesired artifacts when given very few images, and fail to leverage knowledge from multiple scenes (recall NeRFs are trained on a single scene, i.e., one model per scene), and given one or very few views of a novel scene, a reasonable model must extrapolate to complete the occluded parts of the scene.\nPixelNeRF (Yu et al., [2021])) and VisionNeRF (Lin et al., [2022])) address this by training NeRF-like models conditioned on feature maps that encode the novel input view(s). However, these approaches are regressive rather than generative, and as a result, they cannot yield different plausible modes and are prone to blurriness. This type of failure has also been previously observed in regression-based models (Saharia et al., [2021b])). Other works such as CodeNeRF (Jang & Agapito, [2021])) and LoLNeRF (Rebain et al., [2021])) instead employ test-time optimization to handle novel scenes, but still have issues with sample quality.\n\nIn recent literature, geometry-free approaches (i.e., methods without explicit geometric inductive biases like those introduced by volume rendering) such as Light Field Networks (LFN) (Sitzmann et al., [2021])) and Scene Representation Transformers (SRT) (Sajjadi et al., [2021])) have achieved results competitive with 3D-aware methods in the “few-shot” setting, where the number of conditioning views is limited (i.e., 1-10 images vs. dozens of images as in the usual NeRF setting). Similarly to our approach, EG3D (Chan et al., [2022])) provides approximate 3D consistency by leveraging generative models. EG3D employs a StyleGAN (Karras et al., [2019])) with volumetric rendering, followed by generative super-resolution (the latter being responsible for the approximation). In comparison to this complex setup, diffusion not only provides a significantly simpler architecture, but also a simpler hyper-parameter tuning experience compared to GANs, which are well-known to be notoriously difficult to tune (Mescheder et al., [2018])). Notably, diffusion models have already seen some success on 3D point-cloud generation (Luo & Hu, [2021]); Waibel et al., [2022])).\n\nMotivated by these observations and the success of diffusion models in image-to-image tasks, we introduce 3D Diffusion Models (3DiMs).\n3DiMs are image-to-image diffusion models trained on pairs of images of the same scene, where we assume the poses of the two images are known.\nDrawing inspiration from Scene Representation Transformers (Sajjadi et al., [2021])), 3DiMs are trained to build a conditional generative model of one view given another view and their poses.\nOur key discovery is that we can turn this image-to-image model into a model that can produce an entire set of 3D-consistent frames through autoregressive generation, which we enable with our novel stochastic conditioning sampling algorithm.\nWe cover stochastic conditioning in more detail in Section [2.2]D consistency via stochastic conditioning ‣ 2 Pose-conditional diffusion models ‣ Novel View Synthesis with Diffusion Models\") and provide an illustration in Figure [3]Figure 3 ‣ 2.2 3D consistency via stochastic conditioning ‣ 2 Pose-conditional diffusion models ‣ Novel View Synthesis with Diffusion Models\").\nCompared to prior work, 3DiMs are generative (vs. regressive) geometry free models, they allow training to scale to a large number of scenes, and offer a simple end-to-end approach.\n\nWe now summarize our core contributions:\n\n1. 1.\n\n\nWe introduce 3DiM, a geometry-free image-to-image diffusion model for novel view synthesis.\n\n2. 2.\n\n\nWe introduce the stochastic conditioning sampling algorithm, which encourages 3DiM to generate 3D-consistent outputs.\n\n3. 3.\n\n\nWe introduce X-UNet, a new UNet architecture (Ronneberger et al., [2015])) variant for 3D novel view synthesis, demonstrating that changes in architecture are critical for high fidelity results.\n\n4. 4.\n\n\nWe introduce an evaluation scheme for geometry-free view synthesis models, 3D consistency scoring, that can numerically capture 3D consistency by training neural fields on model outputs.",
            "citations": null
          },
          "2 Pose-conditional diffusion models": {
            "content": "To motivate 3DiMs, let us consider the problem of novel view synthesis given few images from a probabilistic perspective.\nGiven a complete description of a 3D scene 𝒮𝒮\\\\mathcal{S}, for any pose 𝒑𝒑{\\\\bm{p}}, the view 𝒙(𝒑)superscript𝒙𝒑{\\\\bm{x}}^{({\\\\bm{p}})} at pose 𝒑𝒑{\\\\bm{p}} is fully determined from 𝒮𝒮\\\\mathcal{S}, i.e., views are conditionally independent given 𝒮𝒮\\\\mathcal{S}.\nHowever, we are interested in modeling distributions of the form q​(𝒙1,…,𝒙m\\|𝒙m+1,…,𝒙n)𝑞subscript𝒙1…conditionalsubscript𝒙𝑚subscript𝒙𝑚1…subscript𝒙𝑛q({\\\\bm{x}}\\_{1},...,{\\\\bm{x}}\\_{m}\\|{\\\\bm{x}}\\_{m+1},...,{\\\\bm{x}}\\_{n})without𝒮𝒮\\\\mathcal{S}, where views are no longer conditionally independent. A concrete example is the following: given the back of a person’s head, there are multiple plausible views for the front. An image-to-image model sampling front views given only the back should indeed yield different outputs for each front view – with no guarantees that they will be consistent with each other – especially if it learns the data distribution perfectly. Similarly, given a single view of an object that appears small, there is ambiguity on the pose itself: is it small and close, or simply far away?\nThus, given the inherent ambiguity in the few-shot setting, we need a sampling scheme where generated views can depend on each other in order to achieve 3D consistency.\nThis contrasts NeRF approaches, where query rays are conditionally independent given a 3D representation 𝒮𝒮\\\\mathcal{S} – an even stronger condition than imposing conditional independence among frames.\nSuch approaches try to learn the richest possible representation for a single scene 𝒮𝒮\\\\mathcal{S}, while 3DiM avoids the difficulty of learning a generative model for 𝒮𝒮\\\\mathcal{S} altogether.\n\n### 2.1 Image-to-image diffusion models with pose conditioning\n\n![Refer to caption]Figure 2: Pose-conditional image-to-image training –\nExample training inputs and outputs for pose-conditional image-to-image diffusion models. Given two frames from a common scene and their poses (R,t)𝑅𝑡(R,t), the task is to undo the noise added to one of the two frames. (\\*) In practice, our neural network is trained to predict the Gaussian noise ϵbold-italic-ϵ\\\\bm{\\\\epsilon} used to corrupt the original view – the predicted view is still just a linear combination of the noisy input and the predicted ϵbold-italic-ϵ\\\\bm{\\\\epsilon}.\n\nGiven a data distribution q​(𝒙1,𝒙2)𝑞subscript𝒙1subscript𝒙2q({\\\\bm{x}}\\_{1},{\\\\bm{x}}\\_{2}) of pairs of views from a common scene at poses 𝒑1,𝒑2∈SE​(3)subscript𝒑1subscript𝒑2SE3{\\\\bm{p}}\\_{1},{\\\\bm{p}}\\_{2}\\\\in\\\\mathrm{SE}(3), we define an isotropic Gaussian process that adds increasing amounts of noise to data samples as the signal-to-noise-ratio λ𝜆\\\\lambda decreases, following Salimans & Ho ( [2022])):\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | q​(𝒛k(λ)\\|𝒙k):=𝒩​(𝒛k(λ);σ​(λ)12​𝒙k,σ​(−λ)​𝐈)assign𝑞conditionalsuperscriptsubscript𝒛𝑘𝜆subscript𝒙𝑘𝒩superscriptsubscript𝒛𝑘𝜆𝜎superscript𝜆12subscript𝒙𝑘𝜎𝜆𝐈q({\\\\bm{z}}\\_{k}^{(\\\\lambda)}\\|{\\\\bm{x}}\\_{k}):=\\\\mathcal{N}({\\\\bm{z}}\\_{k}^{(\\\\lambda)};\\\\sigma(\\\\lambda)^{\\\\frac{1}{2}}{\\\\bm{x}}\\_{k},\\\\sigma(-\\\\lambda)\\\\mathbf{I}) |  | (1) |\n\nwhere σ​(⋅)𝜎⋅\\\\sigma(\\\\cdot) is the sigmoid function. We can apply the reparametrization trick (Kingma & Welling, [2013])) and sample from these marginal distributions via\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | 𝒛k(λ)=σ​(λ)12​𝒙k+σ​(−λ)12​ϵ,ϵ∼𝒩​(𝟎,𝐈)formulae-sequencesuperscriptsubscript𝒛𝑘𝜆𝜎superscript𝜆12subscript𝒙𝑘𝜎superscript𝜆12bold-italic-ϵsimilar-tobold-italic-ϵ𝒩0𝐈{\\\\bm{z}}\\_{k}^{(\\\\lambda)}=\\\\sigma(\\\\lambda)^{\\\\frac{1}{2}}{\\\\bm{x}}\\_{k}+\\\\sigma(-\\\\lambda)^{\\\\frac{1}{2}}\\\\bm{\\\\epsilon},\\\\quad\\\\bm{{\\\\epsilon}}\\\\sim\\\\mathcal{N}(\\\\bm{0},\\\\mathbf{I}) |  | (2) |\n\nThen, given a pair of views, we learn to reverse this process in one of the two frames by minimizing the objective proposed by Ho et al. ( [2020])), which has been shown to yield much better sample quality than maximizing the true evidence lower bound (ELBO):\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | L=𝔼q​(𝒙1,𝒙2)​𝔼λ,ϵ​‖ϵθ​(𝒛2(λ),𝒙1,λ,𝒑1,𝒑2)−ϵ‖22𝐿subscript𝔼𝑞subscript𝒙1subscript𝒙2subscript𝔼𝜆bold-italic-ϵsuperscriptsubscriptnormsubscriptbold-italic-ϵ𝜃superscriptsubscript𝒛2𝜆subscript𝒙1𝜆subscript𝒑1subscript𝒑2bold-italic-ϵ22L=\\\\mathbb{E}\\_{q({\\\\bm{x}}\\_{1},{\\\\bm{x}}\\_{2})}\\\\>\\\\>\\\\mathbb{E}\\_{\\\\lambda,\\\\bm{\\\\epsilon}}\\\\>\\\\>\\\\\\|\\\\bm{\\\\epsilon}\\_{\\\\theta}({\\\\bm{z}}\\_{2}^{(\\\\lambda)},{\\\\bm{x}}\\_{1},\\\\lambda,{\\\\bm{p}}\\_{1},{\\\\bm{p}}\\_{2})-\\\\bm{\\\\epsilon}\\\\\\|\\_{2}^{2} |  | (3) |\n\nwhere ϵθsubscriptbold-italic-ϵ𝜃\\\\bm{\\\\epsilon}\\_{\\\\theta} is a neural network whose task is to denoise the frame 𝒛2(λ)superscriptsubscript𝒛2𝜆{\\\\bm{z}}\\_{2}^{(\\\\lambda)} given a different (clean) frame 𝒙1subscript𝒙1{\\\\bm{x}}\\_{1}, and λ𝜆\\\\lambda is the log signal-to-noise-ratio.\nTo make our notation more legible, we slightly abuse notation and from now on we will simply write ϵθ​(𝒛2(λ),𝒙1)subscriptbold-italic-ϵ𝜃superscriptsubscript𝒛2𝜆subscript𝒙1\\\\bm{\\\\epsilon}\\_{\\\\theta}({\\\\bm{z}}\\_{2}^{(\\\\lambda)},{\\\\bm{x}}\\_{1}).\n\n### 2.2 3D consistency via stochastic conditioning\n\n![Refer to caption]Figure 3: Stochastic conditioning sampler –\nThere are two main components to our sampling procedure: 1) the autoregressive generation of multiple frames, and 2) the denoising process to generate each frame. When generating a new frame, we randomly select a previous frame as the conditioning frame at each denoising step. We omit the pose inputs in the diagram to avoid overloading the figure, but they should be understood to be recomputed at each step, depending on the conditioning view we randomly sample.\n\nMotivation. We begin this section by motivating the need of our stochastic conditioning sampler. In the ideal situation, we would model our 3D scene frames using the chain rule decomposition:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | p​(𝒙)=∏ip​(𝒙i\\|𝒙<i)𝑝𝒙subscriptproduct𝑖𝑝conditionalsubscript𝒙𝑖subscript𝒙absent𝑖\\\\displaystyle p({\\\\bm{x}})=\\\\prod\\_{i}p({\\\\bm{x}}\\_{i}\\|{\\\\bm{x}}\\_{<i}) |  | (4) |\n\nThis factorization is ideal, as it models the distribution exactly without making any conditional independence assumptions.\nEach frame is generated autoregressively, conditioned on all the previous frames.\nHowever, we found this solution to perform poorly. Due to memory limitations, we can only condition on a limited number of frames in practice, (i.e., a k𝑘k-Markovian model). We also find that, as we increase the maximum number of input frames k𝑘k, the worse the sample quality becomes. In order to achieve the best possible sample quality, we thus opt for the bare minimum of k=2𝑘2k=2 (i.e., an image-to-image model). Our key discovery is that, with k=2𝑘2k=2, we can still achieve approximate 3D consistency. Instead of using a sampler that is Markovian over frames, we leverage the iterative nature of diffusion sampling by varying the conditioning frame at each denoising step.\n\nStochastic Conditioning. We now detail our novel stochastic conditioning sampling procedure that allows us to generate 3D-consistent samples from a 3DiM.\nWe start with a set of conditioning views 𝒳={𝒙1,…,𝒙k}𝒳subscript𝒙1…subscript𝒙𝑘\\\\mathcal{X}=\\\\{{\\\\bm{x}}\\_{1},...,{\\\\bm{x}}\\_{k}\\\\} of a static scene, where typically k=1𝑘1k=1 or is very small.\nWe then generate a new frame by running a modified version of the standard denoising diffusion reverse process for steps\nλmin=λT<λT−1<…<λ0=λmaxsubscript𝜆minsubscript𝜆𝑇subscript𝜆𝑇1…subscript𝜆0subscript𝜆max\\\\lambda\\_{\\\\textrm{min}}=\\\\lambda\\_{T}<\\\\lambda\\_{T-1}<...<\\\\lambda\\_{0}=\\\\lambda\\_{\\\\textrm{max}}:\n\n|     |     |     |     |     |     |\n| --- | --- | --- | --- | --- | --- |\n|  | 𝒙^k+1subscript^𝒙𝑘1\\\\displaystyle\\\\hat{{\\\\bm{x}}}\\_{k+1} | =\\\\displaystyle= | 1σ​(λt)12​(𝒛k+1(λt)−σ​(−λt)12​ϵθ​(𝒛k+1(λt),𝒙i))1𝜎superscriptsubscript𝜆𝑡12superscriptsubscript𝒛𝑘1subscript𝜆𝑡𝜎superscriptsubscript𝜆𝑡12subscriptbold-italic-ϵ𝜃superscriptsubscript𝒛𝑘1subscript𝜆𝑡subscript𝒙𝑖\\\\displaystyle\\\\frac{1}{\\\\sigma(\\\\lambda\\_{t})^{\\\\frac{1}{2}}}\\\\left({\\\\bm{z}}\\_{k+1}^{(\\\\lambda\\_{t})}-\\\\sigma(-\\\\lambda\\_{t})^{\\\\frac{1}{2}}\\\\bm{\\\\epsilon}\\_{\\\\theta}({\\\\bm{z}}\\_{k+1}^{(\\\\lambda\\_{t})},{\\\\color\\[rgb\\]{0,0,1}\\\\definecolor\\[named\\]{pgfstrokecolor}{rgb}{0,0,1}{\\\\bm{x}}\\_{i}})\\\\right) |  | (5) |\n|  | 𝒛k+1(λt−1)superscriptsubscript𝒛𝑘1subscript𝜆𝑡1\\\\displaystyle{\\\\bm{z}}\\_{k+1}^{(\\\\lambda\\_{t-1})} | ∼similar-to\\\\displaystyle\\\\sim | q​(𝒛k+1(λt−1)\\|𝒛k+1(λt),𝒙^k+1)𝑞conditionalsuperscriptsubscript𝒛𝑘1subscript𝜆𝑡1superscriptsubscript𝒛𝑘1subscript𝜆𝑡subscript^𝒙𝑘1\\\\displaystyle q\\\\left({\\\\bm{z}}\\_{k+1}^{(\\\\lambda\\_{t-1})}\\|{\\\\bm{z}}\\_{k+1}^{(\\\\lambda\\_{t})},\\\\hat{{\\\\bm{x}}}\\_{k+1}\\\\right) |  | (6) |\n\nwhere, crucially, i∼Uniform​({1,…,k})similar-to𝑖Uniform1…𝑘{\\\\color\\[rgb\\]{0,0,1}\\\\definecolor\\[named\\]{pgfstrokecolor}{rgb}{0,0,1}i}\\\\sim\\\\textrm{Uniform}(\\\\{1,...,k\\\\}) is re-sampled at each denoising step. In other words, each individual denoising step is conditioned on a different random view from 𝒳𝒳\\\\mathcal{X} (the set that contains the input view(s) and the previously generated samples). Once we finish running this sampling chain and produce a final 𝒙k+1subscript𝒙𝑘1{\\\\bm{x}}\\_{k+1}, we simply add it to 𝒳𝒳\\\\mathcal{X} and repeat this procedure if we want to sample more frames. Given sufficient denoising steps, stochastic conditioning allows each generated frame to be guided by all previous frames.\nSee Figure [3]Figure 3 ‣ 2.2 3D consistency via stochastic conditioning ‣ 2 Pose-conditional diffusion models ‣ Novel View Synthesis with Diffusion Models\") for an illustration.\nIn practice, we use 256 denoising steps, which we find to be sufficient to achieve both high sample quality and approximate 3D consistency.\nAs usual in the literature, the first (noisiest sample) is just a Gaussian, i.e., 𝒛i(λT)∼𝒩​(𝟎,𝐈)similar-tosuperscriptsubscript𝒛𝑖subscript𝜆𝑇𝒩0𝐈{\\\\bm{z}}\\_{i}^{(\\\\lambda\\_{T})}\\\\sim\\\\mathcal{N}(\\\\bm{0},\\\\mathbf{I}), and at the last step λ0subscript𝜆0\\\\lambda\\_{0}, we sample noiselessly.\n\nWe can interpret stochastic conditioning as a naïve approximation to true autoregressive sampling that works well in practice. True autoregressive sampling would require a score model of the form ∇𝒛k+1(λ)log⁡q​(𝒛k+1(λ)\\|𝒙1,…,𝒙k)subscript∇superscriptsubscript𝒛𝑘1𝜆𝑞conditionalsuperscriptsubscript𝒛𝑘1𝜆subscript𝒙1…subscript𝒙𝑘\\\\nabla\\_{{\\\\bm{z}}\\_{k+1}^{(\\\\lambda)}}\\\\log q({\\\\bm{z}}\\_{k+1}^{(\\\\lambda)}\\|{\\\\bm{x}}\\_{1},...,{\\\\bm{x}}\\_{k}), but this would strictly require multi-view training data, while we are ultimately interested in enabling novel view synthesis with as few as two training views per scene.\n\n### 2.3 X-UNet\n\n![Refer to caption]Figure 4: X-UNet Architecture – We modify the typical UNet architecture used by recent work on diffusion models to accomodate 3D novel view synthesis. We share the same UNet weights among the two input frames, the clean conditioning view and the denoising target view. We add cross attention layers to mix information between the input and output view, illustrated in yellow.\n\nThe 3DiM model needs a neural network architecture that takes both the conditioning frame and the noisy frame as inputs. One natural way to do this is simply to concatenate the two images along the channel dimensions, and use the standard UNet architecture (Ronneberger et al., [2015]); Ho et al., [2020])). This “Concat-UNet” has found significant success in prior work of image-to-image diffusion models (Saharia et al., [2021b]); [a])).\nHowever, in our early experiments, we found that the Concat-UNet yields very poor results – there were severe 3D inconsistencies and lack of alignment to the conditioning image. We hypothesize that, given limited model capacity and training data, it is difficult to learn complex, nonlinear image transformations that only rely on self-attention. We thus introduce our X-UNet, whose core changes are (1) sharing parameters to process each of the two views, and (2) using cross attention between the two views. We find our X-UNet architecture to be very effective for 3D novel view synthesis.\n\nWe now describe X-UNet in detail. We follow Ho et al. ( [2020])); Song et al. ( [2020])), and use the UNet (Ronneberger et al., [2015])) with residual blocks and self-attention.We also take inspiration from Video Diffusion Models (Ho et al., [2022])) by sharing weights over the two input frames for all the convolutional and self-attention layers, but with several key differences:\n\n1. 1.\n\n\nWe let each frame have its own noise level (recall that the inputs to a DDPM residual block are feature maps as well as a positional encoding for the noise level). We use a positional encoding of λmaxsubscript𝜆max\\\\lambda\\_{\\\\textrm{max}} for the clean frame. Ho et al. ( [2022])) conversely denoise multiple frames simultaneously, each at the same noise level.\n\n2. 2.\n\n\nAlike Ho et al. ( [2020])), we modulate each UNet block via FiLM (Dumoulin et al., [2018])), but we use the sum of pose and noise-level positional encodings, as opposed to the noise-level embedding alone. Our pose encoding additionally differs in that they are of the same dimensionality as frames– they are camera rays, identical to those used by Sajjadi et al. ( [2021])).\n\n3. 3.\n\n\nInstead of attending over “time” after each self-attention layer like Ho et al. ( [2022])),\nwhich in our case would entail only two attention weights,\nwe define a cross-attention layer and let each frame’s feature maps call this layer to query the other frame’s feature maps.\n\n\nFor more details on our proposed architecture, we refer the reader to the Supplementary Material (Sec. [6]Architecture details ‣ Novel View Synthesis with Diffusion Models\")). We also provide a comparison to the “Concat-UNet” architecture in Section [3.2]UNet Architecture Comparisons ‣ 3 Experiments ‣ Novel View Synthesis with Diffusion Models\").",
            "citations": null
          },
          "3 Experiments": {
            "content": "|     |     |     |     |     |     |\n| --- | --- | --- | --- | --- | --- |\n| Input View | SRN | PixelNeRF | VisionNeRF | 3DiM (ours) | Ground Truth |\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\nFigure 5: State-of-the-art comparisons –\nExample input and output views of a 3DiM trained on the SRN cars dataset at the 128x128 resolution, compared to existing geometry-aware methods. Results are best appreciated in the Supplementary Website.\n\n|  | SRN cars | SRN chairs |\n| --- | --- | --- |\n|  | PSNR (↑)↑(\\\\uparrow) | SSIM (↑)↑(\\\\uparrow) | FID (↓)↓(\\\\downarrow) | PSNR (↑)↑(\\\\uparrow) | SSIM (↑)↑(\\\\uparrow) | FID (↓)↓(\\\\downarrow) |\n| --- | --- | --- | --- | --- | --- | --- |\n| Geometry-aware |  |  |  |  |  |  |\n| SRN | 22.25 | 0.88 | 41.21 | 22.89 | 0.89 | 26.51 |\n| PixelNeRF | 23.17 | 0.89 | 59.24 | 23.72 | 0.90 | 38.49 |\n| VisionNeRF | 22.88 | 0.90 | 21.31 | 24.48 | 0.92 | 10.05 |\n| CodeNeRF | 23.80 | \\*0.91 | – | 23.66 | \\*0.90 | – |\n| Geometry-free |  |  |  |  |  |  |\n| LFN | 22.42 | \\*0.89 | – | 22.26 | \\*0.90 | – |\n| ENR | 22.26 | – | – | 22.83 | – | – |\n| 3DiM (ours) | 21.01 | 0.57 | 8.99 | 17.05 | 0.53 | 6.57 |\n\nTable 1: State-of-the-art comparisons –\nResults on the SRN ShapeNet benchmark comparing 3DiMs to prior work on novel view synthesis from a single image. (\\*) SSIM scores may not necessarily be computed with a Gaussian kernel following Wang et al. ( [2004])) – in practice we observe this can lead to differences of up to 0.02. We report these marked numbers directly from prior work.\n\nWe benchmark 3DiMs on the SRN ShapeNet dataset (Sitzmann et al., [2019])) to allow comparisons with prior work on novel view synthesis from a single image. This dataset consists of views and poses of car and chair ShapeNet (Chang et al., [2015])) assets, rendered at the 128x128 resolution.\n\nWe compare 3DiMs with Light Field Networks (LFN) (Sitzmann et al., [2021])) and Equivariant Neural Rendering (ENR) (Dupont et al., [2020])), two competitive geometry-free approaches, as well as geometry-aware approaches including Scene Representation Networks (SRN) (Sitzmann et al., [2019])), PixelNeRF (Yu et al., [2021])), and the recent VisionNeRF (Lin et al., [2022])).\nWe include standard metrics in the literature: peak signal-to-noise-ratio (PSNR), structural similarity (SSIM) (Wang et al., [2004])), and the Fr\\\\a’echet Inception Distance (FID) (Heusel et al., [2017])). To remain consistent with prior work, we evaluate over all scenes in the held-out dataset (each has 251 views), conditioning our models on a single view (view #64) to produce all other 250 views via a single call to our sampler outlined in Section [2.2]D consistency via stochastic conditioning ‣ 2 Pose-conditional diffusion models ‣ Novel View Synthesis with Diffusion Models\"), and then report the average PSNR and SSIM. Importantly, FID scores were computed with this same number of views, comparing the set of all generated views against the set of all the ground truth views. Because prior work did not include FID scores, we acquire the evaluation image outputs of SRN, PixelNeRF and VisionNeRF and compute the scores ourselves. We reproduce PSNR scores, and carefully note that some of the models do not follow Wang et al. ( [2004])) on their SSIM computation (they use a uniform rather than Gaussian kernel), so we also recompute SSIM scores following (Wang et al., [2004])). For more details, including hyperparameter choices, see Supplementary Material (Sec. [7]Hyperparameters ‣ Novel View Synthesis with Diffusion Models\")).\n\n#### Out-of-distribution poses on SRN chairs\n\nWe note that the test split of the SRN ShapeNet chairs was unintentionally released with out-of-distribution poses compared to the train split: most test views are at a much larger distance to the object than those in the training dataset; we confirmed this via correspondence with the authors of Sitzmann et al. ( [2019])).\nBecause 3DiMs are geometry-free, we (unsurprisingly) observe that they do not perform well on this out-of-distribution evaluation task, as all the poses used at test-time are of scale never seen during training. However, simply merging, shuffling, and re-splitting the dataset completely fixes the issue.\nTo maintain comparability with prior work, results on SRN chairs in Table [1]Table 1 ‣ 3 Experiments ‣ Novel View Synthesis with Diffusion Models\") are those on the original dataset, and we denote the re-split dataset as “SRN chairs\\*” (note the \\*) in all subsequent tables to avoid confusion.\n\n#### State-of-the-art comparisons\n\nWhile 3DiM does not necessarily achieve superior reconstruction errors (PSNR and SSIM, see Table [1]Table 1 ‣ 3 Experiments ‣ Novel View Synthesis with Diffusion Models\")), qualitatively, we find that the fidelity of our generated videos can be strikingly better.\nThe use of diffusion models allows us to produce sharp samples, as opposed to regression models that are well-known to be prone to blurriness (Saharia et al., [2021b])) in spite of high PSNR and SSIM scores. This is why we introduce and evaluate FID scores.\nIn fact, we do not expect to achieve very low reconstruction errors due to the inherent ambiguity of novel view synthesis with a single image: constructing a consistent object with the given frame(s) is acceptable, but will still be punished by said reconstruction metrics if it differs from the ground truth views (even if achieving consistency).\nWe additionally refer the reader to Section [3.1]Ablation studies ‣ 3 Experiments ‣ Novel View Synthesis with Diffusion Models\"), where we include simple ablations demonstrating how worse models can improve the different standardized metrics in the literature. E.g., we show that with regression models, similarly to the baseline samples, PSNR and SSIM do not capture sharp modes well – they scores these models as much better despite the samples looking significantly more blurry (with PixelNeRF, which qualitatively seems the blurriest, achieving the best scores).\n\n### 3.1 Ablation studies\n\n|  | SRN cars | SRN chairs\\* |\n| --- | --- | --- |\n|  | PSNR (↑)↑(\\\\uparrow) | SSIM (↑)↑(\\\\uparrow) | FID (↓)↓(\\\\downarrow) | PSNR (↑)↑(\\\\uparrow) | SSIM (↑)↑(\\\\uparrow) | FID (↓)↓(\\\\downarrow) |\n| --- | --- | --- | --- | --- | --- | --- |\n| 3DiM | 21.01 | 0.57 | 8.99 | 14.29 | 0.48 | 3.30 |\n| \\+ no stochastic conditioning | 23.82 | 0.59 | 1.87 | 15.73 | 0.51 | 1.05 |\n| \\+ regression | 22.55 | 0.85 | 17.45 | 16.85 | 0.76 | 20.70 |\n\nTable 2: Ablation – study removing stochastic conditioning and diffusion altogether from 3DiM. Results are included for novel view synthesis from a single image on the SRN ShapeNet benchmark. (\\*) Re-split chairs dataset as detailed in Section [3]Experiments ‣ Novel View Synthesis with Diffusion Models\") – not comparable to numbers in Table [1]Table 1 ‣ 3 Experiments ‣ Novel View Synthesis with Diffusion Models\").\n\nWe now present some ablation studies on 3DiM. First, we remove our proposed sampler and use a naïve image-to-image model as discussed at the start of Section [2.2]D consistency via stochastic conditioning ‣ 2 Pose-conditional diffusion models ‣ Novel View Synthesis with Diffusion Models\"). We additionally remove the use of a diffusion process altogether, i.e., a regression model that generates samples via a single denoising step.\nNaturally, the regression models are trained separately, but we can still use an identical architecture, always feeding white noise for one frame, along with its corresponding noise level λminsubscript𝜆min\\\\lambda\\_{\\\\textrm{min}}. Results are included in Table [2]Table 2 ‣ 3.1 Ablation studies ‣ 3 Experiments ‣ Novel View Synthesis with Diffusion Models\") and samples are included in Figure [6]Figure 6 ‣ Table 3 ‣ 3.1 Ablation studies ‣ 3 Experiments ‣ Novel View Synthesis with Diffusion Models\").\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n| Input view | 3DiM | Image-to-Image | Concat-UNet | Regression |\n\n![[Uncaptioned image]]\n\n|     |     |     |\n| --- | --- | --- |\n| ![[Uncaptioned image]] | ![[Uncaptioned image]] | ![[Uncaptioned image]]![[Uncaptioned image]] |\n| ![[Uncaptioned image]] | ![[Uncaptioned image]] | ![[Uncaptioned image]]![[Uncaptioned image]] |\n\nFigure 6: Ablations – Example input and output views of 3DiM ablations on the SRN chairs dataset at the 128x128 resolution. The second “Image-to-Image” column corresponds to removing our stochastic conditioning sampler from Section [2.2]D consistency via stochastic conditioning ‣ 2 Pose-conditional diffusion models ‣ Novel View Synthesis with Diffusion Models\"). The third “Concat-UNet” column corresponds to removing our proposed architecture in Section [2.3]X-UNet ‣ 2 Pose-conditional diffusion models ‣ Novel View Synthesis with Diffusion Models\"), resorting to a UNet that concatenates both images along the channel axis instead of weight sharing over frames. The fourth “Regression” column is one-step diffusion model trained from scratch.\n\n|  | cars | chairs\\* |\n| --- | --- | --- |\n|  | PSNR (↑)↑(\\\\uparrow) | SSIM (↑)↑(\\\\uparrow) | FID (↓)↓(\\\\downarrow) | PSNR (↑)↑(\\\\uparrow) | SSIM (↑)↑(\\\\uparrow) | FID (↓)↓(\\\\downarrow) |\n| Concat-UNet | 17.21 | 0.52 | 21.54 | 12.36 | 0.44 | 5.15 |\n| X-UNet | 21.01 | 0.57 | 8.99 | 14.29 | 0.48 | 3.30 |\n\nTable 3: Architecture comparison – study comparing the X-UNet and Concat-UNet neural architectures. Results are included for novel view synthesis from a single image on the SRN ShapeNet benchmark, with the re-split chairs as detailed in Section [3]Experiments ‣ Novel View Synthesis with Diffusion Models\"). (\\*) Re-split chairs dataset as detailed in Section [3]Experiments ‣ Novel View Synthesis with Diffusion Models\") – these numbers are not comparable to those in Table [1]Table 1 ‣ 3 Experiments ‣ Novel View Synthesis with Diffusion Models\").\n\nUnsurprisingly, we find that both of these components are crucial to achieve good results. The use of many diffusion steps allows sampling sharp images that achieve much better (lower) FID scores than both prior work and the regression models, where in both cases, reconstructions appear blurry. Notably, the regression models achieve better PSNR and SSIM scores than 3DiM despite the severe blurriness, suggesting that these standardized metrics fail to meaningfully capture sample quality for geometry-free models, at least when comparing them to geometry-aware or non-stochastic reconstruction approaches. Similarly, FID also has a failure mode: naïve image-to-image sampling improves (decreases) FID scores significantly, but severely worsens shape and texture inconsistencies between sampled frames.\nThese findings suggest that none of these standardized metrics are sufficient to effectively evaluate geometry-free models for view synthesis; nevertheless, we observe that said metrics do correlate well with sample quality across 3DiMs and can still be useful indicators for hyperparameter tuning despite their individual failures.\n\n### 3.2 UNet Architecture Comparisons\n\nIn order to demonstrate the benefit of our proposed modifications, we additionally compare our proposed X-UNet architecture from Section [2.3]X-UNet ‣ 2 Pose-conditional diffusion models ‣ Novel View Synthesis with Diffusion Models\") to the simpler UNet architecture following Saharia et al. ( [2021b]); [a])) (which we simply call “Concat-UNet”).\nThe Concat-UNet architecture, unlike ours, does not share weights across frames; instead, it simply concatenates the conditioning image to the noisy input image along the channel axis.\nTo do this comparison, we train 3DiMs on the Concat-UNet architecture with the same number of hidden channels, and keep all other hyperparameters identical. Because our architecture has the additional cross-attention layer at the coarse-resolution blocks, our architecture has a slightly larger number of parameters than the Concat-UNet (∼similar-to\\\\sim471M v.s. ∼similar-to\\\\sim421M).\nResults are included in Table [3]Table 3 ‣ 3.1 Ablation studies ‣ 3 Experiments ‣ Novel View Synthesis with Diffusion Models\") and Figure [6]Figure 6 ‣ Table 3 ‣ 3.1 Ablation studies ‣ 3 Experiments ‣ Novel View Synthesis with Diffusion Models\").\n\nWhile the Concat-UNet architecture is able to sample frames that resemble the data distribution, we find that 3DiMs trained with our proposed X-UNet architecture suffer much less from 3D inconsistency and alignment to the conditioning frame. Moreover, while the metrics should be taken with a grain of salt as previously discussed, we find that all the metrics significantly worsen with the Concat-UNet. We hypothesize that our X-UNet architecture better exploits symmetries between frames and poses due to our proposed weight-sharing mechanism, and that the cross-attention helps significantly to align with the content of the conditioning view.",
            "citations": null
          },
          "4 Evaluating 3D consistency in geometry-free view synthesis": {
            "content": "As we demonstrate in Sections [3.1]Ablation studies ‣ 3 Experiments ‣ Novel View Synthesis with Diffusion Models\") and [3.2]UNet Architecture Comparisons ‣ 3 Experiments ‣ Novel View Synthesis with Diffusion Models\"), the standardized metrics in the literature have failure modes when specifically applied to geometry-free novel view synthesis models, e.g., their inability to successfully measure 3D consistency, and the possibility of improving them with worse models. Leveraging the fact that volumetric rendering of colored density fields are 3D-consistent by design, we thus propose an additional evaluation scheme called “3D consistency scoring”.\nOur metrics should satisfy the following desiderata:\n\n1. 1.\n\n\nThe metric must penalize outputs that are not 3D consistent.\n\n2. 2.\n\n\nThe metric must not penalize outputs that are 3D consistent but deviate from the ground truth.\n\n3. 3.\n\n\nThe metric must penalize outputs that do not align with the conditioning view(s).\n\n\nIn order to satisfy the second requirement, we cannot compare output renders to ground-truth views.\nThus, one straightforward way to satisfy all desiderata is to sample many views from the geometry-free model given a single view, train a NeRF-like neural field (Mildenhall et al., [2020])) on a fraction of these views, and compute a set of metrics that compare neural field renders on the remaining views.\nThis way, if the geometry-free model outputs inconsistent views, the training of neural field will be hindered and classical image evaluation metrics should clearly reflect this.\nAdditionally, to enforce the third requirement, we simply include the conditioning view(s) that were used to generate the rest as part of the training data.\nWe report PSNR, SSIM and FID on the held-out views, although one could use other metrics under our proposed evaluation scheme.\n\n| Training view source | SRN cars | SRN chairs\\* |\n| --- | --- | --- |\n| PSNR (↑)↑(\\\\uparrow) | SSIM (↑)↑(\\\\uparrow) | FID (↓)↓(\\\\downarrow) | PSNR (↑)↑(\\\\uparrow) | SSIM (↑)↑(\\\\uparrow) | FID (↓)↓(\\\\downarrow) |\n| Original data (3D consistent) | 28.21 | 0.96 | 10.57 | 24.87 | 0.93 | 17.05 |\n| 3DiM (∼similar-to\\\\sim1.3B params) | 28.48 | 0.96 | 29.55 | 22.90 | 0.86 | 58.61 |\n| 3DiM (∼similar-to\\\\sim471M params) | 28.53 | 0.96 | 22.09 | 18.84 | 0.79 | 98.78 |\n| \\+ no stochastic conditioning | 25.78 | 0.94 | 30.51 | 17.61 | 0.75 | 116.16 |\n\nTable 4: 3D consistency scores – For neural fields trained with different view sources, we compare renders to held-out views from the same sources.\n\nWe evaluate 3DiMs on the SRN benchmark, and for comparison, we additionally include metrics for models trained on (1) the real test views and (2) on image-to-image samples from the 3DiMs, i.e., without our proposed sampler like we reported in Section [2]Table 2 ‣ 3.1 Ablation studies ‣ 3 Experiments ‣ Novel View Synthesis with Diffusion Models\"). To maintain comparability, we sample the same number of views from the different 3DiMs we evaluate in this section, all at the same poses and conditioned on the same single views. We leave out 10% of the test views (25 out of 251) from neural field training, picking 25 random indices once and maintaining this choice of indices for all subsequent evaluations. We also train models with more parameters (∼similar-to\\\\sim1.3B) in order to investigate whether increasing model capacity can further improve 3D consistency. See Supplementary Material (Sec. [7]Hyperparameters ‣ Novel View Synthesis with Diffusion Models\")) for more details on the neural fields we chose and their hyperparameters.\n\nWe find that our proposed evaluation scheme clearly punishes 3D inconsistency as desired – the neural fields trained on image-to-image 3DiM samples have worse scores across all metrics compared to neural fields trained on 3DiM outputs sampled via our stochastic conditioning.\nThis helps quantify the value of our proposed sampler, and also prevents the metrics from punishing reasonable outputs that are coherent with the input view(s) but do not match the target views – a desirable property due to the stochasticity of generative models. Moreover, we qualitatively find that the smaller model reported in the rest of the paper is comparable in quality to the ∼similar-to\\\\sim1.3B parameter model on cars, though on chairs, we do observe a significant improvement on 3D consistency in our samples. Importantly, 3D consistency scoring agrees with our qualitative observations.",
            "citations": null
          },
          "5 Conclusion and future work": {
            "content": "We propose 3DiM, a diffusion model for 3D novel view synthesis. Combining improvements in our X-UNet neural architecture (Section [2.3]X-UNet ‣ 2 Pose-conditional diffusion models ‣ Novel View Synthesis with Diffusion Models\")), with our novel stochastic conditioning sampling strategy that enables autoregressive generation over frames (Section [2.2]D consistency via stochastic conditioning ‣ 2 Pose-conditional diffusion models ‣ Novel View Synthesis with Diffusion Models\")), we show that from as few as a single image we can generate approximately 3D consistent views with very sharp sample quality. We additionally introduce 3D consistency scoring to evaluate the 3D consistency of geometry-free generative models by training neural fields on model output views, as their performance will be hindered increasingly with inconsistent training data (Section [4]Evaluating 3D consistency in geometry-free view synthesis ‣ Novel View Synthesis with Diffusion Models\")). We thus show, both quantitatively and visually, that 3DiMs with stochastic conditioning can achieve 3D consistency and high sample quality simultaneously, and how classical metrics fail to capture both sharp modes and 3D inconsistency.\n\nWe are most excited about the possibility of applying 3DiM, which can model entire datasets with a single model, to the largest 3D datasets from the real world – though more research is required to handle noisy poses, varying focal lengths, and other challenges such datasets impose. Developing an end-to-end approach for high-quality generation that is 3D consistent by design (Poole et al., [2022])) also remains an important direction to explore for image-to-3D media generation.",
            "citations": null
          },
          "6 Architecture details": {
            "content": "In order to maximize the reproducibility of our results, we provide code in JAX (Bradbury et al., [2021])) for our proposed X-UNet neural architecture from Section [2.3]X-UNet ‣ 2 Pose-conditional diffusion models ‣ Novel View Synthesis with Diffusion Models\"). Assuming we have an input batch with elements each containing\n\n[⬇](data:text/plain;base64,CnsKInoiLCAjIG5vaXN5IGlucHV0IGltYWdlIChIeFd4MyB0ZW5zb3IpCiJ4IiwgIyBjb25kaXRpb25pbmcgdmlldyAoSHhXeDMgdGVuc29yKQoibG9nc25yIiwgIyBsb2cgc2lnbmFsLXRvLW5vaXNlIHJhdGlvIG9mIG5vaXN5IGltYWdlIChzY2FsYXIpCiJ0IiwgIyBjYW1lcmEgcG9zaXRpb25zICh0d28gM2QgdmVjdG9ycykKIlIiLCAjIGNhbWVyYSByb3RhdGlvbnMgKHR3byAzeDMgbWF0cmljZXMpCiJLIiwgIyBjYW1lcmEgaW50cmluc2ljcyAoYS5rLmEuIGNhbGlicmF0aW9uIG1hdHJpeCkgKDN4MyBtYXRyaXgpCn0K)\n\n{\n\n”z”,#noisyinputimage(HxWx3tensor)\n\n”x”,#conditioningview(HxWx3tensor)\n\n”logsnr”,#logsignal-to-noiseratioofnoisyimage(scalar)\n\n”t”,#camerapositions(two3dvectors)\n\n”R”,#camerarotations(two3x3matrices)\n\n”K”,#cameraintrinsics(a.k.a.calibrationmatrix)(3x3matrix)\n\n}\n\nour neural network module is as follows:\n\n[⬇](data:text/plain;base64,CmZyb20gdHlwaW5nIGltcG9ydCBPcHRpb25hbApccGFyaW1wb3J0IGZsYXgubGluZW4gYXMgbm4KaW1wb3J0IGpheAppbXBvcnQgamF4Lm51bXB5IGFzIGpucAppbXBvcnQgbnVtcHkgYXMgb25wCmltcG9ydCB2aXN1M2QgYXMgdjNkClxwYXJccGFybm9ubGluZWFyaXR5ID0gbm4uc3dpc2gKXHBhclxwYXJkZWYgb3V0X2luaXRfc2NhbGUoKToKcmV0dXJuIG5uLmluaXRpYWxpemVycy52YXJpYW5jZV9zY2FsaW5nKDAuLCAnZmFuX2luJywgJ3RydW5jYXRlZF9ub3JtYWwnKQpccGFyXHBhcmRlZiBuZWFyZXN0X25laWdoYm9yX3Vwc2FtcGxlKGgpOgpCLCBGLCBILCBXLCBDID0gaC5zaGFwZQpoID0gaC5yZXNoYXBlKEIsIEYsIEgsIDEsIFcsIDEsIEMpCmggPSBqbnAuYnJvYWRjYXN0X3RvKGgsIChCLCBGLCBILCAyLCBXLCAyLCBDKSkKcmV0dXJuIGgucmVzaGFwZShCLCBGLCBIICogMiwgVyAqIDIsIEMpClxwYXJccGFyZGVmIGF2Z3Bvb2xfZG93bnNhbXBsZShoLCBrPTIpOgpyZXR1cm4gbm4uYXZnX3Bvb2woaCwgKDEsIGssIGspLCAoMSwgaywgaykpClxwYXJccGFyZGVmIHBvc2VuY19kZHBtKHRpbWVzdGVwcywgZW1iX2NoOiBpbnQsIG1heF90aW1lPTEwMDAuLApkdHlwZT1qbnAuZmxvYXQzMik6CiIiIlBvc2l0aW9uYWwgZW5jb2RpbmdzIGZvciBub2lzZSBsZXZlbHMsIGZvbGxvd2luZyBERFBNLiIiIgojIDEwMDAgaXMgdGhlIG1hZ2ljIG51bWJlciBmcm9tIEREUE0uIFdpdGggZGlmZmVyZW50IHRpbWVzdGVwcywgd2UKIyBub3JtYWxpemUgYnkgdGhlIG51bWJlciBvZiBzdGVwcyBidXQgc3RpbGwgbXVsdGlwbHkgYnkgMTAwMC4KdGltZXN0ZXBzICo9ICgxMDAwLiAvIG1heF90aW1lKQpoYWxmX2RpbSA9IGVtYl9jaCAvLyAyCiMgMTAwMDAgaXMgdGhlIG1hZ2ljIG51bWJlciBmcm9tIHRyYW5zZm9ybWVycy4KZW1iID0gb25wLmxvZygxMDAwMCkgLyAoaGFsZl9kaW0gLSAxKQplbWIgPSBqbnAuZXhwKGpucC5hcmFuZ2UoaGFsZl9kaW0sIGR0eXBlPWR0eXBlKSAqIC1lbWIpCmVtYiA9IGVtYi5yZXNoYXBlKCooWzFdICogKHRpbWVzdGVwcy5uZGltIC0gMSkpLCBlbWIuc2hhcGVbLTFdKQplbWIgPSB0aW1lc3RlcHMuYXN0eXBlKGR0eXBlKVsuLi4sIE5vbmVdICogZW1iCmVtYiA9IGpucC5jb25jYXRlbmF0ZShbam5wLnNpbihlbWIpLCBqbnAuY29zKGVtYildLCBheGlzPS0xKQpyZXR1cm4gZW1iClxwYXJccGFyZGVmIHBvc2VuY19uZXJmKHgsIG1pbl9kZWc9MCwgbWF4X2RlZz0xNSk6CiIiIkNvbmNhdGVuYXRlIHggYW5kIGl0cyBwb3NpdGlvbmFsIGVuY29kaW5ncywgZm9sbG93aW5nIE5lUkYuIiIiCmlmIG1pbl9kZWcgPT0gbWF4X2RlZzoKcmV0dXJuIHgKc2NhbGVzID0gam5wLmFycmF5KFsyKippIGZvciBpIGluIHJhbmdlKG1pbl9kZWcsIG1heF9kZWcpXSkKeGIgPSBqbnAucmVzaGFwZSgKKHhbLi4uLCBOb25lLCA6XSAqIHNjYWxlc1s6LCBOb25lXSksIGxpc3QoeC5zaGFwZVs6LTFdKSArIFstMV0pCmVtYiA9IGpucC5zaW4oam5wLmNvbmNhdGVuYXRlKFt4YiwgeGIgKyBvbnAucGkgLyAyLl0sIGF4aXM9LTEpKQpyZXR1cm4gam5wLmNvbmNhdGVuYXRlKFt4LCBlbWJdLCBheGlzPS0xKQpccGFyXHBhcmNsYXNzIEdyb3VwTm9ybShubi5Nb2R1bGUpOgoiIiJHcm91cCBub3JtYWxpemF0aW9uLCBhcHBsaWVkIG92ZXIgZnJhbWVzLiIiIgpccGFyQG5uLmNvbXBhY3QKZGVmIF9fY2FsbF9fKHNlbGYsIGgpOgpCLCBfLCBILCBXLCBDID0gaC5zaGFwZQpoID0gbm4uR3JvdXBOb3JtKG51bV9ncm91cHM9MzIpKGgucmVzaGFwZShCICogMiwgRiwgSCwgVywgQykpCnJldHVybiBoLnJlc2hhcGUoQiwgMiwgSCwgVywgQykKXHBhclxwYXJjbGFzcyBGaUxNKG5uLk1vZHVsZSk6CiIiIkZlYXR1cmUtd2lzZSBsaW5lYXIgbW9kdWxhdGlvbi4iIiIKZmVhdHVyZXM6IGludApccGFyQG5uLmNvbXBhY3QKZGVmIF9fY2FsbF9fKHNlbGYsIGgsIGVtYik6CmVtYiA9IG5uLkRlbnNlKDIgKiBzZWxmLmZlYXR1cmVzKShub25saW5lYXJpdHkoZW1iKSkKc2NhbGUsIHNoaWZ0ID0gam5wLnNwbGl0KGVtYiwgMiwgYXhpcz0tMSkKcmV0dXJuIGggKiAoMS4gKyBzY2FsZSkgKyBzaGlmdApccGFyXHBhcmNsYXNzIFJlc25ldEJsb2NrKG5uLk1vZHVsZSk6CiIiIkJpZ0dBTi1zdHlsZSByZXNpZHVhbCBibG9jaywgYXBwbGllZCBvdmVyIGZyYW1lcy4iIiIKZmVhdHVyZXM6IE9wdGlvbmFsW2ludF0gPSBOb25lCmRyb3BvdXQ6IGZsb2F0ID0gMC4KcmVzYW1wbGU6IE9wdGlvbmFsW3N0cl0gPSBOb25lClxwYXJAbm4uY29tcGFjdApkZWYgX19jYWxsX18oc2VsZiwgaF9pbiwgZW1iLCAqLCB0cmFpbjogYm9vbCk6CkIsIF8sIF8sIF8sIEMgPSBoLnNoYXBlCmZlYXR1cmVzID0gQyBpZiBzZWxmLmZlYXR1cmVzIGlzIE5vbmUgZWxzZSBzZWxmLmZlYXR1cmVzClxwYXJoID0gbm9ubGluZWFyaXR5KEdyb3VwTm9ybSgpKGhfaW4pKQppZiBzZWxmLnJlc2FtcGxlIGlzIG5vdCBOb25lOgp1cGRvd24gPSB7Cid1cCc6IG5lYXJlc3RfbmVpZ2hib3JfdXBzYW1wbGUsCidkb3duJzogYXZncG9vbF9kb3duc2FtcGxlLAp9W3NlbGYucmVzYW1wbGVdClxwYXJoID0gbm4uQ29udigKZmVhdHVyZXMsIGtlcm5lbF9zaXplPSgxLCAzLCAzKSwgc3RyaWRlcz0oMSwgMSwgMSkpKGgpCmggPSBGaUxNKGZlYXR1cmVzPWZlYXR1cmVzKShHcm91cE5vcm0oKShoKSwgZW1iKQpoID0gbm9ubGluZWFyaXR5KGgpCmggPSBubi5Ecm9wb3V0KHJhdGU9c2VsZi5kcm9wb3V0KShoLCBkZXRlcm1pbmlzdGljPW5vdCB0cmFpbikKaCA9IG5uLkNvbnYoCmZlYXR1cmVzLAprZXJuZWxfc2l6ZT0oMSwgMywgMyksCnN0cmlkZXM9KDEsIDEsIDEpLAprZXJuZWxfaW5pdD1vdXRfaW5pdF9zY2FsZSgpKShoKQpccGFyaWYgQyAhPSBmZWF0dXJlczoKaF9pbiA9IG5uLkRlbnNlKGZlYXR1cmVzKShoX2luKQpyZXR1cm4gKGggKyBoX2luKSAvIG9ucC5zcXJ0KDIpClxwYXJccGFyY2xhc3MgQXR0bkxheWVyKG5uLk1vZHVsZSk6CmF0dG5faGVhZHM6IGludCA9IDQKXHBhckBubi5jb21wYWN0CmRlZiBfX2NhbGxfXyhzZWxmLCAqLCBxLCBrdik6CkMgPSBxLnNoYXBlWy0xXQpoZWFkX2RpbSA9IEMgLy8gc2VsZi5hdHRuX2hlYWRzCnEgPSBubi5EZW5zZUdlbmVyYWwoKHNlbGYuYXR0bl9oZWFkcywgaGVhZF9kaW0pKShxKQprID0gbm4uRGVuc2VHZW5lcmFsKChzZWxmLmF0dG5faGVhZHMsIGhlYWRfZGltKSkoa3YpCnYgPSBubi5EZW5zZUdlbmVyYWwoKHNlbGYuYXR0bl9oZWFkcywgaGVhZF9kaW0pKShrdikKcmV0dXJuIG5uLmRvdF9wcm9kdWN0X2F0dGVudGlvbihxLCBrLCB2KQpccGFyXHBhcmNsYXNzIEF0dG5CbG9jayhubi5Nb2R1bGUpOgphdHRuX3R5cGU6IHN0cgphdHRuX2hlYWRzOiBpbnQgPSA0ClxwYXJAbm4uY29tcGFjdApkZWYgX19jYWxsX18oc2VsZiwgaF9pbik6CkIsIF8sIEgsIFcsIEMgPSBoLnNoYXBlClxwYXJoID0gR3JvdXBOb3JtKCkoaF9pbikKaDAgPSBoWzosIDBdLnJlc2hhcGUoQiwgSCAqIFcsIEMpCmgxID0gaFs6LCAxXS5yZXNoYXBlKEIsIEggKiBXLCBDKQphdHRuX2xheWVyID0gQXR0bkxheWVyKGF0dG5faGVhZHM9c2VsZi5hdHRuX2hlYWRzKQpccGFyaWYgc2VsZi5hdHRuX3R5cGUgPT0gJ3NlbGYnOgpoMCA9IGF0dG5fbGF5ZXIocT1oMCwga3Y9aDApCmgxID0gYXR0bl9sYXllcihxPWgxLCBrdj1oMSkKZWxpZiBzZWxmLmF0dG5fdHlwZSA9PSAnY3Jvc3MnOgpoMCA9IGF0dG5fbGF5ZXIocT1oMCwga3Y9aDEpCmgxID0gYXR0bl9sYXllcihxPWgxLCBrdj1oMCkKZWxzZToKcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihzZWxmLmF0dG5fdHlwZSkKXHBhcmggPSBqbnAuc3RhY2soW2gwLCBoMV0sIGF4aXM9MSkKaCA9IGgucmVzaGFwZShCLCBGLCBILCBXLCAtMSkKaCA9IG5uLkRlbnNlR2VuZXJhbCgKQywgYXhpcz0oLTIsIC0xKSwga2VybmVsX2luaXQ9b3V0X2luaXRfc2NhbGUoKSkoaCkKcmV0dXJuIChoICsgaF9pbikgLyBvbnAuc3FydCgyKQpccGFyXHBhcmNsYXNzIFhVTmV0QmxvY2sobm4uTW9kdWxlKToKZmVhdHVyZXM6IGludAp1c2VfYXR0bjogYm9vbCA9IEZhbHNlCmF0dG5faGVhZHM6IGludCA9IDQKZHJvcG91dDogZmxvYXQgPSAwLgpccGFyQG5uLmNvbXBhY3QKZGVmIF9fY2FsbF9fKHNlbGYsIHgsIGVtYiwgKiwgdHJhaW46IGJvb2wpOgpoID0gUmVzbmV0QmxvY2soCmZlYXR1cmVzPXNlbGYuZmVhdHVyZXMsCmRyb3BvdXQ9c2VsZi5kcm9wb3V0KSh4LCBlbWIsIHRyYWluPXRyYWluKQpccGFyaWYgc2VsZi51c2VfYXR0bjoKaCA9IEF0dG5CbG9jaygKYXR0bl90eXBlPSdzZWxmJywgYXR0bl9oZWFkcz1zZWxmLmF0dG5faGVhZHMpKGgpCmggPSBBdHRuQmxvY2soCmF0dG5fdHlwZT0nY3Jvc3MnLCBhdHRuX2hlYWRzPXNlbGYuYXR0bl9oZWFkcykoaCkKXHBhcnJldHVybiBoClxwYXJccGFyY2xhc3MgQ29uZGl0aW9uaW5nUHJvY2Vzc29yKG5uLk1vZHVsZSk6CiIiIlByb2Nlc3MgY29uZGl0aW9uaW5nIGlucHV0cyBpbnRvIGVtYmVkZGluZ3MuIiIiCmVtYl9jaDogaW50Cm51bV9yZXNvbHV0aW9uczogaW50CnVzZV9wb3NfZW1iOiBib29sID0gVHJ1ZQp1c2VfcmVmX3Bvc2VfZW1iOiBib29sID0gVHJ1ZQpccGFyQG5uLmNvbXBhY3QKZGVmIF9fY2FsbF9fKHNlbGYsIGJhdGNoLCBjb25kX21hc2spOgpCLCBILCBXLCBDID0gYmF0Y2hbJ3gnXS5zaGFwZQpccGFyIyBMb2cgc2lnbmFsLXRvLW5vaXNlLXJhdGlvIGVtYmVkZGluZy4KbG9nc25yID0gam5wLmNsaXAoYmF0Y2hbJ2xvZ3NuciddLCAtMjAuLCAyMC4pCmxvZ3NuciA9IDIuICogam5wLmFyY3RhbihqbnAuZXhwKC1sb2dzbnIgLyAyLikpIC8gb25wLnBpCmxvZ3Nucl9lbWIgPSBwb3NlbmNfZGRwbShsb2dzbnIsIGVtYl9jaD1zZWxmLmVtYl9jaCwgbWF4X3RpbWU9MS4pCmxvZ3Nucl9lbWIgPSBubi5EZW5zZShzZWxmLmVtYl9jaCkobG9nc25yX2VtYikKbG9nc25yX2VtYiA9IG5uLkRlbnNlKHNlbGYuZW1iX2NoKShub25saW5lYXJpdHkobG9nc25yX2VtYikpClxwYXIjIFBvc2UgZW1iZWRkaW5ncy4Kd29ybGRfZnJvbV9jYW0gPSB2M2QuVHJhbnNmb3JtKFI9YmF0Y2hbJ1InXSwgdD1iYXRjaFsndCddKQpjYW1fc3BlYyA9IHYzZC5QaW5ob2xlQ2FtZXJhKHJlc29sdXRpb249KEgsIFcpLCBLPWJhdGNoWydLJ10pCnJheXMgPSB2M2QuQ2FtZXJhKApzcGVjPWNhbV9zcGVjLCB3b3JsZF9mcm9tX2NhbT13b3JsZF9mcm9tX2NhbSkucmF5cygpClxwYXJwb3NlX2VtYl9wb3MgPSBwb3NlbmNfbmVyZihyYXlzLnBvcywgbWluX2RlZz0wLCBtYXhfZGVnPTE1KQpwb3NlX2VtYl9kaXIgPSBwb3NlbmNfbmVyZihyYXlzLmRpciwgbWluX2RlZz0wLCBtYXhfZGVnPTgpCnBvc2VfZW1iID0gam5wLmNvbmNhdGVuYXRlKFtwb3NlX2VtYl9wb3MsIHBvc2VfZW1iX2Rpcl0sIGF4aXM9LTEpClxwYXIjIEVuYWJsZSBjbGFzc2lmaWVyLWZyZWUgZ3VpZGFuY2Ugb3ZlciBwb3Nlcy4KRCA9IHBvc2VfZW1iLnNoYXBlWy0xXQphc3NlcnQgY29uZF9tYXNrLnNoYXBlID09IChCLCkKY29uZF9tYXNrID0gY29uZF9tYXNrWzosIE5vbmUsIE5vbmUsIE5vbmUsIE5vbmVdCnBvc2VfZW1iID0gam5wLndoZXJlKGNvbmRfbWFzaywgcG9zZV9lbWIsIGpucC56ZXJvc19saWtlKHBvc2VfZW1iKSkKXHBhciMgTGVhcm5hYmxlIHBvc2l0aW9uIGVtYmVkZGluZ3Mgb3ZlciAoSCwgVykgb2YgZnJhbWVzIChvcHRpb25hbCkuCmlmIHNlbGYudXNlX3Bvc19lbWI6CnBvc19lbWIgPSBzZWxmLnBhcmFtKAoncG9zX2VtYicsCm5uLmluaXRpYWxpemVycy5ub3JtYWwoc3RkZGV2PTEuIC8gb25wLnNxcnQoRCkpLAooSCwgVywgRCksCnBvc2VfZW1iLmR0eXBlKQpwb3NlX2VtYiArPSBwb3NfZW1iW05vbmUsIE5vbmVdClxwYXIjIEJpbmFyeSBlbWJlZGRpbmcgdG8gbGV0IHRoZSBtb2RlbCBkaXN0aW5ndWlzaCBmcmFtZXMgKG9wdGlvbmFsKS4KaWYgc2VsZi51c2VfcmVmX3Bvc2VfZW1iCmZpcnN0X2VtYiA9IHNlbGYucGFyYW0oCidyZWZfcG9zZV9lbWJfZmlyc3QnLApubi5pbml0aWFsaXplcnMubm9ybWFsKHN0ZGRldj0xLiAvIG9ucC5zcXJ0KEQpKSwKKEQsKSwKcG9zZV9lbWIuZHR5cGUpW05vbmUsIE5vbmUsIE5vbmUsIE5vbmVdClxwYXJvdGhlcl9lbWIgPSBzZWxmLnBhcmFtKAoncmVmX3Bvc2VfZW1iX290aGVyJywKbm4uaW5pdGlhbGl6ZXJzLm5vcm1hbChzdGRkZXY9MS4gLyBvbnAuc3FydChEKSksCihELCksCnBvc2VfZW1iLmR0eXBlKVtOb25lLCBOb25lLCBOb25lLCBOb25lXQpccGFycG9zZV9lbWIgKz0gam5wLmNvbmNhdGVuYXRlKFtmaXJzdF9lbWIsIG90aGVyX2VtYl0sIGF4aXM9MSkKXHBhciMgRG93bnNhbXBsZSByYXkgZW1iZWRkaW5ncyBmb3IgZWFjaCBVTmV0IHJlc29sdXRpb24uCnBvc2VfZW1icyA9IFtdCmZvciBpX2xldmVsIGluIHJhbmdlKHNlbGYubnVtX3Jlc29sdXRpb25zKToKcG9zZV9lbWJzLmFwcGVuZChubi5Db252KApmZWF0dXJlcz1zZWxmLmVtYl9jaCwKa2VybmVsX3NpemU9KDEsIDMsIDMpLApzdHJpZGVzPSgxLCAyICoqIGlfbGV2ZWwsIDIgKiogaV9sZXZlbCkpKHBvc2VfZW1iKSkKXHBhcnJldHVybiBsb2dzbnJfZW1iLCBwb3NlX2VtYnMKXHBhclxwYXJjbGFzcyBYVU5ldChubi5Nb2R1bGUpOgoiIiJPdXIgcHJvcG9zZWQgWFVOZXQgYXJjaGl0ZWN0dXJlLiIiIgpjaDogaW50ID0gMjU2CmNoX211bHQ6IHR1cGxlW2ludF0gPSAoMSwgMiwgMiwgNCkKZW1iX2NoOiBpbnQgPSAxMDI0Cm51bV9yZXNfYmxvY2tzOiBpbnQgPSAzCmF0dG5fcmVzb2x1dGlvbnM6IHR1cGxlW2ludF0gPSAoOCwgMTYsIDMyKQphdHRuX2hlYWRzOiBpbnQgPSA0CmRyb3BvdXQ6IGZsb2F0ID0gMC4xCnVzZV9wb3NfZW1iOiBib29sID0gVHJ1ZQp1c2VfcmVmX3Bvc2VfZW1iOiBib29sID0gVHJ1ZQpccGFyQG5uLmNvbXBhY3QKZGVmIF9fY2FsbF9fKHNlbGYsIGJhdGNoOiBkaWN0W3N0ciwgam5wLm5kYXJyYXldLCAqLApjb25kX21hc2s6IGpucC5uZGFycmF5LCB0cmFpbjogYm9vbCk6CkIsIEgsIFcsIEMgPSBiYXRjaFsneCddLnNoYXBlCm51bV9yZXNvbHV0aW9ucyA9IGxlbihzZWxmLmNoX211bHQpClxwYXJsb2dzbnJfZW1iLCBwb3NlX2VtYnMgPSBDb25kaXRpb25pbmdQcm9jZXNzb3IoCmVtYl9jaD1zZWxmLmVtYl9jaCwKbnVtX3Jlc29sdXRpb25zPW51bV9yZXNvbHV0aW9ucywKdXNlX3Bvc19lbWI9c2VsZi51c2VfcG9zX2VtYiwKdXNlX3JlZl9wb3NlX2VtYj1zZWxmLnVzZV9yZWZfcG9zZV9lbWIpKGJhdGNoLCBjb25kX21hc2spCmRlbCBjb25kX21hc2sKXHBhcmggPSBqbnAuc3RhY2soW2JhdGNoWyd4J10sIGJhdGNoWyd6J11dLCBheGlzPTEpCmggPSBubi5Db252KHNlbGYuY2gsIGtlcm5lbF9zaXplPSgxLCAzLCAzKSwgc3RyaWRlcz0oMSwgMSwgMSkoaCkKXHBhciMgRG93bnNhbXBsaW5nLgpocyA9IFtoXQpmb3IgaV9sZXZlbCBpbiBzZWxmLmNoX211bHQ6CmVtYiA9IGxvZ3Nucl9lbWJbLi4uLCBOb25lLCBOb25lLCA6XSArIHBvc2VfZW1ic1tpX2xldmVsXQpccGFyZm9yIGlfYmxvY2sgaW4gcmFuZ2Uoc2VsZi5udW1fcmVzX2Jsb2Nrcyk6CnVzZV9hdHRuID0gaC5zaGFwZVsyXSBpbiBzZWxmLmF0dG5fcmVzb2x1dGlvbnMKaCA9IFhVTmV0QmxvY2soCmZlYXR1cmVzPXNlbGYuY2ggKiBzZWxmLmNoX211bHRbaV9sZXZlbF0sCmRyb3BvdXQ9c2VsZi5kcm9wb3V0LAphdHRuX2hlYWRzPXNlbGYuYXR0bl9oZWFkcywKdXNlX2F0dG49dXNlX2F0dG4pKGgsIGVtYiwgdHJhaW49dHJhaW4pCmhzLmFwcGVuZChoKQpccGFyaWYgaV9sZXZlbCAhPSBudW1fcmVzb2x1dGlvbnMgLSAxOgplbWIgPSBsb2dzbnJfZW1iWy4uLiwgTm9uZSwgTm9uZSwgOl0gKyBwb3NlX2VtYnNbaV9sZXZlbCArIDFdCmggPSBSZXNuZXRCbG9jayhkcm9wb3V0PXNlbGYuZHJvcG91dCwgcmVzYW1wbGU9J2Rvd24nKSgKaCwgZW1iLCB0cmFpbj10cmFpbikKaHMuYXBwZW5kKGgpClxwYXIjIE1pZGRsZS4KZW1iID0gbG9nc25yX2VtYlsuLi4sIE5vbmUsIE5vbmUsIDpdICsgcG9zZV9lbWJzWy0xXQp1c2VfYXR0biA9IGguc2hhcGVbMl0gaW4gc2VsZi5hdHRuX3Jlc29sdXRpb25zCmggPSBYVU5ldEJsb2NrKApmZWF0dXJlcz1zZWxmLmNoICogc2VsZi5jaF9tdWx0W2lfbGV2ZWxdLApkcm9wb3V0PXNlbGYuZHJvcG91dCwKYXR0bl9oZWFkcz1zZWxmLmF0dG5faGVhZHMsCnVzZV9hdHRuPXVzZV9hdHRuKShoLCBlbWIsIHRyYWluPXRyYWluKQpccGFyIyBVcHNhbXBsaW5nLgpmb3IgaV9sZXZlbCBpbiByZXZlcnNlZChyYW5nZShudW1fcmVzb2x1dGlvbnMpKToKZW1iID0gbG9nc25yX2VtYlsuLi4sIE5vbmUsIE5vbmUsIDpdICsgcG9zZV9lbWJzW2lfbGV2ZWxdClxwYXJmb3IgaV9ibG9jayBpbiByYW5nZShzZWxmLm51bV9yZXNfYmxvY2tzICsgMSk6CnVzZV9hdHRuID0gaHNbLTFdLnNoYXBlWzJdIGluIHNlbGYuYXR0bl9yZXNvbHV0aW9ucwpoID0gam5wLmNvbmNhdGVuYXRlKFtoLCBocy5wb3AoKV0sIGF4aXM9LTEpCmggPSBYVU5ldEJsb2NrKApmZWF0dXJlcz1zZWxmLmNoICogc2VsZi5jaF9tdWx0W2lfbGV2ZWxdLApkcm9wb3V0PXNlbGYuZHJvcG91dCwKYXR0bl9oZWFkcz1zZWxmLmF0dG5faGVhZHMsCnVzZV9hdHRuPXVzZV9hdHRuKShoLCBlbWIsIHRyYWluPXRyYWluKQpccGFyaWYgaV9sZXZlbCAhPSAwOgplbWIgPSBsb2dzbnJfZW1iWy4uLiwgTm9uZSwgTm9uZSwgOl0gKyBwb3NlX2VtYnNbaV9sZXZlbF0KaCA9IFJlc25ldEJsb2NrKGRyb3BvdXQ9c2VsZi5kcm9wb3V0LCByZXNhbXBsZT0ndXAnKSgKaCwgZW1iLCB0cmFpbj10cmFpbikKXHBhciMgRW5kLgphc3NlcnQgbm90IGhzCmggPSBub25saW5lYXJpdHkoR3JvdXBOb3JtKCkoaCkpCnJldHVybiBubi5Db252KApDLAprZXJuZWxfc2l6ZT0oMSwgMywgMyksCnN0cmlkZXM9KDEsIDEsIDEpLAprZXJuZWxfaW5pdD1vdXRfaW5pdF9zY2FsZSgpKShoKVs6LCAxXQpccGFyXHBhcg==)\n\nfromtypingimportOptional\n\n\\parimportflax.linenasnn\n\nimportjax\n\nimportjax.numpyasjnp\n\nimportnumpyasonp\n\nimportvisu3dasv3d\n\n\\par\\parnonlinearity=nn.swish\n\n\\par\\pardefout\\_init\\_scale():\n\nreturnnn.initializers.variance\\_scaling(0.,’fan\\_in’,’truncated\\_normal’)\n\n\\par\\pardefnearest\\_neighbor\\_upsample(h):\n\nB,F,H,W,C=h.shape\n\nh=h.reshape(B,F,H,1,W,1,C)\n\nh=jnp.broadcast\\_to(h,(B,F,H,2,W,2,C))\n\nreturnh.reshape(B,F,H\\*2,W\\*2,C)\n\n\\par\\pardefavgpool\\_downsample(h,k=2):\n\nreturnnn.avg\\_pool(h,(1,k,k),(1,k,k))\n\n\\par\\pardefposenc\\_ddpm(timesteps,emb\\_ch:int,max\\_time=1000.,\n\ndtype=jnp.float32):\n\n”””Positionalencodingsfornoiselevels,followingDDPM.”””\n\n#1000isthemagicnumberfromDDPM.Withdifferenttimesteps,we\n\n#normalizebythenumberofstepsbutstillmultiplyby1000.\n\ntimesteps\\*=(1000./max\\_time)\n\nhalf\\_dim=emb\\_ch//2\n\n#10000isthemagicnumberfromtransformers.\n\nemb=onp.log(10000)/(half\\_dim-1)\n\nemb=jnp.exp(jnp.arange(half\\_dim,dtype=dtype)\\*-emb)\n\nemb=emb.reshape(\\*(\\[1\\]\\*(timesteps.ndim-1)),emb.shape\\[-1\\])\n\nemb=timesteps.astype(dtype)\\[…,None\\]\\*emb\n\nemb=jnp.concatenate(\\[jnp.sin(emb),jnp.cos(emb)\\],axis=-1)\n\nreturnemb\n\n\\par\\pardefposenc\\_nerf(x,min\\_deg=0,max\\_deg=15):\n\n”””Concatenatexanditspositionalencodings,followingNeRF.”””\n\nifmin\\_deg==max\\_deg:\n\nreturnx\n\nscales=jnp.array(\\[2\\*\\*iforiinrange(min\\_deg,max\\_deg)\\])\n\nxb=jnp.reshape(\n\n(x\\[…,None,:\\]\\*scales\\[:,None\\]),list(x.shape\\[:-1\\])+\\[-1\\])\n\nemb=jnp.sin(jnp.concatenate(\\[xb,xb+onp.pi/2.\\],axis=-1))\n\nreturnjnp.concatenate(\\[x,emb\\],axis=-1)\n\n\\par\\parclassGroupNorm(nn.Module):\n\n”””Groupnormalization,appliedoverframes.”””\n\n\\par@nn.compact\n\ndef\\_\\_call\\_\\_(self,h):\n\nB,\\_,H,W,C=h.shape\n\nh=nn.GroupNorm(num\\_groups=32)(h.reshape(B\\*2,F,H,W,C))\n\nreturnh.reshape(B,2,H,W,C)\n\n\\par\\parclassFiLM(nn.Module):\n\n”””Feature-wiselinearmodulation.”””\n\nfeatures:int\n\n\\par@nn.compact\n\ndef\\_\\_call\\_\\_(self,h,emb):\n\nemb=nn.Dense(2\\*self.features)(nonlinearity(emb))\n\nscale,shift=jnp.split(emb,2,axis=-1)\n\nreturnh\\*(1.+scale)+shift\n\n\\par\\parclassResnetBlock(nn.Module):\n\n”””BigGAN-styleresidualblock,appliedoverframes.”””\n\nfeatures:Optional\\[int\\]=None\n\ndropout:float=0.\n\nresample:Optional\\[str\\]=None\n\n\\par@nn.compact\n\ndef\\_\\_call\\_\\_(self,h\\_in,emb,\\*,train:bool):\n\nB,\\_,\\_,\\_,C=h.shape\n\nfeatures=Cifself.featuresisNoneelseself.features\n\n\\parh=nonlinearity(GroupNorm()(h\\_in))\n\nifself.resampleisnotNone:\n\nupdown={\n\n’up’:nearest\\_neighbor\\_upsample,\n\n’down’:avgpool\\_downsample,\n\n}\\[self.resample\\]\n\n\\parh=nn.Conv(\n\nfeatures,kernel\\_size=(1,3,3),strides=(1,1,1))(h)\n\nh=FiLM(features=features)(GroupNorm()(h),emb)\n\nh=nonlinearity(h)\n\nh=nn.Dropout(rate=self.dropout)(h,deterministic=nottrain)\n\nh=nn.Conv(\n\nfeatures,\n\nkernel\\_size=(1,3,3),\n\nstrides=(1,1,1),\n\nkernel\\_init=out\\_init\\_scale())(h)\n\n\\parifC!=features:\n\nh\\_in=nn.Dense(features)(h\\_in)\n\nreturn(h+h\\_in)/onp.sqrt(2)\n\n\\par\\parclassAttnLayer(nn.Module):\n\nattn\\_heads:int=4\n\n\\par@nn.compact\n\ndef\\_\\_call\\_\\_(self,\\*,q,kv):\n\nC=q.shape\\[-1\\]\n\nhead\\_dim=C//self.attn\\_heads\n\nq=nn.DenseGeneral((self.attn\\_heads,head\\_dim))(q)\n\nk=nn.DenseGeneral((self.attn\\_heads,head\\_dim))(kv)\n\nv=nn.DenseGeneral((self.attn\\_heads,head\\_dim))(kv)\n\nreturnnn.dot\\_product\\_attention(q,k,v)\n\n\\par\\parclassAttnBlock(nn.Module):\n\nattn\\_type:str\n\nattn\\_heads:int=4\n\n\\par@nn.compact\n\ndef\\_\\_call\\_\\_(self,h\\_in):\n\nB,\\_,H,W,C=h.shape\n\n\\parh=GroupNorm()(h\\_in)\n\nh0=h\\[:,0\\].reshape(B,H\\*W,C)\n\nh1=h\\[:,1\\].reshape(B,H\\*W,C)\n\nattn\\_layer=AttnLayer(attn\\_heads=self.attn\\_heads)\n\n\\parifself.attn\\_type==’self’:\n\nh0=attn\\_layer(q=h0,kv=h0)\n\nh1=attn\\_layer(q=h1,kv=h1)\n\nelifself.attn\\_type==’cross’:\n\nh0=attn\\_layer(q=h0,kv=h1)\n\nh1=attn\\_layer(q=h1,kv=h0)\n\nelse:\n\nraiseNotImplementedError(self.attn\\_type)\n\n\\parh=jnp.stack(\\[h0,h1\\],axis=1)\n\nh=h.reshape(B,F,H,W,-1)\n\nh=nn.DenseGeneral(\n\nC,axis=(-2,-1),kernel\\_init=out\\_init\\_scale())(h)\n\nreturn(h+h\\_in)/onp.sqrt(2)\n\n\\par\\parclassXUNetBlock(nn.Module):\n\nfeatures:int\n\nuse\\_attn:bool=False\n\nattn\\_heads:int=4\n\ndropout:float=0.\n\n\\par@nn.compact\n\ndef\\_\\_call\\_\\_(self,x,emb,\\*,train:bool):\n\nh=ResnetBlock(\n\nfeatures=self.features,\n\ndropout=self.dropout)(x,emb,train=train)\n\n\\parifself.use\\_attn:\n\nh=AttnBlock(\n\nattn\\_type=’self’,attn\\_heads=self.attn\\_heads)(h)\n\nh=AttnBlock(\n\nattn\\_type=’cross’,attn\\_heads=self.attn\\_heads)(h)\n\n\\parreturnh\n\n\\par\\parclassConditioningProcessor(nn.Module):\n\n”””Processconditioninginputsintoembeddings.”””\n\nemb\\_ch:int\n\nnum\\_resolutions:int\n\nuse\\_pos\\_emb:bool=True\n\nuse\\_ref\\_pose\\_emb:bool=True\n\n\\par@nn.compact\n\ndef\\_\\_call\\_\\_(self,batch,cond\\_mask):\n\nB,H,W,C=batch\\[’x’\\].shape\n\n\\par#Logsignal-to-noise-ratioembedding.\n\nlogsnr=jnp.clip(batch\\[’logsnr’\\],-20.,20.)\n\nlogsnr=2.\\*jnp.arctan(jnp.exp(-logsnr/2.))/onp.pi\n\nlogsnr\\_emb=posenc\\_ddpm(logsnr,emb\\_ch=self.emb\\_ch,max\\_time=1.)\n\nlogsnr\\_emb=nn.Dense(self.emb\\_ch)(logsnr\\_emb)\n\nlogsnr\\_emb=nn.Dense(self.emb\\_ch)(nonlinearity(logsnr\\_emb))\n\n\\par#Poseembeddings.\n\nworld\\_from\\_cam=v3d.Transform(R=batch\\[’R’\\],t=batch\\[’t’\\])\n\ncam\\_spec=v3d.PinholeCamera(resolution=(H,W),K=batch\\[’K’\\])\n\nrays=v3d.Camera(\n\nspec=cam\\_spec,world\\_from\\_cam=world\\_from\\_cam).rays()\n\n\\parpose\\_emb\\_pos=posenc\\_nerf(rays.pos,min\\_deg=0,max\\_deg=15)\n\npose\\_emb\\_dir=posenc\\_nerf(rays.dir,min\\_deg=0,max\\_deg=8)\n\npose\\_emb=jnp.concatenate(\\[pose\\_emb\\_pos,pose\\_emb\\_dir\\],axis=-1)\n\n\\par#Enableclassifier-freeguidanceoverposes.\n\nD=pose\\_emb.shape\\[-1\\]\n\nassertcond\\_mask.shape==(B,)\n\ncond\\_mask=cond\\_mask\\[:,None,None,None,None\\]\n\npose\\_emb=jnp.where(cond\\_mask,pose\\_emb,jnp.zeros\\_like(pose\\_emb))\n\n\\par#Learnablepositionembeddingsover(H,W)offrames(optional).\n\nifself.use\\_pos\\_emb:\n\npos\\_emb=self.param(\n\n’pos\\_emb’,\n\nnn.initializers.normal(stddev=1./onp.sqrt(D)),\n\n(H,W,D),\n\npose\\_emb.dtype)\n\npose\\_emb+=pos\\_emb\\[None,None\\]\n\n\\par#Binaryembeddingtoletthemodeldistinguishframes(optional).\n\nifself.use\\_ref\\_pose\\_emb\n\nfirst\\_emb=self.param(\n\n’ref\\_pose\\_emb\\_first’,\n\nnn.initializers.normal(stddev=1./onp.sqrt(D)),\n\n(D,),\n\npose\\_emb.dtype)\\[None,None,None,None\\]\n\n\\parother\\_emb=self.param(\n\n’ref\\_pose\\_emb\\_other’,\n\nnn.initializers.normal(stddev=1./onp.sqrt(D)),\n\n(D,),\n\npose\\_emb.dtype)\\[None,None,None,None\\]\n\n\\parpose\\_emb+=jnp.concatenate(\\[first\\_emb,other\\_emb\\],axis=1)\n\n\\par#DownsamplerayembeddingsforeachUNetresolution.\n\npose\\_embs=\\[\\]\n\nfori\\_levelinrange(self.num\\_resolutions):\n\npose\\_embs.append(nn.Conv(\n\nfeatures=self.emb\\_ch,\n\nkernel\\_size=(1,3,3),\n\nstrides=(1,2\\*\\*i\\_level,2\\*\\*i\\_level))(pose\\_emb))\n\n\\parreturnlogsnr\\_emb,pose\\_embs\n\n\\par\\parclassXUNet(nn.Module):\n\n”””OurproposedXUNetarchitecture.”””\n\nch:int=256\n\nch\\_mult:tuple\\[int\\]=(1,2,2,4)\n\nemb\\_ch:int=1024\n\nnum\\_res\\_blocks:int=3\n\nattn\\_resolutions:tuple\\[int\\]=(8,16,32)\n\nattn\\_heads:int=4\n\ndropout:float=0.1\n\nuse\\_pos\\_emb:bool=True\n\nuse\\_ref\\_pose\\_emb:bool=True\n\n\\par@nn.compact\n\ndef\\_\\_call\\_\\_(self,batch:dict\\[str,jnp.ndarray\\],\\*,\n\ncond\\_mask:jnp.ndarray,train:bool):\n\nB,H,W,C=batch\\[’x’\\].shape\n\nnum\\_resolutions=len(self.ch\\_mult)\n\n\\parlogsnr\\_emb,pose\\_embs=ConditioningProcessor(\n\nemb\\_ch=self.emb\\_ch,\n\nnum\\_resolutions=num\\_resolutions,\n\nuse\\_pos\\_emb=self.use\\_pos\\_emb,\n\nuse\\_ref\\_pose\\_emb=self.use\\_ref\\_pose\\_emb)(batch,cond\\_mask)\n\ndelcond\\_mask\n\n\\parh=jnp.stack(\\[batch\\[’x’\\],batch\\[’z’\\]\\],axis=1)\n\nh=nn.Conv(self.ch,kernel\\_size=(1,3,3),strides=(1,1,1)(h)\n\n\\par#Downsampling.\n\nhs=\\[h\\]\n\nfori\\_levelinself.ch\\_mult:\n\nemb=logsnr\\_emb\\[…,None,None,:\\]+pose\\_embs\\[i\\_level\\]\n\n\\parfori\\_blockinrange(self.num\\_res\\_blocks):\n\nuse\\_attn=h.shape\\[2\\]inself.attn\\_resolutions\n\nh=XUNetBlock(\n\nfeatures=self.ch\\*self.ch\\_mult\\[i\\_level\\],\n\ndropout=self.dropout,\n\nattn\\_heads=self.attn\\_heads,\n\nuse\\_attn=use\\_attn)(h,emb,train=train)\n\nhs.append(h)\n\n\\parifi\\_level!=num\\_resolutions-1:\n\nemb=logsnr\\_emb\\[…,None,None,:\\]+pose\\_embs\\[i\\_level+1\\]\n\nh=ResnetBlock(dropout=self.dropout,resample=’down’)(\n\nh,emb,train=train)\n\nhs.append(h)\n\n\\par#Middle.\n\nemb=logsnr\\_emb\\[…,None,None,:\\]+pose\\_embs\\[-1\\]\n\nuse\\_attn=h.shape\\[2\\]inself.attn\\_resolutions\n\nh=XUNetBlock(\n\nfeatures=self.ch\\*self.ch\\_mult\\[i\\_level\\],\n\ndropout=self.dropout,\n\nattn\\_heads=self.attn\\_heads,\n\nuse\\_attn=use\\_attn)(h,emb,train=train)\n\n\\par#Upsampling.\n\nfori\\_levelinreversed(range(num\\_resolutions)):\n\nemb=logsnr\\_emb\\[…,None,None,:\\]+pose\\_embs\\[i\\_level\\]\n\n\\parfori\\_blockinrange(self.num\\_res\\_blocks+1):\n\nuse\\_attn=hs\\[-1\\].shape\\[2\\]inself.attn\\_resolutions\n\nh=jnp.concatenate(\\[h,hs.pop()\\],axis=-1)\n\nh=XUNetBlock(\n\nfeatures=self.ch\\*self.ch\\_mult\\[i\\_level\\],\n\ndropout=self.dropout,\n\nattn\\_heads=self.attn\\_heads,\n\nuse\\_attn=use\\_attn)(h,emb,train=train)\n\n\\parifi\\_level!=0:\n\nemb=logsnr\\_emb\\[…,None,None,:\\]+pose\\_embs\\[i\\_level\\]\n\nh=ResnetBlock(dropout=self.dropout,resample=’up’)(\n\nh,emb,train=train)\n\n\\par#End.\n\nassertnoths\n\nh=nonlinearity(GroupNorm()(h))\n\nreturnnn.Conv(\n\nC,\n\nkernel\\_size=(1,3,3),\n\nstrides=(1,1,1),\n\nkernel\\_init=out\\_init\\_scale())(h)\\[:,1\\]\n\n\\par\\par",
            "citations": null
          },
          "7 Hyperparameters": {
            "content": "We now detail hyperparameter choices across our experiments. These include choices specific to the neural architecture, the training procedure, and also choices only relevant during inference.\n\n### 7.1 Neural Architecture\n\nFor our neural architecture, our main experiments use `ch=256} ($\\sim$471M params), and we also experiment with \\mintinline` pythonch=448 (∼similar-to\\\\sim1.3B params) in Section [4]Evaluating 3D consistency in geometry-free view synthesis ‣ Novel View Synthesis with Diffusion Models\"). One of our early findings that we kept throughout all experiments in the paper is that `ch_mult=(1, 2, 2, 4)} (i.e., setting the lowest UNet resolution to 8x8) was sufficient to achieve good sample quality, wheras most prior work includes UNet resolutions up to 4x4. We sweeped over the rest of the hyperparameters with the input and target views downsampled from their original 128x128 resolution to the 32x32, selecting values that led to the best qualitative improvements. These values are the default values present in the code we provide for the \\mintinline` pythonXUNet module in Section [6]Architecture details ‣ Novel View Synthesis with Diffusion Models\"). We generally find that the best hyperparameter choices at low-resolution experiments transfer well when applied to the higher resolutions, and thus recommend this strategy for cheaper and more practical hyperparameter tuning.\nFor the ∼similar-to\\\\sim1.3B parameter models, we tried increasing the number of parameters of our proposed UNet architecture through several different ways: increasing the number of blocks per resolution, the number of attention heads, the number of cross-attention layers per block, and the base number of hidden channels. Among all of these, we only found the last to provide noticeably better sample quality. We thus run 3D consistency scoring for models scaled this way, with channel sizes per UNet resolution of 448×\\[1,2,2,4\\]4481224448\\\\times\\[1,2,2,4\\] instead of 256×\\[1,2,2,4\\]2561224256\\\\times\\[1,2,2,4\\] (we could not fit `ch=512} in TPUv4 memory without model parallelism). On cars, we find that the smaller model reported in the rest of the paper is comparable in quality to the $\\sim$1.3B parameter model, though on chairs, we do observe a significant improvement on 3D consistency, both visually and quantitatively (see Table \\ref` results:nerf).\n\n### 7.2 Training\n\nFollowing Equation 3 in the paper, our neural network attempts to model the noise ϵbold-italic-ϵ\\\\bm{\\\\epsilon} added to a real image in order to undo it given the noisy image. Other parameterizations are possible, e.g., predicting 𝒙𝒙{\\\\bm{x}} directly rather than predicting ϵbold-italic-ϵ\\\\bm{\\\\epsilon}, though we did not sweep over these choices. For our noise schedule, we use a cosine-shaped log signal to noise ratio that monotonically decreases from 20 to -20. It can be implemented in JAX as follows:\n\n[⬇](data:text/plain;base64,CmRlZiBsb2dzbnJfc2NoZWR1bGVfY29zaW5lKHQsICosIGxvZ3Nucl9taW49LTIwLiwgbG9nc25yX21heD0yMC4pOgpiID0gb25wLmFyY3RhbihvbnAuZXhwKC0uNSAqIGxvZ3Nucl9tYXgpKQphID0gb25wLmFyY3RhbihvbnAuZXhwKC0uNSAqIGxvZ3Nucl9taW4pKSAtIGIKcmV0dXJuIC0yLiAqIGpucC5sb2coam5wLnRhbihhICogdCArIGIpKQo=)\n\ndeflogsnr\\_schedule\\_cosine(t,\\*,logsnr\\_min=-20.,logsnr\\_max=20.):\n\nb=onp.arctan(onp.exp(-.5\\*logsnr\\_max))\n\na=onp.arctan(onp.exp(-.5\\*logsnr\\_min))-b\n\nreturn-2.\\*jnp.log(jnp.tan(a\\*t+b))\n\nAdditionally:\n\n- •\n\n\nWe use a learning rate with peak value 0.0001, using linear warmup for the first 10 million examples (where one batch has `batch_size} examples), following \\citet` karras2022elucidating\n\n\n.\nWe use a global batch size of 128.\nWe train each batch element as an unconditional example 10% of the time to enable classifier-free guidance. This is done by overriding the conditioning frame to be at the maximum noise level. We note other options are possible (e.g., zeroing-out the conditioning frame), but we chose the option which is most compatible with our neural architecture.\nWe use the Adam optimizer (Kingma & Ba, [2014])) with β1=0.9subscript𝛽10.9\\\\beta\\_{1}=0.9 and β2=0.99subscript𝛽20.99\\\\beta\\_{2}=0.99.\nWe use EMA decay for the model parameters, with a half life of 500K examples (where one batch has `batch_size} examples) following \\citet` karras2022elucidating.\n\n### 7.3 Sampling\n\nWhile Ho et al. ( [2020])) note that their ancestral sampler can be used with any variances between β~tsubscript~𝛽𝑡\\\\tilde{\\\\beta}\\_{t} (variances of q​(𝒛s\\|𝒛t,𝒙)𝑞conditionalsubscript𝒛𝑠subscript𝒛𝑡𝒙q({\\\\bm{z}}\\_{s}\\|{\\\\bm{z}}\\_{t},{\\\\bm{x}})) and βtsubscript𝛽𝑡\\\\beta\\_{t} (variances of the underlying SDE), we simply use the former as those correspond to their ancestral sampler. We do not observe this choice to have a significant effect sample quality. All our samples are generated with 256 denoising steps. As is standard in the literature, we also clip each predicted 𝒙𝒙{\\\\bm{x}} at each denoising step to the normalized range of the images \\[−1,1\\]11\\[-1,1\\].\n\n#### Classifier-free guidance\n\nOur models use classifier-free guidance (Ho & Salimans, [2021])), as we find that small guidance weights help encourage 3D consistency further. All our models were trained unconditionally with a probability of 10% for each minibatch element. For unconditional examples, we zero out the (positionally encoded) pose and replace the clean frame with standard Gaussian noise (leveraging our weight-sharing architecture, see Section [2.3]X-UNet ‣ 2 Pose-conditional diffusion models ‣ Novel View Synthesis with Diffusion Models\")). We swept over various guidance weights, and simply picked those where 3D inconsistency was qualitatively least apparent on sampled videos. For SRN cars, we use a guidance weight of 3.0, while for SRN chairs we use a weight of 2.0.\n\n### 7.4 3D consistency scoring\n\nNote that traditional NeRFs (Mildenhall et al., [2020])) can be 3D inconsistent as the model allows for view-dependent radiance. We thus employ a simpler and faster to train version based on instant-NGP (Müller et al., [2022])) without view dependent components, and with additional distortion and orientation loss terms for improved convergence (Barron et al., [2022]); Verbin et al., [2022])). Note that the specific implementation details of the neural field method chosen will affect the metrics considerably, so it is of utmost importance to apply the same method and hyperparameters for the neural fields to make 3D consistency scores comparable across models.\nWe design the neural fields as simple Multi-Layer Perceptrons (MLPs) of hidden size 64 and no skip connections. The density MLP has one hidden layer, while the MLP that predicts the color components uses 2 hidden layers. We use a learning rate of 0.010.010.01 linearly decayed to 0.0010.0010.001 for the first 100 steps. We use the Adam optimizer with weight decay set to 0.1 and clip gradients of norm exceeding 1.0. We only apply 1000 training steps for each scene and do not optimize camera poses. On each training step, we simply optimize over all available pixels, rather than sampling a random subset of pixels from all the training views.\nTo render the neural fields after training, we set near and far bounds to tn=3​rmin8,tf=3​rmax2formulae-sequencesubscript𝑡𝑛3subscript𝑟min8subscript𝑡𝑓3subscript𝑟max2t\\_{n}=\\\\frac{3r\\_{\\\\textrm{min}}}{8},t\\_{f}=\\\\frac{3r\\_{\\\\textrm{max}}}{2}, where rmin,rmaxsubscript𝑟minsubscript𝑟maxr\\_{\\\\textrm{min}},r\\_{\\\\textrm{max}} are the minimum and maximum distances from the camera positions to the origin (center of each object) in the corresponding dataset. All renders post-training are also performed with differentiable volume rendering.\n\n[◄] [![ar5iv homepage]] [Feeling\\\\\n\\\\\nlucky?] [Conversion\\\\\n\\\\\nreport] [Report\\\\\n\\\\\nan issue] [View original\\\\\n\\\\\non arXiv] [►]",
            "citations": null
          }
        },
        "abstract": "We present 3DiM, a diffusion model for 3D novel view synthesis, which is able\nto translate a single input view into consistent and sharp completions across\nmany views. The core component of 3DiM is a pose-conditional image-to-image\ndiffusion model, which takes a source view and its pose as inputs, and\ngenerates a novel view for a target pose as output. 3DiM can generate multiple\nviews that are 3D consistent using a novel technique called stochastic\nconditioning. The output views are generated autoregressively, and during the\ngeneration of each novel view, one selects a random conditioning view from the\nset of available views at each denoising step. We demonstrate that stochastic\nconditioning significantly improves the 3D consistency of a naive sampler for\nan image-to-image diffusion model, which involves conditioning on a single\nfixed view. We compare 3DiM to prior work on the SRN ShapeNet dataset,\ndemonstrating that 3DiM's generated completions from a single view achieve much\nhigher fidelity, while being approximately 3D consistent. We also introduce a\nnew evaluation methodology, 3D consistency scoring, to measure the 3D\nconsistency of a generated object by training a neural field on the model's\noutput views. 3DiM is geometry free, does not rely on hyper-networks or\ntest-time optimization for novel view synthesis, and allows a single model to\neasily scale to a large number of scenes."
      },
      "bib.bib103": {
        "id": "bib.bib103",
        "citation": "[103]",
        "authors": "",
        "year": "",
        "title": "Learning a probabilistic latent space of object shapes via 3d generative-adversarial modeling.",
        "venue": "",
        "pages": "",
        "url": "https://arxiv.org/abs/1610.07584",
        "arxiv_id": "1610.07584",
        "doi": null,
        "sections": {
          "1 Introduction": {
            "content": "What makes a 3D generative model of object shapes appealing? We believe a good generative model should be able to synthesize 3D objects that are both highly varied and realistic. Specifically, for 3D objects to have variations, a generative model should be able to go beyond memorizing and recombining parts or pieces from a pre-defined repository to produce novel shapes; and for objects to be realistic, there need to be fine details in the generated examples.\n\nIn the past decades, researchers have made impressive progress on 3D object modeling and synthesis (Van Kaick et al., [2011]); Tangelder and Veltkamp, [2008]); Carlson, [1982])), mostly based on meshes or skeletons. Many of these traditional methods synthesize new objects by borrowing parts from objects in existing CAD model libraries. Therefore, the synthesized objects look realistic, but not conceptually novel.\n\nRecently, with the advances in deep representation learning and the introduction of large 3D CAD datasets like ShapeNet (Chang et al., [2015]); Wu et al., [2015])), there have been some inspiring attempts in learning deep object representations based on voxelized objects (Girdhar et al., [2016]); Su et al., [2015a]); Qi et al., [2016])).\nDifferent from part-based methods, many of these generative approaches do not explicitly model the concept of parts or retrieve them from an object repository; instead, they synthesize new objects based on learned object representations. This is a challenging problem because, compared to the space of 2D images, it is more difficult to model the space of 3D shapes due to its higher dimensionality.\nTheir current results are encouraging, but often there still exist artifacts ( _e.g_., fragments or holes) in the generated objects.\n\nIn this paper, we demonstrate that modeling volumetric objects in a general-adversarial manner could be a promising solution to generate objects that are both novel and realistic. Our approach combines the merits of both general-adversarial modeling (Goodfellow et al., [2014]); Radford et al., [2016])) and volumetric convolutional networks (Maturana and Scherer, [2015]); Wu et al., [2015])).\nDifferent from traditional heuristic criteria, generative-adversarial modeling introduces an adversarial discriminator to classify whether an object is synthesized or real.\nThis could be a particularly favorable framework for 3D object modeling: as 3D objects are highly structured, a generative-adversarial criterion, but not a voxel-wise independent heuristic one, has the potential to capture the structural difference of two 3D objects.\nThe use of a generative-adversarial loss may also avoid possible criterion-dependent overfitting ( _e.g_., generating mean-shape-like blurred objects when minimizing a mean squared error).\n\nModeling 3D objects in a generative-adversarial way offers additional distinctive advantages. First, it becomes possible to sample novel 3D objects from a probabilistic latent space such as a Gaussian or uniform distribution. Second, the discriminator in the generative-adversarial approach carries informative features for 3D object recognition, as demonstrated in experiments (Section [4]Evaluation ‣ Learning a Probabilistic Latent Space of Object Shapes via 3D Generative-Adversarial Modeling\")). From a different perspective, instead of learning a single feature representation for both generating and recognizing objects (Girdhar et al., [2016]); Sharma et al., [2016])), our framework learns disentangled generative and discriminative representations for 3D objects without supervision, and applies them on generation and recognition tasks, respectively.\n\nWe show that our generative representation can be used to synthesize high-quality realistic objects, and our discriminative representation can be used for 3D object recognition, achieving comparable performance with recent supervised methods (Maturana and Scherer, [2015]); Shi et al., [2015])), and outperforming other unsupervised methods by a large margin. The learned generative and discriminative representations also have wide applications. For example, we show that our network can be combined with a variational autoencoder (Kingma and Welling, [2014]); Larsen et al., [2016])) to directly reconstruct a 3D object from a 2D input image. Further, we explore the space of object representations and demonstrate that both our generative and discriminative representations carry rich semantic information about 3D objects.",
            "citations": null
          },
          "2 Related Work": {
            "content": "#### Modeling and synthesizing 3D shapes\n\n3D object understanding and generation is an important problem in the graphics and vision community, and the relevant literature is very rich (Carlson, [1982]); Tangelder and Veltkamp, [2008]); Van Kaick et al., [2011]); Blanz and Vetter, [1999]); Kalogerakis et al., [2012]); Chaudhuri et al., [2011]); Xue et al., [2012]); Kar et al., [2015]); Bansal et al., [2016]); Wu et al., [2016])). Since decades ago, AI and vision researchers have made inspiring attempts to design or learn 3D object representations, mostly based on meshes and skeletons. Many of these shape synthesis algorithms are nonparametric and they synthesize new objects by retrieving and combining shapes and parts from a database. Recently, Huang et al. ( [2015])) explored generating 3D shapes with pre-trained templates and producing both object structure and surface geometry. Our framework synthesizes objects without explicitly borrow parts from a repository, and requires no supervision during training.\n\n#### Deep learning for 3D data\n\nThe vision community have witnessed rapid development of deep networks for various tasks. In the field of 3D object recognition, Li et al. ( [2015])); Su et al. ( [2015b])); Girdhar et al. ( [2016])) proposed to learn a joint embedding of 3D shapes and synthesized images, Su et al. ( [2015a])); Qi et al. ( [2016])) focused on learning discriminative representations for 3D object recognition, Wu et al. ( [2016])); Xiang et al. ( [2015])); Choy et al. ( [2016])) discussed 3D object reconstruction from in-the-wild images, possibly with a recurrent network, and Girdhar et al. ( [2016])); Sharma et al. ( [2016])) explored autoencoder-based networks for learning voxel-based object representations. Wu et al. ( [2015])); Rezende et al. ( [2016])); Yan et al. ( [2016])) attempted to generate 3D objects with deep networks, some using 2D images during training with a 3D to 2D projection layer. Many of these networks can be used for 3D shape classification (Su et al., [2015a]); Sharma et al., [2016]); Maturana and Scherer, [2015])), 3D shape retrieval (Shi et al., [2015]); Su et al., [2015a])), and single image 3D reconstruction (Kar et al., [2015]); Bansal et al., [2016]); Girdhar et al., [2016])), mostly with full supervision. In comparison, our framework requires no supervision for training, is able to generate objects from a probabilistic space, and comes with a rich discriminative 3D shape representation.\n\n#### Learning with an adversarial net\n\nGenerative Adversarial Nets (GAN) (Goodfellow et al., [2014])) proposed to incorporate an adversarial discriminator into the procedure of generative modeling. More recently, LAPGAN (Denton et al., [2015])) and DC-GAN (Radford et al., [2016])) adopted GAN with convolutional networks for image synthesis, and achieved impressive performance. Researchers have also explored the use of GAN for other vision problems. To name a few, Wang and Gupta ( [2016])) discussed how to model image style and structure with sequential GANs, Li and Wand ( [2016])) and Zhu et al. ( [2016])) used GAN for texture synthesis and image editing, respectively, and Im et al. ( [2016])) developed a recurrent adversarial network for image generation. While previous approaches focus on modeling 2D images, we discuss the use of an adversarial component in modeling 3D objects.",
            "citations": null
          },
          "3 Models": {
            "content": "![Refer to caption]Figure 1: The generator in 3D-GAN. The discriminator mostly mirrors the generator.\n\nIn this section we introduce our model for 3D object generation. We first discuss how we build our framework, 3D Generative Adversarial Network (3D-GAN), by leveraging previous advances on volumetric convolutional networks and generative adversarial nets. We then show how to train a variational autoencoder (Kingma and Welling, [2014])) simultaneously so that our framework can capture a mapping from a 2D image to a 3D object.\n\n### 3.1 3D Generative Adversarial Network (3D-GAN)\n\nAs proposed in Goodfellow et al. ( [2014])), the Generative Adversarial Network (GAN) consists of a generator and a discriminator, where the discriminator tries to classify real objects and objects synthesized by the generator, and the generator attempts to confuse the discriminator. In our 3D Generative Adversarial Network (3D-GAN), the generator G𝐺G maps a 200200200-dimensional latent vector z𝑧z, randomly sampled from a probabilistic latent space, to a 64×64×6464646464\\\\times 64\\\\times 64 cube, representing an object G​(z)𝐺𝑧G(z) in 3D voxel space. The discriminator D𝐷D outputs a confidence value D​(x)𝐷𝑥D(x) of whether a 3D object input x𝑥x is real or synthetic.\n\nFollowing Goodfellow et al. ( [2014])), we use binary cross entropy as the classification loss, and present our overall adversarial loss function as\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | L3D-GAN=log⁡D​(x)+log⁡(1−D​(G​(z))),subscript𝐿3D-GAN𝐷𝑥1𝐷𝐺𝑧L\\_{\\\\text{3D-GAN}}=\\\\log D(x)+\\\\log(1-D(G(z))), |  | (1) |\n\nwhere x𝑥x is a real object in a 64×64×6464646464\\\\times 64\\\\times 64 space, and z𝑧z is a randomly sampled noise vector from a distribution p​(z)𝑝𝑧p(z). In this work, each dimension of z𝑧z is an i.i.d. uniform distribution over \\[0,1\\]01\\[0,1\\].\n\n#### Network structure\n\nInspired by Radford et al. ( [2016])), we design an all-convolutional neural network to generate 3D objects. As shown in Figure [1]Figure 1 ‣ 3 Models ‣ Learning a Probabilistic Latent Space of Object Shapes via 3D Generative-Adversarial Modeling\"), the generator consists of five volumetric fully convolutional layers of kernel sizes 4×4×44444\\\\times 4\\\\times 4 and strides 222, with batch normalization and ReLU layers added in between and a Sigmoid layer at the end. The discriminator basically mirrors the generator, except that it uses Leaky ReLU (Maas et al., [2013])) instead of ReLU layers.\nThere are no pooling or linear layers in our network. More details can be found in the supplementary material.\n\n#### Training details\n\nA straightforward training procedure is to update both the generator and the discriminator in every batch.\nHowever, the discriminator usually learns much faster than the generator, possibly because generating objects in a 3D voxel space is more difficult than differentiating between real and synthetic objects (Goodfellow et al., [2014]); Radford et al., [2016])). It then becomes hard for the generator to extract signals for improvement from a discriminator that is way ahead, as all examples it generated would be correctly identified as synthetic with high confidence.\nTherefore, to keep the training of both networks in pace, we employ an adaptive training strategy: for each batch, the discriminator only gets updated if its accuracy in the last batch is not higher than 80%percent8080\\\\%. We observe this helps to stabilize the training and to produce better results. We set the learning rate of G𝐺G to 0.00250.00250.0025, D𝐷D to 10−5superscript10510^{-5}, and use a batch size of 100100100. We use ADAM (Kingma and Ba, [2015])) for optimization, with β=0.5𝛽0.5\\\\beta=0.5.\n\n### 3.2 3D-VAE-GAN\n\nWe have discussed how to generate 3D objects by sampling a latent vector z𝑧z and mapping it to the object space. In practice, it would also be helpful to infer these latent vectors from observations. For example, if there exists a mapping from a 2D image to the latent representation, we can then recover the 3D object corresponding to that 2D image.\n\nFollowing this idea, we introduce 3D-VAE-GAN as an extension to 3D-GAN.\nWe add an additional image encoder E𝐸E, which takes a 2D image x𝑥x as input and outputs the latent representation vector z𝑧z. This is inspired by VAE-GAN proposed by (Larsen et al., [2016])), which combines VAE and GAN by sharing the decoder of VAE with the generator of GAN.\n\nThe 3D-VAE-GAN therefore consists of three components: an image encoder E𝐸E, a decoder (the generator G𝐺G in 3D-GAN), and a discriminator D𝐷D. The image encoder consists of five spatial convolution layers with kernel size {11,5,5,5,8}115558\\\\{11,5,5,5,8\\\\} and strides {4,2,2,2,1}42221\\\\{4,2,2,2,1\\\\}, respectively. There are batch normalization and ReLU layers in between, and a sampler at the end to sample a 200200200 dimensional vector used by the 3D-GAN. The structures of the generator and the discriminator are the same as those in Section [3.1]D Generative Adversarial Network (3D-GAN) ‣ 3 Models ‣ Learning a Probabilistic Latent Space of Object Shapes via 3D Generative-Adversarial Modeling\").\n\nSimilar to VAE-GAN (Larsen et al., [2016])), our loss function consists of three parts: an object reconstruction loss Lreconsubscript𝐿reconL\\_{\\\\text{recon}}, a cross entropy loss L3D-GANsubscript𝐿3D-GANL\\_{\\\\text{3D-GAN}} for 3D-GAN, and a KL divergence loss LKLsubscript𝐿KLL\\_{\\\\text{KL}} to restrict the distribution of the output of the encoder. Formally, these loss functions write as\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | L=L3D-GAN+α1​LKL+α2​Lrecon,𝐿subscript𝐿3D-GANsubscript𝛼1subscript𝐿KLsubscript𝛼2subscript𝐿reconL=L\\_{\\\\text{3D-GAN}}+\\\\alpha\\_{1}L\\_{\\\\text{KL}}+\\\\alpha\\_{2}L\\_{\\\\text{recon}}, |  | (2) |\n\nwhere α1subscript𝛼1\\\\alpha\\_{1} and α2subscript𝛼2\\\\alpha\\_{2} are weights of the KL divergence loss and the reconstruction loss. We have\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n|  | L3D-GANsubscript𝐿3D-GAN\\\\displaystyle L\\_{\\\\text{3D-GAN}} | =log⁡D​(x)+log⁡(1−D​(G​(z))),absent𝐷𝑥1𝐷𝐺𝑧\\\\displaystyle=\\\\log D(x)+\\\\log(1-D(G(z))), |  | (3) |\n|  | LKLsubscript𝐿KL\\\\displaystyle L\\_{\\\\text{KL}} | =DKL(q(z\\|y)∣∣p(z)),\\\\displaystyle=D\\_{\\\\text{KL}}(q(z\\|y)\\\\mid\\\\mid p(z)), |  | (4) |\n|  | Lreconsubscript𝐿recon\\\\displaystyle L\\_{\\\\text{recon}} | =‖G​(E​(y))−x‖2,absentsubscriptnorm𝐺𝐸𝑦𝑥2\\\\displaystyle=\\|\\|G(E(y))-x\\|\\|\\_{2}, |  | (5) |\n\nwhere x𝑥x is a 3D shape from the training set, y𝑦y is its corresponding 2D image, and q​(z\\|y)𝑞conditional𝑧𝑦q(z\\|y) is the variational distribution of the latent representation z𝑧z. The KL-divergence pushes this variational distribution towards to the prior distribution p​(z)𝑝𝑧p(z), so that the generator can sample the latent representation z𝑧z from the same distribution p​(z)𝑝𝑧p(z). In this work, we choose p​(z)𝑝𝑧p(z) a multivariate Gaussian distribution with zero-mean and unit variance. For more details, please refer to Larsen et al. ( [2016])).\n\nTraining 3D-VAE-GAN requires both 2D images and their corresponding 3D models. We render 3D shapes in front of background images (16,9131691316,913 indoor images from the SUN database (Xiao et al., [2010]))) in 727272 views (from 242424 angles and 333 elevations). We set α1=5subscript𝛼15\\\\alpha\\_{1}=5, α2=10−4subscript𝛼2superscript104\\\\alpha\\_{2}=10^{-4}, and use a similar training strategy as in Section [3.1]D Generative Adversarial Network (3D-GAN) ‣ 3 Models ‣ Learning a Probabilistic Latent Space of Object Shapes via 3D Generative-Adversarial Modeling\"). See our supplementary material for more details.",
            "citations": null
          },
          "4 Evaluation": {
            "content": "|     |     |     |\n| --- | --- | --- |\n|  | Our results (64×64×6464646464\\\\times 64\\\\times 64) | NN |\n| Gun | ![Refer to caption] | ![Refer to caption]![Refer to caption] |\n| Chair | ![Refer to caption] | ![Refer to caption]![Refer to caption] |\n| Car | ![Refer to caption] | ![Refer to caption]![Refer to caption] |\n| Sofa | ![Refer to caption] | ![Refer to caption]![Refer to caption] |\n| Table | ![Refer to caption] | ![Refer to caption]![Refer to caption] |\n\nObjects generated by Wu et al. ( [2015])) (30×30×3030303030\\\\times 30\\\\times 30)\n\nTable![Refer to caption]Car![Refer to caption]\n\nObjects generated by a volumetric autoencoder (64×64×6464646464\\\\times 64\\\\times 64)\n\n|     |     |     |     |     |     |     |     |     |     |     |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| Chair | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | Table | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | Sofa | ![Refer to caption] | ![Refer to caption] |\n\nFigure 2: Objects generated by 3D-GAN from vectors, without a reference image/object. We show, for the last two objects in each row, the nearest neighbor retrieved from the training set. We see that the generated objects are similar, but not identical, to examples in the training set. For comparison, we show objects generated by the previous state-of-the-art (Wu et al., [2015])) (results supplied by the authors). We also show objects generated by autoencoders trained on a single object category, with latent vectors sampled from empirical distribution. See text for details.\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n| ![Refer to caption]![Refer to caption] | ![Refer to caption]![Refer to caption] | ![Refer to caption]![Refer to caption] | ![Refer to caption]![Refer to caption] |\n| High-res  Low-res | High-res  Low-res | High-res  Low-res | High-res  Low-res |\n\nFigure 3: We present each object at high resolution (64×64×6464646464\\\\times 64\\\\times 64) on the left and at low resolution (down-sampled to 16×16×1616161616\\\\times 16\\\\times 16) on the right. While humans can perceive object structure at a relatively low resolution, fine details and variations only appear in high-res objects.\n\nIn this section, we evaluate our framework from various aspects. We first show qualitative results of generated 3D objects. We then evaluate the unsupervisedly learned representation from the discriminator by using them as features for 3D object classification. We show both qualitative and quantitative results on the popular benchmark ModelNet (Wu et al., [2015])). Further, we evaluate our 3D-VAE-GAN on 3D object reconstruction from a single image, and show both qualitative and quantitative results on the IKEA dataset (Lim et al., [2013])).\n\n### 4.1 3D Object Generation\n\nFigure [2]Figure 2 ‣ 4 Evaluation ‣ Learning a Probabilistic Latent Space of Object Shapes via 3D Generative-Adversarial Modeling\") shows 3D objects generated by our 3D-GAN.\nFor this experiment, we train one 3D-GAN for each object category. For generation, we sample 200200200-dimensional vectors following an i.i.d. uniform distribution over \\[0,1\\]01\\[0,1\\], and render the largest connected component of each generated object.\nWe compare 3D-GAN with Wu et al. ( [2015])), the state-of-the-art in 3D object synthesis from a probabilistic space, and with a volumetric autoencoder, whose variants have been employed by multiple recent methods (Girdhar et al., [2016]); Sharma et al., [2016])). Because an autoencoder does not restrict the distribution of its latent representation, we compute the empirical distribution p0​(z)subscript𝑝0𝑧p\\_{0}(z) of the latent vector z𝑧z of all training examples, fit a Gaussian distribution g0subscript𝑔0g\\_{0} to p0subscript𝑝0p\\_{0}, and sample from g0subscript𝑔0g\\_{0}. Our algorithm produces 3D objects with much higher quality and more fine-grained details.\n\nCompared with previous works, our 3D-GAN can synthesize high-resolution 3D objects with detailed geometries. Figure [3]Figure 3 ‣ 4 Evaluation ‣ Learning a Probabilistic Latent Space of Object Shapes via 3D Generative-Adversarial Modeling\") shows both high-res voxels and down-sampled low-res voxels for comparison. Note that it is relatively easy to synthesize a low-res object, but is much harder to obtain a high-res one due to the rapid growth of 3D space. However, object details are only revealed in high resolution.\n\nA natural concern to our generative model is whether it is simply memorizing objects from training data.\nTo demonstrate that the network can generalize beyond the training set, we compare synthesized objects with their nearest neighbor in the training set. Since the retrieval objects based on ℓ2superscriptℓ2\\\\ell^{2} distance in the voxel space are visually very different from the queries, we use the output of the last convolutional layer in our discriminator (with a 2x pooling) as features for retrieval instead.\nFigure [2]Figure 2 ‣ 4 Evaluation ‣ Learning a Probabilistic Latent Space of Object Shapes via 3D Generative-Adversarial Modeling\") shows that generated objects are similar, but not identical, to the nearest examples in the training set.\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n| Supervision | Pretraining | Method | Classification (Accuracy) |\n| ModelNet40 | ModelNet10 |\n| Category labels | ImageNet | MVCNN (Su et al., [2015a])) | 90.1% | - |\n| MVCNN-MultiRes (Qi et al., [2016])) | 91.4% | - |\n| None | 3D ShapeNets (Wu et al., [2015])) | 77.3% | 83.5% |\n| DeepPano (Shi et al., [2015])) | 77.6% | 85.5% |\n| VoxNet (Maturana and Scherer, [2015])) | 83.0% | 92.0% |\n| ORION (Sedaghat et al., [2016])) | - | 93.8% |\n| Unsupervised | - | SPH (Kazhdan et al., [2003])) | 68.2% | 79.8% |\n| LFD (Chen et al., [2003])) | 75.5% | 79.9% |\n| T-L Network (Girdhar et al., [2016])) | 74.4% | - |\n| VConv-DAE (Sharma et al., [2016])) | 75.5% | 80.5% |\n| 3D-GAN (ours) | 83.3% | 91.0% |\n\nTable 1: Classification results on the ModelNet dataset. Our 3D-GAN outperforms other unsupervised learning methods by a large margin, and is comparable to some recent supervised learning frameworks.\n\n![Refer to caption]Figure 4: ModelNet40 classification with limited training data\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\nFigure 5: The effects of individual dimensions of the object vector\n\n![Refer to caption]\n\n![Refer to caption]\n\nFigure 6: Intra/inter-class interpolation between object vectors\n\n|     |     |     |     |     |     |     |     |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| Method | Bed | Bookcase | Chair | Desk | Sofa | Table | Mean |\n| AlexNet-fc8 (Girdhar et al., [2016])) | 29.5 | 17.3 | 20.4 | 19.7 | 38.8 | 16.0 | 23.6 |\n| AlexNet-conv4 (Girdhar et al., [2016])) | 38.2 | 26.6 | 31.4 | 26.6 | 69.3 | 19.1 | 35.2 |\n| T-L Network (Girdhar et al., [2016])) | 56.3 | 30.2 | 32.9 | 25.8 | 71.7 | 23.3 | 40.0 |\n| 3D-VAE-GAN (jointly trained) | 49.1 | 31.9 | 42.6 | 34.8 | 79.8 | 33.1 | 45.2 |\n| 3D-VAE-GAN (separately trained) | 63.2 | 46.3 | 47.2 | 40.7 | 78.8 | 42.3 | 53.1 |\n\nTable 2: Average precision for voxel prediction on the IKEA dataset.†\n\n|     |\n| --- |\n| ![Refer to caption]![Refer to caption]![Refer to caption]![Refer to caption]![Refer to caption]![Refer to caption]![Refer to caption]![Refer to caption]![Refer to caption]![Refer to caption] |\n| ![Refer to caption]![Refer to caption]![Refer to caption]![Refer to caption]![Refer to caption]![Refer to caption]![Refer to caption]![Refer to caption]![Refer to caption]![Refer to caption] |\n\nFigure 7: Qualitative results of single image 3D reconstruction on the IKEA dataset\n\n|     |     |\n| --- | --- |\n| ![Refer to caption] | ![Refer to caption] |\n\nFigure 8: Shape arithmetic for chairs and tables. The left images show the obtained “arm” vector can be added to other chairs, and the right ones show the “layer” vector can be added to other tables.\n\n|     |     |\n| --- | --- |\n| ![Refer to caption]![Refer to caption]![Refer to caption]![Refer to caption]![Refer to caption] | ![Refer to caption]![Refer to caption]![Refer to caption]![Refer to caption]![Refer to caption] |\n| ![Refer to caption]![Refer to caption]![Refer to caption]![Refer to caption]![Refer to caption] | ![Refer to caption]![Refer to caption]![Refer to caption]![Refer to caption]![Refer to caption] |\n\nFigure 9: Objects and parts that activate specific neurons in the discriminator. For each neuron, we show five objects that activate it most strongly, with colors representing gradients of activations with respect to input voxels.\n\n### 4.2 3D Object Classification\n\nWe then evaluate the representations learned by our discriminator. A typical way of evaluating representations learned without supervision is to use them as features for classification.\nTo obtain features for an input 3D object, we concatenate the responses of the second, third, and fourth convolution layers in the discriminator, and apply max pooling of kernel sizes {8,4,2}842\\\\{8,4,2\\\\}, respectively. We use a linear SVM for classification.\n\n#### Data\n\nWe train a single 3D-GAN on the seven major object categories (chairs, sofas, tables, boats, airplanes, rifles, and cars) of ShapeNet (Chang et al., [2015])). We use ModelNet (Wu et al., [2015])) for testing, following Sharma et al. ( [2016])); Maturana and Scherer ( [2015])); Qi et al. ( [2016])).\\*\\*\\*For ModelNet, there are two train/test splits typically used. Qi et al. ( [2016])); Shi et al. ( [2015])); Maturana and Scherer ( [2015])) used the train/test split included in the dataset, which we also follow; Wu et al. ( [2015])); Su et al. ( [2015a])); Sharma et al. ( [2016])) used 808080 training points and 202020 test points in each category for experiments, possibly with viewpoint augmentation. Specifically, we evaluate our model on both ModelNet10 and ModelNet40, two subsets of ModelNet that are often used as benchmarks for 3D object classification. Note that the training and test categories are not identical, which also shows the out-of-category generalization power of our 3D-GAN.\n\n#### Results\n\nWe compare with the state-of-the-art methods (Wu et al., [2015]); Girdhar et al., [2016]); Sharma et al., [2016]); Sedaghat et al., [2016])) and show per-class accuracy in Table [1]Table 1 ‣ 4.1 3D Object Generation ‣ 4 Evaluation ‣ Learning a Probabilistic Latent Space of Object Shapes via 3D Generative-Adversarial Modeling\"). Our representation outperforms other features learned without supervision by a large margin (83.3%percent83.383.3\\\\% vs. 75.5%percent75.575.5\\\\% on ModelNet40, and 91.0%percent91.091.0\\\\% vs 80.5%percent80.580.5\\\\% on ModelNet10) (Girdhar et al., [2016]); Sharma et al., [2016])). Further, our classification accuracy is also higher than some recent supervised methods (Shi et al., [2015])), and is close to the state-of-the-art voxel-based supervised learning approaches (Maturana and Scherer, [2015]); Sedaghat et al., [2016])). Multi-view CNNs (Su et al., [2015a]); Qi et al., [2016])) outperform us, though their methods are designed for classification, and require rendered multi-view images and an ImageNet-pretrained model.\n\n3D-GAN also works well with limited training data. As shown in Figure [6]Figure 6 ‣ 4.1 3D Object Generation ‣ 4 Evaluation ‣ Learning a Probabilistic Latent Space of Object Shapes via 3D Generative-Adversarial Modeling\"), with roughly 25 training samples per class, 3D-GAN achieves comparable performance on ModelNet40 with other unsupervised learning methods trained with at least 80 samples per class.\n\n### 4.3 Single Image 3D Reconstruction\n\nAs an application, our show that the 3D-VAE-GAN can perform well on single image 3D reconstruction. Following previous work (Girdhar et al., [2016])), we test it on the IKEA dataset (Lim et al., [2013])), and show both qualitative and quantitative results.\n\n#### Data\n\nThe IKEA dataset consists of images with IKEA objects. We crop the images so that the objects are centered in the images. Our test set consists of 1,03910391,039 objects cropped from 759759759 images (supplied by the author). The IKEA dataset is challenging because all images are captured in the wild, often with heavy occlusions. We test on all six categories of objects: bed, bookcase, chair, desk, sofa, and table.\n\n#### Results\n\nWe show our results in Figure [7]Figure 7 ‣ 4.1 3D Object Generation ‣ 4 Evaluation ‣ Learning a Probabilistic Latent Space of Object Shapes via 3D Generative-Adversarial Modeling\") and Table [2]Table 2 ‣ 4.1 3D Object Generation ‣ 4 Evaluation ‣ Learning a Probabilistic Latent Space of Object Shapes via 3D Generative-Adversarial Modeling\"), with performance of a single 3D-VAE-GAN jointly trained on all six categories, as well as the results of six 3D-VAE-GANs separately trained on each class. Following Girdhar et al. ( [2016])), we evaluate results at resolution 20×20×2020202020\\\\times 20\\\\times 20, use the average precision as our evaluation metric, and attempt to align each prediction with the ground-truth over permutations, flips, and translational alignments (up to 10%), as IKEA ground truth objects are not in a canonical viewpoint.\nIn all categories, our model consistently outperforms previous state-of-the-art in voxel-level prediction and other baseline methods.†††For methods from Girdhar et al. ( [2016])), the mean values in the last column are higher than the originals in their paper, because we compute per-class accuracy instead of per-instance accuracy.",
            "citations": null
          },
          "5 Analyzing Learned Representations": {
            "content": "In this section, we look deep into the representations learned by both the generator and the discriminator of 3D-GAN. We start with the 200200200-dimensional object vector, from which the generator produces various objects. We then visualize neurons in the discriminator, and demonstrate that these units capture informative semantic knowledge of the objects, which justifies its good performance on object classification presented in Section [4]Evaluation ‣ Learning a Probabilistic Latent Space of Object Shapes via 3D Generative-Adversarial Modeling\").\n\n### 5.1 The Generative Representation\n\nWe explore three methods for understanding the latent space of vectors for object generation. We first visualize what an individual dimension of the vector represents; we then explore the possibility of interpolating between two object vectors and observe how the generated objects change; last, we present how we can apply shape arithmetic in the latent space.\n\n#### Visualizing the object vector\n\nTo visualize the semantic meaning of each dimension, we gradually increase its value, and observe how it affects the generated 3D object. In Figure [6]Figure 6 ‣ 4.1 3D Object Generation ‣ 4 Evaluation ‣ Learning a Probabilistic Latent Space of Object Shapes via 3D Generative-Adversarial Modeling\"), each column corresponds to one dimension of the object vector, where the red region marks the voxels affected by changing values of that dimension. We observe that some dimensions in the object vector carries semantic knowledge of the object, _e.g_., the thickness or width of surfaces.\n\n#### Interpolation\n\nWe show results of interpolating between two object vectors in Figure [6]Figure 6 ‣ 4.1 3D Object Generation ‣ 4 Evaluation ‣ Learning a Probabilistic Latent Space of Object Shapes via 3D Generative-Adversarial Modeling\"). Earlier works demonstrated interpolation between two 2D images of the same category (Dosovitskiy et al., [2015]); Radford et al., [2016])). Here we show interpolations both within and across object categories. We observe that for both cases walking over the latent space gives smooth transitions between objects.\n\n#### Arithmetic\n\nAnother way of exploring the learned representations is to show arithmetic in the latent space. Previously, Dosovitskiy et al. ( [2015])); Radford et al. ( [2016])) presented that their generative nets are able to encode semantic knowledge of chair or face images in its latent space; Girdhar et al. ( [2016])) also showed that the learned representation for 3D objects behave similarly. We show our shape arithmetic in Figure [8]Figure 8 ‣ 4.1 3D Object Generation ‣ 4 Evaluation ‣ Learning a Probabilistic Latent Space of Object Shapes via 3D Generative-Adversarial Modeling\"). Different from Girdhar et al. ( [2016])), all of our objects are randomly sampled, requiring no existing 3D CAD models as input.\n\n### 5.2 The Discriminative Representation\n\nWe now visualize the neurons in the discriminator. Specifically, we would like to show what input objects,\nand which part of them produce the highest intensity values for each neuron. To do that, for each neuron in the second to last convolutional layer of the discriminator, we iterate through all training objects and exhibit the ones activating the unit most strongly. We further use guided back-propagation (Springenberg et al., [2015])) to visualize the parts that produce the activation.\n\nFigure [9]Figure 9 ‣ 4.1 3D Object Generation ‣ 4 Evaluation ‣ Learning a Probabilistic Latent Space of Object Shapes via 3D Generative-Adversarial Modeling\") shows the results. There are two main observations: first, for a single neuron, the objects producing strongest activations have very similar shapes, showing the neuron is selective in terms of the overall object shape; second, the parts that activate the neuron, shown in red, are consistent across these objects, indicating the neuron is also learning semantic knowledge about object parts.",
            "citations": null
          },
          "6 Conclusion": {
            "content": "In this paper, we proposed 3D-GAN for 3D object generation, as well as 3D-VAE-GAN for learning an image to 3D model mapping. We demonstrated that our models are able to generate novel objects and to reconstruct 3D objects from images. We showed that the discriminator in GAN, learned without supervision, can be used as an informative feature representation for 3D objects, achieving impressive performance on shape classification. We also explored the latent space of object vectors, and presented results on object interpolation, shape arithmetic, and neuron visualization.\n\n#### Acknowledgement\n\nThis work is supported by NSF grants #1212849 and #1447476, ONR MURI N00014-16-1-2007, the Center for Brain, Minds and Machines (NSF STC award CCF-1231216), Toyota Research Institute, Adobe, Shell, IARPA MICrONS, and a hardware donation from Nvidia.",
            "citations": null
          }
        },
        "abstract": "We study the problem of 3D object generation. We propose a novel framework,\nnamely 3D Generative Adversarial Network (3D-GAN), which generates 3D objects\nfrom a probabilistic space by leveraging recent advances in volumetric\nconvolutional networks and generative adversarial nets. The benefits of our\nmodel are three-fold: first, the use of an adversarial criterion, instead of\ntraditional heuristic criteria, enables the generator to capture object\nstructure implicitly and to synthesize high-quality 3D objects; second, the\ngenerator establishes a mapping from a low-dimensional probabilistic space to\nthe space of 3D objects, so that we can sample objects without a reference\nimage or CAD models, and explore the 3D object manifold; third, the adversarial\ndiscriminator provides a powerful 3D shape descriptor which, learned without\nsupervision, has wide applications in 3D object recognition. Experiments\ndemonstrate that our method generates high-quality 3D objects, and our\nunsupervisedly learned features achieve impressive performance on 3D object\nrecognition, comparable with those of supervised learning methods."
      },
      "bib.bib105": {
        "id": "bib.bib105",
        "citation": "[105]",
        "authors": "",
        "year": "",
        "title": "Agg: Amortized generative 3d gaussians for single image to 3d.",
        "venue": "",
        "pages": "",
        "url": "https://arxiv.org/abs/2401.04099",
        "arxiv_id": "2401.04099",
        "doi": null,
        "sections": {
          "1 Introduction": {
            "content": "The rapid development in virtual and augmented reality introduces increasing demand for automatic 3D content creation. Previous workflows often require tedious manual labor by human experts and need specific software tools. A 3D asset generative model is essential to allow non-professional users to realize their ideas into actual 3D digital content.\n\nMuch effort has been put into image-to-3D generation as it allows users to control the generated content. Early methods study the generation of simple objects \\[ [60])\\] or novel view synthesis of limited viewpoints \\[ [21]), [42]), [51])\\]. Later on, with the help of 2D text-to-image diffusion models, score distillation sampling \\[ [35])\\] has enabled 360-degree object generation for in-the-wild instances \\[ [52]), [29]), [45])\\]. More recently, the advances in collecting 3D datasets \\[ [10]), [50]), [61])\\] have supported the training of large-scale 3D-aware generative models \\[ [24]), [23]), [15])\\] for better image-to-3D generations.\n\n![Refer to caption]Figure 1: Overview of our AGG framework. We design a novel cascaded generation pipeline that produces 3D Gaussian-based objects without per-instance optimization. Our AGG framework involves a coarse generator that predicts a hybrid representation for 3D Gaussians at a low resolution and a super-resolution module that delivers dense 3D Gaussians in the fine stage.\n\nVarious 3D representations have been studied as the media to train 3D generative models.\nMany prior works have explored generating explicit representations, such as point clouds \\[ [62])\\], voxels \\[ [64]), [39])\\], and occupancy grid \\[ [49])\\].\nImplicit representations like NeRF \\[ [30])\\] and distance functions \\[ [22])\\] are popular for easy optimization.\nAlthough effective for content generation \\[ [57]), [12]), [34])\\], slow rendering and optimization hinder the wide adoption of these representations.\nAs a result, researchers have looked into more efficient volumetric representations \\[ [31]), [5])\\] to support the training of larger generative models \\[ [7]), [19])\\] and the costly optimization in score distillation \\[ [52]), [29])\\].\nMore recently, 3D Gaussian splatting \\[ [20]), [44]), [8]), [59])\\] has attracted great attention due to its high-quality real-time rendering ability. This owes to the visibility-aware rendering algorithm that facilitates much less optimization time cost compared with NeRF-based variants \\[ [24]), [35])\\]. Such an efficient renderer enables supervising the 3D Gaussians through loss functions defined on the 2D renderings, which is not suitable for other representations.\n\nDespite the exciting progress, how to properly generate 3D Gaussians \\[ [20])\\] remains a less studied topic.\nExisting works \\[ [44]), [8]), [59])\\] focus on the per-instance optimization-based setting. Though 3D Gaussians can be optimized with adaptive density control to represent certain geometry, initialization remains critical for complex object structures.\nAn amortized pipeline is highly desired to produce the 3D Gaussians in one shot.\nSuch a network can learn a shared 3D understanding of images that generalizes to unseen objects of similar categories to the training set.\nThis will further reduce the need for test-time optimization, trading off the computation cost of the inference stage with the training stage.\n\nHowever, building such a feed-forward pipeline is challenging for two major reasons.\nFirst, 3D Gaussians rely on adaptive density control \\[ [20])\\] to represent complex geometry, but this leads to a dynamic number of 3D Gaussians, making it hard to predict them in an amortized training setting.\nSecond, the 3D Gaussians require curated initialization \\[ [59]), [8])\\] to be updated properly via supervision on the rendering. In the amortized setting, the 3D Gaussians are instead predicted by the neural network, which leads to the need to initialize the network well such that generated Gaussians can be supervised decently. Moreover, the optimization process often favors updating the appearance of 3D Gaussians instead of moving their positions directly to desired 3D locations.\n\nTo overcome these issues, we conduct a pilot study on the amortized generation of 3D Gaussians through a feed-forward process.\nAs shown in Fig. [1]Figure 1 ‣ 1 Introduction ‣ AGG: Amortized Generative 3D Gaussians for Single Image to 3D\"), we propose AGG, a cascaded generation framework that generates 3D Gaussians from a single image input.\nIn the first stage, we employ a hybrid generator that produces 3D Gaussians at a coarse resolution. In this stage, we decompose the geometry and texture generation task into two distinct networks. A geometry transformer decodes image features extracted from a pre-trained image feature extractor and predicts the location of 3D Gaussians. Another texture transformer similarly generates a texture field that is later queried by the Gaussian locations to obtain other point attributes. Utilizing this hybrid representation as an intermediate optimization target stabilizes our training process when jointly optimizing the geometry and texture of the 3D Gaussians.\nIn the second stage, we leverage point-voxel convolutional networks to extract local features effectively and super-resolve the coarse 3D Gaussians from the previous stage. RGB information is further injected into the super-resolution networks to refine the texture information.\n\nOur contributions can be summarized as follows,\n\n- •\n\n\nWe conduct a pilot study on the task of amortized single image-to-3D Gaussian setting. Unlike existing works that operate on individual objects, we build a novel cascaded generation framework that instantly presents 3D Gaussians in one shot.\n\n- •\n\n\nOur AGG network first generates coarse Gaussian predictions through a hybrid representation that decomposes geometry and texture. With two separate transformers predicting the geometry and texture information, the 3D Gaussian attributes can be optimized jointly and stably.\n\n- •\n\n\nA UNet-based architecture with point-voxel layers is introduced for the second stage, which effectively super-resolves the 3D Gaussians.\n\n- •\n\n\nCompared with existing baselines including optimization-based 3D Gaussian pipelines and sampling-based frameworks that use other 3D representations, AGG demonstrates competitive performance both quantitatively and qualitatively while enabling zero-shot image-to-object generation, and being several orders of magnitude faster.",
            "citations": null
          },
          "2 Related Works": {
            "content": "### 2.1 Image-to-3D Generation\n\nNumerous research studies have been conducted on generating 3D data from a single image. Early attempts simplify the challenges by either generating objects of simple geometry \\[ [60])\\] or focusing on synthesizing novel view images of limited viewpoints \\[ [21]), [42]), [51])\\].\nLater on, various combinations of 2D image encoder and 3D representations are adopted to build 3D generative models, such as on 3D voxels \\[ [16]), [9]), [54])\\], point clouds \\[ [55]), [13]), [62]), [49]), [22])\\], meshes \\[ [15]), [18]), [48])\\], and implicit functions \\[ [12]), [56])\\].\nMore recently, with the help of score distillation sampling from a pre-trained text-to-image diffusion model, great efforts have been put into generating a 3D asset from a single image through optimization \\[ [52]), [29]), [40]), [45]), [11]), [44])\\].\nAmong them, DreamGaussian utilizes 3D Gaussians as an efficient 3D representation that supports real-time high-resolution rendering via rasterization.\nIn addition to these optimization-based methods,\nbuilding feed-forward models for image-to-3D generation avoids the time-consuming optimization process, and a large generative model can learn unified representation for similar objects, leveraging prior knowledge from the 3D dataset better.\nThe advances in large-scale 3D datasets \\[ [10]), [50]), [61])\\] largely contributed to the design of better image-to-3D generative models \\[ [24]), [23]), [15])\\]. OpenAI has trained a 3D point cloud generation model Point-E \\[ [32])\\], based on millions of internal 3D models. They later published Shap-E \\[ [17])\\], which is trained on more 3D models and further supports generating textured meshes and neural radiance fields.\nOur work follows the direction of building feed-forward models for image-to-3D and makes the first attempt to construct an amortized model that predicts the 3D Gaussians instead of constructing them through optimization.\n\n### 2.2 Implicit 3D Representations\n\nNeural radiance field (NeRF) \\[ [30])\\] implements a coordinate-based neural network to represent the 3D scenes and demonstrates outstanding novel view synthesis abilities. Many following works have attempted to improve NeRF in various aspects. For example,\nMipNeRF \\[ [1])\\] and MipNeRF-360 \\[ [2])\\] introduce advanced rendering techniques to avoid aliasing artifacts.\nSinNeRF \\[ [51])\\], PixelNeRF \\[ [60])\\], and SparseNeRF \\[ [47])\\] extends the application of NeRFs to few-shot input views, making single image-to-3D generation through NeRF a more feasible direction.\nWith the recent advances in score distillation sampling \\[ [35])\\], numerous approaches have looked into optimizing a neural radiance field through guidance from diffusion priors \\[ [52]), [29]), [40]), [45]), [11])\\].\nWhile suitable for optimization, NeRFs are usually expressed implicitly through MLP parameters, which makes it challenging to generate them via network \\[ [12])\\]. Consequently, many works \\[ [28]), [5]), [4])\\] instead choose to generate hybrid representations, where NeRF MLP is adopted to decode features stored in explicit structures \\[ [5]), [6]), [31]), [14]), [58]), [53]), [3])\\].\nAmong them, ATT3D \\[ [28])\\] builds an amortized framework for text-to-3D by generating Instant NGP \\[ [31])\\] via score distillation sampling.\nWhile focusing on generating explicit 3D Gaussians, our work draws inspiration from hybrid representations and utilizes hybrid structures as intermediate generation targets, which can be later decoded into 3D Gaussians.\n\n### 2.3 Explicit 3D Representations\n\nExplicit 3D representations have been widely studied for decades. Many works have attempted to construct 3D assets through 3D voxels \\[ [16]), [9]), [54])\\], point clouds \\[ [55]), [13]), [62]), [49]), [22])\\] and meshes \\[ [15]), [18]), [48])\\].\nSince pure implicit radiance fields are operationally slow, often needing millions of neural network queries to render large-scale scenes, great efforts have been put into integrating explicit representations with implicit radiance fields to combine their advantages.\nMany works looked into employing tensor factorization to achieve efficient explicit representations \\[ [5]), [6]), [14]), [58]), [31])\\]. Multi-scale hash grids \\[ [31])\\] and block decomposition \\[ [43])\\] are introduced to extend to city-scale scenes.\nAnother popular direction focuses on empowering explicit structures with additional implicit attributes.\nPoint NeRF \\[ [53])\\] utilizes neural 3D points to represent and render a continuous radiance volume.\nSimilarly, NU-MCC \\[ [22])\\] uses latent point features, specifically focusing on shape completion tasks.\n3D Gaussian splatting \\[ [20])\\] introduces point-based α𝛼\\\\alpha-blending along with an efficient point-based rasterizer and has attracted great attention due to their outstanding ability in reconstruction \\[ [20])\\] and generation \\[ [44]), [8]), [59])\\] tasks.\nHowever, existing works present 3D Gaussians through optimization, while our work takes one step further and focuses on building a amortized framework that generates 3D Gaussians without per-instance optimization.",
            "citations": null
          },
          "3 Amortized Generative 3D Gaussians": {
            "content": "Unlike the existing methods that optimize Gaussians, initialized from structure-from-motion (SfM) or random blobs, our work pursues a more challenging objective: generating 3D Gaussians from a single image using a neural network in one shot.\nSpecifically, our cascaded approach begins with constructing a hybrid generator that maps input image features into a concise set of 3D Gaussian attributes.\nSubsequently, a UNet architecture with point-voxel layers is employed to super-resolve the 3D Gaussian representation, improving its fidelity.\nIn the following subsections, we first provide the background on 3D Gaussian splatting, then we delve deep into details about our proposed components, and finally, we illustrate how we address the rising challenges with amortized generation.\n\n### 3.1 Background: 3D Gaussian Splatting (3DGS)\n\n3D Gaussian splatting is a recently popularized explicit 3D representation that utilizes anisotropic 3D Gaussians.\nEach 3D Gaussian G𝐺G is defined with a center position μ∈ℝ3𝜇superscriptℝ3\\\\mu\\\\in\\\\mathbb{R}^{3}, covariance matrix ΣΣ\\\\Sigma, color information c∈ℝ3𝑐superscriptℝ3c\\\\in\\\\mathbb{R}^{3}\nand opacity α∈ℝ1𝛼superscriptℝ1\\\\alpha\\\\in\\\\mathbb{R}^{1}.\nThe covariance matrix ΣΣ\\\\Sigma describes the configuration of an ellipsoid and is implemented via a scaling matrix S∈ℝ3𝑆superscriptℝ3S\\\\in\\\\mathbb{R}^{3} and a rotation matrix R∈ℝ3×3𝑅superscriptℝ33R\\\\in\\\\mathbb{R}^{3\\\\times 3}.\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | Σ=R​S​ST​RTΣ𝑅𝑆superscript𝑆𝑇superscript𝑅𝑇\\\\Sigma=RSS^{T}R^{T} |  | (1) |\n\nThis factorization allows independent optimization of the Gaussians’ attributes while maintaining the semi-definite property of the covariance matrix.\nIn summary, each Gaussian centered at point (mean) μ𝜇\\\\mu is defined as follows:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | G​(x)=e−12​xT​Σ−1​x,𝐺𝑥superscript𝑒12superscript𝑥𝑇superscriptΣ1𝑥G(x)=e^{-\\\\frac{1}{2}{x}^{T}\\\\Sigma^{-1}x}, |  | (2) |\n\nwhere x𝑥x refers to the distance between μ𝜇\\\\mu and the query point. G​(x)𝐺𝑥G(x) is multiplied by α𝛼\\\\alpha in the blending process to construct the final accumulated color:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | C=∑i∈Nci​αi​G​(xi)​∏j=1i−1(1−αj​G​(xj)),𝐶subscript𝑖𝑁subscript𝑐𝑖subscript𝛼𝑖𝐺subscript𝑥𝑖superscriptsubscriptproduct𝑗1𝑖11subscript𝛼𝑗𝐺subscript𝑥𝑗C=\\\\sum\\_{i\\\\in N}c\\_{i}\\\\alpha\\_{i}G(x\\_{i})\\\\prod\\_{j=1}^{i-1}(1-\\\\alpha\\_{j}G(x\\_{j})), |  | (3) |\n\nAn efficient tile-based rasterizer enables fast forward and backward pass that facilitates real-time rendering.\nThe optimization method of 3D Gaussian properties is interleaved with adaptive density control of Gaussians, namely, densifying and pruning operations, where Gaussians are added and occasionally removed.\nIn our work, we follow the convention in 3D Gaussian splatting to establish the Gaussian attributes but identify specific canonicalization designed for single image-to-3D task. We first reduce the degree of the spherical harmonic coefficients and allow only diffuse colors for the 3D Gaussians. Additionally, we set canonical isotropic scale and rotation for the 3D Gaussians, as we find these attributes extremely unstable during the amortized optimization process.\n\n![Refer to caption]Figure 2: Architecture of our coarse hybrid generator. We first use a pre-trained DINOv2 image encoder to extract essential features and then adopt two transformers that individually map learnable query tokens to Gaussian locations and a texture field. The texture field accepts location queries from the geometry branch, and a decoding MLP further converts the interpolated plane features into Gaussian attributes.\n\n### 3.2 Coarse Hybrid Generator\n\nIn the coarse stage, our AGG framework utilizes a hybrid generator to produce a hybrid representation as an intermediate generation target. Initially, the input image is encoded using a vision transformer.\nSubsequently, a geometry and a texture generator are constructed to map learnable queries into location sequences and texture fields individually.\nThis hybrid representation is then decoded into explicit 3D Gaussians, which enables efficient high-resolution rendering and facilitates supervision via multi-view images.\nThe overall architecture of our proposed coarse hybrid generator is illustrated in Fig. [2]Figure 2 ‣ 3.1 Background: 3D Gaussian Splatting (3DGS) ‣ 3 Amortized Generative 3D Gaussians ‣ AGG: Amortized Generative 3D Gaussians for Single Image to 3D\"). Our model is trained via rendering loss defined on multi-view images and is warmed up with Chamfer distance loss using 3D Gaussian pseudo labels.\n\n##### Encoding Input RGB Information\n\nSingle image-to-3D is a highly ill-posed problem since multiple 3D objects can align with the single-view projection. As a result, an effective image encoder is greatly needed to extract essential 3D information.\nPrevious work \\[ [24]), [25])\\] mainly incorporate CLIP image encoder \\[ [37])\\], benefiting from the foundational training of Stable diffusion \\[ [38])\\].\nWhile effective for text-to-image generation, CLIP encoder is not well-designed for identifying feature correspondences, which is crucial for 3D vision tasks.\nAs a result, we use the pre-trained DINOv2 transformer as our image encoder, which has demonstrated robust feature extraction capability through self-supervised pre-training.\nUnlike previous works \\[ [46]), [51])\\] that only use the aggregated global \\[CLS\\] token\n, we choose to incorporate patch-wise features as well.\n\n##### Geometry Predictor\n\nThe location information of 3D Gaussian is expressed via their 3D means following 3DGS \\[ [20])\\], which is a three-dimensional vector for each point. Thus, we adopt a transformer-based network for predicting the location sequence. The transformer inputs are a set of learnable queries implemented with a group of learnable position embeddings. Each query will correspond to one 3D Gaussian that we generate. Before feeding into the transformer network, the positional embeddings are summed with the global token \\[CLS\\] extracted from the DINOv2 model. The sequence of queries is then modulated progressively by a series of transformer blocks, each containing a cross-attention block, a self-attention block, and a multi-layer perception block. These components are interleaved with LayerNorm and GeLU activations. The cross-attention blocks accept DINOv2 features as context information. The final layer of our geometry predictor involves an MLP decoding head, converting the hidden features generated by attention modules into a three-dimensional location vector.\n\n##### Texture Field Generator\n\nJoint prediction of texture and geometry presents significant challenges.\nA primary challenge is the lack of direct ground truth supervision for texture in 3D space. Instead, texture information is inferred through rendering losses in 2D.\nWhen geometry and texture information are decoded from a shared network, their generation becomes inevitably intertwined. Consequently, updating the predicted location alters the supervision for rendered texture, leading to divergent optimization directions for texture prediction.\n\nTo resolve this, a distinct transformer is employed to generate a texture field. Our texture field is implemented using a triplane \\[ [5])\\], complemented by a shared decoding MLP head.\nThe triplane accepts 3D location queries from the geometry branch and concatenates interpolated features for further processing.\nUtilization of this texture field facilitates decomposed optimization of geometry and texture information. More importantly, texture information is now stored in structured planes.\nIncorrect geometry predictions do not impact the texture branch’s optimization process, which receives accurate supervision when geometry queries approximate ground truth locations.\n\n##### Supervision Through 2D Renderings\n\nThanks to the efficient rasterizer for 3D Gaussians, we can apply supervision on novel view renderings during the training. The 3D Gaussians we generate are rendered from randomly selected novel views, and image-space loss functions are calculated against ground truth renderings available from the dataset. Concretely, we render the scene into RGB images and corresponding foreground alpha masks. We utilize LPIPS \\[ [63])\\] and ℒ1subscriptℒ1\\\\mathcal{L}\\_{1} loss to minimize their differences,\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | ℒrendering=ℒrgba+ω1​ℒlpips,subscriptℒrenderingsubscriptℒrgbasubscript𝜔1subscriptℒlpips\\\\mathcal{L}\\_{\\\\text{rendering}}=\\\\mathcal{L}\\_{\\\\text{rgba}}+\\\\omega\\_{1}\\\\mathcal{L}\\_{\\\\text{lpips}}, |  | (4) |\n\nwhere ω1subscript𝜔1\\\\omega\\_{1} is a weighting factor.\n\n### 3.3 Gaussian Super Resolution\n\nAlthough our hybrid generator is effective in the coarse generation stage, generating high-resolution 3D Gaussians requires many learnable queries which are computationally expensive due to the quadratic cost of self-attention layers.\nAs a result, we instead utilize a second-stage network as a super-resolution module to introduce more 3D Gaussians into our generation.\nSince coarse geometry is obtained from the first stage, the super-resolution network can focus more on refining local details. For simplicity, we use a lightweight UNet architecture with the efficient point-voxel layers \\[ [26])\\], as shown in Fig. [3]Figure 3 ‣ Incorporating RGB information ‣ 3.3 Gaussian Super Resolution ‣ 3 Amortized Generative 3D Gaussians ‣ AGG: Amortized Generative 3D Gaussians for Single Image to 3D\").\n\n##### Latent Space Super-Resolution\n\nAs mentioned earlier, the 3D Gaussians require curated locations to update the other attributes properly.\nThis leads to the key challenge for the super-resolution stage, which is to introduce more point locations for the super-resolved 3D Gaussians.\nInspired by previous works in 2D image \\[ [41])\\] and point cloud super resolution \\[ [36])\\], we perform feature expanding as a surrogate of directly expanding the number of points.\nThrough a point-voxel convolutional encoder, we first convert the stage one coarse 3D Gaussians into compact latent features that can be safely expanded through a feature expansion operation:\nrearranging a tensor of shape (B, N, C ×\\\\times r) to a tensor of shape (B, N ×\\\\times r, C).\nThe expanded features are then decoded through a point-voxel convolutional decoder that predicts the Gaussian locations and other attributes.\n\n##### Incorporating RGB information\n\nWhile the first-stage network may capture the rough geometry of objects, the texture field may converge into blurry results due to the oscillating point locations and rough geometry. Consequently, utilizing the abundant texture information from the input image is crucial for the super-resolution network to generate plausible details. For this purpose, we introduce RGB features into the bottleneck of the UNet architecture.\nSpecifically, we adopt cross-attention layers before and after the feature expansion operation. Image features are fed through cross-attention layers to modulate the latent point-voxel features.\n\n![Refer to caption]Figure 3: Illustration of the second-stage Gaussian super-resolution network. We first encode the original input image and the stage one prediction separately. Then, we unite them through cross-attention at the latent space. We perform super-resolution in the latent space and decode the features jointly.\n\n### 3.4 Overcoming Challenges in Amortized Training\n\nUnlike the vanilla 3D Gaussian splatting setting, where a set of 3D Gaussians are optimized specifically for each object, our amortized framework involves training a generator that jointly produces the 3D Gaussians for a large set of objects coming from diverse categories.\nAs a result, many specifically designed operations for manipulating 3D Gaussians are not available in our setting. Below, we illustrate how we overcome these challenges in detail.\n\n#### 3.4.1 Adaptive Density Control\n\nThe original 3D Gaussians involve special density control operations to move them toward their desired 3D locations. However, in the amortized training setting, it is non-straightforward to adaptively clone, split, or prune the Gaussians according to the gradients they receive. This is because these operations change the number of points, making it hard for an amortized framework to process.\n\nTo this end, we use a fixed number of 3D Gaussians for each object, avoiding the burden for the generator network to determine the number of points needed.\nMoreover, since we do not have access to clone and split operations, training the amortized generator leads to sharp 3D Gaussians with unpleasant colors that\nare trying to mimic fine-grained texture details. Once the predictions become sharp, they get stuck in the local minimum, and therefore, fewer 3D Gaussians are available to represent the overall object, leading to blurry or corrupted generations. To overcome the issue, we empirically set canonical isotropic scales and rotations for the 3D Gaussians on all objects to stabilize the training process.\n\n#### 3.4.2 Initialization\n\nProper initialization plays an important role in the original optimization-based 3D Gaussian splatting. Though Gaussian locations are jointly optimized with other attributes, it is observed that optimization updates often prefer reducing the opacity and scale instead of moving the Gaussians directly. By doing so, Gaussians are eliminated from the wrong location after reaching the pruning threshold. Instead, the adaptive density control can then clone or split Gaussians at proper locations according to their gradients. Albeit the simplicity of pruning and cloning operations for optimization algorithms, they are non-trivial to implement with amortized neural networks.\n\nTo overcome the issues, we warm up the generator with 3D Gaussian pseudo labels. We use a few 3D objects and perform multi-view reconstruction to obtain 3D Gaussians for each object. Since multiple sets of 3D Gaussians can all be plausible for reconstructing the same 3D ground truth object, the 3D Gaussians are only considered pseudo labels where we use their attributes to initialize our network layers properly.\n\nDue to these Gaussians being stored in random orders as sets, we cannot use ℒ1subscriptℒ1\\\\mathcal{L}\\_{1} reconstruction loss as in generative frameworks such as LION \\[ [62])\\].\n\nAs an alternative, we utilize the Chamfer distance loss to pre-train our network.\nSpecifically, we first calculate the point matching correspondences according to the distance of Gaussians’ 3D means and then minimize the ℒ1subscriptℒ1\\\\mathcal{L}\\_{1} difference of each attribute, including location, opacity, and color. The formulation can be summarized as follows,\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | ℒchamfer​(f)subscriptℒchamfer𝑓\\\\displaystyle\\\\mathcal{L}\\_{\\\\text{chamfer}}(f) | =w1\\|P1\\|​∑p1​i∈P1,p2​j=arg​minx∈P2⁡(‖p1​i−x‖22)(‖f1​i−f2​j‖)absentsubscript𝑤1subscript𝑃1subscriptsubscript𝑝1𝑖subscript𝑃1subscript𝑝2𝑗subscriptargmin𝑥subscript𝑃2superscriptsubscriptnormsubscript𝑝1𝑖𝑥22normsubscript𝑓1𝑖subscript𝑓2𝑗\\\\displaystyle=\\\\dfrac{w\\_{1}}{\\|P\\_{1}\\|}\\\\sum\\\\limits\\_{\\\\begin{subarray}{c}p\\_{1i}\\\\in P\\_{1},\\\\\\<br>p\\_{2j}=\\\\operatorname\\*{arg\\\\,min}\\\\limits\\_{x\\\\in P\\_{2}}\\\\left(\\\\left\\\\\\|p\\_{1i}-x\\\\right\\\\\\|\\_{2}^{2}\\\\right)\\\\end{subarray}}(\\|\\|f\\_{1i}-f\\_{2j}\\|\\|) |  |\n|  |  | +w2\\|P2\\|​∑p2​j∈P2,p1​i=arg​minx∈P1⁡(‖x−p2​j‖22)(‖f2​j−f1​i‖),subscript𝑤2subscript𝑃2subscriptsubscript𝑝2𝑗subscript𝑃2subscript𝑝1𝑖subscriptargmin𝑥subscript𝑃1superscriptsubscriptnorm𝑥subscript𝑝2𝑗22normsubscript𝑓2𝑗subscript𝑓1𝑖\\\\displaystyle+\\\\dfrac{w\\_{2}}{\\|P\\_{2}\\|}\\\\sum\\\\limits\\_{\\\\begin{subarray}{c}p\\_{2j}\\\\in P\\_{2},\\\\\\<br>p\\_{1i}=\\\\operatorname\\*{arg\\\\,min}\\\\limits\\_{x\\\\in P\\_{1}}\\\\left(\\\\left\\\\\\|x-p\\_{2j}\\\\right\\\\\\|\\_{2}^{2}\\\\right)\\\\end{subarray}}(\\|\\|f\\_{2j}-f\\_{1i}\\|\\|), |  |\n\nwhere f𝑓f refers to 3D Gaussian attributes, P1subscript𝑃1P\\_{1} is our generated set of 3D Gaussian, and P2subscript𝑃2P\\_{2} is the 3D Gaussian pseudo label.",
            "citations": null
          },
          "4 Experiments": {
            "content": "![Refer to caption]Figure 4: Novel view rendering comparisons against baseline methods. Our AGG model observes none of these testing images during training.\n\n### 4.1 Implementation Details\n\n##### Gaussian Configuration\n\nWe set the canonical isotropic scale of each 3D Gaussian to 0.03 and 0.01 when 4,096 and 16,384 3D Gaussians are produced for each object, respectively.\nThe canonical rotation for all 3D Gaussians is set to \\[1, 0, 0, 0\\] for the rasterizer.\nWhen preparing the pseudo labels for the warmup training, we use the ground truth point clouds from the OmniObject3D \\[ [50])\\] dataset to initialize the Gaussian locations.\n\n##### Network Architecture\n\nWe implement our transformer blocks following the well-established practice in DINOv2 \\[ [33])\\] with GeLU activation and Layer Normalization layers.\nThe image features are extracted using a pre-trained DINOv2-base model at 256 ×\\\\times 256 input resolution.\n\n##### Object Placement and Camera System\n\nWe reconstruct objects in camera space and normalize the input view azimuth to zero. This means that the image and the 3D assets are aligned and consistent as both are rotated. This 3D augmentation during the training stage enforces rotation equivariance and prevents the network from merely overfitting the canonical placements of objects in the dataset.\n\n### 4.2 Baseline Methods\n\nWe compare with two streams of work. One involves the sampling-based 3D generation that uses different 3D representations, such as Point-E and One-2345.\nPoint-E \\[ [32])\\] includes a large diffusion transformer that generates a point cloud.\nTheir work performs the generation in the world coordinates, where objects are always canonically placed as the original orientation in the dataset.\nOne-2345 \\[ [23])\\] leverages Zero123 \\[ [24])\\] and utilizes SparseNeuS \\[ [27])\\] to fuse information from noisy multi-view generations efficiently.\nWe also compare with DreamGaussian \\[ [44])\\]’s first stage, where 3D Gaussians are optimized with SDS \\[ [35])\\] from Zero123 \\[ [24])\\].\nBoth One-2345 and DreamGaussian require the elevation of the input image at inference time. For One-2345, we use official scripts to estimate the elevation. We provide DreamGaussian with ground truth elevation extracted from the camera pose in the testing dataset.\n\n### 4.3 Dataset\n\nOur model is trained on OmniObject3D dataset \\[ [50])\\], which contains high-quality scans of real-world objects. The number of 3D objects is much fewer than Objaverse \\[ [10])\\]. Alongside point clouds, the OmniObject3D dataset provides 2D renderings of objects obtained through Blender. This allows us to implement rendering-based loss functions that supervise the rendering quality in 2D space. We construct our training set using 2,370 objects from 73 classes in total. We train one model using all classes. The test set contains 146 objects, with two left-out objects per class.\n\n### 4.4 Qualitative and Quantitative Comparisons\n\nWe provide visual comparisons and quantitative analysis between our methods and existing baselines in Fig. [4]Figure 4 ‣ 4 Experiments ‣ AGG: Amortized Generative 3D Gaussians for Single Image to 3D\") and Tab. [1]Table 1 ‣ 4.4 Qualitative and Quantitative Comparisons ‣ 4 Experiments ‣ AGG: Amortized Generative 3D Gaussians for Single Image to 3D\").\nAs shown in the novel view synthesis results, our model learns reasonable geometry understanding and produces plausible generations of texture colors. Point-E \\[ [32])\\] produces reasonable geometry but presents unrealistic colors, possibly because the model was trained on large-scale synthetic 3D data. Both One-2345 \\[ [23])\\] and DreamGaussian \\[ [44])\\] can generate corrupted shapes,\nwhich might be because the novel views synthesized from the Zero-123 diffusion model \\[ [24])\\] are multi-view inconsistent.\n\nSince multiple 3D objects can be reasonable outputs inferred from the single view input, we don’t measure exact matches against the 3D ground truth. Instead, we use CLIP distance defined on image embeddings to reflect high-level image similarity on multi-view renderings, where our method obtains competitive numbers.\nAdditionally, our AGG network enjoys the fastest inference speed.\n\nIn comparison, both Point-E and One-2345 adopt an iterative diffusion process when producing their final results, while DreamGaussian leverages a costly optimization process through score distillation sampling.\n\nTable 1: Comparisons against baseline methods regarding novel view image quality and inference speed.\n\n| Method | Point-E | One-2345 | DreamGaussian | Ours |\n| --- | --- | --- | --- | --- |\n| CLIP Dist ↓↓\\\\downarrow | 0.5139 | 0.3084 | 0.4293 | 0.3458 |\n| Time (s) | 78 | 45 | 60 | 0.19 |\n\nTable 2: Ablation Studies. We validate the effectiveness of our proposed components by comparing their predictions against the 3D ground truth on the test set.\n\n| Model | PSNR↑↑\\\\uparrow | SSIM↑↑\\\\uparrow | LPIPS↓↓\\\\downarrow |\n| --- | --- | --- | --- |\n| w/o Texture Field | 27.09 | 0.85 | 0.1910 |\n| w/o Super Resolution | 27.59 | 0.87 | 0.1772 |\n| Full Model | 28.54 | 0.87 | 0.1426 |\n\n![Refer to caption]Figure 5: Visual comparisons of our full model (c) and its variants: (a) w/o Texture Field, (b) w/o Super Resolution.\n\n### 4.5 Ablation Study\n\nWe conduct thorough experiments to validate the effectiveness of our proposed components using the available 3D ground truth from the dataset.\nWe mainly compare with two variants of the model. “w/o Super Resolution” means that we only train the coarse hybrid generator without involving the Gaussian super-resolution stage. “w/o Texture Field” refers to further removing the texture field generator branch in the coarse hybrid generator and forcing the geometry predictor to generate all attributes at the same time.\nAs shown in Tab. [2]Table 2 ‣ 4.4 Qualitative and Quantitative Comparisons ‣ 4 Experiments ‣ AGG: Amortized Generative 3D Gaussians for Single Image to 3D\") and Fig. [5]Figure 5 ‣ 4.4 Qualitative and Quantitative Comparisons ‣ 4 Experiments ‣ AGG: Amortized Generative 3D Gaussians for Single Image to 3D\"), the full model delivers the best generation results when rendered from novel viewpoints. Results from “w/o Super Resolution” are limited in the number of Gaussians and, therefore, suffer from low resolution and blurry results. The variant “w/o Texture Field” produces corrupted geometry due to the extra burden for the geometry predictor to predict texture information at the same time.\n\n### 4.6 Limitation\n\nDespite the encouraging visual results produced by AGG, the number of 3D Gaussians we generate is still limited to represent very complex geometry. In the future, we will further explore how to expand AGG to more challenging scenarios, such as when the input image contains multiple objects with occlusion.",
            "citations": null
          },
          "5 Conclusion": {
            "content": "In this work, we make the first attempt to develop an amortized pipeline capable of generating 3D Gaussians from a single image input. The proposed AGG framework utilizes a cascaded generation pipeline, comprising a coarse hybrid generator and a Gaussian super-resolution model. Experimental results demonstrate that our method achieves competitive performance with several orders of magnitude speedup in single-image-to-3D generation, compared to both optimization-based 3D Gaussian frameworks and sampling-based 3D generative models utilizing alternative 3D representations.",
            "citations": null
          }
        },
        "abstract": "Given the growing need for automatic 3D content creation pipelines, various\n3D representations have been studied to generate 3D objects from a single\nimage. Due to its superior rendering efficiency, 3D Gaussian splatting-based\nmodels have recently excelled in both 3D reconstruction and generation. 3D\nGaussian splatting approaches for image to 3D generation are often\noptimization-based, requiring many computationally expensive score-distillation\nsteps. To overcome these challenges, we introduce an Amortized Generative 3D\nGaussian framework (AGG) that instantly produces 3D Gaussians from a single\nimage, eliminating the need for per-instance optimization. Utilizing an\nintermediate hybrid representation, AGG decomposes the generation of 3D\nGaussian locations and other appearance attributes for joint optimization.\nMoreover, we propose a cascaded pipeline that first generates a coarse\nrepresentation of the 3D data and later upsamples it with a 3D Gaussian\nsuper-resolution module. Our method is evaluated against existing\noptimization-based 3D Gaussian frameworks and sampling-based pipelines\nutilizing other 3D representations, where AGG showcases competitive generation\nabilities both qualitatively and quantitatively while being several orders of\nmagnitude faster. Project page: https://ir1d.github.io/AGG/"
      },
      "bib.bib106": {
        "id": "bib.bib106",
        "citation": "[106]",
        "authors": "",
        "year": "",
        "title": "Instantmesh: Efficient 3d mesh generation from a single image with sparse-view large reconstruction models.",
        "venue": "",
        "pages": "",
        "url": "https://arxiv.org/abs/2404.07191",
        "arxiv_id": "2404.07191",
        "doi": null,
        "sections": {
          "1 Introduction": {
            "content": "Crafting 3D assets from single-view images can facilitate a broad range of applications,\neg, virtual reality, industrial design, gaming and animation. We have witnessed a revolution on image and video generation with the emergence of large-scale diffusion models \\[ [37]), [38])\\] trained on billion-scale data, which is able to generate vivid and imaginative contents from open-domain prompts. However, duplicating this success on 3D generation presents challenges due to the limited scale and poor annotations of 3D datasets.\n\nTo circumvent the problem of lack of 3D data, previous works have explored distilling 2D diffusion priors into 3D representations with a per-scene optimization strategy. DreamFusion \\[ [34])\\] proposes score distillation sampling (SDS) which makes a breakthrough in open-world 3D synthesis.\nHowever, SDS with text-to-2D models frequently encounter the multi-face issue, _i.e_., the “Janus” problem.\nTo improve 3D consistency, later work \\[ [35])\\] proposes to distill from Zero123 \\[ [23])\\] which is a novel view generator fine-tuned from Stable Diffusion \\[ [37])\\].\nA series of works \\[ [42]), [50]), [26]), [24]), [47])\\] further propose multi-view generation models, thereby the optimization processes can be guided by multiple novel views simultaneously.\n\n2D distillation based methods exhibit strong zero-shot generation capability, but they are time-consuming and not practical for real-world applications.\nWith the advent of large-scale open-world 3D datasets \\[ [8]), [9])\\], pioneer works \\[ [14]), [13]), [45])\\] demonstrate that\nimage tokens can be directly mapped to 3D representations ( _e.g_., triplanes) via a novel large reconstruction model (LRM).\nBased on a highly scalable transformer architecture, LRMs point out a promising direction for the fast creation of high-quality 3D assets.\nConcurrently, Instant3D \\[ [19])\\] proposes a diagram that predicts 3D shapes via an enhanced LRM with multi-view input generated by diffusion models. The method marries LRMs with image generation models, which significantly improves the generalization ability.\n\nLRM-based methods use triplanes as the 3D representation, where novel views are synthesized using an MLP.\nDespite the strong geometry and texture representation capability,\ndecoding triplanes requires a memory-intensive volume rendering process, which significantly impedes training scales.\nMoreover, the expensive computational overhead makes it challenging to utilize high-resolution RGB and geometric information ( _e.g_., depths and normals) for supervision. To boost the training efficiency, recent works seek to utilize Gaussians \\[ [18])\\] as the 3D representation, which is effective for rendering but not suitable for geometric modeling. Several concurrent works \\[ [63]), [54])\\] opt to apply supervisions on the mesh representation directly using differentiable surface optimization techniques \\[ [39]), [40])\\]. However, they adopt CNN-based architectures, which limit their flexibility to deal with varying input viewpoints and training scalability on larger datasets that may be available in the future.\n\nIn this work, we present InstantMesh, a feed-forward framework for high-quality 3D mesh generation from a single image. Given an input image, InstantMesh first generates 3D consistent multi-view images with a multi-view diffusion model, and then utilizes a sparse-view large reconstruction model to predict a 3D mesh directly, where the whole process can be accomplished in seconds. By integrating a differentiable iso-surface extraction module, our reconstruction model applies geometric supervisions on the mesh surface directly, enabling satisfying training efficiency and mesh generation quality. Building upon an LRM-based architecture, our model offers superior training scalability to large-scale datasets. Experimental results demonstrate that InstantMesh outperforms other latest image-to-3D approaches significantly. We hope that InstantMesh can serve as a powerful image-to-3D foundation model and make substantial contributions to the field of 3D generative AI.",
            "citations": null
          },
          "2 Related Work": {
            "content": "Image-to-3D.\nEarly attempts on image-to-3D mainly focus on the single-view reconstruction task \\[ [64]), [49]), [33]), [4]), [28]), [32])\\]. With the rise of diffusion models, pioneer works have investigated image-conditioned 3D generative modeling on various representations, _e.g_., point clouds \\[ [31]), [27]), [56]), [64]), [46])\\], meshes \\[ [25]), [1])\\], SDF grids \\[ [62]), [6]), [7]), [43])\\] and neural fields \\[ [11]), [30]), [61]), [16]), [52])\\]. Despite the promising progress these methods have made, they are hard to generalize to open-world objects due to the limited scale of training data.\n\n![Refer to caption]Figure 2: The overview of our InstantMesh framework. Given an input image, we first utilize a multi-view diffusion model to synthesize 6 novel views at fixed camera poses. Then we feed the generated multi-view images into a transformer-based sparse-view large reconstruction model to reconstruct a high-quality 3D mesh. The whole image-to-3D generation process takes only around 10 seconds. By integrating an iso-surface extraction module, _i.e_., FlexiCubes, we can render the 3D geometry efficiently and apply geometric supervisions like depths and normals directly on the mesh representation to enhance the results.\n\nThe advent of powerful text-to-image diffusion models \\[ [38]), [37])\\] inspires the idea of distilling 2D diffusion priors into 3D neural radiance fields with a per-scene optimization strategy. The score distillation sampling (SDS) proposed by DreamFusion \\[ [34])\\] exhibits superior performance on zero-shot text-to-3D synthesis and outperforms CLIP-guided alternatives \\[ [36]), [15]), [58])\\] significantly. However, SDS-based methods \\[ [48]), [20]), [3]), [53])\\] frequently encounter the multi-face issue, also known as the “Janus” problem. Zero123 \\[ [23])\\] demonstrates that Stable Diffusion can be fine-tuned to synthesize novel views by conditioning on relative camera poses. Leveraging the novel view guidance provided by Zero123, recent image-to-3D methods \\[ [22]), [35]), [57])\\] show improved 3D consistency and can generate plausible shapes from open-domain images.\n\nMulti-view Diffusion Models.\nTo address the inconsistency among multiple generated views of Zero123, some works \\[ [24]), [26]), [41]), [50])\\] try to fine-tune 2D diffusion models to synthesize multiple views for the same object simultaneously. With 3D consistent multi-view images, various techniques can be applied to obtain the 3D object, _e.g_., SDS optimization \\[ [50])\\], neural surface reconstruction methods \\[ [24]), [26])\\], multi-view-conditioned 3D diffusion models \\[ [21])\\]. To further enhance the generalization capability and multi-view consistency, some recent works\\[ [47]), [5]), [12]), [66])\\] exploit the temporal priors in video diffusion models for multi-view generation.\n\nLarge Reconstruction Models.\nThe availability of large-scale 3D datasets \\[ [8]), [9])\\] enables training highly generalizable reconstruction models for feed-forward image-to-3D creation. Large Reconstruction Model \\[ [14]), [51]), [19]), [60])\\] (LRM) demonstrates that the transformer backbone can effectively map image tokens to implicit 3D triplanes with multi-view supervision. Instant3D \\[ [19])\\] further extends LRM to sparse-view input, significantly boosting the reconstruction quality. By combining with multi-view diffusion models, Instant3D can achieve highly generalizable and high-quality single-image to 3D generation. Inspired by Instant3D, LGM \\[ [44])\\] and GRM \\[ [59])\\] replace the triplane NeRF \\[ [29])\\] representation with 3D Gaussians \\[ [18])\\] to enjoy its superior rendering efficiency and circumvent the need for memory-intensive volume rendering process. However, Gaussians fall short on explicit geometry modeling and high-quality surface extraction. Given the success of neural mesh optimization methods \\[ [39]), [40])\\], concurrent works MVD2\\[ [63])\\] and CRM \\[ [54])\\] opt to optimize on the mesh representation directly for efficient training and high-quality geometry and texture modeling. Different from their convolutional network architecture, our model is built upon LRM and opts for a purely transformer-based architecture, offering superior flexibility and training scalability.",
            "citations": null
          },
          "3 InstantMesh": {
            "content": "The architecture of InstantMesh is similar to Instant3D \\[ [19])\\], consisting of a multi-view diffusion model GMsubscript𝐺𝑀G\\_{M} and a sparse-view large reconstruction model GRsubscript𝐺𝑅G\\_{R}. Given an input image I𝐼I, GMsubscript𝐺𝑀G\\_{M} generates 3D consistent multi-view images from I𝐼I, which are fed into GRsubscript𝐺𝑅G\\_{R} to reconstruct a high-quality 3D mesh. We now introduce our technical improvements on data preparation, model architecture and training strategies.\n\n### 3.1 Multi-view Diffusion Model\n\nTechnically, our sparse-view reconstruction model accepts free-viewpoint images as input, so we can integrate arbitrary multi-view generation model into our framework,\n_e.g_., MVDream \\[ [42])\\], ImageDream \\[ [50])\\], SyncDreamer \\[ [24])\\], SPAD \\[ [17])\\] and SV3D \\[ [47])\\], to achieve both text-to-3D and image-to-3D assets creation. We opt for Zero123++ \\[ [41])\\] due to its reliable multi-view consistency and tailored viewpoint distribution that covers both the upper and lower parts of a 3D object.\n\nWhite-background Fine-tuning.\nGiven an input image, Zero123++ generates a 960×640960640960\\\\times 640 gray-background image presenting 6 multi-view images in a 3×2323\\\\times 2 grid. In practice, we notice that the generated background is not consistent across different image areas and varies in RGB values, leading to floaters and cloud-like artifacts in the reconstruction results. And LRMs are often trained on white-background images too. To remove the gray background, we need to utilize third-party libraries or models that cannot guarantee the segmentation consistency among multiple views. Therefore, we opt to fine-tune Zero123++ to synthesize consistent white-background images, ensuring the stability of the latter sparse-view reconstruction procedure.\n\nData Preparation and Fine-tuning Details.\nWe prepare the fine-tuning data following the camera distribution of Zero123++. Specifically, for each 3D model in the LVIS subset of Objaverse \\[ [8])\\], we render a query image and 6 target images, all in white backgrounds. The azimuth, elevation and camera distance of the query image is randomly sampled from a pre-defined range. The poses of the 6 target images consist of interleaving absolute elevations of 20∘superscript2020^{\\\\circ} and −10∘superscript10-10^{\\\\circ}, combined with azimuths relative to the query image that start at 30∘superscript3030^{\\\\circ} and increase by 60∘superscript6060^{\\\\circ} for each pose.\n\nDuring fine-tuning, we use the query image as the condition and stitch the 6 target images into a 3×2323\\\\times 2 grid for denoising. Following Zero123++, we adopt the linear noise schedule and v𝑣v-prediction loss. We also randomly resize the conditional image to make the model adapt to various input resolutions and generate clear images. Since the goal of fine-tuning is a simple replacement of background color, it converges extremely fast. Specifically, we fine-tune the UNet for 1000 steps with a learning rate of 1.0×10−51.0superscript1051.0\\\\times 10^{-5} and a batch size of 48. The fine-tuned model can fully preserve the generation capability of Zero123++ and produce white-background images consistently.\n\n### 3.2 Sparse-view Large Reconstruction Model\n\nWe present the details of the sparse-view reconstruction model GRsubscript𝐺𝑅G\\_{R} that predicts meshes given generated multi-view images. The architecture of GRsubscript𝐺𝑅G\\_{R} is modified and enhanced from Instant3D \\[ [19])\\].\n\nData Preparation.\nOur training dataset is composed of multi-view images rendered from the Objaverse \\[ [8])\\] dataset. Specifically, we render 512×512512512512\\\\times 512 images, depths and normals from 32 random viewpoints for each object in the dataset. Besides, we use a filtered high-quality subset to train our model. The filtering goal is to remove objects that satisfy any of the following criteria: (i) objects without texture maps, (ii) objects with rendered images occupying less than 10%percent1010\\\\% of the view from any angle, (iii) including multiple separate objects, (iv) objects with no caption information provided by the Cap3D dataset, and (v) low-quality objects. The classification of “low-quality” objects is determined based on the presence of tags such as “lowpoly” and its variants (e.g.,\n“low\\_poly”) in the metadata. Specifically, by applying our filtering criteria, we curated approximately 270k high-quality instances from the initial pool of 800k objects in the Objaverse dataset.\n\nInput Views and Resolution.\nDuring training, we randomly select a subset of 6 images as input and another 4 images as supervision for each object. To be consistent with the output resolution of Zero123++, all the input images are resized to 320×320320320320\\\\times 320. During inference, we feed the 6 images generated by Zero123++ as the input of the reconstruction model, whose camera poses are fixed. To be noted, our transformer-based architecture makes it natural to utilize varying number of input views, thus it is practical to use less input views for reconstruction, which can alleviate the multi-view inconsistency issue in some cases.\n\nMesh as 3D Representation.\nPrevious LRM-based methods output triplanes that require volume rendering to synthesize images. During training, volume rendering is memory expensive that hinders the use of high-resolution images and normals for supervision.\nTo enhance the training efficiency and reconstruction quality, we integrate a differentiable iso-surface extraction module, _i.e_., FlexiCubes \\[ [40])\\], into our reconstruction model. Thanks to the efficient mesh rasterization, we can use full-resolution images and additional geometric information for supervision, _e.g_., depths and normals, without cropping them into patches. Applying these geometric supervisions leads to smoother mesh outputs compared to the meshes extracted from the triplane NeRF. Besides, using mesh representation can also bring convenience to applying additional post-processing steps to enhance the results, such as SDS optimization \\[ [20]), [3])\\] or texture baking \\[ [22])\\]. We leave it as a future work.\n\nDifferent from the single-view LRM, our reconstruction model takes 6 views as input, requiring more memory for the cross-attention between the triplane tokens and image tokens. We notice that training such a large-scale transformer from scratch requires a significant period of time. For faster convergence, we initialize our model using the pre-trained weights of OpenLRM \\[ [13])\\], an open-source implementation of LRM. We adopt a two-stage training strategy as described below.\n\nStage 1: Training on NeRF.\nIn the first stage, we train on the triplane NeRF representation and reuse the prior knowledge of the pre-trained OpenLRM. To enable multi-view input, we add AdaLN camera pose modulation layers in the ViT image encoder to make the output image tokens pose-aware following Instant3D, and remove the source camera modulation layers in the triplane decoder of LRM. We adopt both image loss and mask loss in this training stage:\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n|  | ℒ1subscriptℒ1\\\\displaystyle\\\\mathcal{L}\\_{1} | =∑i‖I^i−Iig​t‖22absentsubscript𝑖superscriptsubscriptnormsubscript^𝐼𝑖superscriptsubscript𝐼𝑖𝑔𝑡22\\\\displaystyle=\\\\sum\\_{i}\\\\left\\\\\\|\\\\hat{I}\\_{i}-I\\_{i}^{gt}\\\\right\\\\\\|\\_{2}^{2} |  | (1) |\n|  |  | +λlpips​∑iℒlpips​(I^i,Iig​t)subscript𝜆lpipssubscript𝑖subscriptℒlpipssubscript^𝐼𝑖superscriptsubscript𝐼𝑖𝑔𝑡\\\\displaystyle+\\\\lambda\\_{\\\\text{lpips}}\\\\sum\\_{i}\\\\mathcal{L}\\_{\\\\text{lpips}}\\\\left(\\\\hat{I}\\_{i},I\\_{i}^{gt}\\\\right) |  |\n|  |  | +λmask​∑i‖M^i−Mig​t‖22,subscript𝜆masksubscript𝑖superscriptsubscriptnormsubscript^𝑀𝑖superscriptsubscript𝑀𝑖𝑔𝑡22\\\\displaystyle+\\\\lambda\\_{\\\\text{mask}}\\\\sum\\_{i}\\\\left\\\\\\|\\\\hat{M}\\_{i}-M\\_{i}^{gt}\\\\right\\\\\\|\\_{2}^{2}, |  |\n\nwhere I^isubscript^𝐼𝑖\\\\hat{I}\\_{i}, Iig​tsuperscriptsubscript𝐼𝑖𝑔𝑡I\\_{i}^{gt}, M^isubscript^𝑀𝑖\\\\hat{M}\\_{i} and Mig​tsuperscriptsubscript𝑀𝑖𝑔𝑡M\\_{i}^{gt} denote the rendered images, ground truth images, rendered mask, and ground truth masks of the i𝑖i-th view, respectively. During training, we set λlpips=2.0,λmask=1.0formulae-sequencesubscript𝜆lpips2.0subscript𝜆mask1.0\\\\lambda\\_{\\\\text{lpips}}=2.0,\\\\lambda\\_{\\\\text{mask}}=1.0, and use a learning rate of 4.0×10−44.0superscript1044.0\\\\times 10^{-4} cosine-annealed to 4.0×10−54.0superscript1054.0\\\\times 10^{-5}. To enable high-resolution training, our model renders 192×192192192192\\\\times 192 patches which are supervised by cropped ground truth patches ranging from 192×192192192192\\\\times 192 to 512×512512512512\\\\times 512.\n\nStage 2: Training on Mesh.\nIn the second stage, we switch to the mesh representation for efficient training and applying additional geometric supervisions. We integrate FlexiCubes \\[ [40])\\] into our reconstruction model to extract mesh surface from the triplane implicit fields. The original triplane NeRF renderer consists of a density MLP and a color MLP, we reuse the density MLP to predict SDF instead, and add two additional MLPs to predict the deformation and weights required by FlexiCubes.\n\nFor a density field f​(𝐱)=d,𝐱∈ℝ3formulae-sequence𝑓𝐱𝑑𝐱superscriptℝ3f(\\\\mathbf{x})=d,\\\\mathbf{x}\\\\in\\\\mathbb{R}^{3}, points inside the object have larger values and points outside the object have smaller values, while an SDF field g​(𝐱)=s𝑔𝐱𝑠g(\\\\mathbf{x})=s is just the opposite. Therefore, we initialize the weight 𝐰∈ℝC𝐰superscriptℝ𝐶\\\\mathbf{w}\\\\in\\\\mathbb{R}^{C} and bias b∈ℝ𝑏ℝb\\\\in\\\\mathbb{R} of the last SDF MLP layer as follows:\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n|  | 𝐰𝐰\\\\displaystyle\\\\mathbf{w} | =−𝐰d,absentsubscript𝐰𝑑\\\\displaystyle=-\\\\mathbf{w}\\_{d}, |  | (2) |\n|  | b𝑏\\\\displaystyle b | =τ−bd,absent𝜏subscript𝑏𝑑\\\\displaystyle=\\\\tau-b\\_{d}, |  |\n\nwhere 𝐰d∈ℝCsubscript𝐰𝑑superscriptℝ𝐶\\\\mathbf{w}\\_{d}\\\\in\\\\mathbb{R}^{C} and bd∈ℝsubscript𝑏𝑑ℝb\\_{d}\\\\in\\\\mathbb{R} are the weight and bias of the original density MLP’s last layer, and τ𝜏\\\\tau denotes the iso-surface threshold used for density fields. Denoting the input feature of the last MLP layer as 𝐟∈ℝC𝐟superscriptℝ𝐶\\\\mathbf{f}\\\\in\\\\mathbb{R}^{C}, we have\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n|  | s𝑠\\\\displaystyle s | =𝐰⋅𝐟+babsent⋅𝐰𝐟𝑏\\\\displaystyle=\\\\mathbf{w}\\\\cdot\\\\mathbf{f}+b |  | (3) |\n|  |  | =(−𝐰d)⋅𝐟+(τ−bd)absent⋅subscript𝐰𝑑𝐟𝜏subscript𝑏𝑑\\\\displaystyle=(-\\\\mathbf{w}\\_{d})\\\\cdot\\\\mathbf{f}+(\\\\tau-b\\_{d}) |  |\n|  |  | =−(𝐰d⋅𝐟+bd−τ)absent⋅subscript𝐰𝑑𝐟subscript𝑏𝑑𝜏\\\\displaystyle=-(\\\\mathbf{w}\\_{d}\\\\cdot\\\\mathbf{f}+b\\_{d}-\\\\tau) |  |\n|  |  | =−(d−τ),absent𝑑𝜏\\\\displaystyle=-(d-\\\\tau), |  |\n\nWith such an initialization, we reverse the “direction” of density field to match the SDF direction and ensure that the iso-surface boundary lies at the 0 level-set of the SDF field at the beginning. We empirically find that this initialization benefits the training stability and convergence speed of FlexiCubes. The loss function of the second stage is:\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n|  | ℒ2=ℒ1subscriptℒ2subscriptℒ1\\\\displaystyle\\\\mathcal{L}\\_{2}=\\\\mathcal{L}\\_{1} | +λdepth​∑iMg​t⊗‖D^i−Dig​t‖1subscript𝜆depthsubscript𝑖tensor-productsuperscript𝑀𝑔𝑡subscriptnormsubscript^𝐷𝑖superscriptsubscript𝐷𝑖𝑔𝑡1\\\\displaystyle+\\\\lambda\\_{\\\\text{depth}}\\\\sum\\_{i}M^{gt}\\\\otimes\\\\left\\\\\\|\\\\hat{D}\\_{i}-D\\_{i}^{gt}\\\\right\\\\\\|\\_{1} |  | (4) |\n|  |  | +λnormal​∑iMg​t⊗(1−N^i⋅Nig​t)subscript𝜆normalsubscript𝑖tensor-productsuperscript𝑀𝑔𝑡1⋅subscript^𝑁𝑖superscriptsubscript𝑁𝑖𝑔𝑡\\\\displaystyle+\\\\lambda\\_{\\\\text{normal}}\\\\sum\\_{i}M^{gt}\\\\otimes\\\\left(1-\\\\hat{N}\\_{i}\\\\cdot N\\_{i}^{gt}\\\\right) |  |\n|  |  | +λreg​ℒreg,subscript𝜆regsubscriptℒreg\\\\displaystyle+\\\\lambda\\_{\\\\text{reg}}\\\\mathcal{L}\\_{\\\\text{reg}}, |  |\n\nwhere D^isubscript^𝐷𝑖\\\\hat{D}\\_{i}, Dig​tsuperscriptsubscript𝐷𝑖𝑔𝑡D\\_{i}^{gt}, N^isubscript^𝑁𝑖\\\\hat{N}\\_{i} and Nig​tsuperscriptsubscript𝑁𝑖𝑔𝑡N\\_{i}^{gt} denote the rendered depth, ground truth depth, rendered normal and ground truth normal of the i𝑖i-th view, respectively. ⊗tensor-product\\\\otimes denotes element-wise production, and ℒregsubscriptℒreg\\\\mathcal{L}\\_{\\\\text{reg}} denotes the regularization terms of FlexiCubes. During training, we set λdepth=0.5,λnormal=0.2,λreg=0.01formulae-sequencesubscript𝜆depth0.5formulae-sequencesubscript𝜆normal0.2subscript𝜆reg0.01\\\\lambda\\_{\\\\text{depth}}=0.5,\\\\lambda\\_{\\\\text{normal}}=0.2,\\\\lambda\\_{\\\\text{reg}}=0.01, and use a learning rate of 4.0×10−54.0superscript1054.0\\\\times 10^{-5} cosine-annealed to 0. We train our model on 8 NVIDIA H800 GPUs in both stages.\n\nCamera Augmentation and Perturbation.\nDifferent from view-space reconstruction models \\[ [13]), [45]), [44]), [65])\\], our model reconstruct 3D objects in a canonical world space where the z𝑧z-axis aligns with the anti-gravity direction. To further improve the robustness on the scale and orientation of 3D objects, we perform random rotation and scaling on the input multi-view camera poses. Considering that the multi-view images generated by Zero123++ may be inconsistent with their pre-defined camera poses, we also add random noise to the camera parameters before feeding them into the ViT image encoder.\n\nTable 1: Details of sparse-view reconstruction model variants.\n\n| Parameter | InstantNeRF | InstantMesh |\n| base | large | base | large |\n| Representation | NeRF | NeRF | Mesh | Mesh |\n| Input views | 6 | 6 | 6 | 6 |\n| Transformer dim | 1024 | 1024 | 1024 | 1024 |\n| Transformer layers | 12 | 16 | 12 | 16 |\n| Triplane size | 64 | 64 | 64 | 64 |\n| Triplane dim | 40 | 80 | 40 | 80 |\n| Samples per ray | 96 | 128 | - | - |\n| Grid size | - | - | 128 | 128 |\n| Input size | 320 | 320 | 320 | 320 |\n| Render size | 192 | 192 | 512 | 512 |\n\nModel Variants.\nIn this work, we provide 4 variants of the sparse-view reconstruction model, two from Stage 1 and two from Stage 2. We name each model according to its 3D representation (“NeRF” or “Mesh”) and the scale of parameters (“base” or “large”). The details of each model are shown in Table [1]Table 1 ‣ 3.2 Sparse-view Large Reconstruction Model ‣ 3 InstantMesh ‣ InstantMesh: Efficient 3D Mesh Generation from a Single Image with Sparse-view Large Reconstruction Models\"). Considering that different 3D presentations and model scales can bring convenience to different application scenarios, we release the weights of all the 4 models. We believe our work can serve as a powerful image-to-3D foundation model and facilitate future research on 3D generative AI.",
            "citations": null
          },
          "4 Experiments": {
            "content": "In this section, we conduct experiments to compare our InstantMesh with existing state-of-the-art image-to-3D baseline methods quantitatively and qualitatively.\n\n### 4.1 Experimental Settings\n\nDatasets.\nWe evaluate the quantitative performance using two public datasets, _i.e_., Google Scanned Objects (GSO) \\[ [10])\\] and OmniObject3D (Omni3D) \\[ [55])\\]. GSO contains around 1K objects, from which we randomly pick out 300 objects as the evaluation set. For Omni3D, we select 28 common categories and then pick out the first 5 objects from each category for a total of 130 objects (some categories have less than 5 objects) as the evaluation set.\n\nTo evaluate the 2D visual quality of the generated 3D meshes, we create two image evaluation sets for both GSO and Omni3D. Specifically, we render 21 images of each object in an orbiting trajectory with uniform azimuths and varying elevations in {30∘,0∘,−30∘}superscript30superscript0superscript30\\\\{30^{\\\\circ},0^{\\\\circ},-30^{\\\\circ}\\\\}. As Omni3D also includes benchmark views randomly sampled on the top semi-sphere of an object, we pick 16 views randomly and create an additional image evaluation set for Omni3D.\n\nBaselines.\nWe compare the proposed InstantMesh with 4 baselines: (i) TripoSR \\[ [45])\\]: an open-source LRM implementation showing the best single-view reconstruction performance so far; (ii) LGM \\[ [44])\\]: a unet-based Large Gaussian Model that reconstructs Gaussians from generated multi-view images; (iii) CRM \\[ [54])\\]: a unet-based Convolutional Reconstruction Model that reconstructs 3D meshes from generated multi-view images and canonical coordinate maps (CCMs). (iv) SV3D \\[ [47])\\]: an image-conditioned diffusion model based on Stable Video Diffusion \\[ [2])\\] that generates an orbital video of an object, we only evaluate it on the novel view synthesis task since generating 3D meshes from its output is not straight-forward.\n\nMetrics.\nWe evaluate both the 2D visual quality and 3D geometric quality of the generated assets. For 2D visual evaluation, we render novel views from the generated 3D mesh and compare them with the ground truth views, and adopt PSNR, SSIM, and LPIPS as the metrics. For 3D geometric evaluation, we first align the coordinate system of the generated meshes with the ground truth meshes, and then reposition and re-scale all meshes into a cube of size \\[−1,1\\]3superscript113\\[-1,1\\]^{3}. We report Chamfer Distance (CD) and F-Score (FS) with a threshold of 0.20.20.2, which are computed by sampling 16K points from the surface uniformly.\n\n### 4.2 Main Results\n\nQuantitative Results.\nWe report the quantitative results on different evaluation sets in Table [2]Table 2 ‣ 4.2 Main Results ‣ 4 Experiments ‣ InstantMesh: Efficient 3D Mesh Generation from a Single Image with Sparse-view Large Reconstruction Models\"), [3]Table 3 ‣ 4.2 Main Results ‣ 4 Experiments ‣ InstantMesh: Efficient 3D Mesh Generation from a Single Image with Sparse-view Large Reconstruction Models\"), and [4]Table 4 ‣ 4.2 Main Results ‣ 4 Experiments ‣ InstantMesh: Efficient 3D Mesh Generation from a Single Image with Sparse-view Large Reconstruction Models\"), respectively. For each metric, we highlight the top three results among all methods, and a deeper color indicates a better result. For our method, we report the results of using different sparse-view reconstruction model variants ( _i.e_., “NeRF” and “Mesh”).\n\nFrom the 2D novel view synthesis metrics, we can observe that InstantMesh outperforms the baselines on SSIM and LPIPS significantly, indicating that its generation results have the best perceptually viewing quality. As Figure [3]Figure 3 ‣ 4.2 Main Results ‣ 4 Experiments ‣ InstantMesh: Efficient 3D Mesh Generation from a Single Image with Sparse-view Large Reconstruction Models\") shows, InstantMesh demonstrates plausible appearances, whereas the baselines frequently exhibit distortions in novel views. We can also observe that the PSNR of InstantMesh is slightly lower than the best baseline, suggesting that the novel views are less faithful to the ground truth at pixel level since they are “dreamed” by the multi-view diffusion model. However, we argue that the perceptual quality is more important than faithfulness, as the “true novel views” should be unknown and have multiple possibilities given a single image as reference.\n\nAs for the 3D geometric metrics, InstantMesh outperforms the baselines on both CD and FS significantly, which indicates a higher fidelity of the generated shapes. From Figure [3]Figure 3 ‣ 4.2 Main Results ‣ 4 Experiments ‣ InstantMesh: Efficient 3D Mesh Generation from a Single Image with Sparse-view Large Reconstruction Models\"), we can observe that InstantMesh presents the most reliable geometries among all methods. Benefiting from the scalable architecture and tailored training strategies, InstantMesh achieves the state-of-the-art image-to-3D performance.\n\nTable 2: Quantitative results on Google Scanned Objects (GSO) orbiting views.\n\n| Method | PSNR ↑↑\\\\uparrow | SSIM ↑↑\\\\uparrow | LPIPS ↓↓\\\\downarrow | CD ↓↓\\\\downarrow | FS ↑↑\\\\uparrow |\n| --- | --- | --- | --- | --- | --- |\n| TripoSR | 23.373 | 0.868 | 0.213 | 0.217 | 0.843 |\n| LGM | 21.538 | 0.871 | 0.216 | 0.345 | 0.671 |\n| CRM | 22.195 | 0.891 | 0.150 | 0.252 | 0.787 |\n| SV3D | 22.098 | 0.861 | 0.201 | - | - |\n| Ours (NeRF) | 23.141 | 0.898 | 0.119 | 0.177 | 0.882 |\n| Ours (Mesh) | 22.794 | 0.897 | 0.120 | 0.180 | 0.880 |\n\nTable 3: Quantitative results on OmniObject3D (Omni3D) orbiting views.\n\n| Method | PSNR ↑↑\\\\uparrow | SSIM ↑↑\\\\uparrow | LPIPS ↓↓\\\\downarrow | CD ↓↓\\\\downarrow | FS ↑↑\\\\uparrow |\n| --- | --- | --- | --- | --- | --- |\n| TripoSR | 21.996 | 0.877 | 0.198 | 0.245 | 0.811 |\n| LGM | 20.434 | 0.864 | 0.226 | 0.382 | 0.635 |\n| CRM | 21.630 | 0.892 | 0.147 | 0.246 | 0.802 |\n| SV3D | 21.510 | 0.866 | 0.186 | - | - |\n| Ours (NeRF) | 22.635 | 0.903 | 0.110 | 0.199 | 0.869 |\n| Ours (Mesh) | 21.954 | 0.901 | 0.112 | 0.203 | 0.864 |\n\nTable 4: Quantitative results on OmniObject3D (Omni3D) benchmark views.\n\n| Method | PSNR ↑↑\\\\uparrow | SSIM ↑↑\\\\uparrow | LPIPS ↓↓\\\\downarrow | CD ↓↓\\\\downarrow | FS ↑↑\\\\uparrow |\n| --- | --- | --- | --- | --- | --- |\n| TripoSR | 19.977 | 0.859 | 0.206 | 0.221 | 0.847 |\n| LGM | 18.665 | 0.832 | 0.250 | 0.356 | 0.653 |\n| CRM | 19.422 | 0.865 | 0.172 | 0.274 | 0.778 |\n| SV3D | 20.294 | 0.853 | 0.176 | - | - |\n| Ours (NeRF) | 19.752 | 0.869 | 0.150 | 0.206 | 0.863 |\n| Ours (Mesh) | 19.552 | 0.868 | 0.150 | 0.204 | 0.866 |\n\nQualitative Results.\nTo compare our InstantMesh with other baselines qualitatively, we select two images from the GSO evaluation set and two images from Internet, and obtain the image-to-3D generation results. For each generated mesh, we visualize both the textured renderings (upper) and pure geometry (lower) from two different viewpoints. We use the “Mesh” variant of sparse-view reconstruction model to generate our results.\n\nAs depicted in Figure [3]Figure 3 ‣ 4.2 Main Results ‣ 4 Experiments ‣ InstantMesh: Efficient 3D Mesh Generation from a Single Image with Sparse-view Large Reconstruction Models\"), the generated 3D meshes of InstantMesh present significantly more plausible geometry and appearance. TripoSR can generate satisfactory results from images that have a similar style to the Objaverse dataset, but it lacks the imagination ability and tends to generate degraded geometry and textures on the back when the input image is more free-style (Figure [3]Figure 3 ‣ 4.2 Main Results ‣ 4 Experiments ‣ InstantMesh: Efficient 3D Mesh Generation from a Single Image with Sparse-view Large Reconstruction Models\"), \\\\nth3 row, \\\\nth1 column). Thanks to the high-resolution supervision, InstantMesh can also generate sharper textures compared to TripoSR. LGM and CRM share a similar framework to ours by combining a multi-view diffusion model with a sparse-view reconstruction model, thus they also enjoy the imagination ability. However, LGM exhibits distortions and obvious multi-view inconsistency, while CRM has difficulty in generating smooth surfaces.\n\n![Refer to caption]Figure 3:\nThe 3D meshes generated by InstantMesh demonstrate significantly better geometry and texture compared to the other baselines. The results of InstantMesh are rendered at a fixed elevation of 20∘superscript2020^{\\\\circ}, while the results of other methods are rendered at a fixed elevation of 0∘superscript00^{\\\\circ} since they reconstruct objects in the view space.![Refer to caption]Figure 4: Image-to-3D generation results using different sparse-view reconstruction model variants. For each generated mesh, we visualize both the textured rendering (upper) and untextured geometry (lower). All images are rendered at a fixed elevation of 20∘superscript2020^{\\\\circ}.\n\nComparison between “NeRF” and “Mesh” variants.\nWe also compare the “Mesh” and “NeRF” variants of our sparse-view reconstruction model quantitatively and qualitatively. From Table [2]Table 2 ‣ 4.2 Main Results ‣ 4 Experiments ‣ InstantMesh: Efficient 3D Mesh Generation from a Single Image with Sparse-view Large Reconstruction Models\"), [3]Table 3 ‣ 4.2 Main Results ‣ 4 Experiments ‣ InstantMesh: Efficient 3D Mesh Generation from a Single Image with Sparse-view Large Reconstruction Models\"), and [4]Table 4 ‣ 4.2 Main Results ‣ 4 Experiments ‣ InstantMesh: Efficient 3D Mesh Generation from a Single Image with Sparse-view Large Reconstruction Models\"), we can see that the “NeRF” variant achieves slightly better metrics than the “Mesh” variant. We attribute this to the limited grid resolution of FlexiCubes, resulting in the lost of details when extracting mesh surfaces. Nevertheless, the drop in metrics is marginal and negligible considering the convenience brought by the efficient mesh rendering compared to the memory-intensive volume rendering of NeRF. Besides, we also visualize some image-to-3D generation results of the two model variants in Figure [4]Figure 4 ‣ 4.2 Main Results ‣ 4 Experiments ‣ InstantMesh: Efficient 3D Mesh Generation from a Single Image with Sparse-view Large Reconstruction Models\"). By applying explicit geometric supervisions, _i.e_., depths and normals, the “Mesh” model variant can produce smoother surfaces compared to the meshes extracted from the density field of NeRF, which are generally more desirable in practical applications.",
            "citations": null
          },
          "5 Conclusion": {
            "content": "In this work, we present InstantMesh, an open-source instant image-to-3D framework that utilizes a transformer-based sparse-view large reconstruction model to create high-quality 3D assets from the images generated by a multi-view diffusion model. Building upon the Instant3D framework, we introduce mesh-based representation and additional geometric supervisions, significantly boosting the training efficiency and reconstruction quality. We also make improvements on other aspects, such as data preparation and training strategy. Evaluations on public datasets demonstrate that InstantMesh outperforms other latest image-to-3D baselines both qualitatively and quantitatively. InstantMesh is intended to make substantial contributions to the 3D Generative AI community and empower both researchers and creators.\n\nLimitations. We notice that some limitations still exist in our framework and leave them for future work. (i) Following LRM \\[ [14])\\] and Instant3D \\[ [19])\\], our transformer-based triplane decoder produces 64×64646464\\\\times 64 triplanes, whose resolution may be a bottleneck for high-definition 3D modeling. (ii) Our 3D generation quality is inevitably influenced by the multi-view inconsistency of the diffusion model, while we believe this issue can be alleviated by utilizing more advanced multi-view diffusion architectures in the future. (iii) Although FlexiCubes can improve the smoothness and reduce the artifacts of the mesh surface due to the additional geometric supervisions, we notice that it is less effective on modeling tiny and thin structures compared to NeRF (Figure [4]Figure 4 ‣ 4.2 Main Results ‣ 4 Experiments ‣ InstantMesh: Efficient 3D Mesh Generation from a Single Image with Sparse-view Large Reconstruction Models\"), \\\\nth2 row, \\\\nth1 column).",
            "citations": null
          }
        },
        "abstract": "We present InstantMesh, a feed-forward framework for instant 3D mesh\ngeneration from a single image, featuring state-of-the-art generation quality\nand significant training scalability. By synergizing the strengths of an\noff-the-shelf multiview diffusion model and a sparse-view reconstruction model\nbased on the LRM architecture, InstantMesh is able to create diverse 3D assets\nwithin 10 seconds. To enhance the training efficiency and exploit more\ngeometric supervisions, e.g, depths and normals, we integrate a differentiable\niso-surface extraction module into our framework and directly optimize on the\nmesh representation. Experimental results on public datasets demonstrate that\nInstantMesh significantly outperforms other latest image-to-3D baselines, both\nqualitatively and quantitatively. We release all the code, weights, and demo of\nInstantMesh, with the intention that it can make substantial contributions to\nthe community of 3D generative AI and empower both researchers and content\ncreators."
      },
      "bib.bib107": {
        "id": "bib.bib107",
        "citation": "[107]",
        "authors": "",
        "year": "",
        "title": "Shapeformer: Transformer-based shape completion via sparse representation.",
        "venue": "",
        "pages": "",
        "url": "https://arxiv.org/abs/2201.10326",
        "arxiv_id": "2201.10326",
        "doi": null,
        "sections": {
          "1 Introduction": {
            "content": "![Refer to caption]Figure 1:\nShapeFormer predicts multiple completions for a real-world scan of a sports car (left column), a chair with missing parts (middle column), and a partial point cloud of human lower legs (right column). The input point clouds are superimposed with the generated shapes to emphasize the faithfulness of the completion to the input point cloud.\n††\\\\* Corresponding author: Hui Huang (hhzhiyan@gmail.com)††Project page: [https://shapeformer.github.io]\n\nShapes are typically acquired with cameras that probe and sample surfaces. The process relies on line of sight and, at best, can obtain partial information from the visible parts of objects. Hence, sampling complex real-world geometry is inevitably imperfect, resulting in varying sampling densities and missing parts. This problem of surface completion has been extensively investigated over multiple decades \\[ [5])\\]. The central challenge is to compensate for incomplete data by inspecting non-local hints in the observed data to infer missing parts using various forms of priors.\n\nRecently, deep implicit function (DIF) has\nemerged as an effective representation for learning high-quality surface completion. To learn shape priors, earlier DIFs \\[ [13]), [44]), [51])\\] encode each shape using a single global latent vector. Combining a global code with region-specific local latent codes \\[ [23]), [53]), [15]), [38]), [28]), [14])\\] can faithfully preserve geometric details of the input in the completion.\nHowever, when presented with _ambiguous_ partial input, for which multiple plausible completions are possible (see [Fig.1]In 1 Introduction ‣ ShapeFormer: Transformer-based Shape Completion via Sparse Representation\")), the deterministic nature of local DIF usually fails to produce meaningful completions for unseen regions.\nA viable alternative is to combine generative models to handle the input uncertainty.\nHowever, for representations that contain enormous statistical redundancy, as in the case of current local methods, such combination \\[ [60])\\]\nexcessively allocates model capacity towards perceptually irrelevant details \\[ [26]), [22])\\].\n\nWe present ShapeFormer, a transformer-based autoregressive model that learns a distribution over possible shape completions. We use local codes to form a sequence of discrete, vector quantized features, greatly reducing the representation size while keeping the underlying structure. Applying transformer-based generative models toward such sequences of discrete variables have been shown to be effective for generative pretraining \\[ [11]), [3])\\], generation \\[ [56]), [24])\\] and completion \\[ [67])\\] in image domain.\n\nHowever, directly deploying transformers to 3D feature grids leads to a sequence length cubic in the feature resolution. Since transformers have an innate quadratic complexity on sequence length, only using overly coarse feature resolution, while feasible, can barely represent meaningful shapes.\nTo mitigate the complexity, we first introduce Vector Quantized Deep Implicit Functions (VQDIF), a novel 3D representation that is both compact and structured, that can represent complex 3D shapes with acceptable accuracy, while being rather small in size.\nThe core idea is to sparsely encode shapes as sequences of discrete 2-tuples, each representing both the position and content of a non-empty local feature.\nThese sequences can be decoded to deep implicit functions from which high-quality surfaces can subsequently be extracted.\nDue to the sparse nature of 3D shapes, such encoding reduces the sequence length from cubic to quadratic in the feature resolution, thus enabling effective combination with generative models.\n\nShapeFormer completes shapes by generating complete sequences, conditioned on the sequence for partial observation.\nIt is trained by sequentially predicting the conditional distribution of both location and content over the next element.\nUnlike image completion \\[ [67])\\], where the model is trained with the BERT\\[ [21]), [3])\\] objective to only predict for unseen regions, in the 3D shape completion setting, the input features may also come from both noisy and incomplete observations, and keeping them intact necessarily yields noisy results. Hence, in order to generate whole complete sequences from scratch while being faithful to the partial observations, we adapt the auto-regressive objective and prepend the partial sequence to the complete one to achieve conditioning. This strategy has been proved effective for conditional synthesis for both text \\[ [42])\\] and images \\[ [24])\\].\n\nWe demonstrate the ability of ShapeFormer to produce diverse high-quality completions for ambiguous partial observations of various shape types, including CAD models and human bodies, and of various incomplete sources such as real-world scans with missing parts.\nIn summary, our contributions include: (i) a novel DIF representation based on sequences of discrete variables that compactly represents satisfactory approximations of 3D shapes; (ii) a transformer-based autoregressive model that uses our new representation to predict multiple high-quality completed shapes conditioned on the partial input; and (iii) state-of-the-art results for multi-modal shape completion in terms of completion quality and diversity. The FPD score on PartNet is improved by at most 1.7 compared with prior multi-modal method cGAN \\[ [70])\\].",
            "citations": null
          },
          "2 Related Work": {
            "content": "![Refer to caption]Figure 2: Overview of our shape completion approach. Given a partial point cloud 𝒫𝒫\\\\mathcal{P}, possibly from a depth image, as input, our VQDIF encoder first converts it to a sparse feature sequence 𝐳0​…​K−1subscript𝐳0…𝐾1\\\\mathbf{z}\\_{0...K-1}, replacing them with the indices of their nearest neighbor 𝐞jsubscript𝐞𝑗\\\\mathbf{e}\\_{j} in a learned dictionary 𝒟𝒟\\\\mathcal{D}, forming a sequence of discrete 2-tuples consisting of the coordinate (pink) and the quantized feature index (blue).\nWe refer to this partial sequence as 𝒮𝒫subscript𝒮𝒫\\\\mathcal{S}\\_{\\\\mathcal{P}} (drawn with dashed lines).\nThe ShapeFormer then takes 𝒮𝒫subscript𝒮𝒫\\\\mathcal{S}\\_{\\\\mathcal{P}} as input and models the conditional distribution p​(𝒮𝒞\\|𝒮𝒫)𝑝conditionalsubscript𝒮𝒞subscript𝒮𝒫p(\\\\mathcal{S}\\_{\\\\mathcal{C}}\\|\\\\mathcal{S}\\_{\\\\mathcal{P}}).\nAutoregressive sampling yields a probable complete sequence 𝒮𝒞subscript𝒮𝒞\\\\mathcal{S}\\_{\\\\mathcal{C}}. Finally, the VQDIF decoder converts the sequence 𝒮𝒞subscript𝒮𝒞\\\\mathcal{S}\\_{\\\\mathcal{C}} to a deep implicit function, from which the surface reconstruction ℳℳ\\\\mathcal{M} can be extracted. To show the faithfulness of our reconstructions, we super-impose the input point cloud on them.\nPlease see the supplementary material for more architectural details.\n\n#### Shape reconstruction and completion\n\n3D reconstruction is a longstanding ill-posed problem in computer vision and graphics. Traditional methods can produce faithful reconstruction from complete input such as point cloud \\[ [5])\\], or images \\[ [27])\\]. Recently, neural network-based methods have demonstrated an impressive performance toward reconstruction from partial input \\[ [31])\\], where the unseen regions are completed with the help of data priors. They can be classified according to their output representation, such as voxels, meshes, point clouds, and deep implicit functions.\nSince voxels can be processed or generated easily through 3D convolutions thanks to their regularity, they are commonly used in earlier works \\[ [20]), [59]), [18]), [32])\\]. However, since their cubic complexity toward resolution, the predicted shapes are either too coarse or too heavy in size for later applications.\nWhile meshes are more data-efficient, due to the difficulty of handling mesh topology, mesh-based methods have to either use shape template \\[ [57]), [68]), [41])\\], limiting to a single topology, or produce self-intersecting meshes \\[ [30])\\].\nPoint clouds, in contrast, do not have such a problem and are popularly used lately for generation \\[ [25]), [1])\\] and completion \\[ [74]), [62]), [72]), [71])\\].\nHowever, point clouds need to be non-trivially post-processed using\nclassical methods \\[ [6]), [39]), [40]), [36])\\] to recover surfaces due to their sparse nature.\nRecent works that represent shapes as deep implicit functions have been shown to be effective for high-quality 3D reconstruction \\[ [13]), [44]), [51])\\].\nBy leveraging local priors, follow-up works \\[ [15]), [53]), [23]), [43]), [28])\\] can further improve the fidelity of geometric details.\nHowever, most current methods are not effective toward ambiguous input due to their deterministic nature.\nOther methods handle such input by leveraging generative models. They learn the conditional distribution of complete shapes represented as either a single global code \\[ [70]), [2])\\], which, due to their lack of spatial structure, leads to completions misaligned with the input, or raw point cloud \\[ [76])\\], which, due to its statistical redundancy, is only effective for completing simple shapes with a limited number of points.\nIn this paper, we show how building generative models upon our new compact, structured representation enables multi-modal high-quality reconstruction for complex shapes.\n\n#### Autoregressive models and Transformers\n\nAutoregressive models are generative models that aim to model distributions of high dimensional data by factoring the joint probability distribution to a series of conditional distributions via the chain rule \\[ [4])\\].\nUsing neural networks to parameterize the conditional distribution has been proved to be effective \\[ [63]), [29])\\] in general, and more specifically to image generation \\[ [65]), [50]), [12])\\].\nTransformers \\[ [66])\\], known for their ability to model long-range dependencies through self-attentions, have shown the power of autoregressive models in natural languages \\[ [54]), [8])\\], image generation \\[ [52]), [11])\\].\nContrary to deterministic masked auto-encoders \\[ [33])\\], Transformers can produce diverse image completions \\[ [67])\\] that are sharp in masked regions by adopting the BERT \\[ [21])\\] training objective.\nIn the 3D domain, autoregressive models have been used to learn the distribution of point clouds \\[ [60]), [69])\\] and meshes \\[ [47])\\].\nHowever, these models can only generate small point clouds or meshes restricted to 1024 vertices due to the lack of efficient representation.\nIn contrast, by eliminating statistical redundancy, a compressed discrete representation enables generative models to focus on data dependencies at a more salient level \\[ [64]), [56])\\] and recently allows high-resolution image synthesis \\[ [24]), [55])\\]. Follow-up works utilize data sparsity to obtain even more compact representations \\[ [48]), [22])\\].\nWe explore this direction in the context of surface completion.\nConcurrently with our work, AutoSDF \\[ [45])\\] trains Transformers to complete and generation shapes with dense grid. And Point-BERT \\[ [73])\\] adopts generative pre-training for several downstream tasks.",
            "citations": null
          },
          "3 Method": {
            "content": "We model the shape completion problem as mapping a partial point cloud 𝒫∈ℝN×3𝒫superscriptℝ𝑁3\\\\mathcal{P}\\\\in\\\\mathbb{R}^{N\\\\times 3} to a complete, watertight mesh ℳℳ\\\\mathcal{M} which matches the cloud. Since this is an ill-posed problem, we seek to estimate the probabilistic distribution of such mesh p​(ℳ\\|𝒫)𝑝conditionalℳ𝒫p(\\\\mathcal{M}\\|\\\\mathcal{P}) utilizing the power of Transformers.\nInstead of working directly on point clouds, meshes, or feature grids, we approximate shapes as short discrete sequences (see [Sec.3.1]Compact sequence encoding for 3D shapes ‣ 3 Method ‣ ShapeFormer: Transformer-based Shape Completion via Sparse Representation\")) to greatly reduce both the number of variables and the variable bit size, which enables Transformers to complete complex 3D shapes (see [Sec.3.2]Sequence generation for shape completion ‣ 3 Method ‣ ShapeFormer: Transformer-based Shape Completion via Sparse Representation\")).\n\nWith such compact representation, the conditional distribution becomes p​(𝒮𝒞\\|𝒮𝒫)𝑝conditionalsubscript𝒮𝒞subscript𝒮𝒫p(\\\\mathcal{S}\\_{\\\\mathcal{C}}\\|\\\\mathcal{S}\\_{\\\\mathcal{P}}), where 𝒮𝒫subscript𝒮𝒫\\\\mathcal{S}\\_{\\\\mathcal{P}} and 𝒮𝒞subscript𝒮𝒞\\\\mathcal{S}\\_{\\\\mathcal{C}} are the sequence encoding of the partial point cloud and the complete shape, respectively.\nOnce such distribution is modeled, we can sample multiple complete sequences 𝒮𝒞subscript𝒮𝒞\\\\mathcal{S}\\_{\\\\mathcal{C}}, from which different surface reconstructions ℳℳ\\\\mathcal{M} can be obtained through decoding. This process is illustrated in [Fig.2]In 2 Related Work ‣ ShapeFormer: Transformer-based Shape Completion via Sparse Representation\").\n\n### 3.1 Compact sequence encoding for 3D shapes\n\nWe propose VQDIF, whose goal is to approximate 3D shapes with a shape dictionary, with each entry describing a particular type of local shape part inside a cell of volumetric grid G𝐺G with resolution R𝑅R.\nWith such a dictionary, shapes can be encoded as short sequences of entry indices, describing the local shapes inside all non-empty grid cells, enabling transformers to efficiently model the global dependencies.\n\nWe design an auto-encoder architecture to achieve this. The encoder E𝐸E first maps the input point cloud to a 64 resolution feature grid with local-pooled PointNet and then downsample it to resolution R𝑅R. Unlike the previous strategy for image synthesis \\[ [24])\\], the encoder parameters are carefully set to have the least receptive field, reducing the number of non-empty features to the number of sparse voxels of the voxelized input point cloud 𝒫𝒫\\\\mathcal{P} at resolution R𝑅R.\nThen these non-empty features are flattened to a sequence of length K𝐾K in row-major order. Since these features are sparse, we record their locations with their flattened index {ci}i=0K−1superscriptsubscriptsubscript𝑐𝑖𝑖0𝐾1\\\\{c\\_{i}\\\\}\\_{i=0}^{K-1}.\nOther orderings are also possible, but for generation they are not as effective as row-major order \\[ [24])\\].\n\nFollowing the idea of neural discrete representation learning \\[ [64])\\], we compress the bit size of the feature sequence {𝐳i}i=0K−1superscriptsubscriptsubscript𝐳𝑖𝑖0𝐾1\\\\{\\\\mathbf{z}\\_{i}\\\\}\\_{i=0}^{K-1} through vector quantization, that is, clamping it to its nearest entry in a dictionary 𝒟𝒟\\\\mathcal{D} of V𝑉V embeddings {𝐞j}j=0Vsuperscriptsubscriptsubscript𝐞𝑗𝑗0𝑉\\\\{\\\\mathbf{e}\\_{j}\\\\}\\_{j=0}^{V} and we save the indices of these entries:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | vi=argminj∈\\[0,V)​‖𝐳i−𝐞j‖.subscript𝑣𝑖subscriptargmin𝑗0𝑉normsubscript𝐳𝑖subscript𝐞𝑗v\\_{i}=\\\\text{argmin}\\_{j\\\\in\\[0,V)}\\\\\\|\\\\mathbf{z}\\_{i}-\\\\mathbf{e}\\_{j}\\\\\\|. |  | (1) |\\\n\\\nThus, we get a compact sequence of discrete 2-tuples representing the 3D shape 𝒮={(ci,vi)}i=0K−1𝒮superscriptsubscriptsubscript𝑐𝑖subscript𝑣𝑖𝑖0𝐾1\\\\mathcal{S}=\\\\{(c\\_{i},v\\_{i})\\\\}\\_{i=0}^{K-1}.\\\nFinally, the decoder projects this sequence back to a feature grid and, through a 3D-Unet \\[ [19])\\], decodes it to a local deep implicit function f𝑓f\\[ [53])\\], whose iso-surface is the reconstruction ℳℳ\\\\mathcal{M}.\\\n\\\n#### Training\\\n\\\nWe train the VQDIF by simultaneously minimizing the reconstruction loss and updating the dictionary using exponential moving averages \\[ [64])\\], where dictionary embeddings are gradually pulled toward the encoded features.\\\nWe also adopt commitment loss ℒcommitsubscriptℒcommit\\\\mathcal{L}\\_{\\\\text{commit}}\\[ [64])\\] to encourage encoded features 𝐳isubscript𝐳𝑖\\\\mathbf{z}\\_{i} to stay close to their nearest entry 𝐞visubscript𝐞subscript𝑣𝑖\\\\mathbf{e}\\_{v\\_{i}} in the dictionary, with index visubscript𝑣𝑖v\\_{i}, thus keeping the range of the embeddings bounded. We define the loss as,\\\n\\\n|     |     |     |     |\\\n| --- | --- | --- | --- |\\\n|  | ℒcommit=1K​∑i=0K−1(𝐳i−sg​\\[𝐞vi\\])2,subscriptℒcommit1𝐾superscriptsubscript𝑖0𝐾1superscriptsubscript𝐳𝑖sgdelimited-\\[\\]subscript𝐞subscript𝑣𝑖2\\\\mathcal{L}\\_{\\\\text{commit}}=\\\\frac{1}{K}\\\\sum\\_{i=0}^{K-1}(\\\\mathbf{z}\\_{i}-\\\\text{sg}\\[\\\\mathbf{e}\\_{v\\_{i}}\\])^{2}, |  | (2) |\\\n\\\nwhere sg stands for stop gradient operator which prevents the embedding being affected by this loss.\\\n\\\nThe full training objective for VQDIF is the combination of reconstruction loss of ℒcommitsubscriptℒcommit\\\\mathcal{L}\\_{\\\\text{commit}} with weighting factor β𝛽\\\\beta:\\\n\\\n|     |     |     |     |\\\n| --- | --- | --- | --- |\\\n|  | ℒVQDIF=1T​∑i=0T−1BCE​(f​(𝐱i),oi)+β​ℒcommit.subscriptℒVQDIF1𝑇superscriptsubscript𝑖0𝑇1BCE𝑓subscript𝐱𝑖subscript𝑜𝑖𝛽subscriptℒcommit\\\\mathcal{L}\\_{\\\\text{\\\\tiny{VQDIF}}}=\\\\frac{1}{T}\\\\sum\\_{i=0}^{T-1}\\\\text{BCE}\\\\large(f(\\\\mathbf{x}\\_{i}),o\\_{i}\\\\large)+\\\\beta\\\\mathcal{L}\\_{\\\\text{commit}}. |  | (3) |\\\n\\\nHere, T𝑇T is the size of the target set and BCE is the binary cross-entropy loss which measures the discrepancy between the predicted and the ground truth occupancy oisubscript𝑜𝑖o\\_{i} at target point 𝐱isubscript𝐱𝑖\\\\mathbf{x}\\_{i}. During training, we select the target set 𝒯x={𝐱i=0T−1}subscript𝒯𝑥superscriptsubscript𝐱𝑖0𝑇1\\\\mathcal{T}\\_{x}=\\\\{\\\\mathbf{x}\\_{i=0}^{T-1}\\\\} and its occupancy values 𝒯o={oi=0T−1}subscript𝒯𝑜superscriptsubscript𝑜𝑖0𝑇1\\\\mathcal{T}\\_{o}=\\\\{o\\_{i=0}^{T-1}\\\\} in a similar fashion to prior work \\[ [44])\\].\\\n\\\n![Refer to caption]Figure 3:\\\nThe architecture of the ShapeFormer.\\\nThe partial sequence 𝒮𝒫subscript𝒮𝒫\\\\mathcal{S}\\_{\\\\mathcal{P}} (dashed boxes) and the complete one 𝒮𝒞subscript𝒮𝒞\\\\mathcal{S}\\_{\\\\mathcal{C}} (solid boxes) both appended with an end token are concatenated before sending their locations, cisubscript𝑐𝑖c\\_{i} (pink) and values visubscript𝑣𝑖v\\_{i} (blue), to a Coordinate Transformer to predict the next location ci+1subscript𝑐𝑖1c\\_{i+1}. The Value Transformer takes both ci+1subscript𝑐𝑖1c\\_{i+1} and the former Transformer’s output embedding to predict the next value vi+1subscript𝑣𝑖1v\\_{i+1}.\\\n\\\n### 3.2 Sequence generation for shape completion\\\n\\\n![Refer to caption]Figure 4: Visual comparison with prior shape completion methods on the ShapeNet dataset.\\\nOur method can better handle ambiguous scans and produce completions that are more faithful on both observed and unseen regions.\\\nMore examples are in the supplementary material.\\\n\\\nWe autoregressively model the distribution p​(𝒮𝒞\\|𝒮𝒫)𝑝conditionalsubscript𝒮𝒞subscript𝒮𝒫p(\\\\mathcal{S}\\_{\\\\mathcal{C}}\\|\\\\mathcal{S}\\_{\\\\mathcal{P}}), by predicting the distribution of the next element conditioned on the previous elements. We also factor out the tuple distribution for each element: p​(ci,vi)=p​(ci)​p​(vi\\|ci)𝑝subscript𝑐𝑖subscript𝑣𝑖𝑝subscript𝑐𝑖𝑝conditionalsubscript𝑣𝑖subscript𝑐𝑖p(c\\_{i},v\\_{i})=p(c\\_{i})p(v\\_{i}\\|c\\_{i}) . The final factored sequence distribution is as follows:\\\n\\\n|     |     |     |     |\\\n| --- | --- | --- | --- |\\\n|  | p​(𝒮𝒞\\|𝒮𝒫;θ)𝑝conditionalsubscript𝒮𝒞subscript𝒮𝒫𝜃\\\\displaystyle p(\\\\mathcal{S}\\_{\\\\mathcal{C}}\\|\\\\mathcal{S}\\_{\\\\mathcal{P}};\\\\theta) | =∏i=0K−1pci⋅pviabsentsuperscriptsubscriptproduct𝑖0𝐾1⋅subscript𝑝subscript𝑐𝑖subscript𝑝subscript𝑣𝑖\\\\displaystyle=\\\\prod\\_{i=0}^{K-1}p\\_{c\\_{i}}\\\\cdot p\\_{v\\_{i}} |  |\\\n|  | pcisubscript𝑝subscript𝑐𝑖\\\\displaystyle p\\_{c\\_{i}} | =p​(ci\\|𝐜<i,𝐯<i,𝒮𝒫;θ)absent𝑝conditionalsubscript𝑐𝑖subscript𝐜absent𝑖subscript𝐯absent𝑖subscript𝒮𝒫𝜃\\\\displaystyle=p(c\\_{i}\\|\\\\mathbf{c}\\_{<i},\\\\mathbf{v}\\_{<i},\\\\mathcal{S}\\_{\\\\mathcal{P}};\\\\theta) |  |\\\n|  | pvisubscript𝑝subscript𝑣𝑖\\\\displaystyle p\\_{v\\_{i}} | =p​(vi\\|𝐜≤i,𝐯<i,𝒮𝒫;θ).absent𝑝conditionalsubscript𝑣𝑖subscript𝐜absent𝑖subscript𝐯absent𝑖subscript𝒮𝒫𝜃\\\\displaystyle=p(v\\_{i}\\|\\\\mathbf{c}\\_{\\\\leq i},\\\\mathbf{v}\\_{<i},\\\\mathcal{S}\\_{\\\\mathcal{P}};\\\\theta). |  |\\\n\\\nHere, θ𝜃\\\\theta indicates model parameters and pcisubscript𝑝subscript𝑐𝑖p\\_{c\\_{i}} and pvisubscript𝑝subscript𝑣𝑖p\\_{v\\_{i}} are the distributions of the coordinate and the index value of the i𝑖i-th element of 𝒮𝒞subscript𝒮𝒞\\\\mathcal{S}\\_{\\\\mathcal{C}}, conditioned on previously generated elements and the partial sequence 𝒮𝒫subscript𝒮𝒫\\\\mathcal{S}\\_{\\\\mathcal{P}}. Note that pvisubscript𝑝subscript𝑣𝑖p\\_{v\\_{i}} is also conditioned on the current coordinate cisubscript𝑐𝑖c\\_{i}.\\\n\\\nDifferent approaches have been applied to build a transformer model that can predict tuple sequences.\\\nInstead of flattening them \\[ [60])\\], which in our case doubles the sequence length, we stack two decoder-only transformers to predict the pcisubscript𝑝subscript𝑐𝑖p\\_{c\\_{i}} and pvisubscript𝑝subscript𝑣𝑖p\\_{v\\_{i}} respectively in a similar way to prior works \\[ [69]), [48]), [22])\\], as illustrated in [Fig.3]In Training ‣ 3.1 Compact sequence encoding for 3D shapes ‣ 3 Method ‣ ShapeFormer: Transformer-based Shape Completion via Sparse Representation\").\\\nUnlike in the image completion case \\[ [67])\\], where the partial sequence is strictly a part of the complete sequence so that only the missing regions need to be completed. For our case, however, due to the noise or incompleteness of local observations, we would like to predict complete sequences from scratch to fix such data deficiencies.\\\nAnd thanks to the autoregressive structure of the decoder-only transformer, we can achieve conditioning by simply prepending 𝒮𝒫subscript𝒮𝒫\\\\mathcal{S}\\_{\\\\mathcal{P}} before 𝒮𝒞subscript𝒮𝒞\\\\mathcal{S}\\_{\\\\mathcal{C}} to generate complete sequences that are in coordination with the partial one.\\\nWe also append an additional end token to both sequences to help learning.\\\n\\\n#### Training and inference\\\n\\\nThe training objective of ShapeFormer is to maximize the log-likelihood given both 𝒮𝒞subscript𝒮𝒞\\\\mathcal{S}\\_{\\\\mathcal{C}} and 𝒮𝒫subscript𝒮𝒫\\\\mathcal{S}\\_{\\\\mathcal{P}}:\\\nℒShapeFormer=−log⁡p​(𝒮𝒞\\|𝒮𝒫;θ).subscriptℒShapeFormer𝑝conditionalsubscript𝒮𝒞subscript𝒮𝒫𝜃\\\\mathcal{L}\\_{\\\\text{ShapeFormer}}=-\\\\log p(\\\\mathcal{S}\\_{\\\\mathcal{C}}\\|\\\\mathcal{S}\\_{\\\\mathcal{P}};\\\\theta).\\\nAfter the model is trained, ShapeFormer performs shape completion by sequentially sampling the next element of the complete sequence until an end token (\\[END\\]) is encountered. Given the partial sequence, we alternatively sample the new coordinate and value index using top-p sampling \\[ [35])\\], where only a few top choices, for which the sum of probabilities exceeds a threshold pnsubscript𝑝𝑛p\\_{n}, are kept.\\\nAlso, we mask out the invalid choices for coordinate to guarantee monotonicity.\\\n\\",
            "citations": null
          },
          "4 Results and Evaluation\\": {
            "content": "\\\n![Refer to caption]Figure 5: Visual comparison for multi-modal shape completion of Table, Chair, and Lamp categories on PartNet.\\\nWe can produce diverse completions that better align with the input.\\\n\\\nScan AmbiguityLowHighMethodCD↓↓\\\\downarrowF1↑↑\\\\uparrowFPD↓↓\\\\downarrowCD↓↓\\\\downarrowF1↑↑\\\\uparrowFPD↓↓\\\\downarrowOccNet\\[ [44])\\]1.4863.20.342.7950.43.12ConvONet\\[ [53])\\]0.8172.90.233.1460.42.85IF-Net\\[ [15])\\]0.7973.80.2518.451.53.66PoinTr\\[ [72])\\]0.8070.10.233.1159.33.29cGAN\\[ [70])\\]1.3362.11.363.4959.32.55Ours0.7470.30.244.7260.51.45Ours∗superscriptOurs\\\\text{Ours}^{\\*}0.7371.40.224.6960.71.83VQDIF-only0.7973.80.253.0760.33.14\\\n\\\nTable 1:\\\nQuantitative results on ShapeNet with different scan ambiguity.\\\nOurs: top-p=0.4 sampling, Ours∗superscriptOurs\\\\text{Ours}^{\\*}: top-p=0 sampling.\\\n\\\nIn this section, we demonstrate our method outperforms prior arts for shape completion from ambiguous scans and part-level incompleteness ( [Sec.4.1]Shape completion results ‣ 4 Results and Evaluation ‣ ShapeFormer: Transformer-based Shape Completion via Sparse Representation\")).\\\nThen we show our approach can effectively handle a variety of shape types, out-of-distribution shapes, and real-world scans from the Redwood dataset \\[ [16])\\] ( [Sec.4.2]More results ‣ 4 Results and Evaluation ‣ ShapeFormer: Transformer-based Shape Completion via Sparse Representation\")).\\\nLastly, we show our VQDIF representation has a significantly smaller size compared with prior DIFs while achieving similar accuracy ( [Sec.4.3]Surface reconstruction with VQDIF ‣ 4 Results and Evaluation ‣ ShapeFormer: Transformer-based Shape Completion via Sparse Representation\")).\\\n\\\nThroughout all these experiments, we use feature resolution R=16𝑅16R=16 for VQDIF and set its loss balancing factor β=0.01𝛽0.01\\\\beta=0.01. We also set the vocabulary of the dictionary 𝒟𝒟\\\\mathcal{D} to be V=4096𝑉4096V=4096. We use 202020 and 444 blocks for Coordinate and Value Transformers, respectively.\\\nAll of these blocks have 161616 heads self-attention, and the embedding dimension is 102410241024.\\\nWe find that a maximum sequence length of 812812812 is enough for all of our experiments. We set the default probability factor p=0.4𝑝0.4p=0.4 for sampling.\\\nFurther implementation details such as architecture and training statistics are provided in the supplementary.\\\n\\\n### 4.1 Shape completion results\\\n\\\n#### Data\\\n\\\nWe consider two datasets: 1) ShapeNet \\[ [9])\\] for testing on partial scan and 2) PartNet \\[ [46])\\] for testing on part-level incompleteness; we follow the same setting as in cGAN \\[ [70])\\].\\\nFor ShapeNet, following prior works \\[ [44]), [15]), [53]), [13])\\], we use 13 classes of the ShapeNet with train/val/test split from 3D-R2N2 \\[ [18])\\]. The data are processed and sampled similarly to IMNet \\[ [13])\\] and we create partial input for training via random virtual scanning.\\\nFor evaluation, we first measure the ambiguity score of a partial point cloud 𝒫𝒫\\\\mathcal{P} to its complete counterpart 𝒞𝒞\\\\mathcal{C} as the mean ratio of the distance of each point x∈𝒞𝑥𝒞x\\\\in\\\\mathcal{C} with its nearest neighbor in 𝒫𝒫\\\\mathcal{P} to its distance toward furthest neighbor in 𝒞𝒞\\\\mathcal{C}. We uniformly sample 70 viewpoints on a sphere for each shape. Then we create two setups for the dataset according to ambiguity. The high scan ambiguity setup selects scans with the top half ambiguity score and vice versa. More details about this score are provided in the supplementary material.\\\n\\\nMethodMMD ↓↓\\\\downarrowTMD ↑↑\\\\uparrowUHD ↓↓\\\\downarrowFPD ↓↓\\\\downarrowcGAN \\[ [70])\\]1.983.053.392.95SInv. \\[ [75])\\]2.140.622.323.45Ours1.323.960.981.22\\\n\\\nTable 2:\\\nQuantitative comparison for multi-modal completion on PartNet between our method and prior works.\\\nThe metrics are averaged across all three categories (Table, Chair, Lamp) and are scaled by 103superscript10310^{3}, 102superscript10210^{2}, 102superscript10210^{2}, 101superscript10110^{1} respectively.\\\n\\\n#### Metric\\\n\\\nFor the low ambiguity setting, we use Chamfer L2subscript𝐿2L\\_{2} Distance (CD) and F-score%1 (F1) \\[ [61])\\] to measure how accurate the completion is; this is similar to the previous setup \\[ [53])\\].\\\nAnd to evaluate completion quality for high ambiguity setting, we follow prior work \\[ [58])\\] to use pre-trained PointNet \\[ [10])\\] classifier as a feature extractor to compute the Fréchet Point Cloud Distance (FPD) between the set of completion results and ground truth shapes.\\\nAdditionally, for the PartNet dataset, we follow cGAN \\[ [70])\\] and use Unidirectional Hausdorff Distance (UHD) to measure faithfulness toward input, Total Mutual Difference (TMD) to measure diversity, and Minimal Matching Distance (MMD)\\[ [1])\\].\\\n\\\n#### Baselines\\\n\\\nWe compare our model with a global DIF method OccNet \\[ [44])\\], two local DIF methods ConvONet \\[ [53])\\] and IF-Net \\[ [15])\\], PoinTr \\[ [72])\\], which adopts Transformers without autoregressive learning, and multi-modal completion method cGAN \\[ [70])\\].\\\nWe also compare our VQDIF-only model to illustrate the necessity of ShapeFormer.\\\nWe train these methods for shape completion in our dataset setting with their official implementation.\\\n\\\n#### Results on ShapeNet\\\n\\\nAs shown in [Fig.4]In 3.2 Sequence generation for shape completion ‣ 3 Method ‣ ShapeFormer: Transformer-based Shape Completion via Sparse Representation\"), methods incorporating structured local features can better preserve the input details than those that only operate on global features (OccNet \\[ [44])\\], cGAN \\[ [70])\\])\\\nAnd deterministic methods tend to produce averaged shape since they are unable to handle multi-modality.\\\nNotice that PoinTr \\[ [72])\\] also utilizes the power of Transformers, but they can not alleviate this problem by adopting Transformers without generative modeling.\\\nThis phenomenon is more apparent for the chair example, which has higher ambiguity. Our VQDIF-only model also fails to produce good completion in this case.\\\nBased on VQDIF, our ShapeFormer resolves ambiguity by factoring the estimation into a distribution, with each sampled shape sharp and plausible.\\\nIn contrast, the multi-modal method cGAN \\[ [70])\\] is unable to produce high-quality shapes due to their unstructured representation.\\\nFurther, we generate one completion per input with top-p sampling for quantitative evaluation.\\\nAs shown in [Tab.1]In 4 Results and Evaluation ‣ ShapeFormer: Transformer-based Shape Completion via Sparse Representation\"), our method has a much better FPD for high ambiguity scans.\\\nNotice CD is not reliable when ambiguity is high since it often treats plausible completions as significant errors. For low ambiguity scans, our method is also competitive toward previous state-of-the-art completion methods in terms of accuracy.\\\n\\\n![Refer to caption]Figure 6: Shape completion results on real-world depth scan from Redwood dataset. ShapeFormer takes partial point clouds converted from depth images and produces multiple possible completions whose variation depends on the uncertainty of viewpoints.\\\n![Refer to caption]Figure 7: Shape completion results on out-of-distribution shapes.\\\nGiven a scan of an unseen type of shape, ShapeFormer can produce multiple reasonable completions by generalizing the knowledge learned in the training set.\\\n\\\n#### Results on PartNet\\\n\\\nWe compare our model with cGAN and ShapeInversion \\[ [75])\\] on PartNet. The latter method achieves multiple completions through GAN inversion. The quantitative and qualitative comparisons are shown in [Tab.2]In Data ‣ 4.1 Shape completion results ‣ 4 Results and Evaluation ‣ ShapeFormer: Transformer-based Shape Completion via Sparse Representation\") and [Fig.5]In 4 Results and Evaluation ‣ ShapeFormer: Transformer-based Shape Completion via Sparse Representation\"), respectively. Thanks to our structured representation, we achieve much better faithfulness (UHD) and can generate more varied (TMD) high-quality shapes (MMD and FPD) than these GAN-based methods.\\\n\\\n![Refer to caption]Figure 8: Given partial human body parts (left column), our method generates complete human bodies with different poses (along the rows) and the variety depends on the ambiguity.\\\n\\\n### 4.2 More results\\\n\\\n#### Results on real scans\\\n\\\nWe further investigate how our model pre-trained on ShapeNet can be applied to scans of real objects. We test our model on partial point clouds converted from RGBD scans of the Redwood 3D Scans dataset \\[ [16])\\].\\\n[Figure6]In Results on ShapeNet ‣ 4.1 Shape completion results ‣ 4 Results and Evaluation ‣ ShapeFormer: Transformer-based Shape Completion via Sparse Representation\") shows the results for a sofa and a table, both of them have two scans from different views.\\\nNotice that our model sensitively captures the uncertainty of a scan, producing a distribution of completions that are faithful to the scan and plausible in unobserved regions.\\\nWe also show results for a sports car in [Fig.2]In 2 Related Work ‣ ShapeFormer: Transformer-based Shape Completion via Sparse Representation\").\\\n\\\n#### Results on out-of-distribution objects\\\n\\\nWe further evaluate ShapeFormer’s generalization by testing scans of unseen types of shapes on our trained model of [Sec.4.1]Shape completion results ‣ 4 Results and Evaluation ‣ ShapeFormer: Transformer-based Shape Completion via Sparse Representation\").\\\nWe pick the novel shapes from the \"Famous\" dataset collected by Erler et al. \\[ [23])\\] which includes many famous geometries for testing, such as the \"Utah teapot,\" and apply virtual scan to get the partial point cloud.\\\n[Fig.7]In Results on ShapeNet ‣ 4.1 Shape completion results ‣ 4 Results and Evaluation ‣ ShapeFormer: Transformer-based Shape Completion via Sparse Representation\") demonstrates our ShapeFormer can grasp general concepts such as symmetry or hollow and filled.\\\nEven the model is only trained on the 13 ShapeNet categories, without ever seeing any cups or teapot, it can still successfully produce multiple reasonable completions from the partial scan.\\\nMoreover, in the second row, we see the completions of a one-side scan of a cup contain two distinct features: the cups might be solid or empty.\\\nThese examples show the ShapeFormer’s potential for general-purpose shape completion, where once we have it trained, we can apply it for all types of shapes.\\\n\\\nOcc.CONet.IF.Ours8subscriptOurs8\\\\text{Ours}\\_{8}Ours16subscriptOurs16\\\\text{Ours}\\_{16}Ours32subscriptOurs32\\\\text{Ours}\\_{32}CD3.560.980.431.900.980.55F168.289.097.877.588.196.4len.1323superscript32332^{3}1283superscript1283128^{3}57217889\\\n\\\nTable 3:\\\nAuto-encoding results for objects in ShapeNet.\\\nlen. stands for sequence length of the flattened representation.\\\n![Refer to caption]Figure 9: The relation between representation size and reconstruction accuracy. With higher feature resolution, our VQDIF achieves satisfactory accuracy while keeping a rather small byte size.\\\n\\\n#### Results on human shapes\\\n\\\nIn addition to CAD models, we qualitatively evaluate our completion results on scans of human shapes (D-FAUST dataset \\[ [7])\\]) using the same setting as Niemeyer et al. \\[ [49])\\].\\\nHuman shapes are very challenging due to their thin structures and the wide variety of poses.\\\nTo simulate part level incompleteness, we randomly select a point from the complete cloud and only keep neighboring points within a ball of a fixed radius as partial input.\\\n[Fig.8]In Results on PartNet ‣ 4.1 Shape completion results ‣ 4 Results and Evaluation ‣ ShapeFormer: Transformer-based Shape Completion via Sparse Representation\") shows examples of our results.\\\nWe can see that our completions keep the pose of the observed body parts and generate various possible poses for the unobserved body parts.\\\n\\\n### 4.3 Surface reconstruction with VQDIF\\\n\\\nOur final experiment evaluates the representation size and reconstruction accuracy of VQDIF.\\\nWe compare VQDIF of different feature resolutions (Ours8subscriptOurs8\\\\text{Ours}\\_{8}, Ours16subscriptOurs16\\\\text{Ours}\\_{16}, Ours32subscriptOurs32\\\\text{Ours}\\_{32}) with OccNet, ConvONet, IF-Net, which are retrained to auto-encode the complete shape with their released implementations.\\\nAs shown in [Fig.9]In Results on out-of-distribution objects ‣ 4.2 More results ‣ 4 Results and Evaluation ‣ ShapeFormer: Transformer-based Shape Completion via Sparse Representation\"), Ours32subscriptOurs32\\\\text{Ours}\\_{32} achieves similar accuracy to the local implicit approach IF-Net while being significantly smaller in size thanks to the sparse and discrete VQDIF features.\\\nThe minimum receptive field of our encoder keeps the feature as local as possible, which greatly reduces the feature amount.\\\nThen the multi-dimensional feature vectors are quantized and can be referred to using a single integer index, which further reduces the size. The accuracy loss is only salient for lower feature resolution, as seen in the w/o quant. comparison, where we train VQDIF without vector quantization.\\\nThese together allow transformers to effectively model the distribution of shapes.\\\nWe adopt Ours16subscriptOurs16\\\\text{Ours}\\_{16} for ShapeFormer since it only has an average length of 217 (see [Tab.3]In Results on out-of-distribution objects ‣ 4.2 More results ‣ 4 Results and Evaluation ‣ ShapeFormer: Transformer-based Shape Completion via Sparse Representation\")) and its accuracy is already comparable with ConvONet (see [Fig.10]In 4.3 Surface reconstruction with VQDIF ‣ 4 Results and Evaluation ‣ ShapeFormer: Transformer-based Shape Completion via Sparse Representation\")).\\\n\\\n![Refer to caption]Figure 10: Results for auto-encoding complete shapes. Our VQDIF in different feature resolutions achieves better or similar results compared to the prior DIF methods.\\\n\\",
            "citations": null
          },
          "5 Conclusions\\": {
            "content": "\\\nWe have presented ShapeFormer, a transformer-based architecture that learns a conditional distribution of completions, from which multiple plausible completed shapes can be sampled. By explicitly modeling the underlying distribution, our method produces sharp output instead of regressing to the mean producing a blurry result.\\\nTo facilitate generative learning for 3D shape, we propose a new 3D representation VQDIF that can significantly compress the shapes into short sequences of sparse, discrete local features, which in turn enables producing better results, both in terms of quality and diversity, than previous methods.\\\n\\\nThe major factor limiting our method to be applied in fields like robotics is the sampling speed, which is currently 20 seconds per generated complete shape. In the future, we would also like to explore utilizing a more efficient attention mechanism to allow Transformers to learn VQDIF with smaller size, producing even higher quality completions. Moreover, the current method is generic, leveraging advances in language models. More research is required to include geometric or physical reasoning in the process to better deal with ambiguities.\\\n\\\n#### Acknowledgements\\\n\\\nWe thank the reviews for their comments. We thank Ziyu Wan, Xuelin Chen and Jiahui Lyu for discussions.\\\nThis work was supported in parts by NSFC (62161146005, U21B2023, U2001206), GD Talent Program (2019JC05X328), GD Science and Technology Program (2020A0505100064), DEGP Key Project (2018KZDXM058, 2020SFKC059), Shenzhen Science and Technology Program (RCJC20200714114435012, JCYJ20210324120213036), Royal Society\\\n(NAF-R1-180099), ISF (3441/21, 2492/20) and Guangdong Laboratory of Artificial Intelligence and Digital Economy (SZ).\\\n\\",
            "citations": null
          }
        },
        "abstract": "We present ShapeFormer, a transformer-based network that produces a\ndistribution of object completions, conditioned on incomplete, and possibly\nnoisy, point clouds. The resultant distribution can then be sampled to generate\nlikely completions, each exhibiting plausible shape details while being\nfaithful to the input. To facilitate the use of transformers for 3D, we\nintroduce a compact 3D representation, vector quantized deep implicit function,\nthat utilizes spatial sparsity to represent a close approximation of a 3D shape\nby a short sequence of discrete variables. Experiments demonstrate that\nShapeFormer outperforms prior art for shape completion from ambiguous partial\ninputs in terms of both completion quality and diversity. We also show that our\napproach effectively handles a variety of shape types, incomplete patterns, and\nreal-world scans."
      },
      "bib.bib108": {
        "id": "bib.bib108",
        "citation": "[108]",
        "authors": "",
        "year": "",
        "title": "Pointflow: 3d point cloud generation with continuous normalizing flows.",
        "venue": "",
        "pages": "",
        "url": "https://arxiv.org/abs/1906.12320",
        "arxiv_id": "1906.12320",
        "doi": null,
        "sections": {
          "1 Introduction": {
            "content": "Point clouds are becoming popular as a 3D representation because they can capture a much higher resolution than voxel grids and are a stepping stone to more sophisticated representations such as meshes.\nLearning a generative model of point clouds could benefit a wide range of point cloud synthesis tasks such as reconstruction and super-resolution, by providing a better prior of point clouds.\nHowever, a major roadblock in generating point clouds is the complexity of the space of point clouds.\nA cloud of points corresponding to a chair is best thought of as samples from a distribution that corresponds to the surface of the chair, and the chair itself is best thought of as a sample from a distribution of chair shapes.\nAs a result, in order to generate a chair according to this formulation, we need to characterize a distribution of distributions, which is under-explored by existing generative models.\n\nIn this paper, we propose PointFlow, a principled generative model for 3D point clouds that learns a distribution of distributions: the former being the distribution of shapes and the latter being the distribution of points given a shape.\nOur key insight is that instead of directly parametrizing the distribution of points in a shape, we model this distribution as an _invertible parameterized transformation_ of 3D points from a prior distribution (e.g., a 3D Gaussian).\nIntuitively, under this model, generating points for a given shape involves sampling points from a generic Gaussian prior, and then _moving_ them according to this parameterized transformation to their new location in the target shape, as illustrated in Figure LABEL:fig:teaser.\nIn this formulation, a given shape is then simply the variable that parametrizes such transformation, and a category is simply a distribution of this variable.\nInterestingly, we find that representing this distribution too as a transformation of a prior distribution leads to a more expressive model of shapes.\nIn particular, we use the recently proposed continuous normalizing flow framework to model both kinds of transformations \\[ [40]), [5]), [16])\\].\n\nThis parameterization confers several advantages.\nThe invertibility of these transformations allows us to not just sample but also estimate probability densities.\nThe ability to estimate probability densities in turn allows us to train these models in a principled manner using the variational inference framework \\[ [27])\\], where we maximize a variational lower bound on the log-likelihood of a training set of point clouds.\nThis probabilistic framework for training further lets us avoid the complexities of training GANs or hand-crafting good distance metrics for measuring the difference between two sets of points. Experiments show that PointFlow outperforms previous state-of-the-art generative models of point clouds, and achieves compelling results in point cloud reconstruction and unsupervised feature learning.",
            "citations": null
          },
          "2 Related work": {
            "content": "Deep learning for point clouds.\nDeep learning has been introduced to improve performance in various point cloud discriminative tasks including classification \\[ [38]), [39]), [51]), [55])\\], segmentation \\[ [38]), [43])\\], and critical points sampling \\[ [10])\\].\nRecently, substantial progress has been made in point cloud synthesis tasks such as auto-encoding \\[ [1]), [51]), [17])\\], single-view 3D reconstruction \\[ [12]), [22]), [29]), [31]), [13])\\], stereo reconstruction \\[ [45])\\], and point cloud completion \\[ [54]), [53])\\].\nMany point cloud synthesis works convert a point distribution to a N×3𝑁3N\\\\times 3 matrix by sampling N𝑁N (N𝑁N is pre-defined) points from the distribution so that existing generative models are readily applicable.\nFor example, Gadelha _et al_.\\[ [13])\\] apply variational auto-encoders (VAEs) \\[ [27])\\] and Zamorski _et al_.\\[ [56])\\] apply adversarial auto-encoders (AAEs) \\[ [34])\\] to point cloud generation.\nAchlioptas _et al_.\\[ [1])\\] explore generative adversarial networks (GANs) \\[ [15]), [2]), [19])\\] for point clouds in both raw data space and latent space of a pre-trained auto-encoder. In the above methods, the auto-encoders are trained with heuristic loss functions that measure the distance between two point sets, such as Chamfer distance (CD) or earth mover’s distance (EMD).\nSun _et al_.\\[ [44])\\] apply auto-regressive models \\[ [47])\\] with a discrete point distribution to generate one point at a time, also using a fixed number of points per shape.\n\nHowever, treating a point cloud as a fixed-dimensional matrix has several drawbacks.\nFirst, the model is restricted to generate a fixed number of points.\nGetting more points for a particular shape requires separate up-sampling models such as \\[ [54]), [53]), [52])\\].\nSecond, it ignores the permutation invariance property of point sets, which might lead to suboptimal parameter efficiency.\nHeuristic set distances are also far from ideal objectives from a generative modeling perspective since they make the original probabilistic interpretation of VAE/AAE no longer applicable when used as the reconstruction objective. In addition, exact EMD is slow to compute while approximations could lead to biased or noisy gradients. CD has been shown to incorrectly favor point clouds that are overly concentrated in the mode of the marginal point distribution \\[ [1])\\].\n\nSome recent works introduce sophisticated decoders consisting of a cascade \\[ [51])\\] or a mixture \\[ [17])\\] of smaller decoders to map one (or a mixture of) 2-D uniform distribution(s) to the target point distribution, overcoming the shortcomings of using a fixed number of points. However, they still rely on heuristic set distances that lack a probabilistic guarantee. Also, their methods only learn the distribution of points for each shape, but not the distribution of shapes. Li _et al_.\\[ [30])\\] propose a “sandwiching” reconstruction objective that combines a variant of WGAN \\[ [2])\\] loss with EMD. They also train another GAN in the latent space to learn shape distribution, similar to Achlioptas _et al_.\\[ [1])\\]. In contrast, our method is simply trained end-to-end by maximizing a variational lower bound on the log-likelihood, does not require multi-stage training, and does not have any instability issues common for GAN-based methods.\n\nGenerative models.\nThere are several popular frameworks of deep generative models, including generative adversarial networks \\[ [15]), [2]), [23])\\], variational auto-encoders \\[ [27]), [41])\\], auto-regressive models \\[ [35]), [47])\\], and flow-based models \\[ [8]), [40]), [9]), [25])\\].\nIn particular, flow-based models and auto-regressive models can both perform exact likelihood evaluation, while flow-based models are much more efficient to sample from. Flow-based models have been successfully applied to a variety of generation tasks such as image generation \\[ [25]), [9]), [8])\\], video generation \\[ [28])\\], and\nvoice synthesis \\[ [37])\\].\nAlso, there has been recent work that combines flows with other generative models, such as GANs \\[ [18]), [7])\\], auto-regressive models \\[ [20]), [36]), [26])\\], and VAEs \\[ [26]), [46]), [6]), [40]), [46]), [5]), [16])\\].\n\nMost existing deep generative models aim at learning the distribution of fixed-dimensional variables. Learning the distribution of distributions, where the data consists of a set of sets, is still underexplored. Edwards and Storkey \\[ [11])\\] propose a hierarchical VAE named Neural Statistician that consumes a set of sets. They are mostly interested in the few-shot case where each set only has a few samples. Also, they are focused on classifying sets or generating new samples from a given set. While our method is also applicable to these tasks, our focus is on learning the distribution of sets and generating new sets (point clouds in our case). In addition, our model employs a tighter lower bound on the log-likelihood, thanks to the use of normalizing flow in modeling both the reconstruction likelihood and the prior.",
            "citations": null
          },
          "3 Overview": {
            "content": "Consider a set of shapes 𝒳={Xi}i=1N𝒳superscriptsubscriptsubscript𝑋𝑖𝑖1𝑁\\\\mathcal{X}=\\\\{X\\_{i}\\\\}\\_{i=1}^{N} from a particular class of object, where each shape is represented as a set of 3D points Xi={xji}j=1Misubscript𝑋𝑖superscriptsubscriptsuperscriptsubscript𝑥𝑗𝑖𝑗1subscript𝑀𝑖X\\_{i}=\\\\{x\\_{j}^{i}\\\\}\\_{j=1}^{M\\_{i}}.\nAs discussed in Section [1]Introduction ‣ PointFlow: 3D Point Cloud Generation with Continuous Normalizing Flows\"), each point xji∈ℝ3superscriptsubscript𝑥𝑗𝑖superscriptℝ3x\\_{j}^{i}\\\\in\\\\mathbb{R}^{3} is best thought of as being sampled from a point distribution Qi​(x)superscript𝑄𝑖𝑥Q^{i}(x), usually a uniform distribution over the surface of an object Xisubscript𝑋𝑖X\\_{i}.\nEach shape Xisubscript𝑋𝑖X\\_{i} is itself a sample from a distribution over shapes Q​(X)𝑄𝑋Q(X) that captures what shapes in this category look like.\n\nOur goal is to learn the distribution of shapes, each shape itself being a distribution of points. In other words, our generative model should be able to both sample shapes and sample an arbitrary number of points from a shape.\n\nWe propose to use continuous normalizing flows to model the distribution of points given a shape. A continuous normalizing flow can be thought of as a vector field in the 333-D Euclidean space, which induces a distribution of points through transforming a generic prior distribution ( _e.g_., a standard Gaussian). To sample points from the induced distribution, we simply sample points from the prior and move them according to the vector field. Moreover, the continuous normalizing flow is invertible, which means we can move data points back to the prior distribution to compute the exact likelihood. This model is highly intuitive and interpretable, allowing a close inspection of the generative process as shown in Figure LABEL:fig:teaser.\n\nWe parametrize each continuous normalizing flow with a latent variable that represents the shape.\nAs a result, modeling the distribution of shapes can be reduced to modeling the distribution of the latent variable. Interestingly, we find continuous normalizing flow also effective in modeling the latent distribution.\nOur full generative model thus consists of two levels of continuous normalizing flows, one modeling the shape distribution by modeling the distribution of the latent variable, and the other modeling the point distribution given a shape.\n\nIn order to optimize the generative model, we construct a variational lower bound on the log-likelihood by introducing an inference network that infers a latent variable distribution from a point cloud. Here, we benefit from the fact that the invertibility of the continuous normalizing flow enables likelihood computation. This allows us to train our model end-to-end in a stable manner, unlike previous work based on GANs that requires two-stage training \\[ [1]), [30])\\]. As a side benefit, we find the inference network learns a useful representation of point clouds in an unsupervised manner.\n\nIn Section [4]Background ‣ PointFlow: 3D Point Cloud Generation with Continuous Normalizing Flows\") we introduce some background on continuous normalizing flows and variational auto-encoders. We then describe our model and training in detail in Section [5]Model ‣ PointFlow: 3D Point Cloud Generation with Continuous Normalizing Flows\").",
            "citations": null
          },
          "4 Background": {
            "content": "### 4.1 Continuous normalizing flow\n\nA normalizing flow \\[ [40])\\] is a series of invertible mappings that transform an initial known distribution to a more complicated one.\nFormally, let f1,…,fnsubscript𝑓1…subscript𝑓𝑛f\\_{1},\\\\dots,f\\_{n} denote a series of invertible transformations we want to apply to a latent variable y𝑦y with a distribution P​(y)𝑃𝑦P(y). x=fn∘fn−1∘⋯∘f1​(y)𝑥subscript𝑓𝑛subscript𝑓𝑛1⋯subscript𝑓1𝑦x=f\\_{n}\\\\circ f\\_{n-1}\\\\circ\\\\dots\\\\circ f\\_{1}(y) is the output variable. Then the probability density of the output variable is given by the change of variables formula:\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n|  | log⁡P​(x)𝑃𝑥\\\\displaystyle\\\\log{P(x)} | =log⁡P​(y)−∑k=1nlog⁡\\|det∂fk∂yk−1\\|,absent𝑃𝑦superscriptsubscript𝑘1𝑛subscript𝑓𝑘subscript𝑦𝑘1\\\\displaystyle=\\\\log{P(y)}-\\\\sum\\_{k=1}^{n}\\\\log{\\\\left\\|\\\\det{\\\\frac{\\\\partial f\\_{k}}{\\\\partial y\\_{k-1}}}\\\\right\\|}\\\\,, |  | (1) |\n\nwhere y𝑦y can be computed from x𝑥x using the inverse flow: y=f1−1∘⋯∘fn−1​(x)𝑦superscriptsubscript𝑓11⋯superscriptsubscript𝑓𝑛1𝑥y=f\\_{1}^{-1}\\\\circ\\\\dots\\\\circ f\\_{n}^{-1}(x). In practice, f1,…,fnsubscript𝑓1…subscript𝑓𝑛f\\_{1},\\\\dots,f\\_{n} are usually instantiated as neural networks with an architecture that makes the determinant of the Jacobian \\|det∂fk∂yk−1\\|subscript𝑓𝑘subscript𝑦𝑘1\\\\left\\|\\\\det{\\\\frac{\\\\partial f\\_{k}}{\\\\partial y\\_{k-1}}}\\\\right\\| easy to compute.\nThe normalizing flow has been generalized from a discrete sequence to a continuous transformation \\[ [16]), [5])\\] by defining the transformation f𝑓f using a continuous-time dynamic ∂y​(t)∂t=f​(y​(t),t)𝑦𝑡𝑡𝑓𝑦𝑡𝑡\\\\frac{\\\\partial y(t)}{\\\\partial t}=f(y(t),t), where f𝑓f is a neural network that has an unrestricted architecture. The continuous normalizing flow (CNF) model for P​(x)𝑃𝑥P(x) with a prior distribution P​(y)𝑃𝑦P(y) at the start time can be written as:\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n|  | x𝑥\\\\displaystyle x | =y​(t0)+∫t0t1f​(y​(t),t)​𝑑t,y​(t0)∼P​(y)formulae-sequenceabsent𝑦subscript𝑡0superscriptsubscriptsubscript𝑡0subscript𝑡1𝑓𝑦𝑡𝑡differential-d𝑡similar-to𝑦subscript𝑡0𝑃𝑦\\\\displaystyle=y(t\\_{0})+\\\\int\\_{t\\_{0}}^{t\\_{1}}f(y(t),t)dt,\\\\quad y(t\\_{0})\\\\sim P(y) |  |\n|  | log⁡P​(x)𝑃𝑥\\\\displaystyle\\\\log{P(x)} | =log⁡P​(y​(t0))−∫t0t1Tr⁡(∂f∂y​(t))​𝑑tabsent𝑃𝑦subscript𝑡0superscriptsubscriptsubscript𝑡0subscript𝑡1Tr𝑓𝑦𝑡differential-d𝑡\\\\displaystyle=\\\\log{P(y(t\\_{0}))}-\\\\int\\_{t\\_{0}}^{t\\_{1}}\\\\operatorname{Tr}\\\\left(\\\\frac{\\\\partial f}{\\\\partial y(t)}\\\\right)dt |  | (2) |\n\nand y​(t0)𝑦subscript𝑡0y(t\\_{0}) can be computed using the inverse flow y​(t0)=x+∫t1t0f​(y​(t),t)​𝑑t𝑦subscript𝑡0𝑥superscriptsubscriptsubscript𝑡1subscript𝑡0𝑓𝑦𝑡𝑡differential-d𝑡y(t\\_{0})=x+\\\\int\\_{t\\_{1}}^{t\\_{0}}f(y(t),t)dt. A black-box ordinary differential equation (ODE) solver can been applied to estimate the outputs and the input gradients of a continuous normalizing flow \\[ [16]), [5])\\].\n\n### 4.2 Variational auto-encoder\n\nSuppose we have a random variable X𝑋X that we are building generative models for.\nThe variational auto-encoder (VAE) is a framework that allows one to learn P​(X)𝑃𝑋P(X) from a dataset of observations of X𝑋X\\[ [27]), [41])\\].\nThe VAE models the data distribution via a latent variable z𝑧z with a prior distribution Pψ​(z)subscript𝑃𝜓𝑧P\\_{\\\\psi}(z), and a decoder Pθ​(X\\|z)subscript𝑃𝜃conditional𝑋𝑧P\\_{\\\\theta}(X\\|z) which captures the (hopefully simpler) distribution of X𝑋X given z𝑧z.\nDuring training, it additionally learns an inference model (or encoder) Qϕ​(z\\|X)subscript𝑄italic-ϕconditional𝑧𝑋Q\\_{\\\\phi}(z\\|X). The encoder and decoder are jointly trained to maximize a lower bound on the log-likelihood of the observations\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n|  | log⁡Pθ​(X)subscript𝑃𝜃𝑋\\\\displaystyle\\\\log{P\\_{\\\\theta}(X)} | ≥logPθ(X)−DK​L(Qϕ(z\\|X)\\|\\|Pθ(z\\|X))\\\\displaystyle\\\\geq\\\\log{P\\_{\\\\theta}(X)}-D\\_{KL}(Q\\_{\\\\phi}(z\\|X)\\|\\|P\\_{\\\\theta}(z\\|X)) |  |\n|  |  | =𝔼Qϕ​(z\\|x)\\[logPθ(X\\|z)\\]−DK​L(Qϕ(z\\|X)\\|\\|Pψ(z))\\\\displaystyle=\\\\mathbb{E}\\_{Q\\_{\\\\phi}(z\\|x)}\\\\left\\[\\\\log{P\\_{\\\\theta}(X\\|z)}\\\\right\\]-D\\_{KL}\\\\left(Q\\_{\\\\phi}(z\\|X)\\|\\|P\\_{\\\\psi}(z)\\\\right) |  |\n|  |  | ≜ℒ​(X;ϕ,ψ,θ),≜absentℒ𝑋italic-ϕ𝜓𝜃\\\\displaystyle\\\\triangleq\\\\mathcal{L}(X;\\\\phi,\\\\psi,\\\\theta)\\\\,, |  | (3) |\n\nwhich is also called the evidence lower bound (ELBO).\nOne can interpret ELBO as the sum of the negative reconstruction error (the first term) and a latent space regularizer (the second term). In practice, Qϕ​(z\\|X)subscript𝑄italic-ϕconditional𝑧𝑋Q\\_{\\\\phi}(z\\|X) is usually modeled as a diagonal Gaussian 𝒩​(z\\|μϕ​(X),σϕ​(X))𝒩conditional𝑧subscript𝜇italic-ϕ𝑋subscript𝜎italic-ϕ𝑋\\\\mathcal{N}(z\\|\\\\mu\\_{\\\\phi}(X),\\\\sigma\\_{\\\\phi}(X)) whose mean and standard deviation are predicted by a neural network with parameters ϕitalic-ϕ\\\\phi.\nTo efficiently optimize the ELBO, sampling from Qϕ​(z\\|X)subscript𝑄italic-ϕconditional𝑧𝑋Q\\_{\\\\phi}(z\\|X) is done by reparametrizing z𝑧z as z=μϕ​(X)+σϕ​(X)⋅ϵ𝑧subscript𝜇italic-ϕ𝑋⋅subscript𝜎italic-ϕ𝑋italic-ϵz=\\\\mu\\_{\\\\phi}(X)+\\\\sigma\\_{\\\\phi}(X)\\\\cdot\\\\epsilon, where ϵ∼𝒩​(0,I)similar-toitalic-ϵ𝒩0𝐼\\\\epsilon\\\\sim\\\\mathcal{N}(0,\\\\mathit{I}).",
            "citations": null
          },
          "5 Model": {
            "content": "We now have the paraphernalia needed to define our generative model of point clouds.\nUsing the terminology of the VAE, we need three modules: the encoder Qϕ​(z\\|X)subscript𝑄italic-ϕconditional𝑧𝑋Q\\_{\\\\phi}(z\\|X) that encodes a point cloud into a shape representation z𝑧z, a prior Pψ​(z)subscript𝑃𝜓𝑧P\\_{\\\\psi}(z) over shape representations, and a decoder Pθ​(X\\|z)subscript𝑃𝜃conditional𝑋𝑧P\\_{\\\\theta}(X\\|z) that models the distribution of points given the shape representation.\nWe use a simple permutation-invariant encoder to predict Qϕ​(z\\|X)subscript𝑄italic-ϕconditional𝑧𝑋Q\\_{\\\\phi}(z\\|X), following the architecture in Achlioptas _et al_.\\[ [1])\\].\nWe use continuous normalizing flows for both the prior Pψ​(z)subscript𝑃𝜓𝑧P\\_{\\\\psi}(z) and the generator Pθ​(X\\|z)subscript𝑃𝜃conditional𝑋𝑧P\\_{\\\\theta}(X\\|z), which are described below.\n\n### 5.1 Flow-based point generation from shape representations\n\nWe first decompose the reconstruction log-likelihood of a point set into the sum of log-likelihood of each point\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | log⁡Pθ​(X\\|z)=∑x∈Xlog⁡Pθ​(x\\|z).subscript𝑃𝜃conditional𝑋𝑧subscript𝑥𝑋subscript𝑃𝜃conditional𝑥𝑧\\\\log{P\\_{\\\\theta}(X\\|z)}=\\\\sum\\_{x\\\\in X}\\\\log{P\\_{\\\\theta}(x\\|z)}\\\\,. |  | (4) |\n\nWe propose to model Pθ​(x\\|z)subscript𝑃𝜃conditional𝑥𝑧P\\_{\\\\theta}(x\\|z) using a conditional extension of CNF.\nSpecifically, a point x𝑥x in the point set X𝑋X is the result of transforming some point y​(t0)𝑦subscript𝑡0y(t\\_{0}) in the prior distribution P​(y)=𝒩​(0,I)𝑃𝑦𝒩0𝐼P(y)=\\\\mathcal{N}(0,\\\\mathit{I}) using a CNF conditioned on z𝑧z:\n\n|     |     |     |\n| --- | --- | --- |\n|  | x=Gθ​(y​(t0);z)≜y​(t0)+∫t0t1gθ​(y​(t),t,z)​𝑑t,y​(t0)∼P​(y),formulae-sequence𝑥subscript𝐺𝜃𝑦subscript𝑡0𝑧≜𝑦subscript𝑡0superscriptsubscriptsubscript𝑡0subscript𝑡1subscript𝑔𝜃𝑦𝑡𝑡𝑧differential-d𝑡similar-to𝑦subscript𝑡0𝑃𝑦x=G\\_{\\\\theta}(y(t\\_{0});z)\\\\triangleq y(t\\_{0})+\\\\int\\_{t\\_{0}}^{t\\_{1}}g\\_{\\\\theta}(y(t),t,z)dt,y(t\\_{0})\\\\sim P(y)\\\\,, |  |\n\nwhere gθsubscript𝑔𝜃g\\_{\\\\theta} defines the continuous-time dynamics of the flow Gθsubscript𝐺𝜃G\\_{\\\\theta} conditioned on z𝑧z.\nNote that the inverse of Gθsubscript𝐺𝜃G\\_{\\\\theta} is given by Gθ−1​(x;z)=x+∫t1t0gθ​(y​(t),t,z)​𝑑tsuperscriptsubscript𝐺𝜃1𝑥𝑧𝑥superscriptsubscriptsubscript𝑡1subscript𝑡0subscript𝑔𝜃𝑦𝑡𝑡𝑧differential-d𝑡G\\_{\\\\theta}^{-1}(x;z)=x+\\\\int\\_{t\\_{1}}^{t\\_{0}}g\\_{\\\\theta}(y(t),t,z)dt with y​(t1)=x𝑦subscript𝑡1𝑥y(t\\_{1})=x.\nThe reconstruction likelihood of follows equation ( [2]In 4.1 Continuous normalizing flow ‣ 4 Background ‣ PointFlow: 3D Point Cloud Generation with Continuous Normalizing Flows\")):\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | log⁡Pθ​(x\\|z)=log⁡P​(Gθ−1​(x;z))−∫t0t1Tr⁡(∂gθ∂y​(t))​𝑑t.subscript𝑃𝜃conditional𝑥𝑧𝑃superscriptsubscript𝐺𝜃1𝑥𝑧superscriptsubscriptsubscript𝑡0subscript𝑡1Trsubscript𝑔𝜃𝑦𝑡differential-d𝑡\\\\log{P\\_{\\\\theta}(x\\|z)}=\\\\log{P(G\\_{\\\\theta}^{-1}(x;z))}-\\\\int\\_{t\\_{0}}^{t\\_{1}}\\\\operatorname{Tr}\\\\left(\\\\frac{\\\\partial g\\_{\\\\theta}}{\\\\partial y(t)}\\\\right)dt\\\\,. |  | (5) |\n\nNote that log⁡P​(Gθ−1​(x;z))𝑃superscriptsubscript𝐺𝜃1𝑥𝑧\\\\log{P(G\\_{\\\\theta}^{-1}(x;z))} can be computed in closed form with the Gaussian prior.\n\n![Refer to caption]Figure 1:\nModel architecture. (a) At training time, the encoder Qϕsubscript𝑄italic-ϕQ\\_{\\\\phi} infers a posterior over shape representations given an input point cloud X𝑋X, and samples a shape representation z𝑧z from it. We then compute the probability of z𝑧z in the prior distribution (ℒpriorsubscriptℒprior\\\\mathcal{L}\\_{\\\\text{prior}}) through a inverse CNF Fψ−1superscriptsubscript𝐹𝜓1F\\_{\\\\psi}^{-1}, and compute the reconstruction likelihood of X𝑋X (ℒreconsubscriptℒrecon\\\\mathcal{L}\\_{\\\\text{recon}}) through another inverse CNF Gθ−1superscriptsubscript𝐺𝜃1G\\_{\\\\theta}^{-1} conditioned on z𝑧z. The model is trained end-to-end to maximize the evidence lower bound (ELBO), which is the sum of ℒpriorsubscriptℒprior\\\\mathcal{L}\\_{\\\\text{prior}}, ℒreconsubscriptℒrecon\\\\mathcal{L}\\_{\\\\text{recon}}, and ℒentsubscriptℒent\\\\mathcal{L}\\_{\\\\text{ent}} (the entropy of the posterior Qϕ​(z\\|X)subscript𝑄italic-ϕconditional𝑧𝑋Q\\_{\\\\phi}(z\\|X)). (b) At test time, we sample a shape representation z~~𝑧\\\\tilde{z} by sampling w~~𝑤\\\\tilde{w} from a Gaussian prior and transforming it with Fψsubscript𝐹𝜓F\\_{\\\\psi}. To sample points from the shape represented by z~~𝑧\\\\tilde{z}, we first sample points from the 333-D Gaussian prior and then move them according to the CNF parameterized by z~~𝑧\\\\tilde{z}.\n\n### 5.2 Flow-based prior over shapes\n\nAlthough it is possible to use a simple Gaussian prior over shape representations, it has been shown that a restricted prior tends to limit the performance of VAEs \\[ [6])\\].\nTo alleviate this problem, we use another CNF to parametrize a learnable prior.\nFormally, we rewrite the KL divergence term in Equation [3]In 4.2 Variational auto-encoder ‣ 4 Background ‣ PointFlow: 3D Point Cloud Generation with Continuous Normalizing Flows\") as\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n|  | DK​L(Qϕ(z\\|x)\\|\\|Pψ(z))\\\\displaystyle D\\_{KL}(Q\\_{\\\\phi}(z\\|x)\\|\\|P\\_{\\\\psi}(z)) | =−𝔼Qϕ​(z\\|x)​\\[log⁡Pψ​(z)\\]−H​\\[Qϕ​(z\\|X)\\],absentsubscript𝔼subscript𝑄italic-ϕconditional𝑧𝑥delimited-\\[\\]subscript𝑃𝜓𝑧𝐻delimited-\\[\\]subscript𝑄italic-ϕconditional𝑧𝑋\\\\displaystyle=-\\\\mathbb{E}\\_{Q\\_{\\\\phi}(z\\|x)}\\\\left\\[\\\\log{P\\_{\\\\psi}(z)}\\\\right\\]-H\\[Q\\_{\\\\phi}(z\\|X)\\]\\\\,, |  | (6) |\n\nwhere H𝐻H is the entropy and Pψ​(z)subscript𝑃𝜓𝑧P\\_{\\\\psi}(z) is the prior distribution with learnable parameters ψ𝜓\\\\psi, obtained by transforming a simple Gaussian P​(w)=𝒩​(0,I)𝑃𝑤𝒩0𝐼P(w)=\\\\mathcal{N}(0,\\\\mathit{I}) with a CNF:\n\n|     |     |     |\n| --- | --- | --- |\n|  | z=Fψ​(w​(t0))≜w​(t0)+∫t0t1fψ​(w​(t),t)​𝑑t,w​(t0)∼P​(w),formulae-sequence𝑧subscript𝐹𝜓𝑤subscript𝑡0≜𝑤subscript𝑡0superscriptsubscriptsubscript𝑡0subscript𝑡1subscript𝑓𝜓𝑤𝑡𝑡differential-d𝑡similar-to𝑤subscript𝑡0𝑃𝑤\\\\displaystyle z=F\\_{\\\\psi}(w(t\\_{0}))\\\\triangleq w(t\\_{0})+\\\\int\\_{t\\_{0}}^{t\\_{1}}f\\_{\\\\psi}(w(t),t)dt,w(t\\_{0})\\\\sim P(w)\\\\,, |  |\n\nwhere fψsubscript𝑓𝜓f\\_{\\\\psi} defines the continuous-time dynamics of the flow Fψsubscript𝐹𝜓F\\_{\\\\psi}. Similarly as described above, the inverse of Fψsubscript𝐹𝜓F\\_{\\\\psi} is given by Fψ−1​(z)=z+∫t1t0fψ​(w​(t),t)​𝑑tsuperscriptsubscript𝐹𝜓1𝑧𝑧superscriptsubscriptsubscript𝑡1subscript𝑡0subscript𝑓𝜓𝑤𝑡𝑡differential-d𝑡F\\_{\\\\psi}^{-1}(z)=z+\\\\int\\_{t\\_{1}}^{t\\_{0}}f\\_{\\\\psi}(w(t),t)dt with w​(t1)=z𝑤subscript𝑡1𝑧w(t\\_{1})=z. The log probability of the prior distribution can be computed by:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | log⁡Pψ​(z)=log⁡P​(Fψ−1​(z))−∫t0t1Tr⁡(∂fψ∂w​(t))​𝑑t.subscript𝑃𝜓𝑧𝑃superscriptsubscript𝐹𝜓1𝑧superscriptsubscriptsubscript𝑡0subscript𝑡1Trsubscript𝑓𝜓𝑤𝑡differential-d𝑡\\\\log P\\_{\\\\psi}(z)=\\\\log{P\\\\left(F\\_{\\\\psi}^{-1}(z)\\\\right)}-\\\\int\\_{t\\_{0}}^{t\\_{1}}\\\\operatorname{Tr}\\\\left(\\\\frac{\\\\partial f\\_{\\\\psi}}{\\\\partial w(t)}\\\\right)dt\\\\,. |  | (7) |\n\n### 5.3 Final training objective\n\nPlugging Equation [4]In 5.1 Flow-based point generation from shape representations ‣ 5 Model ‣ PointFlow: 3D Point Cloud Generation with Continuous Normalizing Flows\"), [5]In 5.1 Flow-based point generation from shape representations ‣ 5 Model ‣ PointFlow: 3D Point Cloud Generation with Continuous Normalizing Flows\"), [6]In 5.2 Flow-based prior over shapes ‣ 5 Model ‣ PointFlow: 3D Point Cloud Generation with Continuous Normalizing Flows\"), [7]In 5.2 Flow-based prior over shapes ‣ 5 Model ‣ PointFlow: 3D Point Cloud Generation with Continuous Normalizing Flows\") into Equation [3]In 4.2 Variational auto-encoder ‣ 4 Background ‣ PointFlow: 3D Point Cloud Generation with Continuous Normalizing Flows\"), the ELBO of a point set X𝑋X can be finally written as\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n|  | ℒ​(X;ϕ,ψ,θ)ℒ𝑋italic-ϕ𝜓𝜃\\\\displaystyle\\\\mathcal{L}(X;\\\\phi,\\\\psi,\\\\theta) | =𝔼Qϕ​(z\\|x)​\\[log⁡Pψ​(z)+log⁡Pθ​(X\\|z)\\]+H​\\[Qϕ​(z\\|X)\\]absentsubscript𝔼subscript𝑄italic-ϕconditional𝑧𝑥delimited-\\[\\]subscript𝑃𝜓𝑧subscript𝑃𝜃conditional𝑋𝑧𝐻delimited-\\[\\]subscript𝑄italic-ϕconditional𝑧𝑋\\\\displaystyle=\\\\mathbb{E}\\_{Q\\_{\\\\phi}(z\\|x)}\\\\left\\[\\\\log{P\\_{\\\\psi}(z)}+\\\\log{P\\_{\\\\theta}(X\\|z)}\\\\right\\]+H\\[Q\\_{\\\\phi}(z\\|X)\\] |  |\n|  |  | =𝔼Qϕ​(z\\|X)\\[logP(Fψ−1(z))−∫t0t1Tr(∂fψ∂w​(t))dt\\\\displaystyle=\\\\mathbb{E}\\_{Q\\_{\\\\phi}(z\\|X)}\\[\\\\log{P\\\\left(F\\_{\\\\psi}^{-1}(z)\\\\right)}-\\\\int\\_{t\\_{0}}^{t\\_{1}}\\\\operatorname{Tr}\\\\left(\\\\frac{\\\\partial f\\_{\\\\psi}}{\\\\partial w(t)}\\\\right)dt |  |\\\n|  |  | +∑x∈X(logP(Gθ−1(x;z))−∫t0t1Tr(∂gθ∂y​(t))dt)\\]\\\\displaystyle+\\\\sum\\_{x\\\\in X}(\\\\log{P(G\\_{\\\\theta}^{-1}(x;z))}-\\\\int\\_{t\\_{0}}^{t\\_{1}}\\\\operatorname{Tr}\\\\left(\\\\frac{\\\\partial g\\_{\\\\theta}}{\\\\partial y(t)}\\\\right)dt)\\] |  |\n|  |  | +H​\\[Qϕ​(z\\|X)\\].𝐻delimited-\\[\\]subscript𝑄italic-ϕconditional𝑧𝑋\\\\displaystyle+H\\[Q\\_{\\\\phi}(z\\|X)\\]\\\\,. |  | (8) |\n\nOur model is trained end-to-end by maximizing the ELBO of all point sets in the dataset\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | ϕ∗,ψ∗,θ∗=arg⁡maxϕ,ψ,θ​∑X∈𝒳ℒ​(X;ϕ,ψ,θ).superscriptitalic-ϕsuperscript𝜓superscript𝜃subscriptitalic-ϕ𝜓𝜃subscript𝑋𝒳ℒ𝑋italic-ϕ𝜓𝜃\\\\displaystyle\\\\phi^{\\*},\\\\psi^{\\*},\\\\theta^{\\*}=\\\\arg\\\\max\\_{\\\\phi,\\\\psi,\\\\theta}\\\\sum\\_{X\\\\in\\\\mathcal{X}}\\\\mathcal{L}(X;\\\\phi,\\\\psi,\\\\theta). |  | (9) |\n\nWe can interpret this objective as the sum of three parts:\n\n1. 1.\n\n\nPrior:ℒprior​(X;ψ,ϕ)≜𝔼Qϕ​(z\\|x)​\\[log⁡Pψ​(z)\\]≜subscriptℒprior𝑋𝜓italic-ϕsubscript𝔼subscript𝑄italic-ϕconditional𝑧𝑥delimited-\\[\\]subscript𝑃𝜓𝑧\\\\mathcal{L}\\_{\\\\text{prior}}(X;\\\\psi,\\\\phi)\\\\triangleq\\\\mathbb{E}\\_{Q\\_{\\\\phi}(z\\|x)}\\[\\\\log{P\\_{\\\\psi}(z)}\\] encourages the encoded shape representation to have a high probability under the prior, which is modeled by a CNF as described in Section [5.2]Flow-based prior over shapes ‣ 5 Model ‣ PointFlow: 3D Point Cloud Generation with Continuous Normalizing Flows\").\nWe use the reparameterization trick \\[ [27])\\] to enable a differentiable Monte Carlo estimate of the expectation:\n\n\n\n|     |     |     |\n| --- | --- | --- |\n|  | 𝔼Qϕ​(z\\|x)​\\[log⁡Pψ​(z)\\]≈1L​∑l=1Llog⁡Pψ​(μ+ϵl⊙σ),subscript𝔼subscript𝑄italic-ϕconditional𝑧𝑥delimited-\\[\\]subscript𝑃𝜓𝑧1𝐿superscriptsubscript𝑙1𝐿subscript𝑃𝜓𝜇direct-productsubscriptitalic-ϵ𝑙𝜎\\\\displaystyle\\\\mathbb{E}\\_{Q\\_{\\\\phi}(z\\|x)}\\[\\\\log{P\\_{\\\\psi}(z)}\\]\\\\approx\\\\frac{1}{L}\\\\sum\\_{l=1}^{L}\\\\log{P\\_{\\\\psi}(\\\\mu+\\\\epsilon\\_{l}\\\\odot\\\\sigma)}\\\\,, |  |\n\n\n\nwhere μ𝜇\\\\mu and σ𝜎\\\\sigma are mean and standard deviation of the isotropic Gaussian posterior Qϕ​(z\\|x)subscript𝑄italic-ϕconditional𝑧𝑥Q\\_{\\\\phi}(z\\|x) and L𝐿L is simply set to 111. ϵisubscriptitalic-ϵ𝑖\\\\epsilon\\_{i} is sampled from the standard Gaussian distribution 𝒩​(0,I)𝒩0𝐼\\\\mathcal{N}(0,\\\\mathit{I}).\n\n2. 2.\n\n\nReconstruction likelihood:ℒrecon​(X;θ,ϕ)≜𝔼Qϕ​(z\\|x)​\\[log⁡Pθ​(X\\|z)\\]≜subscriptℒrecon𝑋𝜃italic-ϕsubscript𝔼subscript𝑄italic-ϕconditional𝑧𝑥delimited-\\[\\]subscript𝑃𝜃conditional𝑋𝑧\\\\mathcal{L}\\_{\\\\text{recon}}(X;\\\\theta,\\\\phi)\\\\triangleq\\\\mathbb{E}\\_{Q\\_{\\\\phi}(z\\|x)}\\[\\\\log{P\\_{\\\\theta}(X\\|z)}\\] is the reconstruction log-likelihood of the input point set, computed as described in Section [5.1]Flow-based point generation from shape representations ‣ 5 Model ‣ PointFlow: 3D Point Cloud Generation with Continuous Normalizing Flows\"). The expectation is also estimated using Monte Carlo sampling.\n\n3. 3.\n\n\nPosterior Entropy:ℒent​(X;ϕ)≜H​\\[Qϕ​(z\\|X)\\]≜subscriptℒent𝑋italic-ϕ𝐻delimited-\\[\\]subscript𝑄italic-ϕconditional𝑧𝑋\\\\mathcal{L}\\_{\\\\text{ent}}(X;\\\\phi)\\\\triangleq H\\[Q\\_{\\\\phi}(z\\|X)\\] is the entropy of the approximated posterior:\n\n\n\n|     |     |     |\n| --- | --- | --- |\n|  | H​\\[Qϕ​(z\\|X)\\]=d2​(1+ln⁡(2​π))+∑i=1dln⁡σi.𝐻delimited-\\[\\]subscript𝑄italic-ϕconditional𝑧𝑋𝑑212𝜋superscriptsubscript𝑖1𝑑subscript𝜎𝑖\\\\displaystyle{\\\\textstyle H\\[Q\\_{\\\\phi}(z\\|X)\\]=\\\\frac{d}{2}(1+\\\\ln{(2\\\\pi)})+\\\\sum\\_{i=1}^{d}\\\\ln{\\\\sigma\\_{i}}\\\\,.} |  |\n\n\nAll the training details ( _e.g_., hyper-parameters, model architectures) are included in Section [B]Appendix B Training details ‣ PointFlow: 3D Point Cloud Generation with Continuous Normalizing Flows\") of the appendix.\n\n### 5.4 Sampling\n\nTo sample a shape representation, we first draw w~∼𝒩​(0,I)similar-to~𝑤𝒩0𝐼\\\\tilde{w}\\\\sim\\\\mathcal{N}(0,\\\\mathit{I}) then pass it through Fψsubscript𝐹𝜓F\\_{\\\\psi} to get z~=Fψ​(w~)~𝑧subscript𝐹𝜓~𝑤\\\\tilde{z}=F\\_{\\\\psi}(\\\\tilde{w}).\nTo generate a point given a shape representation z~~𝑧\\\\tilde{z}, we first sample a point y~∈ℝ3~𝑦superscriptℝ3\\\\tilde{y}\\\\in\\\\mathbb{R}^{3} from 𝒩​(0,I)𝒩0𝐼\\\\mathcal{N}(0,\\\\mathit{I}), then pass y~~𝑦\\\\tilde{y} through Gθsubscript𝐺𝜃G\\_{\\\\theta} conditioned on z~~𝑧\\\\tilde{z} to produce a point on the shape : x~=Gθ​(w~;z)~𝑥subscript𝐺𝜃~𝑤𝑧\\\\tilde{x}=G\\_{\\\\theta}(\\\\tilde{w};z).\nTo sample a point cloud with size M~~𝑀\\\\tilde{M}, we simply repeat it for M~~𝑀\\\\tilde{M} times.\nCombining these two steps allows us to sample a point cloud with M~~𝑀\\\\tilde{M} points from our model:\n\n|     |     |     |\n| --- | --- | --- |\n|  | X~={Gθ​(y~j;Fψ​(w~))}1≤j≤M~,w~∼𝒩​(0,I),∀j,y~j∼𝒩​(0,I).formulae-sequence~𝑋subscriptsubscript𝐺𝜃subscript~𝑦𝑗subscript𝐹𝜓~𝑤1𝑗~𝑀formulae-sequencesimilar-to~𝑤𝒩0𝐼for-all𝑗similar-tosubscript~𝑦𝑗𝒩0𝐼\\\\displaystyle\\\\tilde{X}=\\\\{G\\_{\\\\theta}(\\\\tilde{y}\\_{j};F\\_{\\\\psi}(\\\\tilde{w}))\\\\}\\_{1\\\\leq j\\\\leq\\\\tilde{M}},\\\\tilde{w}\\\\sim\\\\mathcal{N}(0,\\\\mathit{I}),\\\\forall j,\\\\tilde{y}\\_{j}\\\\sim\\\\mathcal{N}(0,\\\\mathit{I})\\\\,. |  |",
            "citations": null
          },
          "6 Experiments": {
            "content": "In this section, we first introduce existing metrics for evaluating point cloud generation, discuss their limitations, and introduce a new metric that overcomes these limitations. We then compare the proposed method with previous state-of-the-art generative models of point clouds, using both previous metrics and the proposed one. We additionally evaluate the reconstruction and representation learning ability of the auto-encoder part of our model.\n\n### 6.1 Evaluation metrics\n\nFollowing prior work, we use Chamfer distance (CD) and earth mover’s distance (EMD) to measure the similarity between point clouds.\nFormally, they are defined as follows:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | CD​(X,Y)CD𝑋𝑌\\\\displaystyle\\\\text{CD}(X,Y) | =∑x∈Xminy∈Y⁡‖x−y‖22+∑y∈Yminx∈X⁡‖x−y‖22,absentsubscript𝑥𝑋subscript𝑦𝑌superscriptsubscriptnorm𝑥𝑦22subscript𝑦𝑌subscript𝑥𝑋superscriptsubscriptnorm𝑥𝑦22\\\\displaystyle=\\\\sum\\_{x\\\\in X}\\\\min\\_{y\\\\in Y}\\\\\\|x-y\\\\\\|\\_{2}^{2}+\\\\sum\\_{y\\\\in Y}\\\\min\\_{x\\\\in X}\\\\\\|x-y\\\\\\|\\_{2}^{2}, |  |\n|  | EMD​(X,Y)EMD𝑋𝑌\\\\displaystyle\\\\text{EMD}(X,Y) | =minϕ:X→Y​∑x∈X‖x−ϕ​(x)‖2,absentsubscript:italic-ϕ→𝑋𝑌subscript𝑥𝑋subscriptnorm𝑥italic-ϕ𝑥2\\\\displaystyle=\\\\min\\_{\\\\phi:X\\\\to Y}\\\\sum\\_{x\\\\in X}\\\\\\|x-\\\\phi(x)\\\\\\|\\_{2}, |  |\n\nwhere X𝑋X and Y𝑌Y are two point clouds with the same number of points and ϕitalic-ϕ\\\\phi is a bijection between them. Note that most previous methods use either CD or EMD in their training objectives, which tend to be favored if evaluated under the same metric. Our method, however, does not use CD or EMD during training.\n\nTable 1: Generation results. ↑↑\\\\uparrow: the higher the better, ↓↓\\\\downarrow: the lower the better. The best scores are highlighted in bold. Scores of the real shapes that are worse than some of the generated shapes are marked in gray. MMD-CD scores are multiplied by 103superscript10310^{3}; MMD-EMD scores are multiplied by 102superscript10210^{2}; JSDs are multiplied by 102superscript10210^{2}.\n\n|  |  | \\# Parameters (M) | JSD (↓↓\\\\downarrow) | MMD (↓↓\\\\downarrow) | COV (%, ↑↑\\\\uparrow) | 1-NNA (%, ↓↓\\\\downarrow) |\n| --- | --- | --- | --- | --- | --- | --- |\n| Category | Model | Full | Gen |  | CD | EMD | CD | EMD | CD | EMD |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| Airplane | r-GAN | 7.22 | 6.91 | 7.44 | 0.261 | 5.47 | 42.72 | 18.02 | 93.58 | 99.51 |\n| l-GAN (CD) | 1.97 | 1.71 | 4.62 | 0.239 | 4.27 | 43.21 | 21.23 | 86.30 | 97.28 |\n| l-GAN (EMD) | 1.97 | 1.71 | 3.61 | 0.269 | 3.29 | 47.90 | 50.62 | 87.65 | 85.68 |\n| PC-GAN | 9.14 | 1.52 | 4.63 | 0.287 | 3.57 | 36.46 | 40.94 | 94.35 | 92.32 |\n| PointFlow (ours) | 1.61 | 1.06 | 4.92 | 0.217 | 3.24 | 46.91 | 48.40 | 75.68 | 75.06 |\n| Training set | - | - | 6.61 | 0.226 | 3.08 | 42.72 | 49.14 | 70.62 | 67.53 |\n| Chair | r-GAN | 7.22 | 6.91 | 11.5 | 2.57 | 12.8 | 33.99 | 9.97 | 71.75 | 99.47 |\n| l-GAN (CD) | 1.97 | 1.71 | 4.59 | 2.46 | 8.91 | 41.39 | 25.68 | 64.43 | 85.27 |\n| l-GAN (EMD) | 1.97 | 1.71 | 2.27 | 2.61 | 7.85 | 40.79 | 41.69 | 64.73 | 65.56 |\n| PC-GAN | 9.14 | 1.52 | 3.90 | 2.75 | 8.20 | 36.50 | 38.98 | 76.03 | 78.37 |\n| PointFlow (ours) | 1.61 | 1.06 | 1.74 | 2.42 | 7.87 | 46.83 | 46.98 | 60.88 | 59.89 |\n| Training set | - | - | 1.50 | 1.92 | 7.38 | 57.25 | 55.44 | 59.67 | 58.46 |\n| Car | r-GAN | 7.22 | 6.91 | 12.8 | 1.27 | 8.74 | 15.06 | 9.38 | 97.87 | 99.86 |\n| l-GAN (CD) | 1.97 | 1.71 | 4.43 | 1.55 | 6.25 | 38.64 | 18.47 | 63.07 | 88.07 |\n| l-GAN (EMD) | 1.97 | 1.71 | 2.21 | 1.48 | 5.43 | 39.20 | 39.77 | 69.74 | 68.32 |\n| PC-GAN | 9.14 | 1.52 | 5.85 | 1.12 | 5.83 | 23.56 | 30.29 | 92.19 | 90.87 |\n| PointFlow (ours) | 1.61 | 1.06 | 0.87 | 0.91 | 5.22 | 44.03 | 46.59 | 60.65 | 62.36 |\n| Training set | - | - | 0.86 | 1.03 | 5.33 | 48.30 | 51.42 | 57.39 | 53.27 |\n\nLet Sgsubscript𝑆𝑔S\\_{g} be the set of generated point clouds and Srsubscript𝑆𝑟S\\_{r} be the set of reference point clouds with \\|Sr\\|=\\|Sg\\|subscript𝑆𝑟subscript𝑆𝑔\\|S\\_{r}\\|=\\|S\\_{g}\\|. To evaluate generative models, we first consider the three metrics introduced by Achlioptas _et al_.\\[ [1])\\]:\n\n- •\n\n\nJensen-Shannon Divergence (JSD) are computed between the marginal point distributions:\n\n\n\n|     |     |     |\n| --- | --- | --- |\n|  | JSD(Pg,Pr)=12DK​L(Pr\\|\\|M)+12DK​L(Pg\\|\\|M),\\\\displaystyle\\\\text{JSD}(P\\_{g},P\\_{r})=\\\\frac{1}{2}D\\_{KL}(P\\_{r}\\|\\|M)+\\\\frac{1}{2}D\\_{KL}(P\\_{g}\\|\\|M)\\\\,, |  |\n\n\n\nwhere M=12​(Pr+Pg)𝑀12subscript𝑃𝑟subscript𝑃𝑔M=\\\\frac{1}{2}(P\\_{r}+P\\_{g}). Prsubscript𝑃𝑟P\\_{r} and Pgsubscript𝑃𝑔P\\_{g} are marginal distributions of points in the reference and generated sets, approximated by discretizing the space into 283superscript28328^{3} voxels and assigning each point to one of them. However, it only considers the marginal point distributions but not the distribution of individual shapes. A model that always outputs the “average shape” can obtain a perfect JSD score without learning any meaningful shape distributions.\n\n- •\n\n\nCoverage (COV) measures the fraction of point clouds in the reference set that are matched to at least one point cloud in the generated set. For each point cloud in the generated set, its nearest neighbor in the reference set is marked as a match:\n\n\n\n|     |     |     |\n| --- | --- | --- |\n|  | COV​(Sg,Sr)=\\|{arg⁡minY∈Sr⁡D​(X,Y)\\|X∈Sg}\\|\\|Sr\\|,COVsubscript𝑆𝑔subscript𝑆𝑟conditional-setsubscript𝑌subscript𝑆𝑟𝐷𝑋𝑌𝑋subscript𝑆𝑔subscript𝑆𝑟\\\\displaystyle\\\\text{COV}(S\\_{g},S\\_{r})=\\\\frac{\\|\\\\{\\\\arg\\\\min\\_{Y\\\\in S\\_{r}}D(X,Y)\\|X\\\\in S\\_{g}\\\\}\\|}{\\|S\\_{r}\\|}, |  |\n\n\n\nwhere D​(⋅,⋅)𝐷⋅⋅D(\\\\cdot,\\\\cdot) can be either CD or EMD. While coverage is able to detect mode collapse, it does not evaluate the quality of generated point clouds. In fact, it is possible to achieve a perfect coverage score even if the distances between generated and reference point clouds are arbitrarily large.\n\n- •\n\n\nMinimum matching distance (MMD) is proposed to complement coverage as a metric that measures quality. For each point cloud in the reference set, the distance to its nearest neighbor in the generated set is computed and averaged:\n\n\n\n|     |     |     |\n| --- | --- | --- |\n|  | MMD​(Sg,Sr)=1\\|Sr\\|​∑Y∈SrminX∈Sg⁡D​(X,Y),MMDsubscript𝑆𝑔subscript𝑆𝑟1subscript𝑆𝑟subscript𝑌subscript𝑆𝑟subscript𝑋subscript𝑆𝑔𝐷𝑋𝑌\\\\text{MMD}(S\\_{g},S\\_{r})=\\\\frac{1}{\\|S\\_{r}\\|}\\\\sum\\_{Y\\\\in S\\_{r}}\\\\min\\_{X\\\\in S\\_{g}}D(X,Y)\\\\,, |  |\n\n\n\nwhere D​(⋅,⋅)𝐷⋅⋅D(\\\\cdot,\\\\cdot) can be either CD or EMD. However, MMD is actually very insensitive to low-quality point clouds in Sgsubscript𝑆𝑔S\\_{g}, since they are unlikely to be matched to real point clouds in Srsubscript𝑆𝑟S\\_{r}. In the extreme case, one can imagine that Sgsubscript𝑆𝑔S\\_{g} consists of mostly very low-quality point clouds with one additional point cloud in each mode of Srsubscript𝑆𝑟S\\_{r}, yet has a reasonably good MMD score.\n\n\nAs discussed above, all existing metrics have their limitations. As will be shown later, we also empirically find all these metrics sometimes give generated point clouds even better scores than real point clouds, further casting doubt on whether they can ensure a fair model comparison. We therefore introduce another metric that we believe is better suited for evaluating generative models of point clouds:\n\n- •\n\n\n1-nearest neighbor accuracy (1-NNA) is proposed by Lopez-Paz and Oquab \\[ [32])\\] for two-sample tests, assessing whether two distributions are identical.\nIt has also been explored as a metric for evaluating GANs \\[ [50])\\].\nLet S−X=Sr∪Sg−{X}subscript𝑆𝑋subscript𝑆𝑟subscript𝑆𝑔𝑋S\\_{-X}=S\\_{r}\\\\cup S\\_{g}-\\\\{X\\\\} and NXsubscript𝑁𝑋N\\_{X} be the nearest neighbor of X𝑋X in S−Xsubscript𝑆𝑋S\\_{-X}. 111-NNA is the leave-one-out accuracy of the 1-NN classifier:\n\n\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | 1-NNA(\\\\displaystyle\\\\text{1-NNA}( | Sg,Sr)\\\\displaystyle S\\_{g},S\\_{r}) |  |\n|  | =\\\\displaystyle= | ∑X∈Sg𝕀​\\[NX∈Sg\\]+∑Y∈Sr𝕀​\\[NY∈Sr\\]\\|Sg\\|+\\|Sr\\|,subscript𝑋subscript𝑆𝑔𝕀delimited-\\[\\]subscript𝑁𝑋subscript𝑆𝑔subscript𝑌subscript𝑆𝑟𝕀delimited-\\[\\]subscript𝑁𝑌subscript𝑆𝑟subscript𝑆𝑔subscript𝑆𝑟\\\\displaystyle\\\\frac{\\\\sum\\_{X\\\\in S\\_{g}}\\\\mathbb{I}\\[N\\_{X}\\\\in S\\_{g}\\]+\\\\sum\\_{Y\\\\in S\\_{r}}\\\\mathbb{I}\\[N\\_{Y}\\\\in S\\_{r}\\]}{\\|S\\_{g}\\|+\\|S\\_{r}\\|}, |  |\n\n\n\nwhere 𝕀​\\[⋅\\]𝕀delimited-\\[\\]⋅\\\\mathbb{I}\\[\\\\cdot\\] is the indicator function.\nFor each sample, the 1-NN classifier classifies it as coming from Srsubscript𝑆𝑟S\\_{r} or Sgsubscript𝑆𝑔S\\_{g} according to the label of its nearest sample.\nIf Sgsubscript𝑆𝑔S\\_{g} and Srsubscript𝑆𝑟S\\_{r} are sampled from the same distribution, the accuracy of such a classifier should converge to 50%percent5050\\\\% given a sufficient number of samples. The closer the accuracy is to 50%percent5050\\\\%, the more similar Sgsubscript𝑆𝑔S\\_{g} and Srsubscript𝑆𝑟S\\_{r} are, and therefore the better the model is at learning the target distribution. In our setting, the nearest neighbor can be computed using either CD or EMD. Unlike JSD, 1-NNA considers the similarity between shape distributions rather than between marginal point distributions. Unlike COV and MMD, 1-NNA directly measures distributional similarity and takes both diversity and quality into account.\n\n\n### 6.2 Generation\n\nWe compare our method with three existing generative models for point clouds: raw-GAN \\[ [1])\\], latent-GAN \\[ [1])\\], and PC-GAN \\[ [30])\\], using their official implementations that are either publicly available or obtained by contacting the authors.\nWe train each model using point clouds from one of the three categories in the ShapeNet \\[ [3])\\] dataset: _airplane_, _chair_, and _car_.\nThe point clouds are obtained by sampling points uniformly from the mesh surface.\nAll points in each category are normalized to have zero-mean per axis and unit-variance globally.\nFollowing prior convention \\[ [1])\\], we use 204820482048 points for each shape during both training and testing, although our model is able to sample an arbitrary number of points.\nWe additionally report the performance of point clouds sampled from the training set, which is considered as an upper bound since they are from the target distribution.\n\nIn Table [1]Table 1 ‣ 6.1 Evaluation metrics ‣ 6 Experiments ‣ PointFlow: 3D Point Cloud Generation with Continuous Normalizing Flows\"), we report the performance of different models, as well as their number of parameters in total (full) or in the generative pathways (gen).\nWe first note that all the previous metrics (JSD, MMD, and COV) sometimes assign a better score to point clouds generated by models than those from the training set (marked in gray). The 1-NNA metric does not seem to have this problem and always gives a better score to shapes from the training set. Our model outperforms all baselines across all three categories according to 1-NNA and also obtains the best score in most cases as evaluated by other metrics. Besides, our model has the fewest parameters among compared models. In Section [C]Appendix C Additional comparisons ‣ PointFlow: 3D Point Cloud Generation with Continuous Normalizing Flows\") of the appendix, we perform additional ablation studies to show the effectiveness of different components of our model. Figure [2]Figure 2 ‣ 6.2 Generation ‣ 6 Experiments ‣ PointFlow: 3D Point Cloud Generation with Continuous Normalizing Flows\") shows some examples of novel point clouds generated by our model. Figure [3]Figure 3 ‣ 6.2 Generation ‣ 6 Experiments ‣ PointFlow: 3D Point Cloud Generation with Continuous Normalizing Flows\") shows examples of point clouds reconstructed from given inputs.\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n| ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] |\n| ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] |\n| ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] |\n\nFigure 2: Examples of point clouds generated by our model. From top to bottom: airplane, chair, and car.\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n| ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] |\n| ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] |\n| ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] |\n\nFigure 3: Examples of point clouds reconstructed from inputs. From top to bottom: airplane, chair, and car. On each side of the figure we show the input point cloud on the left and the reconstructed point cloud on the right.Table 2: Unsupervised feature learning. Models are first trained on ShapeNet to learn shape representations, which are then evaluated on ModelNet40 (MN40) and ModelNet10 (MN10) by comparing the accuracy of off-the-shelf SVMs trained using the learned representations.\n\n|     |     |     |\n| --- | --- | --- |\n| Method | MN40 (%) | MN10 (%) |\n| SPH \\[ [24])\\] | 68.2 | 79.8 |\n| LFD \\[ [4])\\] | 75.5 | 79.9 |\n| T-L Network \\[ [14])\\] | 74.4 | - |\n| VConv-DAE \\[ [42])\\] | 75.5 | 80.5 |\n| 3D-GAN \\[ [48])\\] | 83.3 | 91.0 |\n| l-GAN (EMD) \\[ [1])\\] | 84.0 | 95.4 |\n| l-GAN (CD) \\[ [1])\\] | 84.5 | 95.4 |\n| PointGrow \\[ [44])\\] | 85.7 | - |\n| MRTNet-VAE \\[ [13])\\] | 86.4 | - |\n| FoldingNet \\[ [51])\\] | 88.4 | 94.4 |\n| l-GAN (CD) \\[ [1])\\]† | 87.0 | 92.8 |\n| l-GAN (EMD) \\[ [1])\\]† | 86.7 | 92.2 |\n| PointFlow (ours) | 86.8 | 93.7 |\n\n- †\n\n\nWe run the official code of l-GAN on our pre-processed dataset using the same encoder architecture as our model.\n\n\n### 6.3 Auto-encoding\n\nWe further quantitatively compare the reconstruction ability of our flow-based auto-encoder with l-GAN \\[ [1])\\] and AtlasNet \\[ [17])\\]. Following the setting of AtlasNet, the state-of-the-art in this task, we train our auto-encoder on all shapes in the ShapeNet dataset. The auto-encoder is trained with the reconstruction likelihood objective ℒreconsubscriptℒrecon\\\\mathcal{L}\\_{\\\\text{recon}} only. At test time, we sample 409640964096 points per shape and split them into an input set and a reference set, each consisting of 204820482048 points. We then compute the distance (CD or EMD) between the reconstructed input set and the reference set 111We use a separate reference set because we expect the auto-encoder to learn the point distribution. Exactly reproducing the input points is acceptable behavior, but should not be given a higher score than randomly sampling points from the underlying point distribution.. Although our model is not directly trained with EMD, it obtains the best EMD score, even higher than l-GAN trained with EMD and AtlasNet which has more than 404040 times more parameters.\n\nTable 3: Auto-encoding performance evaluated by CD and EMD. AtlasNet is trained with CD and l-GAN is trained on CD or EMD. Our method is not trained on CD or EMD. CD scores are multiplied by 104superscript10410^{4}; EMD scores are multiplied by 102superscript10210^{2}.\n\n| Model | \\# Parameters (M) | CD | EMD |\n| --- | --- | --- | --- |\n| l-GAN (CD)  \\[ [1])\\] | 1.77 | 7.12 | 7.95 |\n| l-GAN (EMD)  \\[ [1])\\] | 1.77 | 8.85 | 5.26 |\n| AtlasNet \\[ [17])\\] | 44.9 | 5.13 | 5.97 |\n| PointFlow (ours) | 1.30 | 7.54 | 5.18 |\n\n### 6.4 Unsupervised representation learning\n\nWe finally evaluate the representation learning ability of our auto-encoders.\nSpecifically, we extract the latent representations of our auto-encoder trained in the full ShapeNet dataset and train a linear SVM classifier on top of it on ModelNet10 or ModelNet40 \\[ [49])\\].\nOnly for this task, we normalize each individual point cloud to have zero-mean per axis and unit-variance globally, following prior works \\[ [55]), [1])\\].\nWe also apply random rotations along the gravity axis when training the auto-encoder.\n\nA problem with this task is that different authors have been using different encoder architectures with a different number of parameters, making it hard to perform an apples-to-apples comparison. In addition, different authors may use different pre-processing protocols (as also noted by Yang _et al_.\\[ [51])\\]), which could also affect the numbers.\n\nIn Table [2]Table 2 ‣ 6.2 Generation ‣ 6 Experiments ‣ PointFlow: 3D Point Cloud Generation with Continuous Normalizing Flows\"), we still show the numbers reported by previous papers, but also include a comparison with l-GAN \\[ [1])\\] trained using the same encoder architecture and the exact same data as our model. On ModelNet10, the accuracy of our model is 1.5%percent1.51.5\\\\% and 0.9%percent0.90.9\\\\% higher than l-GAN (EMD) and l-GAN (CD), respectively. On ModelNet40, the performance of the three models is very close.",
            "citations": null
          },
          "7 Conclusion and future works": {
            "content": "In this paper, we propose PointFlow, a generative model for point clouds consisting of two levels of continuous normalizing flows trained with variational inference.\nFuture work includes applications to other tasks such as point cloud reconstruction from a single image.",
            "citations": null
          },
          "8 Acknowledgment": {
            "content": "This work was supported in part by a research gift from Magic Leap.\nXun Huang was supported by NVIDIA Graduate Fellowship.",
            "citations": null
          }
        },
        "abstract": "As 3D point clouds become the representation of choice for multiple vision\nand graphics applications, the ability to synthesize or reconstruct\nhigh-resolution, high-fidelity point clouds becomes crucial. Despite the recent\nsuccess of deep learning models in discriminative tasks of point clouds,\ngenerating point clouds remains challenging. This paper proposes a principled\nprobabilistic framework to generate 3D point clouds by modeling them as a\ndistribution of distributions. Specifically, we learn a two-level hierarchy of\ndistributions where the first level is the distribution of shapes and the\nsecond level is the distribution of points given a shape. This formulation\nallows us to both sample shapes and sample an arbitrary number of points from a\nshape. Our generative model, named PointFlow, learns each level of the\ndistribution with a continuous normalizing flow. The invertibility of\nnormalizing flows enables the computation of the likelihood during training and\nallows us to train our model in the variational inference framework.\nEmpirically, we demonstrate that PointFlow achieves state-of-the-art\nperformance in point cloud generation. We additionally show that our model can\nfaithfully reconstruct point clouds and learn useful representations in an\nunsupervised manner. The code will be available at\nhttps://github.com/stevenygd/PointFlow."
      },
      "bib.bib109": {
        "id": "bib.bib109",
        "citation": "[109]",
        "authors": "",
        "year": "",
        "title": "Grm: Large gaussian reconstruction model for efficient 3d reconstruction and generation, 2024.",
        "venue": "",
        "pages": "",
        "url": "https://arxiv.org/abs/2403.14621",
        "arxiv_id": "2403.14621",
        "doi": null,
        "sections": {
          "1 Introduction": {
            "content": "The availability of high-quality and diverse 3D assets is critical in many domains, including robotics, gaming, architecture, among others. Yet, creating these assets has been a tedious manual process, requiring expertise in difficult-to-use computer graphics tools.\n\nEmerging 3D generative models offer the ability to easily create diverse 3D assets from simple text prompts or single images \\[ [70])\\]. Optimization-based 3D generative methods can produce high-quality assets, but they often require a long time—often hours—to produce a single 3D asset \\[ [71]), [50]), [98]), [101]), [93])\\]. Recent feed-forward 3D generative methods have demonstrated excellent quality and diversity while offering significant speedups over optimization-based 3D generation approaches \\[ [38]), [12]), [78]), [2]), [91]), [54]), [30]), [46]), [106])\\]. These state-of-the-art (SOTA) models, however, typically build on the triplane representation \\[ [5])\\], which requires inefficient volume rendering. This inefficient rendering step not only hinders fast inference but it often also requires the models to operate at a reduced 3D resolution, limiting representational capacity.\n\nWe introduce the Gaussian Reconstruction Model (GRM) as a new feed-forward 3D generative model.\nAt its core, GRM provides a novel sparse-view reconstructor that takes four different views of a 3D object as input and outputs the corresponding 3D scene.\nGRM implements two key insights: first, we replace the triplane scene representation of recent feed-forward generative frameworks \\[ [30]), [46]), [106])\\] by 3D Gaussians; second, we design a pure transformer architecture to translate the set of input pixels to the set of pixel-aligned 3D Gaussians defining the output 3D scene.\nWhile parts of this architecture uses standard vision transformers (ViT) \\[ [19])\\], we introduce a new upsampler that utilizes a variation of windowed self-attention layers \\[ [3])\\].\nThis upsampler is unique in being able to efficiently pass non-local cues. As demonstrated in our experiment, it is critical for the reconstruction of high-frequency appearance details.\nInstead of attempting to synthesize missing regions from incomplete views—a highly ill-defined problem—we opt to train our model with sparse yet well-distributed views to cover enough information of a scene.\nThis allows us to allocate the model’s capacity for fine-grained detail reconstruction, leading to significantly higher fidelity than relevant baselines for object-level 3D reconstruction. When combined with multi-view diffusion models, GRM achieves SOTA quality and speed for text-to-3D and single image-to-3D object generation.\n\nSpecifically, our contributions include\n\n- •\n\n\na novel and efficient feed-forward 3D generative model that builds on 3D Gaussian splatting;\n\n- •\n\n\nthe design of a sparse-view reconstructor using a pure transformer architecture, including encoder and upsampler, for pixel-to-3D Gaussian translation;\n\n- •\n\n\nthe demonstration of SOTA quality and speed for object-level sparse-view 3D reconstruction and, when combined with existing multi-view diffusion models, also text-to-3D and image-to-3D generation.",
            "citations": null
          },
          "2 Related Work": {
            "content": "#### Sparse-view Reconstruction.\n\nNeural representations, as highlighted in prior works \\[ [62]), [69]), [63]), [86]), [84]), [9]), [64])\\], present a promising foundation for scene representation and neural rendering \\[ [95])\\].\nWhen applied to novel-view synthesis, these methods have demonstrated success in scenarios with multi-view training images, showcasing proficiency in single-scene overfitting.\nNotably, recent advancements \\[ [109]), [10]), [59]), [100]), [51]), [33])\\] have extended these techniques to operate with a sparse set of views, displaying improved generalization to unseen scenes.\nThese methods face challenges in capturing multiple modes within large-scale datasets, resulting in a limitation to generate realistic results.\nRecent works \\[ [99]), [30]), [114])\\] further scale up the model and datasets for better generalization.\nBut relying on neural volume–based scene representation proves inadequate for efficiently synthesizing high-resolution and high-fidelity images.\nOur proposed solution involves the use of pixel-aligned 3D Gaussians \\[ [90]), [8])\\] combined with our effective transformer architecture.\nThis approach is designed to elevate both the efficiency and quality of the sparse-view reconstructor when provided with only four input images.\n\n#### 3D Generation.\n\nThe advances of 3D GANs have set the foundation of 3D scene generation. Leveraging various successful 2D GAN architectures \\[ [23]), [4]), [39]), [41]), [42]), [40]), [112]), [37])\\], 3D GANs \\[ [65]), [77]), [6]), [5]), [67]), [24]), [88]), [105]), [104]), [82]), [22]), [87])\\] combine 3D scene representations and neural rendering to generate 3D-aware content in a feed-forward fashion.\nRecently, Diffusion Models (DM) have emerged as a more powerful generative model, surpassing GANs in 2D generation \\[ [18]), [29]), [89]), [75])\\].\nWith its extension in 3D being actively explored, we review the most relevant work and refer readers to \\[ [70])\\] for a comprehensive review.\nOne research line seek to directly train 3D DMs using 3D \\[ [66]), [36]), [83]), [26]), [68])\\] or 2D supervision \\[ [38]), [12]), [78]), [2]), [25]), [55])\\]. Though impressive, these work either cannot leverage the strong priors from pretrained 2D DMs or they suffer from 3D inconsistency.\nOther researchers propose to exploit 2D diffusion priors using an optimization procedure known as Score Distillation Sampling (SDS) and its variant \\[ [71]), [50]), [98]), [101]), [93]), [13]), [27]), [55]), [81]), [15]), [49])\\].\nThese methods yield high-quality 3D generations, but require hours for the optimization process to converge.\nTherefore, there is a need to combine the feed-forward generation framework with expressive generative powers from DMs.\nTo this end, many recent works first use 2D multi-view diffusion and then lift the multi-view inputs to 3D \\[ [7]), [56]), [94]), [54]), [58]), [96]), [79])\\].\nRecently, the Large Reconstruction Model (LRM) \\[ [30])\\] scales up both the model and the dataset to predict a neural radiance field (NeRF) from single-view images. Although LRM is a reconstruction model, it can be combined with DMs to achieve text-to-3D and image-to-3D generation, as demonstrated by extensions such as Instant3D \\[ [46])\\] and DMV3D \\[ [106])\\].\nOur method also builds on a strong reconstruction model and uses pretrained 2D DMs to provide input images for 3D generation in a feed-forward fashion. However, we adopt highly efficient 3D Gaussians \\[ [43])\\] for representing and rendering a scene. This design lifts the computation and memory bottleneck posed by NeRF and volumetric rendering, allowing us to to generate high-quality 3D assets within seconds.\n\nSome concurrent works, such as LGM \\[ [92])\\], AGG \\[ [103])\\], and Splatter Image \\[ [90])\\], also use 3D Gaussians in a feed-forward model.\nOur model differs from them in the choice of architecture—instead of using conventional convolution-based U-Net, we opt for a purely transformer-based encoder and a highly efficient transformer-based upsampler to generate a large number of pixel-aligned 3D Gaussians, which offering superior reconstruction quality.\n\n#### Generalizable Gaussians.\n\n3D Gaussians \\[ [44]), [43])\\] and differentiable splatting \\[ [43])\\] have gained broad popularity thanks to their ability to efficiently reconstruct high-fidelity 3D scenes from posed images using only a moderate number of 3D Gaussians.\nThis representation has been quickly adopted for various application, including image- or text-conditioned 3D \\[ [47]), [14]), [49])\\] and 4D generation \\[ [74]), [52])\\], avatar reconstruction \\[ [48]), [113]), [72]), [31]), [76])\\], dynamic scene reconstruction \\[ [61]), [102]), [108]), [107])\\], among others \\[ [21]), [97]), [11])\\].\nAll of these aforementioned work focus on single-scene optimization, although very recent work also adopts 3D Gaussians into a GAN framework for 3D human generation \\[ [1])\\].",
            "citations": null
          },
          "3 Method": {
            "content": "GRM is a feed-forward sparse-view 3D reconstructor, utilizing four input images to efficiently infer underlying 3D Gaussians \\[ [43])\\].\nSupplied with a multi-view image generator head \\[ [46]), [79])\\], GRM can be utilized to generate 3D from text or a single image.\nDifferent from LRM \\[ [30]), [46]), [106]), [99])\\], we leverage _pixel-aligned Gaussians_ ( [Sec.3.1]Pixel-aligned Gaussians ‣ 3 Method ‣ GRM: Large Gaussian Reconstruction Model for Efficient 3D Reconstruction and Generation\")) to enhance efficient and reconstruction quality and we adopt a transformer-based network to predict the properties of the Gaussians by associating information from all input views in a memory-efficient way ( [Sec.3.2]Large Gaussian Reconstruction Model ‣ 3 Method ‣ GRM: Large Gaussian Reconstruction Model for Efficient 3D Reconstruction and Generation\")).\nFinally, we detail the training objectives in [Sec.3.3]Training ‣ 3 Method ‣ GRM: Large Gaussian Reconstruction Model for Efficient 3D Reconstruction and Generation\") and demonstrate high-quality text-to-3D and image-to-3D generation in a few seconds (Sec. [3.4]Reconstructor for 3D Generation ‣ 3 Method ‣ GRM: Large Gaussian Reconstruction Model for Efficient 3D Reconstruction and Generation\")).\n\n### 3.1 Pixel-aligned Gaussians\n\n3D Gaussians use a sparse set of primitives 𝒢={𝐠i}i=1N𝒢superscriptsubscriptsubscript𝐠𝑖𝑖1𝑁\\\\mathcal{G}=\\\\{\\\\mathbf{g}\\_{i}\\\\}\\_{i=1}^{N} to represent the geometry and appearance of a 3D scene,\nwhere each Gaussian is parameterized with location 𝝁∈ℝ3𝝁superscriptℝ3\\\\bm{\\\\mu}\\\\in\\\\mathbb{R}^{3}, rotation quaternion 𝐫∈ℝ4𝐫superscriptℝ4\\\\mathbf{r}\\\\in\\\\mathbb{R}^{4}, scale 𝐬∈ℝ3𝐬superscriptℝ3\\\\mathbf{s}\\\\in\\\\mathbb{R}^{3}, opacity o∈ℝ𝑜ℝo\\\\in\\\\mathbb{R}, and the spherical harmonics (SH) coefficients 𝐜∈ℝD𝐜superscriptℝ𝐷\\\\mathbf{c}\\\\in\\\\mathbb{R}^{D}, with D𝐷D denoting the number of SH bases.\nThese Gaussians can be rendered in real time using the differentiable rasterizer \\[ [43])\\].\n3D Gaussians have gained tremendous popularity for single-scene optimization (SSO), but utilizing them in a generalizable framework remains challenging.\nA primary reason is that the properties of Gaussians are highly inter-dependent—multiple configurations can lead to the same visual representation, causing optimization difficulty.\nOn the other hand, 3D Gaussians are an unstructured 3D representation, making it challenging to integrate effectively with neural networks for predictions which potentially increases the complexity of the prediction process.\nWe introduce pixel-aligned Gaussians \\[ [8]), [90])\\] to address the above challenges. Instead of directly predicting a set of Gaussians and expect them to accurately cover the entire shape, we constrain the Gaussians’ locations along the input viewing rays, _i.e_.,\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | 𝝁=𝐜o+τ​𝐫,𝝁subscript𝐜𝑜𝜏𝐫\\\\bm{\\\\mu}=\\\\mathbf{c}\\_{o}+\\\\tau\\\\mathbf{r}, |  | (1) |\n\nwhere 𝐜osubscript𝐜𝑜\\\\mathbf{c}\\_{o} and 𝐫𝐫\\\\mathbf{r} denote the camera center and the ray direction.\nSpecifically, for every input view we predict a Gaussian attribute map 𝐓∈ℝH×W×C𝐓superscriptℝ𝐻𝑊𝐶\\\\mathbf{T}\\\\in\\\\mathbb{R}^{H\\\\times W\\\\times C} of C=12𝐶12C=12 channels, corresponding to depth τ𝜏\\\\tau, rotation, scaling, opacity, and the DC term of the SH coefficients.\nWe then unproject the pixel-aligned Gaussians into 3D, producing a total of V×H×W𝑉𝐻𝑊V\\\\times H\\\\times W densely distributed 3D Gaussians.\nPixel-aligned Gaussians establish connections between input pixels and the 3D space in a more direct way, alleviating the learning difficulty, resulting to better reconstruction quality as we empirically show in [Sec.4.5]Ablation Study ‣ 4 Experiments ‣ GRM: Large Gaussian Reconstruction Model for Efficient 3D Reconstruction and Generation\").\n\n![Refer to caption]Figure 2: GRM pipeline. Given 4 input views, which can be generated from text \\[ [46])\\] or a single image \\[ [79])\\], our sparse-view reconstructor estimates the underlying 3D scene in a single feed-forward pass using pixel-aligned Gaussians. The transformer-based sparse-view reconstructor, equipped with a novel transformer-based upsampler, is capable of leveraging long-range visual cues to efficiently generate a large number of 3D Gaussians for high-fidelity 3D reconstruction.\n\n### 3.2 Large Gaussian Reconstruction Model\n\nIn the following, we introduce our network, which transforms a set of input images ℐ={𝐈v}v=1Vℐsuperscriptsubscriptsubscript𝐈𝑣𝑣1𝑉\\\\mathcal{I}=\\\\{\\\\mathbf{I}\\_{v}\\\\}\\_{v=1}^{V} and their camera poses 𝒞={𝐜v}v=1V𝒞superscriptsubscriptsubscript𝐜𝑣𝑣1𝑉\\\\mathcal{C}=\\\\{\\\\mathbf{c}\\_{v}\\\\}\\_{v=1}^{V} to the Gaussian maps 𝒯={𝐓v}v=1V𝒯superscriptsubscriptsubscript𝐓𝑣𝑣1𝑉\\\\mathcal{T}=\\\\{\\\\mathbf{T}\\_{v}\\\\}\\_{v=1}^{V}.\n\n#### Transformer-based Encoder.\n\nFor a given input image 𝐈v∈ℝH×W×3subscript𝐈𝑣superscriptℝ𝐻𝑊3\\\\mathbf{I}\\_{v}\\\\in\\\\mathbb{R}^{H\\\\times W\\\\times 3}, we first inject the camera information to every pixel following \\[ [106]), [85])\\] with Plücker embedding \\[ [34]), [85])\\].\nThen we use a convolutional image tokenizer with kernel and stride 16 to extract local image features, resulting in a H/16×W/16𝐻16𝑊16\\\\nicefrac{{H}}{{16}}\\\\times\\\\nicefrac{{W}}{{16}} feature map.\nThe features from every view are concatenated together to a single feature vector of length (V×H/16×W/16)𝑉𝐻16𝑊16\\\\left(V\\\\times\\\\nicefrac{{H}}{{16}}\\\\times\\\\nicefrac{{W}}{{16}}\\\\right).\nFollowing common practice in vision transformers, we append learnable image position encodings for each token to encode the spatial information in the image space.\nThe resulting feature vector is subsequently fed to a series of self-attention layers.\nThe self-attention layers attend to all tokens across all the input views, ensuring mutual information exchange among all input views, resembling traditional feature matching and encouraging consistent predictions for pixels belonging to different images.\nThe output of the transformer-based encoder is a V×H/16×W/16𝑉𝐻16𝑊16V\\\\times\\\\nicefrac{{H}}{{16}}\\\\times\\\\nicefrac{{W}}{{16}}-long feature vector, denoted as 𝐅𝐅\\\\mathbf{F}.\nFormally, the transformer function can be written as\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | 𝐅=Eθ,ϕ​(ℐ,𝒞),𝐅subscript𝐸𝜃italic-ϕℐ𝒞\\\\displaystyle\\\\mathbf{F}=E\\_{\\\\theta,\\\\phi}\\\\left(\\\\mathcal{I},\\\\mathcal{C}\\\\right), |  | (2) |\n\nwhere θ𝜃\\\\theta and ϕitalic-ϕ\\\\phi denote the network parameters and the learnable image position encodings.\n\nIn the transformer encoder, we utilize patch convolution to tokenize the input images, resulting in the output feature 𝐅𝐅\\\\mathbf{F} with a smaller spatial dimension.\nWhile this is advantageous for capturing broader image context, it is limited in modeling high-frequency details.\nTo this end, we introduce a transformer-based upsampler to improve the detail reconstruction.\n\n#### Transformer-based Upsampler.\n\nInspired by previous work \\[ [3]), [57])\\], we use windowed attention to balance the need for non-local multi-view information aggregation and feasible computation cost.\nSpecifically, we construct multiple upsampler blocks to progressively upsample the features by factors of 2 until we reach the original input image resolution.\nIn each block, we first quadruple the feature dimensions with a linear layer and then double the spatial dimension with a PixelShuffle layer \\[ [80])\\].\nThe upsampled feature maps are grouped and passed to a self-attention layer in a sliding window of size W𝑊W and shift W/2𝑊2\\\\nicefrac{{W}}{{2}}.\nWhile the self-attention operation is performed within each distinct window, to maintain manageable memory and computation, the overlapping between shifted windows improves non-local information flow.\nFormally, an upsampler block contains the following operations:\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n|  | 𝐅𝐅\\\\displaystyle\\\\mathbf{F} | =PixelShuffle⁡(Linear⁡(𝐅),2),absentPixelShuffleLinear𝐅2\\\\displaystyle=\\\\operatorname{\\\\textsc{PixelShuffle}}\\\\left(\\\\operatorname{\\\\textsc{Linear}}\\\\left(\\\\mathbf{F}\\\\right),2\\\\right), |  | (3) |\n|  | 𝐅𝐅\\\\displaystyle\\\\mathbf{F} | =SelfAttention⁡(𝐅,W),absentSelfAttention𝐅𝑊\\\\displaystyle=\\\\operatorname{\\\\textsc{SelfAttention}}\\\\left(\\\\mathbf{F},W\\\\right), |  | (4) |\n|  | 𝐅𝐅\\\\displaystyle\\\\mathbf{F} | =Shift⁡(SelfAttention⁡(Shift⁡(𝐅,W/2),W),−W/2).absentShiftSelfAttentionShift𝐅𝑊2𝑊𝑊2\\\\displaystyle=\\\\operatorname{\\\\textsc{Shift}}\\\\left(\\\\operatorname{\\\\textsc{SelfAttention}}\\\\left(\\\\operatorname{\\\\textsc{Shift}}\\\\left(\\\\mathbf{F},W/2\\\\right),W\\\\right),-W/2\\\\right). |  | (5) |\n\nAfter several blocks, the context length expands to the same spatial dimension as the input.\nWe reshape the features back to 2D tensors, resulting in V𝑉V feature maps with a resolution of H×W𝐻𝑊{H}\\\\times{W}, denoted as ℱ={𝐅v}v=1Vℱsuperscriptsubscriptsubscript𝐅𝑣𝑣1𝑉\\\\mathcal{F}=\\\\{\\\\mathbf{F}\\_{v}\\\\}\\_{v=1}^{V}.\n\n#### Rendering with Gaussian Splatting.\n\nFrom the upsampled features ℱℱ\\\\mathcal{F}, we predict the Gaussian attribute maps {𝐓v}v=1Vsuperscriptsubscriptsubscript𝐓𝑣𝑣1𝑉\\\\{\\\\mathbf{T}\\_{v}\\\\}\\_{v=1}^{V} for pixel-aligned Gaussians using separate linear heads.\nAs mentioned in  [Sec.3.1]Pixel-aligned Gaussians ‣ 3 Method ‣ GRM: Large Gaussian Reconstruction Model for Efficient 3D Reconstruction and Generation\"), these are then unprojected along the viewing ray according to the predicted depth, from which a final image 𝐈v′subscript𝐈superscript𝑣′\\\\mathbf{I}\\_{v^{\\\\prime}} and alpha mask 𝐌v′subscript𝐌superscript𝑣′\\\\mathbf{M}\\_{v^{\\\\prime}} (used for supervision) can be rendered at an arbitrary camera view 𝐜v′subscript𝐜superscript𝑣′\\\\mathbf{c}\\_{v^{\\\\prime}} through Gaussian splatting.\n\n### 3.3 Training\n\nDuring the training phase, we sample V=4𝑉4V=4 input views that sufficiently cover the whole scene, and supervise with additional views to guide the reconstruction.\nTo remove floaters, we also supervise the alpha map from Gaussian splatting with the ground truth object mask available from the training data.\n\nGiven V′superscript𝑉′V^{\\\\prime} supervision views, the training objective is\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n|  | ℒsubscriptℒ\\\\displaystyle\\\\mathcal{L}\\_{\\\\textrm{}} | =1V′​∑1≤v′≤V′ℒimg+ℒmask,absent1superscript𝑉′subscript1superscript𝑣′superscript𝑉′subscriptℒimgsubscriptℒmask\\\\displaystyle=\\\\dfrac{1}{V^{\\\\prime}}\\\\sum\\_{{1\\\\leq v^{\\\\prime}\\\\leq V^{\\\\prime}}}\\\\mathcal{L}\\_{\\\\textrm{img}}+\\\\mathcal{L}\\_{\\\\textrm{mask}}, |  | (6) |\n|  | ℒimgsubscriptℒimg\\\\displaystyle\\\\mathcal{L}\\_{\\\\textrm{img}} | =L2​(𝐈v′,𝐈^v′)+0.5​Lp​(𝐈v′,𝐈^v′),absentsubscript𝐿2subscript𝐈superscript𝑣′subscript^𝐈superscript𝑣′0.5subscript𝐿𝑝subscript𝐈superscript𝑣′subscript^𝐈superscript𝑣′\\\\displaystyle=L\\_{2}\\\\left(\\\\mathbf{I}\\_{v^{\\\\prime}},\\\\hat{\\\\mathbf{I}}\\_{v^{\\\\prime}}\\\\right)+0.5L\\_{p}\\\\left(\\\\mathbf{I}\\_{v^{\\\\prime}},\\\\hat{\\\\mathbf{I}}\\_{v^{\\\\prime}}\\\\right), |  | (7) |\n|  | ℒmasksubscriptℒmask\\\\displaystyle\\\\mathcal{L}\\_{\\\\textrm{mask}} | =L2​(𝐌v′,𝐌^v′),absentsubscript𝐿2subscript𝐌superscript𝑣′subscript^𝐌superscript𝑣′\\\\displaystyle=L\\_{2}\\\\left(\\\\mathbf{M}\\_{v^{\\\\prime}},\\\\hat{\\\\mathbf{M}}\\_{v^{\\\\prime}}\\\\right), |  | (8) |\n\nwhere 𝐈^v′subscript^𝐈superscript𝑣′\\\\hat{\\\\mathbf{I}}\\_{v^{\\\\prime}} and 𝐌^v′subscript^𝐌superscript𝑣′\\\\hat{\\\\mathbf{M}}\\_{v^{\\\\prime}} denote ground truth image and alpha mask, respectively. L2subscript𝐿2L\\_{2} and Lpsubscript𝐿𝑝L\\_{p} are L2 loss and perceptual loss \\[ [35])\\].\n\nTo further constrain the Gaussian scaling, we employ the following activation function corresponding to the output 𝐬osubscript𝐬𝑜\\\\mathbf{s}\\_{o} of the linear head for scale. Subsequently, we conduct linear interpolation within predefined scale values sm​i​nsubscript𝑠𝑚𝑖𝑛s\\_{min} and sm​a​xsubscript𝑠𝑚𝑎𝑥s\\_{max}:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | 𝐬=sm​i​n​Sigmoid​(𝐬o)+sm​a​x​(1−Sigmoid​(𝐬o)).𝐬subscript𝑠𝑚𝑖𝑛Sigmoidsubscript𝐬𝑜subscript𝑠𝑚𝑎𝑥1Sigmoidsubscript𝐬𝑜\\\\displaystyle\\\\mathbf{s}=s\\_{min}\\\\textsc{Sigmoid}(\\\\mathbf{s}\\_{o})+s\\_{max}(1-\\\\textsc{Sigmoid}(\\\\mathbf{s}\\_{o})). |  | (9) |\n\n### 3.4 Reconstructor for 3D Generation\n\nOur reconstructor alone is able to efficiently estimate a 3D scene from 4 input images.\nWe can seamlessly integrate this reconstructor with any diffusion model that generates multi-view images to enable fast text-to-3D and image-to-3D generation, similar to Instant3D \\[ [46])\\].\nSpecifically, we use the first stages of Instant3D \\[ [46])\\] and Zero123++\\[ [79])\\] to produce 4 multi-view images from a text prompt or a single image, respectively. Note that Zero123++ generates 6 images, from which we select the 1st, 3rd, 5th, and 6th as input to our reconstructor.",
            "citations": null
          },
          "4 Experiments": {
            "content": "### 4.1 Experimental Settings\n\n#### Training Settings.\n\nThe encoder E𝐸E consists of 1 strided convolution layer to tokenize the image and 24 self-attention layers with channel width 768.\nThe upsampler consists of 4 upsampler blocks and each block contains 2 attention layers.\nFor training, we use AdamW \\[ [60])\\] with a learning rate initialized at 0.00030.00030.0003 decayed with cosine annealing after 3k𝑘k steps.\nDeferred back-propagation \\[ [110])\\] is adopted to optimize GPU memory.\nWe train our model on 32 NVIDIA A100 GPUs for 40M images on the resolution of 512×\\\\times512, using a batch size of 8 per GPU and taking about 4 days to complete.\nThe window size in the transformer-upsampler is 4096.\nThe values for sm​i​nsubscript𝑠𝑚𝑖𝑛s\\_{min} and sm​a​xsubscript𝑠𝑚𝑎𝑥s\\_{max} are set to 0.005 and 0.02.\n\n#### Training Data.\n\nWe obtain multi-view images from Objaverse \\[ [17])\\] as training inputs.\nObjaverse contains more than 800k𝑘k 3D objects with varied quality.\nFollowing \\[ [46])\\], we filter 100k𝑘k high-quality objects, and render 32 images at random viewpoints with a fixed 50∘ field of view under ambient lighting.\n\n#### Test Data.\n\nWe use Google Scanned Objects (GSO) \\[ [20])\\], and render a total of 64 test views with equidistant azimuth at {10,20,30,40}10203040\\\\{10,20,30,40\\\\} degree elevations.\nIn sparse-view reconstruction, the evaluation uses full renderings from 100 objects to assess all models.\nFor single-view reconstruction, we restrict the analysis to renderings generated at an elevation angle of 20 from 250 objects.\nMore details about training settings and data are presented in Supplementary Material.\n\n![Refer to caption]Figure 3: Sparse-view reconstruction. Given the same sparse-view inputs (top), we compare the 3D reconstruction quality with strong baselines, among which GS \\[ [43])\\] is optimization based. SparseNeuS \\[ [59])\\] (trained in One-2-3-45 \\[ [54])\\]) and IBRNet \\[ [100])\\] require 16 views (only 4 of those are visualized in the top row). GRM more accurately reconstructs the geometric structure as well as the finer appearance details.\n\n### 4.2 Sparse-view Reconstruction\n\n#### Baselines and Metrics.\n\nWe compare our method with Gaussian Splatting \\[ [43])\\], SparseNeuS \\[ [54]), [59])\\], IBRNet \\[ [100])\\], MV-LRM \\[ [46])\\], and the concurrent LGM \\[ [92])\\].\nSince MV-LRM neither released their code nor model, we reproduce it following their paper. The original SparseNeuS does not support 360∘ reconstruction, so we use the improved version trained in One-2-3-45 \\[ [54])\\]. The remaining baselines are evaluated using their original implementations.\nFor all baselines, except for SparseNeuS and IBRNet, we use the same set of four input views that roughly cover the entire object.\nSparseNeuS and IBRNet are originally intended for denser input views, hence we additionally sample another 121212 views, resulting in 16 roughly uniformly distributed views.\nFollowing MV-LRM, we use PSNR, SSIM, and LPIPS to measure the reconstruction quality.\nAdditional evaluations for geometry reconstruction accuracy is included in the Supplementary Material.\nWe conduct all the comparisons using a resolution of 512×\\\\times512.\n\nTable 1: Sparse-view reconstruction. We compare the reconstruction quality for 64 novel views with 100 objects from GSO \\[ [20])\\]. GRM yields superior quality while maintaining fast speed. INF. Time is time from image inputs to the corresponding 3D representation (e.g., 3D Gaussians or Triplane NeRF); REND. Time is the time used to render a 5122superscript5122512^{2} image from the 3D representation.\n\n| Method | #views | PSNR↑ | SSIM↑ | LPIPS↓ | INF. Time↓ | REND. Time↓ |\n| --- | --- | --- | --- | --- | --- | --- |\n| GS \\[ [43])\\] | 4 | 21.22 | 0.854 | 0.140 | 9 min | Real time |\n| IBRNet \\[ [100])\\] | 16 | 21.50 | 0.877 | 0.155 | 21 sec | 1.2 sec |\n| SparseNeuS \\[ [54]), [59])\\] | 16 | 22.60 | 0.873 | 0.132 | 6 sec | Real time |\n| LGM \\[ [92])\\] | 4 | 23.79 | 0.882 | 0.097 | 0.07 sec | Real time |\n| MV-LRM \\[ [46])\\] | 4 | 25.38 | 0.897 | 0.068 | 0.25 sec | 1.7 sec |\n| GRM (Ours) | 4 | 30.05 | 0.906 | 0.052 | 0.11 sec | Real time |\n\n#### Results.\n\nAs [Tab.1]In Baselines and Metrics. ‣ 4.2 Sparse-view Reconstruction ‣ 4 Experiments ‣ GRM: Large Gaussian Reconstruction Model for Efficient 3D Reconstruction and Generation\") shows,\nour method significantly outperforms all baselines across all metrics by a large margin, even though SparseNeuS and IBRNet require 4 times more input views.\nAt the same time, our inference speed is among the fastest two, only second to the concurrent LGM.\nHowever, ours predicts 16 times more Gaussians than they do, which leads to a much higher reconstruction fidelity.\n[Fig.3]In Test Data. ‣ 4.1 Experimental Settings ‣ 4 Experiments ‣ GRM: Large Gaussian Reconstruction Model for Efficient 3D Reconstruction and Generation\") shows the novel-view rendering results.\nCompared to other methods, our reconstructions accurately reflect the geometric structures, containing no visible floaters, and they capture better appearance details than the baselines.\n\n### 4.3 Single Image-to-3D Generation\n\nAs shown in [Sec.3.4]Reconstructor for 3D Generation ‣ 3 Method ‣ GRM: Large Gaussian Reconstruction Model for Efficient 3D Reconstruction and Generation\"), GRM can be used for single image-to-3D generation by combining it with image-to-multiview diffusion models, such as Zero123++\\[ [79])\\].\n\n#### Baselines and Metrics.\n\nThe baselines include SOTA single-image 3D generation methods: ShapE \\[ [36])\\], One-2-3-45 \\[ [54])\\], One-2-3-45++ \\[ [53])\\], DreamGaussian \\[ [93])\\], Wonder3D \\[ [58])\\], TriplaneGaussian \\[ [114])\\], and LGM \\[ [92])\\].\nFor all methods, we use the same input image that is selected randomly from the 4 input views in the sparse-view reconstruction task.\nAll the comparisons are done using a resolution of 256×\\\\times256.\n\n![Refer to caption]Figure 4: Single image-to-3D generation. We compare with methods using Gaussians (top) and non-Gaussians (bottom) as 3D representations. Reconstruction methods, e.g., TriplaneGaussian \\[ [114])\\] struggle to realistically complete the unseen region (rows 1–2). SDS-based methods, e.g., DreamGaussian \\[ [93])\\] suffer from considerable inconsistencies with the input image. LGM \\[ [92])\\], One-2-3-45 \\[ [54])\\], One-2-3-45++ \\[ [53])\\], and Wonder3D \\[ [58])\\] also combine multiview diffusion and reconstruction for single image-to-3D generation, but they produce blurrier texture and noticeable geometry artifacts. Our results contain more appearance details and shows significantly better consistency with the input.\n\nSimilar to sparse-view reconstruction, we compute PSNR, SSIM and LPIPS.\nWe also include CLIP scores \\[ [73])\\] and FID \\[ [28])\\], which are two common metrics to evaluate image similarity in generation tasks \\[ [55]), [54]), [106])\\].\nGeometry evaluations are included in the Supplementary Material.\n\nTable 2: Single image-to-3D generation. Combined with an image-to-multiview diffusion model \\[ [79])\\], GRM can be used for single image-to-3D generation. Our method outperforms relevant baselines in terms of the quality of the synthesized novel views with fast inference speed.\n\n| Method | PSNR↑ | SSIM↑ | LPIPS↓ | CLIP↑ | FID↓ | INF. Time↓ |\n| One-2-3-45 \\[ [54])\\] | 17.84 | 0.800 | 0.199 | 0.832 | 89.4 | 45 sec |\n| Shap-E \\[ [36])\\] | 15.45 | 0.772 | 0.297 | 0.854 | 56.5 | 9 sec |\n| DreamGaussian \\[ [93])\\] | 19.19 | 0.811 | 0.171 | 0.862 | 57.6 | 2 min |\n| Wonder3D \\[ [58])\\] | 17.29 | 0.815 | 0.240 | 0.871 | 55.7 | 3 min |\n| One-2-3-45++ \\[ [53])\\] | 17.79 | 0.819 | 0.219 | 0.886 | 42.1 | 1 min |\n| TriplaneGaussian \\[ [114])\\] | 16.81 | 0.797 | 0.257 | 0.840 | 52.6 | 0.2 sec |\n| LGM  \\[ [92])\\] | 16.90 | 0.819 | 0.235 | 0.855 | 42.1 | 5 sec |\n| GRM (Ours) | 20.10 | 0.826 | 0.136 | 0.932 | 27.4 | 5 sec |\n\n#### Results.\n\nThe quantitative results are presented in [Tab.2]In Baselines and Metrics. ‣ 4.3 Single Image-to-3D Generation ‣ 4 Experiments ‣ GRM: Large Gaussian Reconstruction Model for Efficient 3D Reconstruction and Generation\"). Notably, GRM outperforms all baselines across all metrics.\nOur model only takes 5 seconds in total to generate 3D Gaussians from the input image, which includes the runtime of the generation head. While this is slower than TriplaneGaussian, we achieve significantly higher reconstruction quality.\nOur advantage is further demonstrated in the qualitative results shown in [Fig.4]In Baselines and Metrics. ‣ 4.3 Single Image-to-3D Generation ‣ 4 Experiments ‣ GRM: Large Gaussian Reconstruction Model for Efficient 3D Reconstruction and Generation\"). On the top, we compare with other 3D Gaussian-based methods. The pure reconstruction method TriplaneGaussian struggles to fill in the missing content realistically (see rows 1–2). DreamGaussian, using SDS optimization, shows various geometry artifacts (row 1) and overall noticeable inconsistencies with the input image. LGM, also using an image-to-MV generation head, produces blurrier and inconsistent texture and geometry.\n\nThe bottom of [Fig.4]In Baselines and Metrics. ‣ 4.3 Single Image-to-3D Generation ‣ 4 Experiments ‣ GRM: Large Gaussian Reconstruction Model for Efficient 3D Reconstruction and Generation\") shows non-Gaussians based approaches. These methods all display various geometry and appearance artifacts, inconsistent with the input.\nIn contrast, our scalable GRM learns robust data priors from extensive training data, demonstrating strong generalization ability on generated multi-view input images with accurate geometry and sharper details. This leads to fast 3D generation and state-of-the-art single-image 3D reconstruction.\n\n### 4.4 Text-to-3D Generation\n\nBy using a text-to-MV diffusion model, such as the first stage of Instant3D \\[ [46])\\], GRM can generate 3D assets from text prompts.\n\n#### Baselines and metrics.\n\nWe choose Shap-E \\[ [36])\\], Instant3D \\[ [46])\\], LGM \\[ [92])\\], and MVDream \\[ [81])\\] as baselines. MVDream represents the SOTA of optimization-based methods, while others are feed-forward methods.\nWe use the 200 text prompts from DreamFusion \\[ [71])\\]. The metrics we use are CLIP Precisions \\[ [32]), [93])\\], Averaged Precision \\[ [106])\\], CLIP Score \\[ [46]), [106])\\], which measure the alignment between the text and images.\nAll the comparisons are done using a resolution of 512×\\\\times512.\nAdditionally, we include a preference study on Amazon Mechanical Turk, where we recruited 90 unique users to compare the generations for 50 text prompts.\n\n#### Results.\n\nAs shown in [Tab.3]In Results. ‣ 4.4 Text-to-3D Generation ‣ 4 Experiments ‣ GRM: Large Gaussian Reconstruction Model for Efficient 3D Reconstruction and Generation\"), our method consistently ranks the highest among feed-forward methods (rows 1–3) and compares onpar with optimization-based MVDream. Visually, as shown in [Fig.5]In Results. ‣ 4.4 Text-to-3D Generation ‣ 4 Experiments ‣ GRM: Large Gaussian Reconstruction Model for Efficient 3D Reconstruction and Generation\"), our method excels at generating plausible geometry and highly detailed texture.\nMVDream, using SDS-based optimization, requires 1 hours to generate a single scene.\nIt delivers impressive visual quality, but exhibits sub-optimal text-image alignment, as indicated by the CLIP score and the ‘a cat wearing eyeglasses’ example in [Fig.4]In Baselines and Metrics. ‣ 4.3 Single Image-to-3D Generation ‣ 4 Experiments ‣ GRM: Large Gaussian Reconstruction Model for Efficient 3D Reconstruction and Generation\").\n\n![Refer to caption]Figure 5: Text-to-3D Generation. Our method creates high-quality 3D assets from text prompts with accurate text alignment. GRM only requires 8 seconds to generate comparable results to the SOTA optimization-based MVDream, which takes 1 hour.Table 3: Text-to-3D Generation. Combined with a text-to-multiview diffusion model \\[ [46])\\], GRM can be used for text-to-3D generation and it achieves a competitive CLIP score. Our method is most often preferred in our user study while maintains very fast inference speed.\n\n| Method | R-Prec↑ | AP↑ | CLIP↑ | User Pref↑ | INF. Time |\n| --- | --- | --- | --- | --- | --- |\n| Shap-E \\[ [36])\\] | 12.7 | 17.7 | 17.3 | 15.7% | 9 sec |\n| LGM \\[ [92])\\] | 35.8 | 41.4 | 17.2 | 13.3% | 5 sec |\n| Instant3D \\[ [46])\\] | 59.3 | 64.3 | 17.9 | 15.7% | 20 sec |\n| MVDream-SDS \\[ [81])\\] | 70.1 | 74.4 | 17.6 | 25.9% | 1 hour |\n| GRM (ours) | 67.5 | 72.0 | 18.5 | 29.5% | 8 sec |\n\nTable 4: Ablation.Left:\nUsing the sigmoid activation improves the visual quality across all metrics; increasing the number of sampling blocks also increases the Gaussians’ density and their modeling capability, as demonstrated by the growing trend of PSNR; finally supervising the alpha channel further boost the reconstruction quality by removing outlier Gaussians.\nRight: We ablate the proposed transformer-based upsampler and pixel-aligned Gaussians using alternative approaches, and demonstrate that each component is critical for the final reconstruction quality.\n\n| Scale Act | #Up | α𝛼\\\\alpha-reg | PSNR | SSIM | LPIPS |\n| ✗ | 0 | ✗ | 24.43 | 0.638 | 0.133 |\n| ✓ | 0 | ✗ | 27.51 | 0.900 | 0.044 |\n| ✓ | 1 | ✗ | 29.11 | 0.922 | 0.037 |\n| ✓ | 3 | ✗ | 29.38 | 0.917 | 0.036 |\n| ✓ | 3 | ✓ | 29.48 | 0.920 | 0.031 |\n\n| Method | PSNR | SSIM | LPIPS |\n| --- | --- | --- | --- |\n| Conv-Upsampler | 27.23 | 0.894 | 0.063 |\n| XYZ prediction | 28.61 | 0.910 | 0.037 |\n| Full model | 29.48 | 0.920 | 0.031 |\n\n### 4.5 Ablation Study\n\nWe analyze our model components and architectural design choices on the training resolution of 256.\nThe results are shown in [Tab.4]In Results. ‣ 4.4 Text-to-3D Generation ‣ 4 Experiments ‣ GRM: Large Gaussian Reconstruction Model for Efficient 3D Reconstruction and Generation\").\nNote that all ablations are trained with 16 GPUs for 14M images.\n\n#### Scale Activation.\n\nWe conduct an experiment to study the function of the activation function for the Gaussians’ scales.\nConventionally, gaussian splatting \\[ [43])\\] takes the scales with an exponential activation.\nHowever, the exponential activation can easily result in very large Gaussians, resulting in unstable training and blurry images.\nWith the linear interpolation between the predefined scale ranges, the model achieves better appearance regarding all metrics in the first two rows of [Tab.4]In Results. ‣ 4.4 Text-to-3D Generation ‣ 4 Experiments ‣ GRM: Large Gaussian Reconstruction Model for Efficient 3D Reconstruction and Generation\").\n\n#### Number of Upsampler Blocks.\n\nWe analyze the effects of different number of upsampler blocks.\nWe can see that the model performance increases as the number of upsampler blocks grows from 0 to 3 ( [Tab.4]In Results. ‣ 4.4 Text-to-3D Generation ‣ 4 Experiments ‣ GRM: Large Gaussian Reconstruction Model for Efficient 3D Reconstruction and Generation\"), left, rows 2–4), benefiting from the detailed spatial features modulated by our transformer-based upsampler.\n\n![Refer to caption]Figure 6: Comparison on alpha regularization.\n\n#### Alpha Regularization.\n\nWe ablate the alpha regularization used during training.\nWithout alpha regularization, floaters are observable around the objects.\nThe model can successfully remove those floaters with the help of alpha regularization as shown in [Fig.6]In Number of Upsampler Blocks. ‣ 4.5 Ablation Study ‣ 4 Experiments ‣ GRM: Large Gaussian Reconstruction Model for Efficient 3D Reconstruction and Generation\"), leading to a improvement over all metrics ( [Tab.4]In Results. ‣ 4.4 Text-to-3D Generation ‣ 4 Experiments ‣ GRM: Large Gaussian Reconstruction Model for Efficient 3D Reconstruction and Generation\"), left, rows 4–5).\n\n#### Upsampler Architecture.\n\nThere is an alternative design of the upsampler, which mimics the conventional 2D upsamplers by replacing the transformers with CNNs.\nWe find that CNN-based upsampler leads to worse results ( [Tab.4]In Results. ‣ 4.4 Text-to-3D Generation ‣ 4 Experiments ‣ GRM: Large Gaussian Reconstruction Model for Efficient 3D Reconstruction and Generation\"), right).\nWe conjecture that the transformer can capture multi-view correspondences and further enhance the spatial details.\n\n#### Depth vs. XYZ.\n\nIn [Tab.4]In Results. ‣ 4.4 Text-to-3D Generation ‣ 4 Experiments ‣ GRM: Large Gaussian Reconstruction Model for Efficient 3D Reconstruction and Generation\") (right), we conduct an ablation where we predict the 3D coordinates of each Gaussian instead of the depth value.\nWe observe a performance drop across all metrics.\nWithout the constraint of camera rays, the positions of the Gaussians in 3D space become unstructured, making it prone to getting stuck at local minima, resulting in a degraded performance.",
            "citations": null
          },
          "5 Discussion": {
            "content": "In this paper, we introduce the Gaussian Reconstruction Model (GRM)—a new feed-forward 3D generative model that achieves state-of-the-art quality and speed.\nAt the core of GRM is a sparse-view 3D reconstructor, which leverages a novel transformer-based architecture to reconstruct 3D objects represented by pixel-aligned Gaussians.\nWe plan to release the code and trained models to make this advancement in 3D content creation available to the community.\n\n#### Limitations and Future Work.\n\nThe output quality of our sparse-view reconstructor suffers when the input views are inconsistent. The reconstructor is deterministic in nature and future work could embed it in a probabilistic framework, akin to DMV3D \\[ [106])\\]. Our current framework is limited to object-centric scenes due to the lack of large-scale 3D scene datasets. Future work could explore the generation of larger and more complicated scenes.\n\n#### Ethics.\n\nGenerative models pose a societal threat—we do not condone using our work to generate deep fakes intending to spread misinformation.\n\n#### Conclusion.\n\nOur work represents a significant advancement towards efficient and high-quality 3D reconstruction and generation.\n\n#### Acknowledgement.\n\nWe would like to thank Shangzhan Zhang for his help with the demo video, and Minghua Liu for assisting with the evaluation of One-2-3-45++. This project was supported by Google, Samsung, and a Swiss Postdoc Mobility fellowship.\n\nGRM: Large Gaussian Reconstruction Model for\n\nEfficient 3D Reconstruction and Generation Supplementary Material\n\nYinghao XuE1​q​u​a​l​C​o​n​t​r​i​b​u​t​i​o​nsuperscript𝐸1𝑞𝑢𝑎𝑙𝐶𝑜𝑛𝑡𝑟𝑖𝑏𝑢𝑡𝑖𝑜𝑛{}^{1}{EqualContribution} Zifan Shi1,2⋆ Yifan Wang1 Hansheng Chen1\n\nCeyuan Yang3 Sida Peng4 Yujun Shen5 Gordon Wetzstein1\n\nThis supplementary material is organized as follows.\nWe first introduce implementation details of our GRM ( [Appendix0.A]Appendix 0.A Implementation Details ‣ GRM: Large Gaussian Reconstruction Model for Efficient 3D Reconstruction and Generation\")) .\nThen, we evaluate the geometry quality of our GRM against the baselines ( [Appendix0.B]Appendix 0.B Geometry Evaluation ‣ GRM: Large Gaussian Reconstruction Model for Efficient 3D Reconstruction and Generation\")).\nWe also present the details of mesh extraction from 3D Gaussians in [Appendix0.C]Appendix 0.C Mesh Extraction from 3D Gaussians ‣ GRM: Large Gaussian Reconstruction Model for Efficient 3D Reconstruction and Generation\").\nFinally, we show additional results on 3D reconstruction and generation to evaluate the flexibility and effectiveness of our approach ( [Appendix0.D]Appendix 0.D Additional Visual Results ‣ GRM: Large Gaussian Reconstruction Model for Efficient 3D Reconstruction and Generation\")).",
            "citations": null
          }
        },
        "abstract": "We introduce GRM, a large-scale reconstructor capable of recovering a 3D\nasset from sparse-view images in around 0.1s. GRM is a feed-forward\ntransformer-based model that efficiently incorporates multi-view information to\ntranslate the input pixels into pixel-aligned Gaussians, which are unprojected\nto create a set of densely distributed 3D Gaussians representing a scene.\nTogether, our transformer architecture and the use of 3D Gaussians unlock a\nscalable and efficient reconstruction framework. Extensive experimental results\ndemonstrate the superiority of our method over alternatives regarding both\nreconstruction quality and efficiency. We also showcase the potential of GRM in\ngenerative tasks, i.e., text-to-3D and image-to-3D, by integrating it with\nexisting multi-view diffusion models. Our project website is at:\nhttps://justimyhxu.github.io/projects/grm/."
      },
      "bib.bib110": {
        "id": "bib.bib110",
        "citation": "[110]",
        "authors": "",
        "year": "",
        "title": "Gaussian opacity fields: Efficient high-quality compact surface reconstruction in unbounded scenes.",
        "venue": "",
        "pages": "",
        "url": "https://arxiv.org/abs/2404.10772",
        "arxiv_id": "2404.10772",
        "doi": null,
        "sections": {},
        "abstract": "Recently, 3D Gaussian Splatting (3DGS) has demonstrated impressive novel view\nsynthesis results, while allowing the rendering of high-resolution images in\nreal-time. However, leveraging 3D Gaussians for surface reconstruction poses\nsignificant challenges due to the explicit and disconnected nature of 3D\nGaussians. In this work, we present Gaussian Opacity Fields (GOF), a novel\napproach for efficient, high-quality, and adaptive surface reconstruction in\nunbounded scenes. Our GOF is derived from ray-tracing-based volume rendering of\n3D Gaussians, enabling direct geometry extraction from 3D Gaussians by\nidentifying its levelset, without resorting to Poisson reconstruction or TSDF\nfusion as in previous work. We approximate the surface normal of Gaussians as\nthe normal of the ray-Gaussian intersection plane, enabling the application of\nregularization that significantly enhances geometry. Furthermore, we develop an\nefficient geometry extraction method utilizing Marching Tetrahedra, where the\ntetrahedral grids are induced from 3D Gaussians and thus adapt to the scene's\ncomplexity. Our evaluations reveal that GOF surpasses existing 3DGS-based\nmethods in surface reconstruction and novel view synthesis. Further, it\ncompares favorably to or even outperforms, neural implicit methods in both\nquality and speed."
      },
      "bib.bib111": {
        "id": "bib.bib111",
        "citation": "[111]",
        "authors": "",
        "year": "",
        "title": "Physdiff: Physics-guided human motion diffusion model.",
        "venue": "",
        "pages": "",
        "url": "https://arxiv.org/abs/2212.02500",
        "arxiv_id": "2212.02500",
        "doi": null,
        "sections": {
          "1 Introduction": {
            "content": "Deep learning-based human motion generation is an important task with numerous applications in animation, gaming, and virtual reality. In common settings such as text-to-motion synthesis, we need to learn a conditional generative model that can capture the multi-modal distribution of human motions. The distribution can be highly complex due to the high variety of human motions and the intricate interaction between human body parts.\nDenoising diffusion models \\[ [75]), [25]), [76])\\] are a class of generative models that are especially suited for this task due to their strong ability to model complex distributions, which has been demonstrated extensively in the image generation domain \\[ [68]), [63]), [67]), [13])\\].\nThese models have exhibited strong mode coverage often indicated by high test likelihood \\[ [77]), [33]), [81])\\].\nThey also have better training stability compared to generative adversarial networks (GANs \\[ [19])\\]) and better sample quality compared to variational autoencoders (VAEs \\[ [35])\\]) and normalizing flows \\[ [74]), [81]), [80]), [4])\\]. Motivated by this, recent works have proposed motion diffusion models \\[ [79]), [94])\\] which significantly outperform standard deep generative models in motion generation performance.\n\nHowever, existing motion diffusion models overlook one essential aspect of human motion – the underlying laws of physics. Even though diffusion models have a superior ability to model the distribution of human motion, they still have no explicit mechanisms to enforce physical constraints or model the complex dynamics induced by forces and contact. As a result, the motions they generate often contain pronounced artifacts such as floating, foot sliding, and ground penetration. This severely hinders many real-world applications such as animation and virtual reality, where humans are highly sensitive to the slightest clue of physical inaccuracy \\[ [64]), [27])\\]. In light of this, a critical problem we need to address is making human motion diffusion models physics-aware.\n\n![Refer to caption]Figure 1: (Left) Performing one physics-based projection step (post-processing) at the end yields unnatural motion since the motion is too physically-implausible to correct. (Right) Our approach solves this issue by iteratively applying physics and diffusion.\n\nTo tackle this problem, we propose a novel physics-guided motion diffusion model (PhysDiff) that instills the laws of physics into the denoising diffusion process. Specifically, PhysDiff leverages a physics-based motion projection module (details provided later) that projects an input motion to a physically-plausible space. During the diffusion process, we use the motion projection module to project the denoised motion of a diffusion step into a physically-plausible motion. This new motion is further used in the next diffusion step to guide the denoising diffusion process. Note that it may be tempting to only add the physics-based projection at the end of the diffusion process, i.e., using physics as a post-processing step. However, this can produce unnatural motions since the final denoised kinematic motion from diffusion may be too physically-implausible to be corrected by physics (see Fig. [1]Figure 1 ‣ 1 Introduction ‣ PhysDiff: Physics-Guided Human Motion Diffusion Model\") for an example) and the motion may be pushed away from the data distribution. Instead, we need to embed the projection in the diffusion process and apply physics and diffusion iteratively to keep the motion close to the data distribution while moving toward the physically-plausible space (see Sec. [4.4]Comparing against Post-Processing ‣ 4 Experiments ‣ PhysDiff: Physics-Guided Human Motion Diffusion Model\")).\n\nThe physics-based motion projection module serves the vital role of enforcing physical constraints in PhysDiff, which is achieved by motion imitation in a physics simulator. Specifically, using large-scale motion capture data, we train a motion imitation policy that can control a character agent in the simulator to mimic a vast range of input motions. The resulting simulated motion enforces physical constraints and removes artifacts such as floating, foot sliding, and ground penetration. Once trained, the motion imitation policy can be used to mimic the denoised motion of a diffusion step to output a physically-plausible motion.\n\nWe evaluate our model, PhysDiff, on two tasks: text-to-motion generation and action-to-motion generation. Since our approach is agnostic to the specific instantiation of the denoising network used for diffusion, we test two state-of-the-art (SOTA) motion diffusion models (MDM \\[ [79])\\] and MotionDiffuse \\[ [94])\\]) as our model’s denoiser. For text-to-motion generation, our model outperforms SOTA motion diffusion models significantly on the large-scale HumanML3D \\[ [22])\\] benchmark, reducing physical errors by more than 86% while also improving the motion quality by more than 20% as measured by the Frechet inception distance (FID). For action-to-motion generation, our model again improves the physics error metric by more than 78% on HumanAct12 \\[ [23])\\] and 94% on UESTC \\[ [29])\\] while also achieving competitive FID scores.\n\nWe further perform extensive experiments to investigate various schedules of the physics-based projection, _i.e_., at which diffusion timesteps to perform the projection. Interestingly, we observe a trade-off between physical plausibility and motion quality when varying the number of physics-based projection steps. Specifically, while more projection steps always lead to better physical plausibility, the motion quality increases before a certain number of steps and decreases after that, _i.e_., the resulting motion satisfies the physical constraints but still may look unnatural. This observation guides us to use a balanced number of physics-based projection steps where both high physical plausibility and motion quality is achieved. We also find that adding the physics-based projection to late diffusion steps performs better than early steps. We hypothesize that motions from early diffusion steps may tend toward the mean motion of the training data and the physics-based projection could push the motion further away from the data distribution, thus hampering the diffusion process. Finally, we also show that our approach outperforms physics-based post-processing (single or multiple steps) in motion quality and physical plausibility significantly.\n\nOur contributions are summarized as follows:\n\n- •\n\n\nWe present a novel physics-guided motion diffusion model that generates physically-plausible motions by instilling the laws of physics into the diffusion process. Its plug-and-play nature makes it flexible to use with different kinematic diffusion models.\n\n- •\n\n\nWe propose to leverage human motion imitation in a physics simulator as a motion projection module to enforce physical constraints.\n\n- •\n\n\nOur model achieves SOTA performance in motion quality and drastically improves physical plausibility on large-scale motion datasets. Our extensive analysis also provides insights such as schedules and tradeoffs, and we demonstrate significant improvements over physics-based post-processing.",
            "citations": null
          },
          "2 Related Work": {
            "content": "Denoising Diffusion Models. Score-based denoising diffusion models \\[ [75]), [25]), [77]), [76])\\] have achieved great successes in various applications such as image generation \\[ [68]), [63]), [67]), [74]), [81])\\], text-to-speech synthesis \\[ [36])\\], 3D shape generation \\[ [97]), [46]), [93])\\], machine learning security \\[ [55])\\], as well as human motion generation \\[ [79]), [94]), [66])\\]. These models are trained via denoising autoencoder objectives that can be interpreted as score matching \\[ [82])\\], and generate samples via an iterative denoising procedure that may use stochastic updates \\[ [6]), [5]), [15]), [96])\\] which solve stochastic differential equations (SDEs) or deterministic updates \\[ [76]), [44]), [42]), [95]), [30]), [14])\\] which solve ordinary differential equations (ODEs).\n\nTo perform conditional generation, the most common technique is classifier(-free) guidance \\[ [13]), [26])\\]. However, it requires training the model specifically over paired data and conditions. Alternatively, one could use pretrained diffusion models that are trained only for unconditional generation. For example, SDEdit \\[ [53])\\] modifies the initialization of the diffusion model to synthesize or edit an existing image via colored strokes. In image domains, various methods solve linear inverse problems by repeatedly injecting known information to the diffusion process \\[ [45]), [12]), [77]), [11]), [32]), [31])\\]. A similar idea is applied to human motion diffusion models in the context of motion infilling \\[ [79])\\].\nIn our case, generating physically-plausible motions with diffusion models has a different set of challenges. First, the constraint is specified through a physics simulator, which is non-differentiable. Second, the physics-based projection itself is relatively expensive to compute, unlike image-based constraints which use much less compute than the diffusion model in general. As a result, we cannot simply apply the physics-based projection to every step of the sampling process.\n\nHuman Motion Generation.\nEarly work on motion generation adopts deterministic human motion modeling which only generates a single motion \\[ [17]), [39]), [18]), [52]), [57]), [20]), [2]), [83]), [51]), [88])\\]. Since human motions are stochastic in nature, more work has started to use deep generative models which avoid the mode averaging problem common in deterministic methods. These methods often use GANs or VAEs to generate motions from various conditions such as past motions \\[ [7]), [85]), [3]), [90]), [89])\\], key frames \\[ [24])\\], music \\[ [38]), [98]), [37])\\], text \\[ [1]), [9]), [22]), [62])\\], and action labels \\[ [23]), [61]), [10])\\]. Recently, denoising diffusion models \\[ [75]), [25]), [76])\\] have emerged as a new class of generative models that combine the advantages of standard generative models. Therefore, several motion diffusion models \\[ [79]), [94]), [66])\\] have been proposed which demonstrate SOTA motion generation performance. However, existing motion diffusion models often produce physically-implausible motions since they disregard physical constraints in the diffusion process. Our method addresses this problem by guiding the diffusion process with a physics-based motion projection module.\n\nPhysics-Based Human Motion Modeling.\nPhysics-based human motion imitation is first applied to learning locomotion skills such as walking, running, and acrobatics with deep reinforcement learning (RL) \\[ [40]), [41]), [54]), [58]), [59])\\]. RL-based motion imitation has also been used to learn user-controllable policies for character animation \\[ [8]), [56]), [84])\\]. For 3D human pose estimation, recent work has adopted physics-based trajectory optimization \\[ [92]), [65]), [73]), [72])\\] and motion imitation \\[ [87]), [88]), [28]), [91]), [86]), [47]), [48])\\] to model human dynamics. Unlike previous work, we explore the synergy between physics simulation and diffusion models, and show that applying physics and diffusion iteratively can generate more realistic and physically-plausible motions.",
            "citations": null
          },
          "3 Method": {
            "content": "![Refer to caption]Figure 2: Overview of PhysDiff. Each physics-guided diffusion step denoises a motion from timestep t𝑡t to s𝑠s, where physics-based motion projection is used to enforce physical constraints. The projection is achieved using a motion imitation policy to control a character in a physics simulator. A scheduler controls when the physics-based projection is applied. The denoiser can be any motion-denoising network.\n\nGiven some conditional information 𝒄𝒄\\\\boldsymbol{c} such as text or an action label, we aim to generate a physically-plausible human motion 𝒙1:H={𝒙h}h=1Hsuperscript𝒙:1𝐻superscriptsubscriptsuperscript𝒙ℎℎ1𝐻\\\\boldsymbol{x}^{1:H}=\\\\{\\\\boldsymbol{x}^{h}\\\\}\\_{h=1}^{H} of length H𝐻H. Each pose 𝒙h∈ℝJ×Dsuperscript𝒙ℎsuperscriptℝ𝐽𝐷\\\\boldsymbol{x}^{h}\\\\in\\\\mathbb{R}^{J\\\\times D} in the generated motion is represented by the D𝐷D-dimensional features of J𝐽J joints, which can be either the joint positions or angles. We propose a physics-guided denoising diffusion model (PhysDiff) for human motion generation. Starting from a noisy motion 𝒙T1:Hsuperscriptsubscript𝒙𝑇:1𝐻\\\\boldsymbol{x}\\_{T}^{1:H}, PhysDiff models the denoising distribution q​(𝒙s1:H\\|𝒙t1:H,𝒫π,𝒄)𝑞conditionalsuperscriptsubscript𝒙𝑠:1𝐻superscriptsubscript𝒙𝑡:1𝐻subscript𝒫𝜋𝒄q(\\\\boldsymbol{x}\\_{s}^{1:H}\\|\\\\boldsymbol{x}\\_{t}^{1:H},\\\\mathcal{P}\\_{\\\\pi},\\\\boldsymbol{c}) that denoises the motion from diffusion timestep t𝑡t to s𝑠s (s<t𝑠𝑡s<t). Iteratively applying the model denoises the motion into a clean motion 𝒙01:Hsuperscriptsubscript𝒙0:1𝐻\\\\boldsymbol{x}\\_{0}^{1:H}, which becomes the final output 𝒙1:Hsuperscript𝒙:1𝐻\\\\boldsymbol{x}^{1:H}. A critical component in the model is a physics-based motion projection module 𝒫πsubscript𝒫𝜋\\\\mathcal{P}\\_{\\\\pi} that enforces physical constraints. It leverages a motion imitation policy π𝜋\\\\pi to mimic the denoised motion of a diffusion step in a physics simulator and uses the simulated motion to further guide the diffusion process. An overview of our PhysDiff model is provided in Fig. [2]Figure 2 ‣ 3 Method ‣ PhysDiff: Physics-Guided Human Motion Diffusion Model\"). In the following, we first introduce the physics-guided motion diffusion process in Sec. [3.1]Physics-Guided Motion Diffusion ‣ 3 Method ‣ PhysDiff: Physics-Guided Human Motion Diffusion Model\"). We then describe the details of the physics-based motion projection 𝒫πsubscript𝒫𝜋\\\\mathcal{P}\\_{\\\\pi} in Sec. [3.2]Physics-Based Motion Projection ‣ 3 Method ‣ PhysDiff: Physics-Guided Human Motion Diffusion Model\").\n\n### 3.1 Physics-Guided Motion Diffusion\n\nMotion Diffusion.\nTo simplify notations, here we sometimes omit the explicit dependence over the condition 𝒄𝒄\\\\boldsymbol{c}. Note that we can always train diffusion models with some condition 𝒄𝒄\\\\boldsymbol{c}; even for the unconditional case, we can condition the model on a universal null token ∅\\\\varnothing\\[ [26])\\].\n\nLet p0​(𝒙)subscript𝑝0𝒙p\\_{0}(\\\\boldsymbol{x}) denote the data distribution, and define a series of time-dependent distributions pt​(𝒙t)subscript𝑝𝑡subscript𝒙𝑡p\\_{t}(\\\\boldsymbol{x}\\_{t}) by injecting i.i.d. Gaussian noise to samples from p0subscript𝑝0p\\_{0}, _i.e_., pt​(𝒙t\\|𝒙)=𝒩​(𝒙,σt2​𝐈)subscript𝑝𝑡conditionalsubscript𝒙𝑡𝒙𝒩𝒙superscriptsubscript𝜎𝑡2𝐈p\\_{t}(\\\\boldsymbol{x}\\_{t}\\|\\\\boldsymbol{x})=\\\\mathcal{N}(\\\\boldsymbol{x},\\\\sigma\\_{t}^{2}\\\\mathbf{I}), where σtsubscript𝜎𝑡\\\\sigma\\_{t} defines a series of noise levels that is increasing over time such that σ0=0subscript𝜎00\\\\sigma\\_{0}=0 and σTsubscript𝜎𝑇\\\\sigma\\_{T} for the largest possible T𝑇T is much bigger than the data’s standard deviation. Generally, diffusion models draw samples by solving the following stochastic differential equation (SDE) from t=T𝑡𝑇t=T to t=0𝑡0t=0\\[ [21]), [30]), [96])\\]:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | d​𝒙=−(βt+σ˙t)​σt​∇𝒙log⁡pt​(𝒙)​d​t+2​βt​σt​d​ωt,d𝒙subscript𝛽𝑡subscript˙𝜎𝑡subscript𝜎𝑡subscript∇𝒙subscript𝑝𝑡𝒙d𝑡2subscript𝛽𝑡subscript𝜎𝑡dsubscript𝜔𝑡\\\\displaystyle\\\\mathrm{d}\\\\boldsymbol{x}=-(\\\\beta\\_{t}+\\\\dot{\\\\sigma}\\_{t})\\\\sigma\\_{t}\\\\nabla\\_{\\\\boldsymbol{x}}\\\\log p\\_{t}(\\\\boldsymbol{x})\\\\mathrm{d}t+\\\\sqrt{2\\\\beta\\_{t}}\\\\sigma\\_{t}\\\\mathrm{d}\\\\omega\\_{t}, |  | (1) |\n\nwhere ∇𝒙log⁡pt​(𝒙)subscript∇𝒙subscript𝑝𝑡𝒙\\\\nabla\\_{\\\\boldsymbol{x}}\\\\log p\\_{t}(\\\\boldsymbol{x}) is the score function, ωtsubscript𝜔𝑡\\\\omega\\_{t} is the standard Wiener process, and βtsubscript𝛽𝑡\\\\beta\\_{t} controls the amount of stochastic noise injected in the process; when it is zero, the SDE becomes and ordinary differential equation (ODE). A notable property of the score function ∇𝒙tlog⁡pt​(𝒙t)subscript∇subscript𝒙𝑡subscript𝑝𝑡subscript𝒙𝑡\\\\nabla\\_{\\\\boldsymbol{x}\\_{t}}\\\\log p\\_{t}(\\\\boldsymbol{x}\\_{t}) is that it recovers the minimum mean squared error (MMSE) estimator of 𝒙𝒙\\\\boldsymbol{x} given 𝒙tsubscript𝒙𝑡\\\\boldsymbol{x}\\_{t}\\[ [78]), [16]), [69])\\]:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | 𝒙~:=𝔼​\\[𝒙\\|𝒙t\\]=𝒙t+σt2​∇𝒙tlog⁡pt​(𝒙t),assign~𝒙𝔼delimited-\\[\\]conditional𝒙subscript𝒙𝑡subscript𝒙𝑡superscriptsubscript𝜎𝑡2subscript∇subscript𝒙𝑡subscript𝑝𝑡subscript𝒙𝑡\\\\displaystyle\\\\tilde{\\\\boldsymbol{x}}:=\\\\mathbb{E}\\[\\\\boldsymbol{x}\\|\\\\boldsymbol{x}\\_{t}\\]=\\\\boldsymbol{x}\\_{t}+\\\\sigma\\_{t}^{2}\\\\nabla\\_{\\\\boldsymbol{x}\\_{t}}\\\\log p\\_{t}(\\\\boldsymbol{x}\\_{t}), |  | (2) |\n\nwhere we can essentially treat 𝒙~~𝒙\\\\tilde{\\\\boldsymbol{x}} as a “denoised” version of 𝒙tsubscript𝒙𝑡\\\\boldsymbol{x}\\_{t}. Since 𝒙tsubscript𝒙𝑡\\\\boldsymbol{x}\\_{t} and σtsubscript𝜎𝑡\\\\sigma\\_{t} are known during sampling, we can obtain ∇𝒙tlog⁡pt​(𝒙t)subscript∇subscript𝒙𝑡subscript𝑝𝑡subscript𝒙𝑡\\\\nabla\\_{\\\\boldsymbol{x}\\_{t}}\\\\log p\\_{t}(\\\\boldsymbol{x}\\_{t}) from 𝒙~~𝒙\\\\tilde{\\\\boldsymbol{x}}, and vice versa.\n\nDiffusion models approximate the score function with the following denoising autoencoder objective \\[ [82])\\]:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | 𝔼𝒙∼p0​(𝒙),t∼p​(t),ϵ∼p​(ϵ)​\\[λ​(t)​‖𝒙−D​(𝒙+σt​ϵ,t,𝒄)‖22\\]subscript𝔼formulae-sequencesimilar-to𝒙subscript𝑝0𝒙formulae-sequencesimilar-to𝑡𝑝𝑡similar-toitalic-ϵ𝑝italic-ϵdelimited-\\[\\]𝜆𝑡superscriptsubscriptnorm𝒙𝐷𝒙subscript𝜎𝑡italic-ϵ𝑡𝒄22\\\\displaystyle\\\\mathbb{E}\\_{\\\\boldsymbol{x}\\\\sim p\\_{0}(\\\\boldsymbol{x}),t\\\\sim p(t),\\\\epsilon\\\\sim p(\\\\epsilon)}\\[\\\\lambda(t)\\\\\\|\\\\boldsymbol{x}-D(\\\\boldsymbol{x}+\\\\sigma\\_{t}\\\\epsilon,t,\\\\boldsymbol{c})\\\\\\|\\_{2}^{2}\\] |  | (3) |\n\nwhere D𝐷D is the denoiser that depends on the noisy data, the time t𝑡t and the condition 𝒄𝒄\\\\boldsymbol{c}, ϵ∼𝒩​(𝟎,𝑰)similar-toitalic-ϵ𝒩0𝑰\\\\epsilon\\\\sim\\\\mathcal{N}(\\\\boldsymbol{0},\\\\boldsymbol{I}), p​(t)𝑝𝑡p(t) is a distribution from which time is sampled, and λ​(t)𝜆𝑡\\\\lambda(t) is the loss weighting factor. The optimal solution to D𝐷D would be one that recovers the MMSE estimator 𝒙~~𝒙\\\\tilde{\\\\boldsymbol{x}} according to [Eq.2]In 3.1 Physics-Guided Motion Diffusion ‣ 3 Method ‣ PhysDiff: Physics-Guided Human Motion Diffusion Model\"). For a detailed characterization of the training procedure, we refer the reader to Karras _et al_.\\[ [30])\\].\n\nAfter the denoising diffusion model has been trained, one can apply it to solve the SDE / ODE in [Eq.1]In 3.1 Physics-Guided Motion Diffusion ‣ 3 Method ‣ PhysDiff: Physics-Guided Human Motion Diffusion Model\"). A particular approach, DDIM \\[ [76])\\], performs a one-step update from time t𝑡t to time s𝑠s (s<t𝑠𝑡s<t) given the sample 𝒙tsubscript𝒙𝑡\\\\boldsymbol{x}\\_{t}, which is described in [Algorithm1]In 3.1 Physics-Guided Motion Diffusion ‣ 3 Method ‣ PhysDiff: Physics-Guided Human Motion Diffusion Model\"). Intuitively, the sample 𝒙ssubscript𝒙𝑠\\\\boldsymbol{x}\\_{s} at time s𝑠s is generated from a Gaussian distribution; its mean is a linear interpolation between 𝒙tsubscript𝒙𝑡\\\\boldsymbol{x}\\_{t} and the denoised result 𝒙~~𝒙\\\\tilde{\\\\boldsymbol{x}}, and its variance depends on a hyperparameter η∈\\[0,1\\]𝜂01\\\\eta\\\\in\\[0,1\\].\nSpecifically, η=0𝜂0\\\\eta=0 corresponds to denoising diffusion probabilistic models (DDPM \\[ [25])\\]) and η=1𝜂1\\\\eta=1 corresponds to denoising diffusion implicit models (DDIM \\[ [76])\\]). We find η=0𝜂0\\\\eta=0 produces better performance for our model.\nSince the above sampling procedure is general, it can also be applied to human motion data, _i.e_., 𝒙1:Hsuperscript𝒙:1𝐻\\\\boldsymbol{x}^{1:H}. To incorporate the condition 𝒄𝒄\\\\boldsymbol{c} during sampling, one can employ classifier-based or classifier-free guidance \\[ [13]), [26])\\].\n\nAlgorithm 1 DDIM sampling algorithm\n\n1:Input: Denoiser D𝐷D, sample 𝒙tsubscript𝒙𝑡\\\\boldsymbol{x}\\_{t} at time t𝑡t, target time s𝑠s, condition 𝒄𝒄\\\\boldsymbol{c}, hyperparameter η∈\\[0,1\\]𝜂01\\\\eta\\\\in\\[0,1\\].\n\n2:Compute the denoised result 𝒙~:=D​(𝒙t,t,𝒄)assign~𝒙𝐷subscript𝒙𝑡𝑡𝒄\\\\tilde{\\\\boldsymbol{x}}:=D(\\\\boldsymbol{x}\\_{t},t,\\\\boldsymbol{c}).\n\n3:Obtain variance vssubscript𝑣𝑠v\\_{s} as a scalar that depends on η𝜂\\\\eta.\n\n4:Obtain mean μssubscript𝜇𝑠\\\\mu\\_{s} as a linear combination of 𝒙~~𝒙\\\\tilde{\\\\boldsymbol{x}} and 𝒙tsubscript𝒙𝑡\\\\boldsymbol{x}\\_{t}:\n\n|     |     |     |\n| --- | --- | --- |\n|  | μs:=𝒙~+σs2−vsσt​(𝒙t−𝒙~)assignsubscript𝜇𝑠~𝒙superscriptsubscript𝜎𝑠2subscript𝑣𝑠subscript𝜎𝑡subscript𝒙𝑡~𝒙\\\\mu\\_{s}:=\\\\tilde{\\\\boldsymbol{x}}+\\\\frac{\\\\sqrt{\\\\sigma\\_{s}^{2}-v\\_{s}}}{\\\\sigma\\_{t}}(\\\\boldsymbol{x}\\_{t}-\\\\tilde{\\\\boldsymbol{x}}) |  |\n\n5:Draw sample 𝒙s∼𝒩​(μs,vs​𝑰)similar-tosubscript𝒙𝑠𝒩subscript𝜇𝑠subscript𝑣𝑠𝑰\\\\boldsymbol{x}\\_{s}\\\\sim\\\\mathcal{N}(\\\\mu\\_{s},v\\_{s}\\\\boldsymbol{I}).\n\nApplying Physical Constraints.\nExisting diffusion models for human motions are not necessarily trained on data that complies with physical constraints, and even if they are, there is no guarantee that the produced motion samples are still physically realizable, due to the approximation errors in the denoiser networks and the stochastic nature of the sampling process. While one may attempt to directly correct the final motion sample to be physically-plausible, the physical errors in the motion might be so large that even after such a correction, the motion is still not ideal (see Fig. [1]Figure 1 ‣ 1 Introduction ‣ PhysDiff: Physics-Guided Human Motion Diffusion Model\") for a concrete example and Sec. [4.4]Comparing against Post-Processing ‣ 4 Experiments ‣ PhysDiff: Physics-Guided Human Motion Diffusion Model\") for comparison).\n\nTo address this issue, we exploit the fact that diffusion models produce intermediate estimates of the desired outcome, _i.e_., the denoised motion 𝒙~1:Hsuperscript~𝒙:1𝐻\\\\tilde{\\\\boldsymbol{x}}^{1:H} of each diffusion step. In particular, we may apply physical constraints not only to the final step of the diffusion process, but to the intermediate steps as well. Concretely, we propose a physics-based motion projection 𝒫π:ℝH×J×D→ℝH×J×D:subscript𝒫𝜋→superscriptℝ𝐻𝐽𝐷superscriptℝ𝐻𝐽𝐷\\\\mathcal{P}\\_{\\\\pi}:\\\\mathbb{R}^{H\\\\times J\\\\times D}\\\\to\\\\mathbb{R}^{H\\\\times J\\\\times D} as a module that maps the original motion 𝒙~1:Hsuperscript~𝒙:1𝐻\\\\tilde{\\\\boldsymbol{x}}^{1:H} to a physically-plausible one, denoted as 𝒙^1:Hsuperscript^𝒙:1𝐻\\\\hat{\\\\boldsymbol{x}}^{1:H}. We incorporate the proposed physics-based projection 𝒫πsubscript𝒫𝜋\\\\mathcal{P}\\_{\\\\pi} into the denoising diffusion sampling procedure, where the one-step update from time t𝑡t to time s𝑠s is described in [Algorithm2]In 3.1 Physics-Guided Motion Diffusion ‣ 3 Method ‣ PhysDiff: Physics-Guided Human Motion Diffusion Model\"). The process differs from the DDIM sampler mostly in terms of performing the additional physics-based projection; as we will show in the experiments, this is a simple yet effective approach to enforcing physical constraints. Notably, our model, PhysDiff, is agnostic to the specific instantiation of the denoiser D𝐷D, which is often implemented with various network architectures. The physics-based projection in PhysDiff is also only applied during diffusion sampling (inference), which makes PhysDiff generally compatible with different pretrained motion diffusion models. In other words, PhysDiff can be used to improve the physical plausibility of existing diffusion models without retraining.\n\nAlgorithm 2 PhysDiff sampling algorithm for motion.\n\n1:Input: Denoiser D𝐷D, sample 𝒙t1:Hsuperscriptsubscript𝒙𝑡:1𝐻\\\\boldsymbol{x}\\_{t}^{1:H} at time t𝑡t, condition 𝒄𝒄\\\\boldsymbol{c}, target time s𝑠s, physics-based projection 𝒫πsubscript𝒫𝜋\\\\mathcal{P}\\_{\\\\pi}, η∈\\[0,1\\]𝜂01\\\\eta\\\\in\\[0,1\\].\n\n2:Compute the denoised motion 𝒙~1:H:=D​(𝒙t1:H,t,𝒄)assignsuperscript~𝒙:1𝐻𝐷subscriptsuperscript𝒙:1𝐻𝑡𝑡𝒄\\\\tilde{\\\\boldsymbol{x}}^{1:H}:=D(\\\\boldsymbol{x}^{1:H}\\_{t},t,\\\\boldsymbol{c}).\n\n3:if projection is performed at time t𝑡tthen\n\n4:𝒙^1:H:=𝒫π​(𝒙~1:H)assignsuperscript^𝒙:1𝐻subscript𝒫𝜋superscript~𝒙:1𝐻\\\\hat{\\\\boldsymbol{x}}^{1:H}:=\\\\mathcal{P}\\_{\\\\pi}(\\\\tilde{\\\\boldsymbol{x}}^{1:H}) # Physics-Based Projection\n\n5:else\n\n6:𝒙^1:H:=𝒙~1:Hassignsuperscript^𝒙:1𝐻superscript~𝒙:1𝐻\\\\hat{\\\\boldsymbol{x}}^{1:H}:=\\\\tilde{\\\\boldsymbol{x}}^{1:H}\n\n7:endif\n\n8:\\# The remaining part is similar to DDIM\n\n9:Obtain variance vssubscript𝑣𝑠v\\_{s} as a scalar that depends on η𝜂\\\\eta.\n\n10:Obtain mean μssubscript𝜇𝑠\\\\mu\\_{s}:\n\n|     |     |     |\n| --- | --- | --- |\n|  | μs:=𝒙^1:H+σs2−vsσt​(𝒙t1:H−𝒙^1:H)assignsubscript𝜇𝑠superscript^𝒙:1𝐻superscriptsubscript𝜎𝑠2subscript𝑣𝑠subscript𝜎𝑡superscriptsubscript𝒙𝑡:1𝐻superscript^𝒙:1𝐻\\\\mu\\_{s}:=\\\\hat{\\\\boldsymbol{x}}^{1:H}+\\\\frac{\\\\sqrt{\\\\sigma\\_{s}^{2}-v\\_{s}}}{\\\\sigma\\_{t}}(\\\\boldsymbol{x}\\_{t}^{1:H}-\\\\hat{\\\\boldsymbol{x}}^{1:H}) |  |\n\n11:Draw sample 𝒙s1:H∼𝒩​(μs,vs​𝑰)similar-tosubscriptsuperscript𝒙:1𝐻𝑠𝒩subscript𝜇𝑠subscript𝑣𝑠𝑰\\\\boldsymbol{x}^{1:H}\\_{s}\\\\sim\\\\mathcal{N}(\\\\mu\\_{s},v\\_{s}\\\\boldsymbol{I}).\n\nScheduling Physics-based Projection.\nDue to the use of physics simulation, the projection 𝒫πsubscript𝒫𝜋\\\\mathcal{P}\\_{\\\\pi} is rather expensive, and it is infeasible to perform the projection at every diffusion timestep. Therefore, if we have a limited number of physics-based projection steps to be performed, we need to prioritize certain timesteps over others. Here, we argue that we should not perform physics projection when the diffusion noise level is high. This is because the denoiser D𝐷D by design gives us 𝒙~1:H=𝔼​\\[𝒙1:H\\|𝒙t1:H\\]superscript~𝒙:1𝐻𝔼delimited-\\[\\]conditionalsuperscript𝒙:1𝐻subscriptsuperscript𝒙:1𝐻𝑡\\\\tilde{\\\\boldsymbol{x}}^{1:H}=\\\\mathbb{E}\\[\\\\boldsymbol{x}^{1:H}\\|\\\\boldsymbol{x}^{1:H}\\_{t}\\], _i.e_., the mean motion of 𝒙1:Hsuperscript𝒙:1𝐻\\\\boldsymbol{x}^{1:H} given the current noisy motion 𝒙t1:Hsubscriptsuperscript𝒙:1𝐻𝑡\\\\boldsymbol{x}^{1:H}\\_{t}, and it is close to the mean of the training data for high noise levels when the condition 𝒙t1:Hsubscriptsuperscript𝒙:1𝐻𝑡\\\\boldsymbol{x}^{1:H}\\_{t} contains little information. Empirically, the mean motion often has little body movement due to mode averaging while still having some root translations and rotations, which is clearly physically-implausible. Correcting such a physically-incorrect motion with the physics-based projection would push the motion further away from the data distribution and hinder the diffusion process.\nIn Sec. [4.3]Schedule of Physics-Based Projection ‣ 4 Experiments ‣ PhysDiff: Physics-Guided Human Motion Diffusion Model\"), we perform a systematic study that validates this hypothesis and reveals a favorable scheduling strategy that balances sample quality and efficiency.\n\n### 3.2 Physics-Based Motion Projection\n\nAn essential component in the physics-guided diffusion process is the physics-based motion projection 𝒫πsubscript𝒫𝜋\\\\mathcal{P}\\_{\\\\pi}. It is tasked with projecting the denoised motion 𝒙~1:Hsuperscript~𝒙:1𝐻\\\\tilde{\\\\boldsymbol{x}}^{1:H} of a diffusion step, which disregards the laws of physics, into a physically-plausible motion 𝒙^1:H=𝒫π​(𝒙~1:H)superscript^𝒙:1𝐻subscript𝒫𝜋superscript~𝒙:1𝐻\\\\hat{\\\\boldsymbol{x}}^{1:H}=\\\\mathcal{P}\\_{\\\\pi}(\\\\tilde{\\\\boldsymbol{x}}^{1:H}). The projection is achieved by learning a motion imitation policy π𝜋\\\\pi that controls a simulated character to mimic the denoised motion 𝒙~1:Hsuperscript~𝒙:1𝐻\\\\tilde{\\\\boldsymbol{x}}^{1:H} in a physics simulator. The resulting motion 𝒙^1:Hsuperscript^𝒙:1𝐻\\\\hat{\\\\boldsymbol{x}}^{1:H} from the simulator is considered physically-plausible since it obeys the laws of physics.\n\nMotion Imitation Formulation.\nThe task of human motion imitation \\[ [58]), [90])\\] can be formulated as a Markov decision process (MDP). The MDP is defined by a tuple ℳ=(𝒮,𝒜,𝒯,R,γ)ℳ𝒮𝒜𝒯𝑅𝛾\\\\mathcal{M}=(\\\\mathcal{S},\\\\mathcal{A},\\\\mathcal{T},R,\\\\gamma) of states, actions, transition dynamics, a reward function, and a discount factor. A character agent acts in a physics simulator according to a motion imitation policy π​(𝒂h\\|𝒔h)𝜋conditionalsuperscript𝒂ℎsuperscript𝒔ℎ\\\\pi(\\\\boldsymbol{a}^{h}\\|\\\\boldsymbol{s}^{h}), which models the distribution of choosing an action 𝒂h∈𝒜superscript𝒂ℎ𝒜\\\\boldsymbol{a}^{h}\\\\in\\\\mathcal{A} given the current state 𝒔h∈𝒮superscript𝒔ℎ𝒮\\\\boldsymbol{s}^{h}\\\\in\\\\mathcal{S}. The state 𝒔hsuperscript𝒔ℎ\\\\boldsymbol{s}^{h} consists of the character’s physical state ( _e.g_., joint angles, velocities, positions) as well as the next pose 𝒙~h+1superscript~𝒙ℎ1\\\\tilde{\\\\boldsymbol{x}}^{h+1} from the input motion. Including 𝒙~h+1superscript~𝒙ℎ1\\\\tilde{\\\\boldsymbol{x}}^{h+1} in the state informs the policy π𝜋\\\\pi to choose an action 𝒂hsuperscript𝒂ℎ\\\\boldsymbol{a}^{h} that can mimic 𝒙~h+1superscript~𝒙ℎ1\\\\tilde{\\\\boldsymbol{x}}^{h+1} in the simulator. Starting from an initial state 𝒔1superscript𝒔1\\\\boldsymbol{s}^{1}, the agent iteratively samples an action 𝒂hsuperscript𝒂ℎ\\\\boldsymbol{a}^{h} from the policy π𝜋\\\\pi and the simulator with transition dynamics 𝒯​(𝒔h+1\\|𝒔h,𝒂h)𝒯conditionalsuperscript𝒔ℎ1superscript𝒔ℎsuperscript𝒂ℎ\\\\mathcal{T}(\\\\boldsymbol{s}^{h+1}\\|\\\\boldsymbol{s}^{h},\\\\boldsymbol{a}^{h}) generates the next state 𝒔h+1superscript𝒔ℎ1\\\\boldsymbol{s}^{h+1}, from which we can extract the simulated pose 𝒙^h+1superscript^𝒙ℎ1\\\\hat{\\\\boldsymbol{x}}^{h+1}. By running the policy for H𝐻H steps, we can obtain the physically-simulated motion 𝒙^1:Hsuperscript^𝒙:1𝐻\\\\hat{\\\\boldsymbol{x}}^{1:H}.\n\nTraining. During training, a reward rhsuperscript𝑟ℎr^{h} is also assigned to the character based on how well the simulated motion 𝒙^1:Hsuperscript^𝒙:1𝐻\\\\hat{\\\\boldsymbol{x}}^{1:H} aligns with the ground-truth motion 𝒙¯1:Hsuperscript¯𝒙:1𝐻\\\\bar{\\\\boldsymbol{x}}^{1:H}. Note that the motion imitation policy π𝜋\\\\pi is trained on large motion capture datasets where high-quality ground-truth motion is available. We use reinforcement learning (RL) to learn the policy π𝜋\\\\pi, where the objective is to maximize the expected discounted return J​(π)=𝔼π​\\[∑hγh​rh\\]𝐽𝜋subscript𝔼𝜋delimited-\\[\\]subscriptℎsuperscript𝛾ℎsuperscript𝑟ℎJ(\\\\pi)=\\\\mathbb{E}\\_{\\\\pi}\\\\left\\[\\\\sum\\_{h}\\\\gamma^{h}r^{h}\\\\right\\] which translates to mimicking the ground-truth motion as closely as possible. We adopt a standard RL algorithm (PPO \\[ [71])\\]) to solve for the optimal policy. In the following, we will elaborate on the design of rewards, states, actions, and the policy.\n\nRewards. The reward function is designed to encourage the simulated motion 𝒙^1:Hsuperscript^𝒙:1𝐻\\\\hat{\\\\boldsymbol{x}}^{1:H} to match the ground truth 𝒙¯1:Hsuperscript¯𝒙:1𝐻\\\\bar{\\\\boldsymbol{x}}^{1:H}. Here, we use ⋅¯¯⋅\\\\;\\\\bar{\\\\cdot}\\\\; to denote ground-truth quantities. The reward rhsuperscript𝑟ℎr^{h} at each timestep consists of four sub-rewards:\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n|  | rhsuperscript𝑟ℎ\\\\displaystyle r^{h} | =wp​rph+wv​rvh+wj​rjh+wq​rqh,absentsubscript𝑤psubscriptsuperscript𝑟ℎpsubscript𝑤vsubscriptsuperscript𝑟ℎvsubscript𝑤jsubscriptsuperscript𝑟ℎjsubscript𝑤qsubscriptsuperscript𝑟ℎq\\\\displaystyle=w\\_{\\\\texttt{p}}r^{h}\\_{\\\\texttt{p}}+w\\_{\\\\texttt{v}}r^{h}\\_{\\\\texttt{v}}+w\\_{\\\\texttt{j}}r^{h}\\_{\\\\texttt{j}}+w\\_{\\\\texttt{q}}r^{h}\\_{\\\\texttt{q}}\\\\,, |  | (4) |\n|  | rphsubscriptsuperscript𝑟ℎp\\\\displaystyle r^{h}\\_{\\\\texttt{p}} | =exp⁡\\[−αp​(∑j=1J‖𝒐jh⊖𝒐¯jh‖2)\\],absentsubscript𝛼psuperscriptsubscript𝑗1𝐽superscriptnormsymmetric-differencesubscriptsuperscript𝒐ℎ𝑗subscriptsuperscript¯𝒐ℎ𝑗2\\\\displaystyle=\\\\textstyle\\\\exp\\\\left\\[-\\\\alpha\\_{\\\\texttt{p}}\\\\left(\\\\sum\\_{j=1}^{J}\\\\\\|\\\\boldsymbol{o}^{h}\\_{j}\\\\ominus\\\\bar{\\\\boldsymbol{o}}^{h}\\_{j}\\\\\\|^{2}\\\\right)\\\\right\\], |  | (5) |\n|  | rvhsubscriptsuperscript𝑟ℎv\\\\displaystyle r^{h}\\_{\\\\texttt{v}} | =exp⁡\\[−αv​‖𝒗h−𝒗¯h‖2\\],absentsubscript𝛼vsuperscriptnormsuperscript𝒗ℎsuperscript¯𝒗ℎ2\\\\displaystyle=\\\\textstyle\\\\exp\\\\left\\[-\\\\alpha\\_{\\\\texttt{v}}\\\\\\|\\\\boldsymbol{v}^{h}-\\\\bar{\\\\boldsymbol{v}}^{h}\\\\\\|^{2}\\\\right\\], |  | (6) |\n|  | rjhsubscriptsuperscript𝑟ℎj\\\\displaystyle r^{h}\\_{\\\\texttt{j}} | =exp⁡\\[−αj​(∑j=1J‖𝒑jh−𝒑¯jh‖2)\\],absentsubscript𝛼jsuperscriptsubscript𝑗1𝐽superscriptnormsubscriptsuperscript𝒑ℎ𝑗subscriptsuperscript¯𝒑ℎ𝑗2\\\\displaystyle=\\\\textstyle\\\\exp\\\\left\\[-\\\\alpha\\_{\\\\texttt{j}}\\\\left(\\\\sum\\_{j=1}^{J}\\\\\\|\\\\boldsymbol{p}^{h}\\_{j}-\\\\bar{\\\\boldsymbol{p}}^{h}\\_{j}\\\\\\|^{2}\\\\right)\\\\right\\], |  | (7) |\n|  | rqhsubscriptsuperscript𝑟ℎq\\\\displaystyle r^{h}\\_{\\\\texttt{q}} | =exp⁡\\[−αq​(∑j=1J‖𝒒jh−𝒒¯jh‖2)\\].absentsubscript𝛼qsuperscriptsubscript𝑗1𝐽superscriptnormsubscriptsuperscript𝒒ℎ𝑗subscriptsuperscript¯𝒒ℎ𝑗2\\\\displaystyle=\\\\textstyle\\\\exp\\\\left\\[-\\\\alpha\\_{\\\\texttt{q}}\\\\left(\\\\sum\\_{j=1}^{J}\\\\\\|\\\\boldsymbol{q}^{h}\\_{j}-\\\\bar{\\\\boldsymbol{q}}^{h}\\_{j}\\\\\\|^{2}\\\\right)\\\\right\\]. |  | (8) |\n\nwhere wp,wv,wj,wq,αp,αv,αj,αqsubscript𝑤psubscript𝑤vsubscript𝑤jsubscript𝑤qsubscript𝛼psubscript𝛼vsubscript𝛼jsubscript𝛼qw\\_{\\\\texttt{p}},w\\_{\\\\texttt{v}},w\\_{\\\\texttt{j}},w\\_{\\\\texttt{q}},\\\\alpha\\_{\\\\texttt{p}},\\\\alpha\\_{\\\\texttt{v}},\\\\alpha\\_{\\\\texttt{j}},\\\\alpha\\_{\\\\texttt{q}} are weighting factors. The pose reward rphsubscriptsuperscript𝑟ℎpr^{h}\\_{\\\\texttt{p}} measures the difference between the local joint rotations 𝒐jhsubscriptsuperscript𝒐ℎ𝑗\\\\boldsymbol{o}^{h}\\_{j} and the ground truth 𝒐¯jhsubscriptsuperscript¯𝒐ℎ𝑗\\\\bar{\\\\boldsymbol{o}}^{h}\\_{j}, where ⊖symmetric-difference\\\\ominus denotes the relative rotation between two rotations, and ∥⋅∥\\\\\\|\\\\cdot\\\\\\| computes the rotation angle.\nThe velocity reward rvhsubscriptsuperscript𝑟ℎvr^{h}\\_{\\\\texttt{v}} measures the mismatch between joint velocities 𝒗hsuperscript𝒗ℎ\\\\boldsymbol{v}^{h} and the ground truth 𝒗¯hsuperscript¯𝒗ℎ\\\\bar{\\\\boldsymbol{v}}^{h}, which are computed via finite difference.\nThe joint position reward rjhsubscriptsuperscript𝑟ℎjr^{h}\\_{\\\\texttt{j}} encourages the 3D world joint positions 𝒑jhsubscriptsuperscript𝒑ℎ𝑗\\\\boldsymbol{p}^{h}\\_{j} to match the ground truth 𝒑¯jhsubscriptsuperscript¯𝒑ℎ𝑗\\\\bar{\\\\boldsymbol{p}}^{h}\\_{j}.\nFinally, the joint rotation reward rqhsubscriptsuperscript𝑟ℎqr^{h}\\_{\\\\texttt{q}} measures the difference between the global joint rotations 𝒒jhsubscriptsuperscript𝒒ℎ𝑗\\\\boldsymbol{q}^{h}\\_{j} and the ground truth 𝒒¯jhsubscriptsuperscript¯𝒒ℎ𝑗\\\\bar{\\\\boldsymbol{q}}^{h}\\_{j}.\n\nStates. The agent state 𝒔hsuperscript𝒔ℎ\\\\boldsymbol{s}^{h} consists of the character’s current physical state, the input motion’s next pose 𝒙~h+1superscript~𝒙ℎ1\\\\tilde{\\\\boldsymbol{x}}^{h+1}, and a character attribute vector 𝝍𝝍\\\\boldsymbol{\\\\psi}. The character’s physical state includes its joint angles, joint velocities, and rigid bodies’ positions, rotations, and linear and angular velocities. For the input pose 𝒙~h+1superscript~𝒙ℎ1\\\\tilde{\\\\boldsymbol{x}}^{h+1}, the state 𝒔hsuperscript𝒔ℎ\\\\boldsymbol{s}^{h} contains the difference of 𝒙~h+1superscript~𝒙ℎ1\\\\tilde{\\\\boldsymbol{x}}^{h+1} w.r.t. the agent in joint angles as well as rigid body positions and rotations. Using the difference informs the policy about the pose residual it needs to compensate for. All the features are computed in the character’s heading coordinate to ensure rotation and translation invariance. Since our character is based on the SMPL body model \\[ [43])\\], the attribute 𝝍𝝍\\\\boldsymbol{\\\\psi} includes the gender and SMPL shape parameters to allow the policy to control different characters.\n\nActions. We use the target joint angles of proportional derivative (PD) controllers as the action representation, which enables robust motion imitation as observed in prior work \\[ [60]), [90])\\]. We also add residual forces \\[ [90])\\] in the action space to stabilize the character and compensate for missing contact forces required to imitate motions such as sitting.\n\nPolicy.\nWe use a parametrized Gaussian policy π​(𝒂h\\|𝒔h)=𝒩​(𝝁θ​(𝒔h),𝚺)𝜋conditionalsuperscript𝒂ℎsuperscript𝒔ℎ𝒩subscript𝝁𝜃superscript𝒔ℎ𝚺\\\\pi(\\\\boldsymbol{a}^{h}\\|\\\\boldsymbol{s}^{h})=\\\\mathcal{N}(\\\\boldsymbol{\\\\mu}\\_{\\\\theta}(\\\\boldsymbol{s}^{h}),\\\\boldsymbol{\\\\Sigma}) where the mean action 𝝁θsubscript𝝁𝜃\\\\boldsymbol{\\\\mu}\\_{\\\\theta} is output by a simple multi-layer perceptron (MLP) network with parameters θ𝜃\\\\theta, and 𝚺𝚺\\\\boldsymbol{\\\\Sigma} is a fixed diagonal covariance matrix.",
            "citations": null
          },
          "4 Experiments": {
            "content": "We perform experiments on two standard human motion generation tasks: text-to-motion and action-to-motion generation. In particular, our experiments are designed to answer the following questions: (1) Can PhysDiff achieve SOTA motion quality and physical plausibility? (2) Can PhysDiff be applied to different kinematic motion diffusion models to improve their motion quality and physical plausibility? (3) How do different schedules of the physics-based projection impact motion generation performance? (4) Can PhysDiff outperform physics-based post-processing?\n\nEvaluation Metrics.\nFor text-to-motion generation, we first use two standard metrics suggested by Guo _et al_.\\[ [22])\\]: _FID_ measures the distance between the generated and ground-truth motion distributions; _R-Precision_ assesses the relevancy of the generated motions to the input text. For action-to-motion generation, we replace R-Precision with an _Accuracy_ metric, which measures the accuracy of a trained action classifier over the generated motion. Additionally, we also use four physics-based metrics to evaluate the physical plausibility of generated motions: _Penetrate_ measures ground penetration; _Float_ measures floating; _Skate_ measures foot sliding; _Phys-Err_ is an overall physical error metric that sums the three metrics (all in _mm_) together. Please refer to Appendix [A]Appendix A Details of Evaluation Metrics ‣ PhysDiff: Physics-Guided Human Motion Diffusion Model\") for details.\n\nImplementation Details.\nOur model uses 50 diffusion steps with classifier-free guidance \\[ [26])\\]. We test PhysDiff with two SOTA motion diffusion models, MDM \\[ [79])\\] and MotionDiffuse \\[ [94])\\], as the denoiser D𝐷D. By default, MDM is the denoiser of PhysDiff for qualitative results. We adopt IsaacGym \\[ [50])\\] as the physics simulator for motion imitation. More details are provided in Appendices [B]Appendix B Details of Motion Diffusion ‣ PhysDiff: Physics-Guided Human Motion Diffusion Model\") and [C]Appendix C Details of Physics-Based Motion Imitation ‣ PhysDiff: Physics-Guided Human Motion Diffusion Model\").\n\n### 4.1 Text-to-Motion Generation\n\n| Method | FID ↓↓\\\\downarrow | R-Precision ↑↑\\\\uparrow | Penetrate ↓↓\\\\downarrow | Float ↓↓\\\\downarrow | Skate ↓↓\\\\downarrow | Phys-Err ↓↓\\\\downarrow |\n| J2LP \\[ [1])\\] | 11.020 | 0.486 | - | - | - | - |\n| Text2Gesture \\[ [9])\\] | 7.664 | 0.345 | - | - | - | - |\n| T2M \\[ [22])\\] | 1.067 | 0.740 | 11.897 | 7.779 | 2.908 | 22.584 |\n| MDM \\[ [79])\\] | 0.544 | 0.611 | 11.291 | 18.876 | 1.406 | 31.572 |\n| MotionDiffuse (MD) \\[ [94])\\] | 0.630 | 0.782 | 20.278 | 6.450 | 3.925 | 30.652 |\n| PhysDiff w/ MD (Ours) | 0.551 | 0.780 | 0.898 | 1.368 | 0.423 | 2.690 |\n| PhysDiff w/ MDM (Ours) | 0.433 | 0.631 | 0.998 | 2.601 | 0.512 | 4.111 |\n\nTable 1: Text-to-motion results on HumanML3D \\[ [22])\\].\n\n| Method | FID ↓↓\\\\downarrow | Accuracy ↑↑\\\\uparrow | Penetrate ↓↓\\\\downarrow | Float ↓↓\\\\downarrow | Skate ↓↓\\\\downarrow | Phys-Err ↓↓\\\\downarrow |\n| --- | --- | --- | --- | --- | --- | --- |\n| Action2Motion \\[ [23])\\] | 0.338 | 0.917 | - | - | - | - |\n| ACTOR \\[ [61])\\] | 0.120 | 0.955 | 8.939 | 14.479 | 2.277 | 25.695 |\n| INR \\[ [10])\\] | 0.088 | 0.973 | 7.055 | 13.212 | 0.928 | 22.096 |\n| MDM \\[ [79])\\] | 0.100 | 0.990 | 5.600 | 6.703 | 1.075 | 13.377 |\n| PhysDiff w/ MDM (Ours) | 0.096 | 0.983 | 0.689 | 2.002 | 0.159 | 2.850 |\n\nTable 2: Action-to-motion results on HumanAct12 \\[ [23])\\].\n\n| Method | FID ↓↓\\\\downarrow | Accuracy ↑↑\\\\uparrow | Penetrate ↓↓\\\\downarrow | Float ↓↓\\\\downarrow | Skate ↓↓\\\\downarrow | Phys-Err ↓↓\\\\downarrow |\n| --- | --- | --- | --- | --- | --- | --- |\n| ACTOR \\[ [61])\\] | 23.43 | 0.911 | 8.441 | 9.737 | 1.073 | 19.251 |\n| INR \\[ [10])\\] | 15.00 | 0.941 | 5.999 | 4.633 | 0.741 | 11.373 |\n| MDM \\[ [79])\\] | 12.81 | 0.950 | 13.077 | 13.912 | 1.383 | 28.371 |\n| PhysDiff w/ MDM (Ours) | 13.27 | 0.956 | 0.874 | 0.201 | 0.389 | 1.463 |\n\nTable 3: Action-to-motion results on UESTC \\[ [29])\\].\n\nData.\nWe use the HumanML3D \\[ [22])\\] dataset, which is a textually annotated subset of two large-scale motion capture datasets, AMASS \\[ [49])\\] and HumanAct12 \\[ [23])\\]. It contains 14,616 motions annotated with 44,970 textual descriptions.\n\n![Refer to caption]Figure 3: Visual comparison of PhysDiff against the SOTA, MDM \\[ [79])\\], on HumanML3D, HumanAct12, and UESTC. PhysDiff reduces physical artifacts such as floating and penetration significantly. Please refer to the [project page] for more qualitative comparison.\n\nResults. In Table [1]Table 1 ‣ 4.1 Text-to-Motion Generation ‣ 4 Experiments ‣ PhysDiff: Physics-Guided Human Motion Diffusion Model\"), we compare our method to the SOTA methods: JL2P \\[ [1])\\], Text2Gesture \\[ [9])\\], T2M \\[ [22])\\], MotionDiffuse \\[ [94])\\], and MDM \\[ [79])\\]. Due to the plug-and-play nature of our method, we design two variants of PhysDiff using MotionDiffuse (MD) and MDM. PhysDiff with MDM achieves SOTA FID and also reduces Phys-Err by more than 86% compared to MDM. Similarly, PhysDiff with MD achieves SOTA in physics-based metrics while maintaining high R-Precision and improving FID significantly. We also provide qualitative comparison in Fig. [3]Figure 3 ‣ 4.1 Text-to-Motion Generation ‣ 4 Experiments ‣ PhysDiff: Physics-Guided Human Motion Diffusion Model\"), where we can clearly see that PhysDiff substantially reduces physical artifacts such as penetration and floating. Please also refer to the [project page] for more qualitative results.\n\n### 4.2 Action-to-Motion Generation\n\nData.\nWe evaluate on two datasets: HumanAct12 \\[ [23])\\], which contains around 1200 motion clips for 12 action categories; UESTC \\[ [29])\\], which consists of 40 action classes, 40 subjects, and 25k samples. For both datasets, we use the sequences provided by Petrovich _et al_.\\[ [61])\\].\n\nResults.\nTables [2]Table 2 ‣ 4.1 Text-to-Motion Generation ‣ 4 Experiments ‣ PhysDiff: Physics-Guided Human Motion Diffusion Model\") and [3]Table 3 ‣ 4.1 Text-to-Motion Generation ‣ 4 Experiments ‣ PhysDiff: Physics-Guided Human Motion Diffusion Model\") summarize the results on HumanAct12 and UESTC, respectively, where we compare PhysDiff against the SOTA methods: MDM \\[ [79])\\], INR \\[ [10])\\], Action2Motion \\[ [23])\\], and ACTOR \\[ [61])\\]. The results show that our method achieves competitive FID on both datasets while drastically improving Phys-Err (by 78% on HumanAct12 and 94% on UESTC). Please refer to Fig. [3]Figure 3 ‣ 4.1 Text-to-Motion Generation ‣ 4 Experiments ‣ PhysDiff: Physics-Guided Human Motion Diffusion Model\") and the [project page] for qualitative comparison, where we show that PhysDiff improves the physical plausibility of generated motions significantly.\n\n### 4.3 Schedule of Physics-Based Projection\n\nWe perform extensive experiments to analyze the schedule of the physics-based projection, _i.e_., at which timesteps we perform the projection in the diffusion process.\n\nNumber of Projection Steps.\nSince the physics-based projection is relatively expensive to compute, we first investigate whether we can reduce the number of projection steps without sacrificing performance. To this end, we vary the number of projection steps performed during diffusion from 50 to 0, where the projection steps are gradually removed from earlier timesteps and applied consecutively. We plot the curves of FID, R-Precision, and Phys-Err in Fig. [4]Figure 4 ‣ 4.3 Schedule of Physics-Based Projection ‣ 4 Experiments ‣ PhysDiff: Physics-Guided Human Motion Diffusion Model\"). As can be seen, Phys-Err keeps decreasing with more physics-based projection steps, which indicates more projection steps always help improve the physical plausibility of PhysDiff. Interestingly, both the FID and R-Precision first improve (FID decreases and R-Precision increases) and then deteriorate when increasing the number of projection steps. This suggests that there is a trade-off between physical plausibility and motion quality when more projection steps are performed at the early diffusion steps. We hypothesize that motions generated at the early diffusion steps are denoised to the mean motion of the dataset (with little body movement) and are often not physically-plausible. As a result, performing the physics-based projection at these early steps can push the generated motion away from the data distribution, thus hindering the diffusion process.\n\n![Refer to caption]Figure 4: Effect of varying the number of physics-based projection steps for text-to-motion generation on HumanML3D \\[ [22])\\].\n\n| Schedule | FID ↓↓\\\\downarrow | R-Precision ↑↑\\\\uparrow | Penetrate ↓↓\\\\downarrow | Float ↓↓\\\\downarrow | Skate ↓↓\\\\downarrow | Phys-Err ↓↓\\\\downarrow |\n| Uniform 4 | 0.473 | 0.630 | 0.979 | 3.479 | 0.463 | 4.921 |\n| Start 3, End 1 | 0.510 | 0.623 | 0.918 | 3.173 | 0.459 | 4.550 |\n| Start 2, End 2 | 0.503 | 0.623 | 0.918 | 2.723 | 0.492 | 4.133 |\n| End 4, Space 3 | 0.469 | 0.630 | 0.990 | 3.226 | 0.473 | 4.689 |\n| End 4, Space 2 | 0.469 | 0.630 | 0.990 | 3.004 | 0.476 | 4.470 |\n| End 4, Space 1 | 0.433 | 0.631 | 0.998 | 2.601 | 0.512 | 4.111 |\n\nTable 4: Projection schedule comparison on HumanML3D \\[ [22])\\].\n\nPlacement of Projections Steps.\nFig. [4]Figure 4 ‣ 4.3 Schedule of Physics-Based Projection ‣ 4 Experiments ‣ PhysDiff: Physics-Guided Human Motion Diffusion Model\") indicates that four physics-based projection steps yield a good trade-off between physical plausibility and motion quality. Next, we investigate the best placement of these projection steps in the diffusion process. We compare three groups of schedules: (1) _Uniform N𝑁N_, which spreads the N𝑁N projection steps evenly across the diffusion timesteps _i.e_., for 50 diffusion steps and N=4𝑁4N=4, the projection steps are performed at t∈{0,15,30,45}𝑡0153045t\\\\in\\\\{0,15,30,45\\\\}; (2) _Start M𝑀M, End N𝑁N_, which places M𝑀M consecutive projection steps at the beginning of the diffusion process and N𝑁N projection steps at the end; (3) _End N𝑁N, Space S𝑆S_, which places N𝑁N projections steps with time spacing S𝑆S at the end of the diffusion process ( _e.g_., for N=4,S=3formulae-sequence𝑁4𝑆3N=4,S=3, the projections steps are performed at t∈{0,3,6,9}𝑡0369t\\\\in\\\\{0,3,6,9\\\\}). We summarize the results in Table [4]Table 4 ‣ 4.3 Schedule of Physics-Based Projection ‣ 4 Experiments ‣ PhysDiff: Physics-Guided Human Motion Diffusion Model\"). We can see that the schedule _Start M𝑀M, End N𝑁N_ has inferior FID and R-Precision since more physics-based projection steps are performed at early diffusion steps, which is consistent with our findings in Fig. [4]Figure 4 ‣ 4.3 Schedule of Physics-Based Projection ‣ 4 Experiments ‣ PhysDiff: Physics-Guided Human Motion Diffusion Model\"). The schedule _Uniform N𝑁N_ works better in terms of FID and R-Precision but has worse Phys-Err. This is likely because too many non-physics-based diffusion steps between the physics-based projections undo the effect of the projection and reintroduce physical errors. This is also consistent with _End 444, Space 333_ being worse than _End 444, Space 111_ since the former has more diffusion steps between the physics-based projections. Hence, the results suggest that it is better to schedule the physics-based projection steps consecutively toward the end. This guides us to use _End 444, Space 111_ for baseline comparison.\n\nInference Time.\nDue to the use of physics simulation, PhysDiff is 2.5x slower than MDM (51.6s vs. 19.6s) to generate a single motion, where both methods use 1000 diffusion steps. The gap closes when increasing the batch size to 256 where PhysDiff is only 1.7x slower (280.3s vs. 471.3s), as the physics simulator benefits more from parallelization.\n\n![Refer to caption]Figure 5: Comparison with post-processing, _i.e_., applying physics-based projections after the diffusion process.\n\n### 4.4 Comparing against Post-Processing\n\nTo demonstrate the synergy between physics and diffusion, we compare PhysDiff against a post-processing baseline that applies one or more physics-based projection steps to the final kinematic motion from diffusion. As shown in Fig. [5]Figure 5 ‣ 4.3 Schedule of Physics-Based Projection ‣ 4 Experiments ‣ PhysDiff: Physics-Guided Human Motion Diffusion Model\"), multiple post-processing steps cannot enhance motion quality or physical plausibility; instead, they deteriorate them. This is because the final kinematic motion may be too physically implausible for the physics to imitate, _e.g_., the human may lose balance due to wrong gaits. Repeatedly imitating these implausible motions could amplify the problem and lead to unstable simulation. PhysDiff overcomes this issue by iteratively applying diffusion and physics to recover from bad simulation states and move closer to the data distribution.",
            "citations": null
          },
          "5 Conclusion and Future Work": {
            "content": "In this paper, we proposed a novel physics-guided motion diffusion model (PhysDiff) which instills the laws of physics into the diffusion process to generate physically-plausible human motions. To achieve this, we proposed a physics-based motion projection module that uses motion imitation in physics simulation to enforce physical constraints.\nOur approach is agnostic to the denoising network and can be used to improve SOTA motion diffusion models without retraining. Experiments on large-scale motion data demonstrate that PhysDiff achieves SOTA motion quality and substantially improves physical plausibility.\n\nDue to physics simulation, the inference speed of PhysDiff can be two-to-three times slower than SOTA models. Future work could speed up the model with a faster physics simulator or improve the physics-based projection to reduce the number of required projection steps.",
            "citations": null
          }
        },
        "abstract": "Denoising diffusion models hold great promise for generating diverse and\nrealistic human motions. However, existing motion diffusion models largely\ndisregard the laws of physics in the diffusion process and often generate\nphysically-implausible motions with pronounced artifacts such as floating, foot\nsliding, and ground penetration. This seriously impacts the quality of\ngenerated motions and limits their real-world application. To address this\nissue, we present a novel physics-guided motion diffusion model (PhysDiff),\nwhich incorporates physical constraints into the diffusion process.\nSpecifically, we propose a physics-based motion projection module that uses\nmotion imitation in a physics simulator to project the denoised motion of a\ndiffusion step to a physically-plausible motion. The projected motion is\nfurther used in the next diffusion step to guide the denoising diffusion\nprocess. Intuitively, the use of physics in our model iteratively pulls the\nmotion toward a physically-plausible space, which cannot be achieved by simple\npost-processing. Experiments on large-scale human motion datasets show that our\napproach achieves state-of-the-art motion quality and improves physical\nplausibility drastically (>78% for all datasets)."
      },
      "bib.bib112": {
        "id": "bib.bib112",
        "citation": "[112]",
        "authors": "",
        "year": "",
        "title": "Lion: Latent point diffusion models for 3d shape generation.",
        "venue": "",
        "pages": "",
        "url": "https://arxiv.org/abs/2210.06978",
        "arxiv_id": "2210.06978",
        "doi": null,
        "sections": {
          "1 Introduction": {
            "content": "Generative modeling of 3D shapes has extensive applications in 3D content creation\nand has become an active area of research \\[ [1]), [2]), [3]), [4]), [5]), [6]), [7]), [8]), [9]), [10]), [11]), [12]), [13]), [14]), [15]), [16]), [17]), [18]), [19]), [20]), [21]), [22]), [23]), [24]), [25]), [26]), [27]), [28]), [29]), [30]), [31]), [32]), [33]), [34]), [35]), [36]), [37]), [38]), [39]), [40]), [41]), [42]), [43]), [44]), [45]), [46]), [47]), [48]), [49]), [50]), [51]), [52])\\]. However, to be useful as a tool for digital artists, generative models of 3D shapes have to fulfill several criteria: (i) Generated shapes need to be realistic and of high-quality without artifacts. (ii) The model should enable flexible and interactive use and refinement: For example, a user may want to refine a generated shape and synthesize versions with varying details. Or an artist may provide a coarse or noisy input shape, thereby guiding the model to produce multiple realistic high-quality outputs. Similarly, a user may want to interpolate different shapes. (iii) The model should output smooth meshes, which are the standard representation in most graphics software.\n\nExisting 3D generative models build on various frameworks, including generative adversarial networks (GANs) \\[ [1]), [2]), [3]), [4]), [5]), [6]), [7]), [8]), [9]), [10]), [11]), [12]), [13]), [14]), [15]), [16]), [17]), [18]), [19]), [20]), [21]), [22]), [23])\\], variational autoencoders (VAEs) \\[ [24]), [25]), [26]), [27]), [28]), [29]), [30])\\], normalizing flows \\[ [31]), [32]), [33]), [34])\\], autoregressive models \\[ [35]), [36]), [37]), [38])\\], and more \\[ [39]), [40]), [41]), [42]), [43]), [44])\\]. Most recently, denoising diffusion models (DDMs) have emerged as powerful generative models, achieving outstanding results not only on image synthesis \\[ [53]), [54]), [55]), [56]), [57]), [58]), [59]), [60]), [61]), [62]), [63]), [64])\\] but also for point cloud-based 3D shape generation \\[ [45]), [46]), [47])\\]. In DDMs, the data is gradually perturbed by a diffusion process, while a deep neural network is trained to denoise. This network can then be used to synthesize novel data in an iterative fashion when initialized from random noise \\[ [53]), [65]), [66]), [67])\\].\nHowever, existing DDMs for 3D shape synthesis struggle with simultaneously satisfying all criteria discussed above for practically useful 3D generative models.\n\nHere, we aim to develop a DDM-based generative model of 3D shapes overcoming these limitations.\nWe introduce the\nLatent Point Diffusion Model (LION) for 3D shape generation (see Fig. [1]Figure 1 ‣ 1 Introduction ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\")). Similar to previous 3D DDMs, LION operates on point clouds, but it is constructed as a VAE with DDMs in latent space.\nLION comprises a hierarchical latent space with a vector-valued global shape latent and another point-structured latent space. The latent representations are predicted with point cloud processing encoders, and two latent DDMs are trained in these latent spaces. Synthesis in LION proceeds by drawing novel latent samples from the hierarchical latent DDMs and\ndecoding back to the original point cloud space. Importantly, we also demonstrate how to augment LION with modern surface reconstruction methods \\[ [68])\\] to synthesize smooth shapes as desired by artists. LION has multiple advantages:\n\n![Refer to caption]\n\nFigure 1: LION is set up as a hierarchical point cloud VAE with denoising diffusion models over the shape latent and latent point distributions. Point-Voxel CNNs (PVCNN) with adaptive Group Normalization (Ada. GN) are used as neural networks. The latent points can be interpreted as a smoothed version of the input point cloud. Shape As Points (SAP) is optionally used for mesh reconstruction.\n\nExpressivity: By mapping point clouds into regularized latent spaces, the DDMs in latent space are effectively tasked with learning a smoothed distribution. This is easier than training on potentially complex point clouds directly \\[ [58])\\], thereby improving expressivity. However, point clouds are, in principle, an ideal representation for DDMs. Because of that, we use latent points, this is, we keep a point cloud structure for our main latent representation. Augmenting the model with an additional global shape latent variable in a hierarchical manner further boosts expressivity.\nWe validate LION on several popular ShapeNet benchmarks and achieve state-of-the-art synthesis performance.\n\nVarying Output Types: Extending LION with Shape As Points (SAP) \\[ [68])\\] geometry reconstruction allows us to also output smooth meshes. Fine-tuning SAP on data generated by LION’s autoencoder reduces synthesis noise and enables us to generate high-quality geometry. LION combines (latent) point cloud-based modeling, ideal for DDMs, with surface reconstruction, desired by artists.\n\nFlexibility: Since LION is set up as a VAE, it can be easily adapted for different tasks without re-training the latent DDMs: We can efficiently fine-tune LION’s encoders on voxelized or noisy inputs, which a user can provide for guidance. This enables\nmultimodal voxel-guided synthesis and shape denoising.\nWe also leverage LION’s latent spaces for shape interpolation and autoencoding. Optionally training the DDMs conditioned on CLIP embeddings enables image- and text-driven 3D generation.\n\nIn summary, we make the following contributions: (i) We introduce LION, a novel generative model for 3D shape synthesis, which operates on point clouds and is built on a hierarchical VAE framework with two latent DDMs. (ii) We validate LION’s high synthesis quality by reaching state-of-the-art performance on widely used ShapeNet benchmarks. (iii) We achieve high-quality and diverse 3D shape synthesis with LION even when trained jointly over many classes without conditioning. (iv) We propose to combine LION with SAP-based surface reconstruction. (v) We demonstrate the flexibility of our framework by adapting it to relevant tasks such as multimodal voxel-guided synthesis.",
            "citations": null
          },
          "2 Background": {
            "content": "Traditionally, DDMs were introduced in a discrete-step fashion: Given samples 𝐱0∼q​(𝐱0)similar-tosubscript𝐱0𝑞subscript𝐱0{\\\\mathbf{x}}\\_{0}\\\\sim q({\\\\mathbf{x}}\\_{0}) from a data distribution, DDMs use a Markovian fixed forward diffusion process defined as \\[ [65]), [53])\\]\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | q​(𝐱1:T\\|𝐱0):=∏t=1Tq​(𝐱t\\|𝐱t−1),q​(𝐱t\\|𝐱t−1):=𝒩​(𝐱t;1−βt​𝐱t−1,βt​𝑰),formulae-sequenceassign𝑞conditionalsubscript𝐱:1𝑇subscript𝐱0superscriptsubscriptproduct𝑡1𝑇𝑞conditionalsubscript𝐱𝑡subscript𝐱𝑡1assign𝑞conditionalsubscript𝐱𝑡subscript𝐱𝑡1𝒩subscript𝐱𝑡1subscript𝛽𝑡subscript𝐱𝑡1subscript𝛽𝑡𝑰q({\\\\mathbf{x}}\\_{1:T}\\|{\\\\mathbf{x}}\\_{0}):=\\\\prod\\_{t=1}^{T}q({\\\\mathbf{x}}\\_{t}\\|{\\\\mathbf{x}}\\_{t-1}),\\\\qquad q({\\\\mathbf{x}}\\_{t}\\|{\\\\mathbf{x}}\\_{t-1}):=\\\\mathcal{N}({\\\\mathbf{x}}\\_{t};\\\\sqrt{1-\\\\beta\\_{t}}{\\\\mathbf{x}}\\_{t-1},\\\\beta\\_{t}{\\\\bm{I}}), |  | (1) |\n\nwhere T𝑇T denotes the number of steps and q​(𝐱t\\|𝐱t−1)𝑞conditionalsubscript𝐱𝑡subscript𝐱𝑡1q({\\\\mathbf{x}}\\_{t}\\|{\\\\mathbf{x}}\\_{t-1}) is a Gaussian transition kernel, which gradually adds noise to the input with a variance schedule β1,…,βTsubscript𝛽1…subscript𝛽𝑇\\\\beta\\_{1},...,\\\\beta\\_{T}. The βtsubscript𝛽𝑡\\\\beta\\_{t} are chosen such that the chain approximately converges to a standard Gaussian distribution after T𝑇T steps, q​(𝐱T)≈𝒩​(𝐱T;𝟎,𝑰)𝑞subscript𝐱𝑇𝒩subscript𝐱𝑇0𝑰q({\\\\mathbf{x}}\\_{T}){\\\\approx}{\\\\mathcal{N}}({\\\\mathbf{x}}\\_{T};\\\\bm{0},{\\\\bm{I}}). DDMs learn a parametrized reverse process (model parameters 𝜽𝜽{\\\\bm{\\\\theta}}) that inverts the forward diffusion:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | p𝜽​(𝐱0:T):=p​(𝐱T)​∏t=1Tp𝜽​(𝐱t−1\\|𝐱t),p𝜽​(𝐱t−1\\|𝐱t):=𝒩​(𝐱t−1;μ𝜽​(𝐱t,t),ρt2​𝑰).formulae-sequenceassignsubscript𝑝𝜽subscript𝐱:0𝑇𝑝subscript𝐱𝑇superscriptsubscriptproduct𝑡1𝑇subscript𝑝𝜽conditionalsubscript𝐱𝑡1subscript𝐱𝑡assignsubscript𝑝𝜽conditionalsubscript𝐱𝑡1subscript𝐱𝑡𝒩subscript𝐱𝑡1subscript𝜇𝜽subscript𝐱𝑡𝑡superscriptsubscript𝜌𝑡2𝑰p\\_{\\\\bm{\\\\theta}}({\\\\mathbf{x}}\\_{0:T}):=p({\\\\mathbf{x}}\\_{T})\\\\prod\\_{t=1}^{T}p\\_{\\\\bm{\\\\theta}}({\\\\mathbf{x}}\\_{t-1}\\|{\\\\mathbf{x}}\\_{t}),\\\\qquad p\\_{\\\\bm{\\\\theta}}({\\\\mathbf{x}}\\_{t-1}\\|{\\\\mathbf{x}}\\_{t}):=\\\\mathcal{N}({\\\\mathbf{x}}\\_{t-1};\\\\mathbf{\\\\mu}\\_{\\\\bm{\\\\theta}}({\\\\mathbf{x}}\\_{t},t),\\\\rho\\_{t}^{2}{\\\\bm{I}}). |  | (2) |\n\nThis generative reverse process is also Markovian with Gaussian transition kernels, which use fixed variances ρt2superscriptsubscript𝜌𝑡2\\\\rho\\_{t}^{2}. DDMs can be interpreted as latent variable models, where 𝐱1,…,𝐱Tsubscript𝐱1…subscript𝐱𝑇{\\\\mathbf{x}}\\_{1},...,{\\\\mathbf{x}}\\_{T} are latents, and the forward process q​(𝐱1:T\\|𝐱0)𝑞conditionalsubscript𝐱:1𝑇subscript𝐱0q({\\\\mathbf{x}}\\_{1:T}\\|{\\\\mathbf{x}}\\_{0}) acts as a fixed approximate posterior, to which the generative p𝜽​(𝐱0:T)subscript𝑝𝜽subscript𝐱:0𝑇p\\_{\\\\bm{\\\\theta}}({\\\\mathbf{x}}\\_{0:T}) is fit. DDMs are trained by minimizing the variational upper bound on the negative log-likelihood of the data 𝐱0subscript𝐱0{\\\\mathbf{x}}\\_{0} under p𝜽​(𝐱0:T)subscript𝑝𝜽subscript𝐱:0𝑇p\\_{\\\\bm{\\\\theta}}({\\\\mathbf{x}}\\_{0:T}). Up to irrelevant constant terms, this objective can be expressed as \\[ [53])\\]\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | min𝜽⁡𝔼t∼U​{1,T},𝐱0∼p​(𝐱0),ϵ∼𝒩​(𝟎,𝑰)​\\[w​(t)​‖ϵ−ϵ𝜽​(αt​𝐱0+σt​ϵ,t)‖22\\],w​(t)=βt22​ρt2​(1−βt)​(1−αt2),subscript𝜽subscript𝔼formulae-sequencesimilar-to𝑡𝑈1𝑇formulae-sequencesimilar-tosubscript𝐱0𝑝subscript𝐱0similar-tobold-italic-ϵ𝒩0𝑰delimited-\\[\\]𝑤𝑡superscriptsubscriptnormbold-italic-ϵsubscriptbold-italic-ϵ𝜽subscript𝛼𝑡subscript𝐱0subscript𝜎𝑡bold-italic-ϵ𝑡22𝑤𝑡superscriptsubscript𝛽𝑡22superscriptsubscript𝜌𝑡21subscript𝛽𝑡1superscriptsubscript𝛼𝑡2\\\\min\\_{\\\\bm{\\\\theta}}\\\\mathbb{E}\\_{t\\\\sim U\\\\{1,T\\\\},{\\\\mathbf{x}}\\_{0}\\\\sim p({\\\\mathbf{x}}\\_{0}),{\\\\bm{\\\\epsilon}}\\\\sim{\\\\mathcal{N}}(\\\\bm{0},{\\\\bm{I}})}\\\\left\\[w(t)\\|\\|{\\\\bm{\\\\epsilon}}-{\\\\bm{\\\\epsilon}}\\_{\\\\bm{\\\\theta}}(\\\\alpha\\_{t}{\\\\mathbf{x}}\\_{0}+\\\\sigma\\_{t}{\\\\bm{\\\\epsilon}},t)\\|\\|\\_{2}^{2}\\\\right\\],\\\\;\\\\;w(t)=\\\\frac{\\\\beta\\_{t}^{2}}{2\\\\rho\\_{t}^{2}(1-\\\\beta\\_{t})(1-\\\\alpha\\_{t}^{2})}, |  | (3) |\n\nwhere αt=∏s=1t(1−βs)subscript𝛼𝑡superscriptsubscriptproduct𝑠1𝑡1subscript𝛽𝑠\\\\alpha\\_{t}=\\\\sqrt{\\\\prod\\_{s=1}^{t}(1-\\\\beta\\_{s})} and σt=1−αt2subscript𝜎𝑡1superscriptsubscript𝛼𝑡2\\\\sigma\\_{t}=\\\\sqrt{1-\\\\alpha\\_{t}^{2}} are the parameters of the tractable diffused distribution after t𝑡t steps q​(𝐱t\\|𝐱0)=𝒩​(𝐱t;αt​𝐱0,σt2​𝑰)𝑞conditionalsubscript𝐱𝑡subscript𝐱0𝒩subscript𝐱𝑡subscript𝛼𝑡subscript𝐱0superscriptsubscript𝜎𝑡2𝑰q({\\\\mathbf{x}}\\_{t}\\|{\\\\mathbf{x}}\\_{0})={\\\\mathcal{N}}({\\\\mathbf{x}}\\_{t};\\\\alpha\\_{t}{\\\\mathbf{x}}\\_{0},\\\\sigma\\_{t}^{2}{\\\\bm{I}}). Furthermore, Eq. ( [3]In 2 Background ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\")) employs the widely used parametrization μ𝜽​(𝐱t,t):=11−βt​(𝐱t−βt1−αt2​ϵ𝜽​(𝐱t,t))assignsubscript𝜇𝜽subscript𝐱𝑡𝑡11subscript𝛽𝑡subscript𝐱𝑡subscript𝛽𝑡1superscriptsubscript𝛼𝑡2subscriptbold-italic-ϵ𝜽subscript𝐱𝑡𝑡\\\\mathbf{\\\\mu}\\_{\\\\bm{\\\\theta}}({\\\\mathbf{x}}\\_{t},t):=\\\\tfrac{1}{\\\\sqrt{1-\\\\beta\\_{t}}}\\\\left({\\\\mathbf{x}}\\_{t}-\\\\tfrac{\\\\beta\\_{t}}{\\\\sqrt{1-\\\\alpha\\_{t}^{2}}}{\\\\bm{\\\\epsilon}}\\_{\\\\bm{\\\\theta}}({\\\\mathbf{x}}\\_{t},t)\\\\right). It is common practice to set w​(t)=1𝑤𝑡1w(t)=1, instead of the one in Eq. ( [3]In 2 Background ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\")), which often promotes perceptual quality of the generated output. In the objective of Eq. ( [3]In 2 Background ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\")), the model ϵ𝜽subscriptbold-italic-ϵ𝜽{\\\\bm{\\\\epsilon}}\\_{\\\\bm{\\\\theta}} is, for all possible steps t𝑡t along the diffusion process, effectively trained to predict the noise vector ϵbold-italic-ϵ{\\\\bm{\\\\epsilon}} that is necessary to denoise an observed diffused sample 𝐱tsubscript𝐱𝑡{\\\\mathbf{x}}\\_{t}. After training, the DDM can be sampled with ancestral sampling in an iterative fashion:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | 𝐱t−1=11−βt​(𝐱t−βt1−αt2​ϵ𝜽​(𝐱t,t))+ρt​𝜼,subscript𝐱𝑡111subscript𝛽𝑡subscript𝐱𝑡subscript𝛽𝑡1superscriptsubscript𝛼𝑡2subscriptbold-italic-ϵ𝜽subscript𝐱𝑡𝑡subscript𝜌𝑡𝜼{\\\\mathbf{x}}\\_{t-1}=\\\\tfrac{1}{\\\\sqrt{1-\\\\beta\\_{t}}}({\\\\mathbf{x}}\\_{t}-\\\\tfrac{\\\\beta\\_{t}}{\\\\sqrt{1-\\\\alpha\\_{t}^{2}}}{\\\\bm{\\\\epsilon}}\\_{\\\\bm{\\\\theta}}({\\\\mathbf{x}}\\_{t},t))+\\\\rho\\_{t}\\\\bm{\\\\eta}, |  | (4) |\n\nwhere 𝜼∼𝒩​(𝜼;𝟎,𝑰)similar-to𝜼𝒩𝜼0𝑰\\\\bm{\\\\eta}\\\\sim{\\\\mathcal{N}}(\\\\bm{\\\\eta};\\\\bm{0},{\\\\bm{I}}). This sampling chain is initialized from a random sample 𝐱T∼𝒩​(𝐱T;𝟎,𝑰)similar-tosubscript𝐱𝑇𝒩subscript𝐱𝑇0𝑰{\\\\mathbf{x}}\\_{T}\\\\sim{\\\\mathcal{N}}({\\\\mathbf{x}}\\_{T};\\\\bm{0},{\\\\bm{I}}). Furthermore, the noise injection in Eq. [4]In 2 Background ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\") is usually omitted in the last sampling step.\n\nDDMs can also be expressed with a continuous-time framework \\[ [67]), [69])\\]. In this formulation, the diffusion and reverse generative processes are described by differential equations.\nThis approach\nallows for deterministic sampling and encoding schemes based on ordinary differential equations (ODEs). We make use of this framework in Sec. [3.1]Applications and Extensions ‣ 3 Hierarchical Latent Point Diffusion Models ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\") and we review this approach in more detail in App. [B]Appendix B Continuous-Time Diffusion Models and Probability Flow ODE Sampling ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\").\n\n|     |     |     |     |     |     |     |     |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n|  |  |  |  |  |  |  |  |\n|  |  |  |  |  |  |  |  |\n|  |  |  |  |  |  |  |  |\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\nFigure 2: Generated meshes with LION. Right: Synthesizing different details by diffuse-denoise (see Sec. [3.1]Applications and Extensions ‣ 3 Hierarchical Latent Point Diffusion Models ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\")) in latent space, while preserving overall shapes.",
            "citations": null
          },
          "3 Hierarchical Latent Point Diffusion Models": {
            "content": "We first formally introduce LION, then discuss various applications and extensions in Sec. [3.1]Applications and Extensions ‣ 3 Hierarchical Latent Point Diffusion Models ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\"), and finally recapitulate its unique advantages in Sec. [3.2]LION’s Advantages ‣ 3 Hierarchical Latent Point Diffusion Models ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\"). See Fig. [1]Figure 1 ‣ 1 Introduction ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\") for a visualization of LION.\n\nWe are modeling point clouds 𝐱∈ℝ3×N𝐱superscriptℝ3𝑁{\\\\mathbf{x}}\\\\in\\\\mathbb{R}^{3\\\\times N}, consisting of N𝑁N points with x​y​z𝑥𝑦𝑧xyz-coordinates in ℝ3superscriptℝ3\\\\mathbb{R}^{3}. LION is set up as a hierarchical VAE with DDMs in latent space. It uses a vector-valued global shape latent 𝐳0∈ℝD𝐳subscript𝐳0superscriptℝsubscript𝐷𝐳{\\\\mathbf{z}}\\_{0}\\\\in\\\\mathbb{R}^{D\\_{\\\\mathbf{z}}} and a point cloud-structured latent 𝐡0∈ℝ(3+D𝐡)×Nsubscript𝐡0superscriptℝ3subscript𝐷𝐡𝑁{\\\\mathbf{h}}\\_{0}\\\\in\\\\mathbb{R}^{(3+D\\_{\\\\mathbf{h}})\\\\times N}. Specifically, 𝐡0subscript𝐡0{\\\\mathbf{h}}\\_{0} is a latent point cloud consisting of N𝑁N points with x​y​z𝑥𝑦𝑧xyz-coordinates in ℝ3superscriptℝ3\\\\mathbb{R}^{3}. In addition, each latent point can carry additional D𝐡subscript𝐷𝐡D\\_{\\\\mathbf{h}} latent features. Training of LION is then performed in two stages—first, we train it as a regular VAE with standard Gaussian priors; then, we train the latent DDMs on the latent encodings.\n\nFirst Stage Training. Initially, LION is trained by maximizing a modified variational lower bound on the data log-likelihood (ELBO) with respect to the encoder and decoder parameters ϕbold-italic-ϕ{\\\\bm{\\\\phi}} and 𝝃𝝃{\\\\bm{\\\\xi}}\\[ [70]), [71])\\]:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | ℒELBO​(ϕ,𝝃)=𝔼p​(𝐱),qϕ​(𝐳0\\|𝐱),qϕ​(𝐡0\\|𝐱,𝐳0)\\[logp𝝃(𝐱\\|𝐡0,𝐳0)−λ𝐳DKL(qϕ(𝐳0\\|𝐱)\\|p(𝐳0))−λ𝐡DKL(qϕ(𝐡0\\|𝐱,𝐳0)\\|p(𝐡0))\\].subscriptℒELBObold-italic-ϕ𝝃subscript𝔼𝑝𝐱subscript𝑞bold-italic-ϕconditionalsubscript𝐳0𝐱subscript𝑞bold-italic-ϕconditionalsubscript𝐡0𝐱subscript𝐳0delimited-\\[\\]subscript𝑝𝝃\\|𝐱subscript𝐡0subscript𝐳0subscript𝜆𝐳subscript𝐷KL\\|subscript𝑞bold-italic-ϕ\\|subscript𝐳0𝐱𝑝subscript𝐳0subscript𝜆𝐡subscript𝐷KL\\|subscript𝑞bold-italic-ϕ\\|subscript𝐡0𝐱subscript𝐳0𝑝subscript𝐡0\\\\begin{split}\\\\mathcal{L}\\_{\\\\textrm{ELBO}}({\\\\bm{\\\\phi}},{\\\\bm{\\\\xi}})&=\\\\mathbb{E}\\_{p({\\\\mathbf{x}}),q\\_{\\\\bm{\\\\phi}}({\\\\mathbf{z}}\\_{0}\\|{\\\\mathbf{x}}),q\\_{\\\\bm{\\\\phi}}({\\\\mathbf{h}}\\_{0}\\|{\\\\mathbf{x}},{\\\\mathbf{z}}\\_{0})}\\\\bigl{\\[}\\\\log p\\_{\\\\bm{\\\\xi}}({\\\\mathbf{x}}\\|{\\\\mathbf{h}}\\_{0},{\\\\mathbf{z}}\\_{0})\\\\\\<br>&-\\\\lambda\\_{\\\\mathbf{z}}D\\_{\\\\textrm{KL}}\\\\left(q\\_{\\\\bm{\\\\phi}}({\\\\mathbf{z}}\\_{0}\\|{\\\\mathbf{x}})\\|p({\\\\mathbf{z}}\\_{0})\\\\right)-\\\\lambda\\_{\\\\mathbf{h}}D\\_{\\\\textrm{KL}}\\\\left(q\\_{\\\\bm{\\\\phi}}({\\\\mathbf{h}}\\_{0}\\|{\\\\mathbf{x}},{\\\\mathbf{z}}\\_{0})\\|p({\\\\mathbf{h}}\\_{0})\\\\right)\\\\bigr{\\]}.\\\\end{split} |  | (5) |\n\nHere, the global shape latent 𝐳0subscript𝐳0{\\\\mathbf{z}}\\_{0} is sampled from the posterior distribution qϕ​(𝐳0\\|𝐱)subscript𝑞bold-italic-ϕconditionalsubscript𝐳0𝐱q\\_{\\\\bm{\\\\phi}}({\\\\mathbf{z}}\\_{0}\\|{\\\\mathbf{x}}), which is parametrized by factorial Gaussians, whose means and variances are predicted via an encoder network. The point cloud latent 𝐡0subscript𝐡0{\\\\mathbf{h}}\\_{0} is sampled from a similarly parametrized posterior qϕ​(𝐡0\\|𝐱,𝐳0)subscript𝑞bold-italic-ϕconditionalsubscript𝐡0𝐱subscript𝐳0q\\_{\\\\bm{\\\\phi}}({\\\\mathbf{h}}\\_{0}\\|{\\\\mathbf{x}},{\\\\mathbf{z}}\\_{0}), while also conditioning on 𝐳0subscript𝐳0{\\\\mathbf{z}}\\_{0} (ϕbold-italic-ϕ{\\\\bm{\\\\phi}} denotes the parameters of both encoders). Furthermore, p𝝃​(𝐱\\|𝐡0,𝐳0)subscript𝑝𝝃conditional𝐱subscript𝐡0subscript𝐳0p\\_{\\\\bm{\\\\xi}}({\\\\mathbf{x}}\\|{\\\\mathbf{h}}\\_{0},{\\\\mathbf{z}}\\_{0}) denotes the decoder, parametrized as a factorial Laplace distribution with predicted means and fixed unit scale parameter (corresponding to an L1subscript𝐿1L\\_{1} reconstruction loss). λ𝐳subscript𝜆𝐳\\\\lambda\\_{\\\\mathbf{z}} and λ𝐡subscript𝜆𝐡\\\\lambda\\_{\\\\mathbf{h}} are hyperparameters balancing reconstruction accuracy and Kullback-Leibler regularization (note that only for λ𝐳=λ𝐡=1subscript𝜆𝐳subscript𝜆𝐡1\\\\lambda\\_{\\\\mathbf{z}}=\\\\lambda\\_{\\\\mathbf{h}}=1 we are optimizing a rigorous ELBO). The priors p​(𝐳0)𝑝subscript𝐳0p({\\\\mathbf{z}}\\_{0}) and p​(𝐡0)𝑝subscript𝐡0p({\\\\mathbf{h}}\\_{0}) are 𝒩​(𝟎,𝑰)𝒩0𝑰{\\\\mathcal{N}}(\\\\bm{0},{\\\\bm{I}}). Also see Fig. [1]Figure 1 ‣ 1 Introduction ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\") again.\n\n|     |     |     |     |     |     |     |     |     |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- |\n|  |  |  |  |  |  |  |  |  |\n|  |  |  |  |  |  |  |  |  |\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\nFigure 3: Generated shapes (top: point clouds, bottom: corresponding meshes) from LION trained jointly over 13 classes of ShapeNet-vol without conditioning (Sec. [5.2]Many-class Unconditional 3D Shape Generation ‣ 5 Experiments ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\")).\n\nSecond Stage Training.\nIn principle, we could use the VAE’s priors to sample encodings and generate new shapes. However, the simple Gaussian priors will not accurately match the encoding distribution from the training data and therefore produce poor samples (prior hole problem\\[ [58]), [72]), [73]), [74]), [75]), [76]), [77]), [78]), [79])\\]). This motivates training highly expressive latent DDMs. In particular, in the second stage\nwe freeze the VAE’s encoder and decoder networks and train two latent DDMs\non the encodings 𝐳0subscript𝐳0{\\\\mathbf{z}}\\_{0} and 𝐡0subscript𝐡0{\\\\mathbf{h}}\\_{0} sampled from qϕ​(𝐳0\\|𝐱)subscript𝑞bold-italic-ϕconditionalsubscript𝐳0𝐱q\\_{\\\\bm{\\\\phi}}({\\\\mathbf{z}}\\_{0}\\|{\\\\mathbf{x}}) and qϕ​(𝐡0\\|𝐱,𝐳0)subscript𝑞bold-italic-ϕconditionalsubscript𝐡0𝐱subscript𝐳0q\\_{\\\\bm{\\\\phi}}({\\\\mathbf{h}}\\_{0}\\|{\\\\mathbf{x}},{\\\\mathbf{z}}\\_{0}), minimizing score matching (SM) objectives similar to Eq. ( [2]In 2 Background ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\")):\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n|  | ℒSM𝐳​(𝜽)subscriptℒsuperscriptSM𝐳𝜽\\\\displaystyle\\\\mathcal{L}\\_{\\\\textrm{SM}^{\\\\mathbf{z}}}({\\\\bm{\\\\theta}}) | =𝔼t∼U​{1,T},p​(𝐱),qϕ​(𝐳0\\|𝐱),ϵ∼𝒩​(𝟎,𝑰)​‖ϵ−ϵ𝜽​(𝐳t,t)‖22,absentsubscript𝔼formulae-sequencesimilar-to𝑡𝑈1𝑇𝑝𝐱subscript𝑞bold-italic-ϕconditionalsubscript𝐳0𝐱similar-tobold-italic-ϵ𝒩0𝑰superscriptsubscriptnormbold-italic-ϵsubscriptbold-italic-ϵ𝜽subscript𝐳𝑡𝑡22\\\\displaystyle=\\\\mathbb{E}\\_{t\\\\sim U\\\\{1,T\\\\},p({\\\\mathbf{x}}),q\\_{\\\\bm{\\\\phi}}({\\\\mathbf{z}}\\_{0}\\|{\\\\mathbf{x}}),{\\\\bm{\\\\epsilon}}\\\\sim{\\\\mathcal{N}}(\\\\bm{0},{\\\\bm{I}})}\\|\\|{\\\\bm{\\\\epsilon}}-{\\\\bm{\\\\epsilon}}\\_{\\\\bm{\\\\theta}}({\\\\mathbf{z}}\\_{t},t)\\|\\|\\_{2}^{2}, |  | (6) |\n|  | ℒSM𝐡​(𝝍)subscriptℒsuperscriptSM𝐡𝝍\\\\displaystyle\\\\mathcal{L}\\_{\\\\textrm{SM}^{\\\\mathbf{h}}}({\\\\bm{\\\\psi}}) | =𝔼t∼U​{1,T},p​(𝐱),qϕ​(𝐳0\\|𝐱),qϕ​(𝐡0\\|𝐱,𝐳0),ϵ∼𝒩​(𝟎,𝑰)​‖ϵ−ϵ𝝍​(𝐡t,𝐳0,t)‖22,absentsubscript𝔼formulae-sequencesimilar-to𝑡𝑈1𝑇𝑝𝐱subscript𝑞bold-italic-ϕconditionalsubscript𝐳0𝐱subscript𝑞bold-italic-ϕconditionalsubscript𝐡0𝐱subscript𝐳0similar-tobold-italic-ϵ𝒩0𝑰superscriptsubscriptnormbold-italic-ϵsubscriptbold-italic-ϵ𝝍subscript𝐡𝑡subscript𝐳0𝑡22\\\\displaystyle=\\\\mathbb{E}\\_{t\\\\sim U\\\\{1,T\\\\},p({\\\\mathbf{x}}),q\\_{\\\\bm{\\\\phi}}({\\\\mathbf{z}}\\_{0}\\|{\\\\mathbf{x}}),q\\_{\\\\bm{\\\\phi}}({\\\\mathbf{h}}\\_{0}\\|{\\\\mathbf{x}},{\\\\mathbf{z}}\\_{0}),{\\\\bm{\\\\epsilon}}\\\\sim{\\\\mathcal{N}}(\\\\bm{0},{\\\\bm{I}})}\\|\\|{\\\\bm{\\\\epsilon}}-{\\\\bm{\\\\epsilon}}\\_{\\\\bm{\\\\psi}}({\\\\mathbf{h}}\\_{t},{\\\\mathbf{z}}\\_{0},t)\\|\\|\\_{2}^{2}, |  | (7) |\n\nwhere 𝐳t=αt​𝐳0+σt​ϵsubscript𝐳𝑡subscript𝛼𝑡subscript𝐳0subscript𝜎𝑡bold-italic-ϵ{\\\\mathbf{z}}\\_{t}=\\\\alpha\\_{t}{\\\\mathbf{z}}\\_{0}+\\\\sigma\\_{t}{\\\\bm{\\\\epsilon}} and 𝐡t=αt​𝐡0+σt​ϵsubscript𝐡𝑡subscript𝛼𝑡subscript𝐡0subscript𝜎𝑡bold-italic-ϵ{\\\\mathbf{h}}\\_{t}=\\\\alpha\\_{t}{\\\\mathbf{h}}\\_{0}+\\\\sigma\\_{t}{\\\\bm{\\\\epsilon}} are the diffused latent encodings. Furthermore, 𝜽𝜽{\\\\bm{\\\\theta}} denotes the parameters of the global shape latent DDM ϵ𝜽​(𝐳t,t)subscriptbold-italic-ϵ𝜽subscript𝐳𝑡𝑡{\\\\bm{\\\\epsilon}}\\_{\\\\bm{\\\\theta}}({\\\\mathbf{z}}\\_{t},t), and 𝝍𝝍{\\\\bm{\\\\psi}} refers to the parameters of the conditional DDM ϵ𝝍​(𝐡t,𝐳0,t)subscriptbold-italic-ϵ𝝍subscript𝐡𝑡subscript𝐳0𝑡{\\\\bm{\\\\epsilon}}\\_{\\\\bm{\\\\psi}}({\\\\mathbf{h}}\\_{t},{\\\\mathbf{z}}\\_{0},t) trained over the latent point cloud (note the conditioning on 𝐳0subscript𝐳0{\\\\mathbf{z}}\\_{0}).\n\nGeneration. With the latent DDMs, we can formally define a hierarchical generative model p𝝃,𝝍,𝜽​(𝐱,𝐡0,𝐳0)=p𝝃​(𝐱\\|𝐡0,𝐳0)​p𝝍​(𝐡0\\|𝐳0)​p𝜽​(𝐳0)subscript𝑝𝝃𝝍𝜽𝐱subscript𝐡0subscript𝐳0subscript𝑝𝝃conditional𝐱subscript𝐡0subscript𝐳0subscript𝑝𝝍conditionalsubscript𝐡0subscript𝐳0subscript𝑝𝜽subscript𝐳0p\\_{{\\\\bm{\\\\xi}},{\\\\bm{\\\\psi}},{\\\\bm{\\\\theta}}}({\\\\mathbf{x}},{\\\\mathbf{h}}\\_{0},{\\\\mathbf{z}}\\_{0})=p\\_{{\\\\bm{\\\\xi}}}({\\\\mathbf{x}}\\|{\\\\mathbf{h}}\\_{0},{\\\\mathbf{z}}\\_{0})p\\_{{\\\\bm{\\\\psi}}}({\\\\mathbf{h}}\\_{0}\\|{\\\\mathbf{z}}\\_{0})p\\_{{\\\\bm{\\\\theta}}}({\\\\mathbf{z}}\\_{0}), where p𝜽​(𝐳0)subscript𝑝𝜽subscript𝐳0p\\_{{\\\\bm{\\\\theta}}}({\\\\mathbf{z}}\\_{0}) denotes the distribution of the global shape latent DDM, p𝝍​(𝐡0\\|𝐳0)subscript𝑝𝝍conditionalsubscript𝐡0subscript𝐳0p\\_{{\\\\bm{\\\\psi}}}({\\\\mathbf{h}}\\_{0}\\|{\\\\mathbf{z}}\\_{0}) refers to the DDM modeling the point cloud-structured latents, and p𝝃​(𝐱\\|𝐡0,𝐳0)subscript𝑝𝝃conditional𝐱subscript𝐡0subscript𝐳0p\\_{{\\\\bm{\\\\xi}}}({\\\\mathbf{x}}\\|{\\\\mathbf{h}}\\_{0},{\\\\mathbf{z}}\\_{0}) is LION’s decoder. We can hierarchically sample the latent DDMs following Eq. ( [4]In 2 Background ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\")) and then translate the latent points back to the original point cloud space with the decoder.\n\nNetwork Architectures and DDM Parametrization. Let us briefly summarize key implementation choices. The encoder networks, as well as the decoder and the latent point DDM, operating on point clouds 𝐱𝐱{\\\\mathbf{x}}, are all implemented based on Point-Voxel CNNs (PVCNNs) \\[ [80])\\], following Zhou et al. \\[ [46])\\]. PVCNNs efficiently combine the point-based processing of PointNets \\[ [81]), [82])\\] with the strong spatial inductive bias of convolutions. The DDM modeling the global shape latent uses a ResNet \\[ [83])\\] structure with fully-connected layers (implemented as 1×1111{\\\\times}1-convolutions). All conditionings on the global shape latent are implemented via adaptive Group Normalization \\[ [84])\\] in the PVCNN layers. Furthermore, following Vahdat et al. \\[ [58])\\] we use a mixed score parametrization in both latent DDMs. This means that the score models are parametrized to predict a residual correction to an analytic standard Gaussian score. This is beneficial since the latent encodings are regularized towards a standard Gaussian distribution during the first training stage (see App. [D]Appendix D Implementation ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\") for all details).\n\n### 3.1 Applications and Extensions\n\nHere, we discuss how LION can be used and extended for different relevant applications.\n\nMultimodal Generation.\nWe can synthesize different variations of a given shape, enabling multimodal generation in a controlled manner: Given a shape, i.e., its point cloud 𝐱𝐱{\\\\mathbf{x}}, we encode it into latent space. Then, we diffuse its encodings 𝐳0subscript𝐳0{\\\\mathbf{z}}\\_{0} and 𝐡0subscript𝐡0{\\\\mathbf{h}}\\_{0} for a small number of steps τ<T𝜏𝑇\\\\tau<T towards intermediate 𝐳τsubscript𝐳𝜏{\\\\mathbf{z}}\\_{\\\\tau} and 𝐡τsubscript𝐡𝜏{\\\\mathbf{h}}\\_{\\\\tau} along the diffusion process such that only local details are destroyed. Running the reverse generation process from this intermediate τ𝜏\\\\tau, starting at 𝐳τsubscript𝐳𝜏{\\\\mathbf{z}}\\_{\\\\tau} and 𝐡τsubscript𝐡𝜏{\\\\mathbf{h}}\\_{\\\\tau}, leads to variations of the original shape with different details (see, for instance, Fig. [2]Figure 2 ‣ 2 Background ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\")). We refer to this procedure as diffuse-denoise (details in App. [C.1]C.1 Diffuse-Denoise ‣ Appendix C Technical Details on LION’s Applications and Extensions ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\")). Similar techniques have been used for image editing \\[ [85])\\].\n\n![Refer to caption]\n\nFigure 4: Voxel-guided synthesis with LION. We run diffuse-denoise in latent space (see Sec. [3.1]Applications and Extensions ‣ 3 Hierarchical Latent Point Diffusion Models ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\")) to generate diverse plausible clean shapes.\n\nEncoder Fine-tuning for Voxel-Conditioned Synthesis and Denoising. In practice, an artist using a 3D generative model may have a rough idea of the desired shape. For instance, they may be able to quickly construct a coarse voxelized shape, to which the generative model then adds realistic details.\nIn LION, we can support such applications: using a similar ELBO as in Eq. ( [5]In 3 Hierarchical Latent Point Diffusion Models ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\")), but with a frozen decoder, we can fine-tune LION’s encoder networks to take voxelized shapes as input (we simply place points at the voxelized shape’s surface) and map them to the corresponding latent encodings 𝐳0subscript𝐳0{\\\\mathbf{z}}\\_{0} and 𝐡0subscript𝐡0{\\\\mathbf{h}}\\_{0} that reconstruct the original non-voxelized point cloud. Now, a user can utilize the fine-tuned encoders to encode voxelized shapes and generate plausible detailed shapes. Importantly, this can be naturally combined with the diffuse-denoise procedure to clean up imperfect encodings and to generate different possible detailed shapes (see Fig. [4]Figure 4 ‣ 3.1 Applications and Extensions ‣ 3 Hierarchical Latent Point Diffusion Models ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\")).\n\nFurthermore, this approach is general. Instead of voxel-conditioned synthesis, we can also fine-tune the encoder networks on noisy shapes to perform multimodal shape denoising, also potentially combined with diffuse-denoise. LION supports these applications easily without re-training the latent DDMs due to its VAE framework with additional encoders and decoders, in contrast to previous works that train DDMs on point clouds directly \\[ [46]), [47])\\]. See App. [C.2]C.2 Encoder Fine-Tuning for Voxel-Conditioned Synthesis and Denoising ‣ Appendix C Technical Details on LION’s Applications and Extensions ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\") for technical details.\n\nShape Interpolation.\nLION also enables shape interpolation: We can encode different point clouds into LION’s hierarchical latent space and use the probability flow ODE (see App. [B]Appendix B Continuous-Time Diffusion Models and Probability Flow ODE Sampling ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\")) to further encode into the latent DDMs’ Gaussian priors, where we can safely perform spherical interpolation and expect valid shapes along the interpolation path. We can use the intermediate encodings to generate the interpolated shapes\n(see Fig. [7]Figure 7 ‣ 4 Related Work ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\"); details in App. [C.3]C.3 Shape Interpolation ‣ Appendix C Technical Details on LION’s Applications and Extensions ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\")).\n\n![Refer to caption]Figure 5: Reconstructing a mesh from LION’s generated points.\n\nSurface Reconstruction.\nWhile point clouds are an ideal 3D representation for DDMs, artists may prefer meshed outputs. Hence, we propose to combine LION with modern geometry reconstruction methods (see Figs. [2]Figure 2 ‣ 2 Background ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\"), [4]Figure 4 ‣ 3.1 Applications and Extensions ‣ 3 Hierarchical Latent Point Diffusion Models ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\") and [5]Figure 5 ‣ 3.1 Applications and Extensions ‣ 3 Hierarchical Latent Point Diffusion Models ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\")).\nWe use Shape As Points (SAP) \\[ [68])\\],\nwhich is based on differentiable Poisson surface reconstruction and can be trained to extract smooth meshes from noisy point clouds. Moreover, we fine-tune SAP on training data generated by LION’s autoencoder to better adjust SAP to the noise distribution in point clouds generated by LION. Specifically, we take clean shapes, encode them into latent space, run a few steps of diffuse-denoise that only slightly modify some details, and decode back. The diffuse-denoise in latent space results in noise in the generated point clouds similar to what is observed during unconditional synthesis (details in App. [C.4]C.4 Mesh Reconstruction with Shape As Points ‣ Appendix C Technical Details on LION’s Applications and Extensions ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\")).\n\n### 3.2 LION’s Advantages\n\nWe now recapitulate LION’s unique advantages. LION’s structure as a hierarchical VAE with latent DDMs is inspired by latent DDMs on images \\[ [57]), [58]), [77])\\]. This framework has key benefits:\n\n(i) Expressivity: First training a VAE that regularizes the latent encodings to approximately fall under standard Gaussian distributions, which are also the DDMs’ equilibrium distributions towards which the diffusion processes converge, results in an easier modeling task for the DDMs: They have to model only the remaining mismatch between the actual encoding distributions and their own Gaussian priors \\[ [58])\\]. This translates into improved expressivity, which is further enhanced by the additional decoder network. However, point clouds are, in principle, an ideal representation for the DDM framework, because they can be diffused and denoised easily and powerful point cloud processing architectures exist. Therefore, LION uses point cloud latents that combine the advantages of both latent DDMs and 3D point clouds. Our point cloud latents can be interpreted as smoothed versions of the original point clouds that are easier to model (see Fig. [1]Figure 1 ‣ 1 Introduction ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\")). Moreover, the hierarchical VAE setup with an additional global shape latent increases LION’s expressivity even further and results in natural disentanglement between overall shape and local details captured by the shape latents and latent points (Sec. [5.2]Many-class Unconditional 3D Shape Generation ‣ 5 Experiments ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\")).\n\n(ii) Flexibility: Another advantage of LION’s VAE framework is that its encoders can be fine-tuned for various relevant tasks, as discussed previously, and it also enables easy shape interpolation. Other 3D point cloud DDMs operating on point clouds directly \\[ [47]), [46])\\] do not offer simultaneously as much flexibility and expressivity out-of-the-box (see quantitative comparisons in Secs. [5.1]Single-Class 3D Shape Generation ‣ 5 Experiments ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\") and [5.4]Voxel-guided Shape Synthesis and Denoising with Fine-tuned Encoders ‣ 5 Experiments ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\")).\n\n(iii) Mesh Reconstruction: As discussed, while point clouds are ideal for DDMs, artists likely prefer meshed outputs. As explained above, we propose to use LION together with modern surface reconstruction techniques \\[ [68])\\], again combining the best of both worlds—a point cloud-based VAE backbone ideal for DDMs, and smooth geometry reconstruction methods operating on the synthesized point clouds to generate practically useful smooth surfaces, which can be easily transformed into meshes.\n\n|     |     |     |     |     |     |     |     |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n|  |  |  |  |  |  |  |  |\n|  |  |  |  |  |  |  |  |\n|  |  |  |  |  |  |  |  |\n| PointFlow | ShapeGF | SetVAE | DPM | PVD |  | LION (ours) |  |\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\nFigure 6: Unconditional shape generation with 2,048 points for\nairplane, car and chair classes (class-specific models trained on PointFlow’s ShapeNet data with global normalization).",
            "citations": null
          },
          "4 Related Work": {
            "content": "We are building on DDMs \\[ [53]), [65]), [66]), [67])\\], which have been used most prominently for image \\[ [53]), [54]), [55]), [56]), [57]), [58]), [59]), [60]), [61]), [62]), [63])\\] and speech synthesis \\[ [86]), [87]), [88]), [89]), [90]), [91])\\]. We train DDMs in latent space, an idea that has been explored for image \\[ [57]), [58]), [77])\\] and music \\[ [92])\\] generation, too. However, these works did not train separate conditional DDMs.\nHierarchical DDM training has been used for generative image upsampling \\[ [54])\\], text-to-image generation \\[ [63]), [64])\\], and semantic image modeling \\[ [60])\\]. Most relevant among these works is Preechakul et al. \\[ [60])\\], which extracts a high-level semantic representation of an image with an auxiliary encoder and then trains a DDM that adds details directly in image space.\nWe are the first to explore related concepts for 3D shape synthesis and we also train both DDMs in latent space. Furthermore, DDMs and VAEs have also been combined in such a way that the DDM improves the output of the VAE \\[ [93])\\].\n\nMost related to LION\nare “Point-Voxel Diffusion” (PVD) \\[ [46])\\] and “Diffusion Probabilistic Models for 3D Point Cloud Generation” (DPM) \\[ [47])\\]. PVD trains a DDM directly on point clouds, and our decision to use PVCNNs is inspired by this work. DPM, like LION, uses a shape latent variable, but models its distribution with Normalizing Flows \\[ [94]), [95])\\], and then trains a weaker point-wise conditional DDM directly on the point cloud data (this allows DPM to learn useful representations in its latent variable, but sacrifices generation quality). As we show below, neither PVD nor DPM easily enables applications such as multimodal voxel-conditioned synthesis and denoising. Furthermore, LION achieves significantly stronger generation performance. Finally, neither PVD nor DPM reconstructs meshes from the generated point clouds. Point cloud and 3D shape generation have also been explored with other generative models:\nPointFlow \\[ [31])\\], DPF-Net \\[ [33])\\]\nand SoftFlow \\[ [32])\\] rely on\nNormalizing Flows \\[ [94]), [95]), [96]), [97])\\]. SetVAE \\[ [29])\\] treats point cloud synthesis as set generation and uses\nVAEs. ShapeGF \\[ [45])\\]\nlearns distributions over gradient fields that model shape surfaces. Both IM-GAN \\[ [7])\\], which models shapes\nas neural fields, and l-GAN \\[ [2])\\] train GANs over latent variables that encode the shapes, similar to other works \\[ [3])\\], while r-GAN \\[ [2])\\] generates point clouds directly. PDGN \\[ [52])\\] proposes progressive deconvolutional networks within a point cloud GAN.\nSP-GAN \\[ [19])\\]\nuses a spherical point cloud prior.\nOther progressive \\[ [22]), [37])\\] and graph-based architectures \\[ [4]), [6])\\] have been used, too. Also generative cellular automata (GCAs) can be employed for voxel-based 3D shape generation \\[ [43])\\].\nIn orthogonal work, point cloud DDMs have been used for generative shape completion \\[ [46]), [98])\\].\n\n|     |     |     |     |     |     |     |     |     |     |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n|  |  |  |  |  |  |  |  |  |  |\n|  |  |  |  |  |  |  |  |  |  |\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\nFigure 7: Interpolating different shapes by interpolating their encodings in the standard Gaussian priors of LION’s latent DDMs (details in App. [C.3]C.3 Shape Interpolation ‣ Appendix C Technical Details on LION’s Applications and Extensions ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\")).\n\nRecently, image-driven \\[ [8]), [9]), [10]), [11]), [12]), [13]), [14]), [15]), [16]), [44])\\] training of 3D generative models as well as text-driven 3D generation \\[ [34]), [49]), [50]), [51])\\] have received much attention. These are complementary directions to ours; in fact, augmenting LION with additional image-based training or including text-guidance are promising future directions. Finally, we are relying on SAP \\[ [68])\\] for mesh generation. Strong alternative approaches for reconstructing smooth surfaces from point clouds exist \\[ [99]), [100]), [101]), [102]), [103])\\].",
            "citations": null
          },
          "5 Experiments": {
            "content": "We provide an overview of our most interesting experimental results in the main paper. All experiment details and extensive additional experiments can be found in App. [E]Appendix E Experiment Details ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\") and App. [F]Appendix F Additional Experimental Results ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\"), respectively.\n\nTable 1: Generation metrics (1-NNA↓↓\\\\downarrow) on airplane, chair, car categories from ShapeNet dataset from PointFlow \\[ [31])\\]. Training and test data normalized globally into \\[-1, 1\\].\n\n|  | Airplane | Chair | Car |\n| --- | --- | --- | --- |\n|  | CD | EMD | CD | EMD | CD | EMD |\n| --- | --- | --- | --- | --- | --- | --- |\n| r-GAN \\[ [2])\\] | 98.40 | 96.79 | 83.69 | 99.70 | 94.46 | 99.01 |\n| l-GAN (CD) \\[ [2])\\] | 87.30 | 93.95 | 68.58 | 83.84 | 66.49 | 88.78 |\n| l-GAN (EMD) \\[ [2])\\] | 89.49 | 76.91 | 71.90 | 64.65 | 71.16 | 66.19 |\n| PointFlow \\[ [31])\\] | 75.68 | 70.74 | 62.84 | 60.57 | 58.10 | 56.25 |\n| SoftFlow \\[ [32])\\] | 76.05 | 65.80 | 59.21 | 60.05 | 64.77 | 60.09 |\n| SetVAE \\[ [29])\\] | 76.54 | 67.65 | 58.84 | 60.57 | 59.94 | 59.94 |\n| DPF-Net \\[ [33])\\] | 75.18 | 65.55 | 62.00 | 58.53 | 62.35 | 54.48 |\n| DPM \\[ [47])\\] | 76.42 | 86.91 | 60.05 | 74.77 | 68.89 | 79.97 |\n| PVD \\[ [46])\\] | 73.82 | 64.81 | 56.26 | 53.32 | 54.55 | 53.83 |\n| LION (ours) | 67.41 | 61.23 | 53.70 | 52.34 | 53.41 | 51.14 |\n\nTable 2: Generation results (1-NNA↓↓\\\\downarrow) on ShapeNet dataset from PointFlow \\[ [31])\\]. All data normalized individually into \\[-1, 1\\].\n\n|  | Airplane | Chair | Car |\n|  | CD | EMD | CD | EMD | CD | EMD |\n| TreeGAN \\[ [6])\\] | 97.53 | 99.88 | 88.37 | 96.37 | 89.77 | 94.89 |\n| ShapeGF \\[ [45])\\] | 81.23 | 80.86 | 58.01 | 61.25 | 61.79 | 57.24 |\n| SP-GAN \\[ [19])\\] | 94.69 | 93.95 | 72.58 | 83.69 | 87.36 | 85.94 |\n| PDGN \\[ [52])\\] | 94.94 | 91.73 | 71.83 | 79.00 | 89.35 | 87.22 |\n| GCA \\[ [43])\\] | 88.15 | 85.93 | 64.27 | 64.50 | 70.45 | 64.20 |\n| LION (ours) | 76.30 | 67.04 | 56.50 | 53.85 | 59.52 | 49.29 |\n\nTable 3: Results (1-NNA↓↓\\\\downarrow) on ShapeNet-vol.\n\n|  | Airplane | Chair | Car |\n|  | CD | EMD | CD | EMD | CD | EMD |\n| IM-GAN \\[ [7])\\] | 79.70 | 77.85 | 57.09 | 58.20 | 88.92 | 84.58 |\n| DPM \\[ [47])\\] | 83.04 | 96.04 | 61.96 | 74.96 | 77.30 | 87.12 |\n| PVD \\[ [46])\\] | 66.46 | 56.06 | 61.89 | 57.90 | 64.49 | 55.74 |\n| LION (ours) | 53.47 | 53.84 | 52.07 | 48.67 | 54.81 | 50.53 |\n\n![Refer to caption]Figure 8: Samples from our unconditional 13-class model: In each column, we use the same global shape latent 𝐳0subscript𝐳0{\\\\mathbf{z}}\\_{0}.\n\n### 5.1 Single-Class 3D Shape Generation\n\nDatasets. To compare LION against existing methods, we use ShapeNet \\[ [104])\\], the most widely used dataset to benchmark 3D shape generative models. Following previous works \\[ [31]), [46]), [47])\\], we train on three categories: airplane, chair, car. Also like previous methods, we primarily rely on PointFlow’s \\[ [31])\\] dataset splits and preprocssing. It normalizes the data globally across the whole dataset. However, some baselines require per-shape normalization \\[ [19]), [43]), [45]), [52])\\]; hence, we also train on such data. Furthermore, training SAP requires signed distance fields (SDFs) for volumetric supervision, which the PointFlow data does not offer. Hence, for simplicity we follow Peng et al. \\[ [68]), [101])\\] and also use their data splits and preprocessing, which includes SDFs.We train LION, DPM, PVD, and IM-GAN (which synthesizes shapes as SDFs) also on this dataset version (denoted as ShapeNet-vol here). This data is also per-shape normalized. Dataset details in App. [E.1]E.1 Different Datasets ‣ Appendix E Experiment Details ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\").\n\nTable 4: Generation results (1-NNA↓↓\\\\downarrow) of LION trained jointly on 13 classes of ShapeNet-vol.\n\n| Model | CD | EMD |\n| --- | --- | --- |\n| TreeGAN \\[ [6])\\] | 96.80 | 96.60 |\n| PointFlow \\[ [31])\\] | 63.25 | 66.05 |\n| ShapeGF \\[ [45])\\] | 55.65 | 59.00 |\n| SetVAE \\[ [29])\\] | 79.25 | 95.25 |\n| PDGN \\[ [52])\\] | 71.05 | 86.00 |\n| DPF-Net \\[ [33])\\] | 67.10 | 64.75 |\n| DPM \\[ [47])\\] | 62.30 | 86.50 |\n| PVD \\[ [46])\\] | 58.65 | 57.85 |\n| LION (ours) | 51.85 | 48.95 |\n\nEvaluation. Model evaluation follows previous works \\[ [31]), [46])\\]. Various metrics to evaluate point cloud generative models exist, with different advantages and disadvantages, discussed in detail by Yang et al. \\[ [31])\\]. Following recent works \\[ [31]), [46])\\], we use 1-NNA (with both Chamfer distance (CD) and earth mover distance (EMD)) as our main metric. It quantifies the distributional similarity between generated shapes and validation set and measures both quality and diversity \\[ [31])\\]. For fair comparisons, all metrics are computed on point clouds, not meshed outputs (App. [E.2]E.2 Evaluation Metrics ‣ Appendix E Experiment Details ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\") discusses different metrics; further results on coverage (COV) and minimum matching distance (MMD) in App. [F.2]F.2 Single-Class Unconditional Generation ‣ Appendix F Additional Experimental Results ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\")).\n\n|     |     |     |     |     |     |     |     |     |     |     |     |     |     |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n|  |  |  |  |  |  |  |  |  |  |  |  |  |  |\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\nFigure 9: Generated point clouds from LION trained jointly over 55 classes of ShapeNet-vol (no conditioning).\n\nResults. Samples from LION are shown in Fig. [6]Figure 6 ‣ 3.2 LION’s Advantages ‣ 3 Hierarchical Latent Point Diffusion Models ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\") and quantitative results in Tabs. [3]Table 3 ‣ 5 Experiments ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\")- [3]Table 3 ‣ 5 Experiments ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\") (see Sec. [4]Related Work ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\") for details about baselines—to reduce the number of baselines to train, we are focusing on the most recent and competitive ones). LION outperforms all baselines and achieves state-of-the-art performance on all classes and dataset versions. Importantly, we outperform both PVD and DPM, which also leverage DDMs, by large margins. Our samples are diverse and appear visually pleasing.\n\nMesh Reconstruction. As explained in Sec. [3.1]Applications and Extensions ‣ 3 Hierarchical Latent Point Diffusion Models ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\"), we combine LION with mesh reconstruction, to directly synthesize practically useful meshes. We show generated meshes in Fig. [2]Figure 2 ‣ 2 Background ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\"), which look smooth and of high quality. In Fig. [2]Figure 2 ‣ 2 Background ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\"), we also visually demonstrate how we can vary the local details of synthesized shapes while preserving the overall shape with our diffuse-denoise technique (Sec. [3.1]Applications and Extensions ‣ 3 Hierarchical Latent Point Diffusion Models ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\")). Details about the number of diffusion steps for all diffuse-denoise experiments\nare in App. [E]Appendix E Experiment Details ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\").\n\nShape Interpolation. As discussed in Sec. [3.1]Applications and Extensions ‣ 3 Hierarchical Latent Point Diffusion Models ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\"), LION also enables shape interpolation, potentially useful for shape editing applications. We show this in Fig. [7]Figure 7 ‣ 4 Related Work ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\"), combined with mesh reconstruction. The generated shapes are clean and semantically plausible along the entire interpolation path. In App. [F.12.1]F.12.1 Shape Interpolation with PVD and DPM ‣ F.12 More Shape Interpolations ‣ Appendix F Additional Experimental Results ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\"), we also show interpolations from PVD \\[ [46])\\] and DPM \\[ [47])\\] for comparison.\n\n### 5.2 Many-class Unconditional 3D Shape Generation\n\n13-Class LION Model. We train a LION model jointly without any class conditioning on 13 different categories (airplane, chair, car, lamp, table, sofa, cabinet, bench, telephone, loudspeaker, display, watercraft, rifle) from ShapeNet (ShapeNet-vol version).\nTraining a single model without conditioning over such diverse\nshapes is challenging, as the data distribution is highly complex and multimodal. We show LION’s generated samples in Fig. [3]Figure 3 ‣ 3 Hierarchical Latent Point Diffusion Models ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\"), including meshes: LION synthesizes high-quality and diverse plausible shapes even when trained on such complex data. We report the model’s quantitative generation performance in Tab. [4]Table 4 ‣ 5.1 Single-Class 3D Shape Generation ‣ 5 Experiments ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\"), and we also trained various strong baseline methods under the same setting for comparison. We find that LION significantly outperforms all baselines by a large margin.\nWe further observe that the hierarchical VAE architecture of LION becomes crucial: The shape latent variable 𝐳0subscript𝐳0{\\\\mathbf{z}}\\_{0} captures global shape, while the latent points 𝐡0subscript𝐡0{\\\\mathbf{h}}\\_{0} model details. This can be seen in Fig. [8]Figure 8 ‣ 5 Experiments ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\"): we show samples when fixing the global shape latent 𝐳0subscript𝐳0{\\\\mathbf{z}}\\_{0} and only sample 𝐡0subscript𝐡0{\\\\mathbf{h}}\\_{0} (details in App. [F.3]F.3 Unconditional Generation of 13 ShapeNet Classes ‣ Appendix F Additional Experimental Results ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\")).\n\n55-Class LION Model. Encouraged by these results, we also trained a LION model again jointly without any class conditioning on all 55 different categories from ShapeNet. Note that we did on purpose not use class-conditioning in these experiments to create a difficult 3D generation task and thereby explore LION’s scalability to highly complex and multimodal datasets. We show generated point cloud samples in Fig. [9]Figure 9 ‣ 5.1 Single-Class 3D Shape Generation ‣ 5 Experiments ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\") (we did not train an SAP model on the 55 classes data): LION synthesizes high-quality and diverse shapes. It can even generate samples from the cap class, which contributes with only 39 training data samples, indicating that LION has an excellent mode coverage that even includes the very rare classes. To the best of our knowledge no previous 3D shape generative models have demonstrated satisfactory generation performance for such diverse and multimodal 3D data without relying on conditioning information (details in App. [F.4]F.4 Unconditional Generation of all 55 ShapeNet Classes ‣ Appendix F Additional Experimental Results ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\")). In conclusion, we observe that LION out-of-the-box easily scales to highly complex multi-category shape generation.\n\n|     |     |     |     |     |     |     |     |     |     |     |     |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] |\n| ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] |\n\nFigure 10: Samples from LION trained on ShapeNet’s Mug and Bottle classes, and on Turbosquid animals.\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  |  |  |  |\n|  | DPM-0 | PVD-0 | LION-0 (ours) |\n|  |  |  |  |\n| Input Voxels | DPM-50 | PVD-50 | LION-50 (ours) |\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\n![[Uncaptioned image]]\n\nFigure 11: Voxel-guided synthesis. We show different methods with 0 and 50 steps of diffuse-denoise. Voxelizations of generated points are also shown: Yellow boxes indicate generated points correctly fill input voxels, green boxes indicate voxels should be filled but are left empty, red boxes indicate extra voxels.\n\n### 5.3 Training LION on Small Datasets\n\nNext, we explore whether LION can also be trained successfully on very small datasets. To this end, we train models on the Mug and Bottle ShapeNet classes. The number of training samples is 149 and 340, respectively, which is much smaller than the common classes like chair, car and airplane. Furthermore, we also train LION on 553 animal assets from the TurboSquid data repository. Generated shapes from the three models are shown in Fig. [10]Figure 10 ‣ 5.2 Many-class Unconditional 3D Shape Generation ‣ 5 Experiments ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\"). LION is able to generate correct mugs and bottles as well as diverse and high-quality animal shapes. We conclude that LION also performs well even when training in the challenging low-data setting (details in Apps. [F.5]F.5 Unconditional Generation of ShapeNet’s Mug and Bottle Classes ‣ Appendix F Additional Experimental Results ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\") and [F.6]F.6 Unconditional Generation of Animal Shapes ‣ Appendix F Additional Experimental Results ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\")).\n\n### 5.4 Voxel-guided Shape Synthesis and Denoising with Fine-tuned Encoders\n\nNext, we test our strategy for multimodal voxel-guided shape synthesis (see Sec. [3.1]Applications and Extensions ‣ 3 Hierarchical Latent Point Diffusion Models ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\")) using the airplane class LION model (experiment details in App. [E]Appendix E Experiment Details ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\"), more experiments in App. [F.7]F.7 Voxel-guided Synthesis and Denoising ‣ Appendix F Additional Experimental Results ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\")). We first voxelize our training set and fine-tune our encoder networks to produce the correct encodings to decode back the original shapes. When processing voxelized shapes with our point-cloud networks, we sample points on the surface of the voxels. As discussed, we can use different numbers of diffuse-denoise steps in latent space to generate various plausible shapes and correct for poor encodings. Instead of voxelizations, we can also consider different noisy inputs (we use normal, uniform, and outlier noise, see App. [F.7]F.7 Voxel-guided Synthesis and Denoising ‣ Appendix F Additional Experimental Results ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\")) and achieve multimodal denoising with the same approach. The same tasks can be attempted with the important DDM-based baselines PVD and DPM, by directly—not in a latent space—diffusing and denoising voxelized (converted to point clouds) or noisy point clouds.\n\n![Refer to caption]Figure 12: Reconstruction metrics with respect to clean inputs for airplane category (lower is better) when guiding synthesis with voxelized or noisy inputs (using uniform, outlier, and normal noise, see App. [F.7]F.7 Voxel-guided Synthesis and Denoising ‣ Appendix F Additional Experimental Results ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\")). x𝑥x-axes denote number of diffuse-denoise steps.\n\n![Refer to caption]Figure 13: Voxel-guided generation. Quality metrics for output points (lower is better) and voxel IOU with respect to input (higher is better). x𝑥x-axes denote diffuse-denoise steps.\n\n|     |     |     |     |     |     |\n| --- | --- | --- | --- | --- | --- |\n| ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] |\n| an airplane made <br>of strawberries | an airplane made <br>of fabric leather | a chair made of<br>wood | a car made of<br>rusty metal | a car made of<br>brick | a denim fabric<br>animal |\n\nFigure 14: We apply Text2Mesh \\[ [49])\\] on meshes generated by LION. In Text2Mesh, textures are generated and meshes refined such that rendered images of the 3D objects are aligned with user-provided text prompts \\[ [105])\\].\n\nFig. [13]Figure 13 ‣ 5.4 Voxel-guided Shape Synthesis and Denoising with Fine-tuned Encoders ‣ 5 Experiments ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\") shows the reconstruction performance of LION, DPM and PVD for different numbers of diffuse-denoise steps (we voxelized or noised the validation set to measure this). We see that for almost all inputs—voxelized or different noises—LION performs best. PVD and DPM perform acceptably for normal and uniform noise, which is similar to the noise injected during training of their DDMs, but perform very poorly for outlier noise or voxel inputs, which is the most relevant case to us, because voxels can be easily placed by users. It is LION’s unique framework with additional fine-tuned encoders in its VAE and only latent DDMs that makes this possible. Performing more diffuse-denoise steps means that more independent, novel shapes are generated. These will be cleaner and of higher quality, but also correspond less to the noisy or voxel inputs used for guidance. In Fig. [13]Figure 13 ‣ 5.4 Voxel-guided Shape Synthesis and Denoising with Fine-tuned Encoders ‣ 5 Experiments ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\"), we show this trade-off for the voxel-guidance experiment (other experiments in App. [F.7]F.7 Voxel-guided Synthesis and Denoising ‣ Appendix F Additional Experimental Results ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\")), where (top) we measured the outputs’ synthesis quality by calculating 1-NNA with respect to the validation set, and (bottom) the average intersection over union (IOU) between the input voxels and the voxelized outputs. We generally see a trade-off: More diffuse-denoise steps result in lower 1-NNA (better quality), but also lower IOU. LION strikes the best balance by a large gap: Its additional encoder network directly generates plausible latent encodings from the perturbed inputs that are both high quality and also correspond well to the input. This trade-off is visualized in Fig. [11]Figure 11 ‣ 5.2 Many-class Unconditional 3D Shape Generation ‣ 5 Experiments ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\") for LION, DPM, and PVD, where we show generated point clouds and voxelizations (note that performing no diffuse-denoise at all for PVD and DPM corresponds to simply keeping the input, as these models’ DDMs operate directly on point clouds). We see that running 50 diffuse-denoise steps to generate diverse outputs for DPM and especially PVD results in a significant violation of the input voxelization. In contrast, LION generates realistic outputs that also obey the driving voxels.\nOverall, LION wins out both in this task and also in unconditional generation with large gaps over these previous DDM-based point cloud generative models.\nWe conclude that LION does not only offer state-of-the-art 3D shape generation quality, but is also very versatile. Note that guided synthesis can also be combined with mesh reconstruction, as shown in Fig. [4]Figure 4 ‣ 3.1 Applications and Extensions ‣ 3 Hierarchical Latent Point Diffusion Models ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\").\n\n|     |     |\n| --- | --- |\n| ![Refer to caption] | ![Refer to caption] |\n| ![Refer to caption] | ![Refer to caption] |\n\nFigure 15: 25-step DDIM \\[ [106])\\] samples (0.89 seconds per shape).\n\n### 5.5 Sampling Time\n\nWhile our main experiments use 1,000-step DDPM-based synthesis, which takes ≈27.12absent27.12\\\\approx 27.12 seconds, we can significantly accelerate generation without significant loss in quality. Using DDIM-based sampling \\[ [106])\\], we can generate high quality shapes in under one second (Fig. [15]Figure 15 ‣ 5.4 Voxel-guided Shape Synthesis and Denoising with Fine-tuned Encoders ‣ 5 Experiments ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\")), which would enable real-time interactive applications. More analyses in App. [F.9]F.9 Synthesis Time and DDIM Sampling ‣ Appendix F Additional Experimental Results ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\").\n\n### 5.6 Overview of Additional Experiments in Appendix\n\n(i) In App. [F.1]F.1 Ablation Studies ‣ Appendix F Additional Experimental Results ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\"), we perform various ablation studies. The experiments quantitatively validate LION’s architecture choices and the advantage of our hierarchical VAE setup with conditional latent DDMs. (ii) In App. [F.8]F.8 Autoencoding ‣ Appendix F Additional Experimental Results ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\"), we measure LION’s autoencoding performance.\n(iii) To demonstrate the value of directly outputting meshes, in App. [F.10]F.10 Per-sample Text-driven Texture Synthesis ‣ Appendix F Additional Experimental Results ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\") we use Text2Mesh \\[ [49])\\] to generate textures based on text prompts for synthesized LION samples (Fig. [14]Figure 14 ‣ 5.4 Voxel-guided Shape Synthesis and Denoising with Fine-tuned Encoders ‣ 5 Experiments ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\")). This would not be possible, if we only generated point clouds.\n(iv) To qualitatively show that LION can be adapted easily to other relevant tasks, in App. [F.11]F.11 Single View Reconstruction and Text-driven Shape Synthesis ‣ Appendix F Additional Experimental Results ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\") we condition LION on CLIP embeddings of the shapes’ rendered images, following CLIP-Forge \\[ [34])\\] (Fig. [16]Figure 16 ‣ 5.6 Overview of Additional Experiments in Appendix ‣ 5 Experiments ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\")). This enables text-driven 3D shape generation and single view 3D reconstruction (Fig. [17]Figure 17 ‣ 5.6 Overview of Additional Experiments in Appendix ‣ 5 Experiments ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\")).\n(v) We also show many more samples (Apps. [F.2]F.2 Single-Class Unconditional Generation ‣ Appendix F Additional Experimental Results ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\")- [F.6]F.6 Unconditional Generation of Animal Shapes ‣ Appendix F Additional Experimental Results ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\")) and shape interpolations (App. [F.12]F.12 More Shape Interpolations ‣ Appendix F Additional Experimental Results ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\")) from our models, more examples of voxel-guided and noise-guided synthesis (App. [F.7]F.7 Voxel-guided Synthesis and Denoising ‣ Appendix F Additional Experimental Results ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\")), and we further analyze our 13-class LION model (App. [F.3.2]F.3.2 Shape Latent Space Visualization ‣ F.3 Unconditional Generation of 13 ShapeNet Classes ‣ Appendix F Additional Experimental Results ‣ LION: Latent Point Diffusion Models for 3D Shape Generation\")).\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n| ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] |\n| narrow chair | office chair | bmw convertible | jeep |\n\nFigure 16: Text-driven shape generation of chairs and cars with LION. Bottom row is the text prompt used as input.\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n| ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] |\n\nFigure 17: Single view 3D reconstructions of a car from an RGB image. LION can generate multiple plausible outputs using our diffuse-denoise technique.",
            "citations": null
          },
          "6 Conclusions": {
            "content": "We introduced LION, a novel generative model of 3D shapes. LION uses a VAE framework with hierarchical DDMs in latent space and can be combined with SAP for mesh generation. LION achieves state-of-the-art shape generation performance and enables applications such as voxel-conditioned synthesis, multimodal shape denoising, and shape interpolation.\nLION is currently trained on 3D point clouds only and can not directly generate textured shapes.\nA promising extension would be to include image-based training by incorporating neural or differentiable rendering \\[ [17]), [107]), [108]), [109]), [110]), [111])\\] and to also synthesize textures \\[ [16]), [112]), [113]), [114])\\]. Furthermore, LION currently focuses on single object generation only. It would be interesting to extend it to full 3D scene synthesis. Moreover, synthesis could be further accelerated by building on works on accelerated sampling from DDMs \\[ [61]), [62]), [67]), [106]), [115]), [116]), [117]), [118]), [119]), [120]), [121])\\].\n\nBroader Impact. We believe that LION can potentially improve 3D content creation and assist the workflow of digital artists. We designed LION with such applications in mind and hope that it can grow into a practical tool enhancing artists’ creativity.\nAlthough we do not see any immediate negative use-cases for LION, it is important that practitioners apply an abundance of caution to mitigate impacts given generative modeling more generally can also be used for malicious purposes, discussed for instance in Vaccari and Chadwick \\[ [122])\\], Nguyen et al. \\[ [123])\\], Mirsky and Lee \\[ [124])\\].",
            "citations": null
          }
        },
        "abstract": "Denoising diffusion models (DDMs) have shown promising results in 3D point\ncloud synthesis. To advance 3D DDMs and make them useful for digital artists,\nwe require (i) high generation quality, (ii) flexibility for manipulation and\napplications such as conditional synthesis and shape interpolation, and (iii)\nthe ability to output smooth surfaces or meshes. To this end, we introduce the\nhierarchical Latent Point Diffusion Model (LION) for 3D shape generation. LION\nis set up as a variational autoencoder (VAE) with a hierarchical latent space\nthat combines a global shape latent representation with a point-structured\nlatent space. For generation, we train two hierarchical DDMs in these latent\nspaces. The hierarchical VAE approach boosts performance compared to DDMs that\noperate on point clouds directly, while the point-structured latents are still\nideally suited for DDM-based modeling. Experimentally, LION achieves\nstate-of-the-art generation performance on multiple ShapeNet benchmarks.\nFurthermore, our VAE framework allows us to easily use LION for different\nrelevant tasks: LION excels at multimodal shape denoising and voxel-conditioned\nsynthesis, and it can be adapted for text- and image-driven 3D generation. We\nalso demonstrate shape autoencoding and latent shape interpolation, and we\naugment LION with modern surface reconstruction techniques to generate smooth\n3D meshes. We hope that LION provides a powerful tool for artists working with\n3D shapes due to its high-quality generation, flexibility, and surface\nreconstruction. Project page and code: https://nv-tlabs.github.io/LION."
      },
      "bib.bib113": {
        "id": "bib.bib113",
        "citation": "[113]",
        "authors": "",
        "year": "",
        "title": "3DILG: Irregular latent grids for 3d generative modeling.",
        "venue": "",
        "pages": "",
        "url": "https://arxiv.org/abs/2205.13914",
        "arxiv_id": "2205.13914",
        "doi": null,
        "sections": {
          "1 Introduction": {
            "content": "![Refer to caption](1) SR![Refer to caption](2) HRICG![Refer to caption](3) LRICG![Refer to caption](4) PCCG![Refer to caption](5) CCG\n\nFigure 1:\nIrregular Latent Grids enable many applications: (1) shape reconstruction, (2) high-resolution-image-conditioned generation, (3) low-resolution-image-conditioned generation, (4) point-cloud-conditioned generation, and (5) category-conditioned generation. The data structure is especially suited for auto-regressive modeling (applications 2-5). For each of these applications the probabilistic approach enables sampling of many plausible models for a single query.\n\nNeural fields for 3D shapes are popular in machine learning because they are generally easier to process with neural networks than other alternative representations, _e.g_., triangle meshes or spline surfaces. Earlier works represent a shape with a single _global_ latent \\[ [29]), [13]), [7]), [36]), [66])\\]. This already gives promising results in shape autoencoding and shape reconstruction. However, shape details are often missing and hard to recover from a global latent. Later, _local_ latent grids for shapes were proposed \\[ [39]), [23]), [3]), [48])\\]. A local latent mainly influences the shape (surface) in a local 3D neighborhood, thus perceiving shape details. However, in contrast to global latents, local latents require positional information about their location, _e.g_., as implicitly defined by a regular grid. Furthermore, _multiscale_ latent pyramid grids \\[ [9]), [6])\\] provide some performance improvement over basic grids.\nWe illustrate the three current ways of modeling neural fields in Fig. [2]Figure 2 ‣ 1 Introduction ‣ 3DILG: Irregular Latent Grids for 3D Generative Modeling\").\n\nIn this paper, we set out to study irregular grids as 3D shape representation for neural fields. This extends previous grid-based representations, but allows each latent to have an arbitrary position in space, rather than a position that is pre-determined on a regular grid. We do not want to give up the advantages of a fixed length representation, and therefore propose to encode shapes as a fixed length sequence of tuples (𝐱i,𝐳i)i∈ℳsubscriptsubscript𝐱𝑖subscript𝐳𝑖𝑖ℳ(\\\\mathbf{x}\\_{i},\\\\mathbf{z}\\_{i})\\_{i\\\\in\\\\mathcal{M}}, where 𝐱isubscript𝐱𝑖\\\\mathbf{x}\\_{i} are the 3D positions and 𝐳isubscript𝐳𝑖\\\\mathbf{z}\\_{i} are the latents.\nThe overall advantages of this representation are that it is fixed length, works well with transformer-based architectures using established building blocks, and that it can adapt to the 3D shape it encodes by placing latents at the most important positions. The representation also scales better than grid-based (and especially pyramid-based) representations to a larger number of latents. The number of latents in a representation is a factor that greatly influences the training time of transformer architectures, as the computation time is quadratic in the number of latents.\n\nWhile our proposed representation brings some improvement for 3D shape reconstruction from point clouds, the improvement is very significant for 3D generative models that have been less explored.\nWe believe that the most promising avenue for 3D shape generation is to follow recent image generative methods based on vector quantization and auto-regressive models using transformer, _e.g_. VQGAN \\[ [16])\\]. These models operate on discrete latent vectors represented by indices \\[ [53])\\]. During training, an autoregressive probabilistic model is trained to predict discrete indices. When doing inference (sampling), discrete indices are sampled from the autoregressive model and are decoded to images with a learned decoder.\nThese models work well in the image domain, because a single image can comfortably be represented by medium size, _e.g_.16×16161616\\\\times 16 latent grids of 256 latents \\[ [16])\\]. This does not directly scale to 3D shapes, as a 16×16×1616161616\\\\times 16\\\\times 16 grid is too large to be comfortably trained on 4-8 GPUs due to the quadratic complexity of the transformer architecture \\[ [55])\\]. As a result, generative models based on low-resolution regular grids lead to artifacts in the details, whereas our representation yields a nice and clean surface ( _e.g_. Fig. [9]Figure 9 ‣ 6.2 Category-Conditioned Generation ‣ 6 Generative Experiments ‣ 3DILG: Irregular Latent Grids for 3D Generative Modeling\")).\n\nWe show the following applications of our proposed representations (see Fig. [1]Figure 1 ‣ 1 Introduction ‣ 3DILG: Irregular Latent Grids for 3D Generative Modeling\")). For 3D shape reconstruction, we show results for 3D reconstruction from a point cloud. For generative modeling, we show results for image-conditioned 3D shape generation, object category-conditioned 3D shape generation, and point-cloud-conditioned 3D shape generation. The generative model is probabilistic and can generate multiple different 3D shapes for the same conditioning information.\n\n\\\\begin{overpic}\\[trim=0.0pt 0.0pt 0.0pt 0.0pt,clip,width=433.62pt,grid=false\\]{images/grid\\_l.jpg}\n\\\\put(4.0,12.0){\\\\tiny{Global}}\n\\\\dashline{0.7}(15,0)(15,12)\n\\\\put(20.0,12.0){\\\\tiny{Local}}\n\\\\dashline{0.7}(31,0)(31,12)\n\\\\put(55.0,12.0){\\\\tiny{Multiscale}}\n\\\\dashline{0.7}(86,0)(86,12)\n\\\\put(91.0,12.0){\\\\tiny{Irregular}}\n\\\\end{overpic}Figure 2: Latent grids. From left to right, we show single global latent ( _e.g_., OccNet \\[ [29])\\]), latent grid ( _e.g_. ConvONet \\[ [39])\\]), multiscale latent grids ( _e.g_. IF-Net \\[ [9])\\]), and our irregular latent grid.\n\nWe summarize the contributions of our work as follows:\n1) We propose irregular latent grids as 3D shape representation for neural fields. Our shape representation thereby extends existing works using a global latent, a local latent grid or a multi-scale grid.\n2) We improve upon grid-based SOTA methods for 3D shape reconstruction for point-clouds.\n3) We improve state-of-the art generative models for 3D shape generation, including image-conditioned generation, object category-conditioned generation and point cloud-conditioned generation.",
            "citations": null
          },
          "2 Related Work": {
            "content": "### 2.1 Neural shape representations\n\nShape analysis with neural networks processes shapes in different representations. Common representations include voxels \\[ [27]), [10]), [12]), [44])\\] and point clouds \\[ [40]), [41]), [57]), [58]), [51])\\]. More recently, researchers study shapes represented with neural fields \\[ [63])\\], _e.g_., signed distance functions (SDFs) or occupancy (indicator) functions of shapes modeled by neural networks. Subsequently, meshes can be extracted by contouring methods such as marching cubes \\[ [28])\\]. The methods have been called _neural implicit representations_\\[ [29]), [30]), [36]), [18]), [13]), [7]), [66])\\] or coordinate-based representations \\[ [47])\\]. We decided to use the term _neural fields_ in this paper \\[ [63])\\].\n\n#### Point cloud processing.\n\nEarlier works for point cloud processing rely on multilayer perceptrons (MLPs), _e.g_., PointNet \\[ [40])\\]. PointNet++ \\[ [41])\\] and DGCNN \\[ [57])\\] extended the idea by employing a hierarchical structure to capture local information. Inspired by ViT \\[ [15])\\], which treats images as a set of patches, PCT \\[ [20])\\] and PT \\[ [67])\\] propose a transformer backbone for point cloud processing. Both works introduce extra modules which are not standard transformers \\[ [55])\\] anymore. Since our main goal is not to develop a general backbone for point clouds, we simply work with a _standard_ transformer for shape autoencoding (first-stage training). Similarly, both PointBERT\\[ [65])\\] and PointMAE \\[ [34])\\] use standard transformers for point cloud self-supervised learning.\n\n#### Neural fields for 3D shapes.\n\nOne possible approach is to represent a shape with a single _global_ latent, _e.g_., OccNet \\[ [29])\\], CvxNet \\[ [13])\\] and Zhang _et al_.\\[ [66])\\]. While this method is very simple, it is not suitable to encode surface details or shapes with complex topology. Later works studied the use of _local_ latents. Compared to global latents, these representations represent shapes with multiple local latents. Each latent is responsible for reconstruction in a local region. ConvONet \\[ [39])\\], as a follow-up work of OccNet, learns latents on a grid (2d or 3d). IF-Net \\[ [9])\\], trains a model which outputs 3d latent grids of several different resolutions. The grids are then concatenated into a final representation. Some more recent works \\[ [17]), [26]), [49])\\] learn to put latents on 3D positions.\n\n### 2.2 Generative models\n\nGenerative models include generative adversarial networks (GANs) \\[ [19])\\], variational autoencoders (VAEs) \\[ [24])\\], energy-based models \\[ [25]), [59]), [61]), [62]), [60])\\], normalizing flows (NFs) \\[ [43]), [14])\\] and auto-regressive models (ARs) \\[ [54])\\]. Our shape representation is designed to be compatible with auto-regressive generative models. Thus we will mainly discuss related work in this area.\n\nIn the image domain, earlier AR works generate pixels one-by-one, _e.g_., PixelRNN \\[ [54])\\] and its follow-up works \\[ [52]), [45])\\]. Combining this idea with autoregressive transformers, similar approaches are applied to 3D data, _e.g_., PointGrow \\[ [46])\\] for point cloud generation and PolyGen \\[ [33])\\] for polygonal mesh generation. Other use cases include floor plan generation \\[ [35])\\] and indoor scene generation \\[ [56]), [38])\\].\n\nAn important ingredient of many auto-regressive models is vector quantization (VQ) that was originally integrated into VAEs. VQVAE \\[ [53])\\] adopts a two-stage training strategy. The first stage is an autoencoder with vector quantization, where bottleneck latents are quantized to discrete indices. In the second stage, an autoregressive model is trained to predict the discrete indices. This idea is further developed in VQGAN \\[ [16])\\] which builds the autoregressive model with a transformer \\[ [55])\\]. Vector quantization, has been shown to be an efficient way for generating high resolution images. We study how VQ can be used in the 3D domain, specifically, _neural fields_ for 3D shapes.\n\nThere are some works adopting VQVAE to the 3D domain. Canonical Mapping \\[ [8])\\] proposes point cloud generation models with VQVAE. In concurrent work, AutoSDF \\[ [32])\\] generalizes VQVAE to 3D voxels. However, the bottleneck latent grid resolution is low and it is difficult to capture details as in ConvONet and IF-Net. Increasing the resolution is the key for detailed 3D shape reconstruction. On the other hand, higher resolution leads to more difficult training of autoregressive transformers. Another concurrent work, ShapeFormer \\[ [64])\\], shows a solution by sparsifying latent grids. However, ShapeFormer still only accepts voxel grids as input (point clouds need to be voxelized). Additionally, the sequence length varies for different shapes, requiring the method to go through a whole dataset to find a maximum sequence length. This relies on dataset-dependent maximum sequence lengths.\nIn contrast to existing works, our method processes point clouds directly, learns fixed-size latents and outputs neural fields. A comparison summary can be found in Table [1]Table 1 ‣ 2.2 Generative models ‣ 2 Related Work ‣ 3DILG: Irregular Latent Grids for 3D Generative Modeling\").\n\nTable 1: Method comparison. All methods here take point clouds as input. If the column Requiring Voxelization says yes, it means the method takes voxels as input. The numbers shown in parenthesis are alternative choices of hyperparameters.\n\n|  | Local | Requiring | Output | Latent | Vector | Sequence | Comments |\n|  | Latents | Voxelization | Resolution | Quantization | Length |\n| OccNet \\[ [29])\\] | ✗ | ✗ | Fields | 1 | ✗ | 1 |  |\n| ConvONet \\[ [39])\\] | ✓ | ✓ | Fields | 323superscript32332^{3}(643superscript64364^{3}) | ✗ | 323superscript32332^{3}(643superscript64364^{3}) |  |\n| IF-Net \\[ [9])\\] | ✓ | ✓ | Fields | 1283superscript1283128^{3} | ✗ | 1283superscript1283128^{3} | Multiscale |\n| AutoSDF \\[ [32])\\] | ✓ | ✓ | Voxels | 83superscript838^{3} | ✓ | 83superscript838^{3} |  |\n| CanMap\\[ [8])\\] | ✓ | ✗ | Point Cloud | 128 | ✓ | 128 |  |\n| ShapeFormer \\[ [64])\\] | ✓ | ✓ | Fields | 163superscript16316^{3}(323superscript32332^{3}) | ✓ | variable | Sparsification |\n| 3DILG (Ours) | ✓ | ✗ | Fields | 512 | ✓ | 512 |  |",
            "citations": null
          },
          "3 Shape Reconstruction": {
            "content": "![Refer to caption]𝐳(0)superscript𝐳0\\\\mathbf{z}^{(0)}⋯⋯\\\\cdots![Refer to caption]𝐳(l)superscript𝐳𝑙\\\\mathbf{z}^{(l)}![Refer to caption]𝐳^(l)superscript^𝐳𝑙\\\\mathbf{\\\\hat{z}}^{(l)}VQ⋯⋯\\\\cdots![Refer to caption]𝐳(L)superscript𝐳𝐿\\\\mathbf{z}^{(L)}Transformer Blocks![Refer to caption]𝐳(0)superscript𝐳0\\\\mathbf{z}^{(0)}⋯⋯\\\\cdots![Refer to caption]𝐳(l)superscript𝐳𝑙\\\\mathbf{z}^{(l)}⋯⋯\\\\cdots![Refer to caption]𝐳(L)superscript𝐳𝐿\\\\mathbf{z}^{(L)}Transformer Blocks![Refer to caption]ℝN×3superscriptℝ𝑁3\\\\mathbb{R}^{N\\\\times 3}![Refer to caption]ℝM×3superscriptℝ𝑀3\\\\mathbb{R}^{M\\\\times 3}FPS![Refer to caption]ℝM×K×3superscriptℝ𝑀𝐾3\\\\mathbb{R}^{M\\\\times K\\\\times 3}KNN![Refer to caption]ℝM×Csuperscriptℝ𝑀𝐶\\\\mathbb{R}^{M\\\\times C}PointNet![Refer to caption]ℝM×Csuperscriptℝ𝑀𝐶\\\\mathbb{R}^{M\\\\times C}Transformer![Refer to caption]ℝ3→\\[0,1\\]→superscriptℝ301\\\\mathbb{R}^{3}\\\\rightarrow\\[0,1\\]Reconstruction\n\nFigure 3: Shape reconstruction from point clouds.Left: the main pipeline. The framework can be used with (Bottom Right) or without (Top Right) vector quantization.\n\nHere we build a shape autoencoding method. Given a shape surface, we want to output the same shape surface. We preprocess a shape surface via uniform sampling to a point cloud\n{𝐱i:𝐱i∈ℝ3}i∈𝒩subscriptconditional-setsubscript𝐱𝑖subscript𝐱𝑖superscriptℝ3𝑖𝒩\\\\{\\\\mathbf{x}\\_{i}\\\\colon\\\\mathbf{x}\\_{i}\\\\in\\\\mathbb{R}^{3}\\\\}\\_{i\\\\in\\\\mathcal{N}} (also in matrix form 𝐗∈ℝN×3𝐗superscriptℝ𝑁3\\\\mathbf{X}\\\\in\\\\mathbb{R}^{N\\\\times 3}), our goal is to predict the indicator function 𝒪​(⋅):ℝ3→\\[0,1\\]:𝒪⋅→superscriptℝ301\\\\mathcal{O}(\\\\cdot):\\\\mathbb{R}^{3}\\\\rightarrow\\[0,1\\] corresponding to the volume represented by the point cloud.\nOur representation is being generated in three steps (See Fig. [3]Figure 3 ‣ 3 Shape Reconstruction ‣ 3DILG: Irregular Latent Grids for 3D Generative Modeling\")): patch construction (Sec. [3.1]Patch Construction ‣ 3 Shape Reconstruction ‣ 3DILG: Irregular Latent Grids for 3D Generative Modeling\")), patch information processing (Sec. [3.2]Transformer ‣ 3 Shape Reconstruction ‣ 3DILG: Irregular Latent Grids for 3D Generative Modeling\")), and reconstruction (Sec. [3.3]Reconstruction ‣ 3 Shape Reconstruction ‣ 3DILG: Irregular Latent Grids for 3D Generative Modeling\")).\n\n### 3.1 Patch Construction\n\nWe sub-sample the input point cloud via Farthest Point Sampling (FPS),\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | FPS​({𝐱i}i∈𝒩)={𝐱i}i∈ℳ=𝐗ℳ∈ℝM×3,FPSsubscriptsubscript𝐱𝑖𝑖𝒩subscriptsubscript𝐱𝑖𝑖ℳsubscript𝐗ℳsuperscriptℝ𝑀3\\\\raisebox{-4.0pt}{ \\\\leavevmode\\\\hbox to25.75pt{\\\\vbox to13.7pt{\\\\pgfpicture\\\\makeatletter\\\\hbox{\\\\hskip 12.87747pt\\\\lower-6.84966pt\\\\hbox to0.0pt{\\\\pgfsys@beginscope\\\\pgfsys@invoke{ }\\\\definecolor{pgfstrokecolor}{rgb}{0,0,0}\\\\pgfsys@color@rgb@stroke{0}{0}{0}\\\\pgfsys@invoke{ }\\\\pgfsys@color@rgb@fill{0}{0}{0}\\\\pgfsys@invoke{ }\\\\pgfsys@setlinewidth{0.4pt}\\\\pgfsys@invoke{ }\\\\nullfont\\\\pgfsys@beginscope\\\\pgfsys@invoke{ }\\\\pgfsys@invoke{\\\\lxSVG@closescope }\\\\pgfsys@endscope\\\\hbox to0.0pt{\\\\pgfsys@beginscope\\\\pgfsys@invoke{ }{\\\\definecolor{wwccqq}{rgb}{0.4,0.8,0} {{}}\\\\hbox{\\\\hbox{{\\\\pgfsys@beginscope\\\\pgfsys@invoke{ }\\\\definecolor{pgfstrokecolor}{rgb}{0.52,0.84,0.2}\\\\pgfsys@color@rgb@stroke{0.52}{0.84}{0.2}\\\\pgfsys@invoke{ }\\\\pgfsys@setlinewidth{0.2pt}\\\\pgfsys@invoke{ }\\\\definecolor{pgffillcolor}{rgb}{0.88,0.96,0.8}\\\\pgfsys@color@rgb@fill{0.88}{0.96}{0.8}\\\\pgfsys@invoke{ }{{}{}{{<br>{}{}}}{<br>{}{}}<br>{{}{{}}}{{}{}}{}{{}{}}<br>{\\\\pgfsys@beginscope\\\\pgfsys@invoke{ }\\\\definecolor{pgfstrokecolor}{rgb}{0.52,0.84,0.2}\\\\pgfsys@color@rgb@stroke{0.52}{0.84}{0.2}\\\\pgfsys@invoke{ }\\\\pgfsys@setlinewidth{0.2pt}\\\\pgfsys@invoke{ }\\\\definecolor{pgffillcolor}{rgb}{0.88,0.96,0.8}\\\\pgfsys@color@rgb@fill{0.88}{0.96}{0.8}\\\\pgfsys@invoke{ }{}\\\\pgfsys@rect{-12.77748pt}{-6.74966pt}{25.55496pt}{13.49933pt}\\\\pgfsys@fillstroke\\\\pgfsys@invoke{ }<br>\\\\pgfsys@invoke{\\\\lxSVG@closescope }\\\\pgfsys@endscope}{{{{}}\\\\pgfsys@beginscope\\\\pgfsys@invoke{ }\\\\pgfsys@transformcm{1.0}{0.0}{0.0}{1.0}{-9.44447pt}{-3.41666pt}\\\\pgfsys@invoke{ }\\\\hbox{{\\\\definecolor{pgfstrokecolor}{rgb}{0,0,0}\\\\pgfsys@color@rgb@stroke{0}{0}{0}\\\\pgfsys@invoke{ }\\\\pgfsys@color@rgb@fill{0}{0}{0}\\\\pgfsys@invoke{ }\\\\hbox{{FPS}}<br>}}\\\\pgfsys@invoke{\\\\lxSVG@closescope }\\\\pgfsys@endscope}}}<br>\\\\pgfsys@invoke{\\\\lxSVG@closescope }\\\\pgfsys@endscope}}}<br>}<br>\\\\pgfsys@invoke{\\\\lxSVG@closescope }\\\\pgfsys@endscope{}{}{}\\\\hss}\\\\pgfsys@discardpath\\\\pgfsys@invoke{\\\\lxSVG@closescope }\\\\pgfsys@endscope\\\\hss}}\\\\lxSVG@closescope\\\\endpgfpicture}}}\\\\left(\\\\{\\\\mathbf{x}\\_{i}\\\\}\\_{i\\\\in\\\\mathcal{N}}\\\\right)=\\\\{\\\\mathbf{x}\\_{i}\\\\}\\_{i\\\\in\\\\mathcal{M}}=\\\\mathbf{X}\\_{\\\\mathcal{M}}\\\\in\\\\mathbb{R}^{M\\\\times 3}, |  | (1) |\n\nwhere ℳ⊂𝒩ℳ𝒩\\\\mathcal{M}\\\\subset\\\\mathcal{N} and \\|ℳ\\|=Mℳ𝑀\\|\\\\mathcal{M}\\|=M. Next, for each point in the sub-sampled point set {𝐱i}i∈ℳsubscriptsubscript𝐱𝑖𝑖ℳ\\\\{\\\\mathbf{x}\\_{i}\\\\}\\_{i\\\\in\\\\mathcal{M}}, we apply the K-nearest neighbor (KNN) algorithm to find K−1𝐾1K-1 points to form a point patch of size K𝐾K,\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | ∀i∈ℳ,KNN​(𝐱i)={𝐱j}j∈𝒩i,formulae-sequencefor-all𝑖ℳKNNsubscript𝐱𝑖subscriptsubscript𝐱𝑗𝑗subscript𝒩𝑖\\\\forall i\\\\in\\\\mathcal{M},\\\\quad\\\\raisebox{-4.0pt}{ \\\\leavevmode\\\\hbox to29.64pt{\\\\vbox to13.7pt{\\\\pgfpicture\\\\makeatletter\\\\hbox{\\\\hskip 14.82191pt\\\\lower-6.84966pt\\\\hbox to0.0pt{\\\\pgfsys@beginscope\\\\pgfsys@invoke{ }\\\\definecolor{pgfstrokecolor}{rgb}{0,0,0}\\\\pgfsys@color@rgb@stroke{0}{0}{0}\\\\pgfsys@invoke{ }\\\\pgfsys@color@rgb@fill{0}{0}{0}\\\\pgfsys@invoke{ }\\\\pgfsys@setlinewidth{0.4pt}\\\\pgfsys@invoke{ }\\\\nullfont\\\\pgfsys@beginscope\\\\pgfsys@invoke{ }\\\\pgfsys@invoke{\\\\lxSVG@closescope }\\\\pgfsys@endscope\\\\hbox to0.0pt{\\\\pgfsys@beginscope\\\\pgfsys@invoke{ }{\\\\definecolor{ffzzcc}{rgb}{1,0.6,0.8} {{}}\\\\hbox{\\\\hbox{{\\\\pgfsys@beginscope\\\\pgfsys@invoke{ }\\\\definecolor{pgfstrokecolor}{rgb}{1,0.68,0.84}\\\\pgfsys@color@rgb@stroke{1}{0.68}{0.84}\\\\pgfsys@invoke{ }\\\\pgfsys@setlinewidth{0.2pt}\\\\pgfsys@invoke{ }\\\\definecolor{pgffillcolor}{rgb}{1,0.92,0.96}\\\\pgfsys@color@rgb@fill{1}{0.92}{0.96}\\\\pgfsys@invoke{ }{{}{}{{<br>{}{}}}{<br>{}{}}<br>{{}{{}}}{{}{}}{}{{}{}}<br>{\\\\pgfsys@beginscope\\\\pgfsys@invoke{ }\\\\definecolor{pgfstrokecolor}{rgb}{1,0.68,0.84}\\\\pgfsys@color@rgb@stroke{1}{0.68}{0.84}\\\\pgfsys@invoke{ }\\\\pgfsys@setlinewidth{0.2pt}\\\\pgfsys@invoke{ }\\\\definecolor{pgffillcolor}{rgb}{1,0.92,0.96}\\\\pgfsys@color@rgb@fill{1}{0.92}{0.96}\\\\pgfsys@invoke{ }{}\\\\pgfsys@rect{-14.72192pt}{-6.74966pt}{29.44385pt}{13.49933pt}\\\\pgfsys@fillstroke\\\\pgfsys@invoke{ }<br>\\\\pgfsys@invoke{\\\\lxSVG@closescope }\\\\pgfsys@endscope}{{{{}}\\\\pgfsys@beginscope\\\\pgfsys@invoke{ }\\\\pgfsys@transformcm{1.0}{0.0}{0.0}{1.0}{-11.38892pt}{-3.41666pt}\\\\pgfsys@invoke{ }\\\\hbox{{\\\\definecolor{pgfstrokecolor}{rgb}{0,0,0}\\\\pgfsys@color@rgb@stroke{0}{0}{0}\\\\pgfsys@invoke{ }\\\\pgfsys@color@rgb@fill{0}{0}{0}\\\\pgfsys@invoke{ }\\\\hbox{{KNN}}<br>}}\\\\pgfsys@invoke{\\\\lxSVG@closescope }\\\\pgfsys@endscope}}}<br>\\\\pgfsys@invoke{\\\\lxSVG@closescope }\\\\pgfsys@endscope}}}<br>}<br>\\\\pgfsys@invoke{\\\\lxSVG@closescope }\\\\pgfsys@endscope{}{}{}\\\\hss}\\\\pgfsys@discardpath\\\\pgfsys@invoke{\\\\lxSVG@closescope }\\\\pgfsys@endscope\\\\hss}}\\\\lxSVG@closescope\\\\endpgfpicture}}}\\\\left(\\\\mathbf{x}\\_{i}\\\\right)=\\\\{\\\\mathbf{x}\\_{j}\\\\}\\_{j\\\\in\\\\mathcal{N}\\_{i}}, |  | (2) |\n\nwhere 𝒩isubscript𝒩𝑖\\\\mathcal{N}\\_{i} is the neighbor index set for point 𝐱isubscript𝐱𝑖\\\\mathbf{x}\\_{i} and \\|𝒩i\\|=K−1subscript𝒩𝑖𝐾1\\|\\\\mathcal{N}\\_{i}\\|=K-1. Thus we have a collection of point patches,\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | {(𝐱i,{𝐱j}j∈𝒩i):\\|𝒩i\\|=K−1}i∈ℳ=𝐗ℳ,K∈ℝM×K×3.subscriptconditional-setsubscript𝐱𝑖subscriptsubscript𝐱𝑗𝑗subscript𝒩𝑖subscript𝒩𝑖𝐾1𝑖ℳsubscript𝐗ℳ𝐾superscriptℝ𝑀𝐾3\\\\{\\\\left(\\\\mathbf{x}\\_{i},\\\\{\\\\mathbf{x}\\_{j}\\\\}\\_{j\\\\in\\\\mathcal{N}\\_{i}}\\\\right)\\\\colon\\|\\\\mathcal{N}\\_{i}\\|=K-1\\\\}\\_{i\\\\in\\\\mathcal{M}}=\\\\mathbf{X}\\_{\\\\mathcal{M},K}\\\\in\\\\mathbb{R}^{M\\\\times K\\\\times 3}. |  | (3) |\n\nWe project each patch with a mini-PointNet-like \\[ [40])\\] module to an embedding vector\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | ∀i∈ℳ,PointNet​(𝐱i,{𝐱j}j∈𝒩i)=𝐞i∈ℝC,formulae-sequencefor-all𝑖ℳPointNetsubscript𝐱𝑖subscriptsubscript𝐱𝑗𝑗subscript𝒩𝑖subscript𝐞𝑖superscriptℝ𝐶\\\\forall i\\\\in\\\\mathcal{M},\\\\quad\\\\raisebox{-4.0pt}{ \\\\leavevmode\\\\hbox to46.17pt{\\\\vbox to13.7pt{\\\\pgfpicture\\\\makeatletter\\\\hbox{\\\\hskip 23.08582pt\\\\lower-6.84966pt\\\\hbox to0.0pt{\\\\pgfsys@beginscope\\\\pgfsys@invoke{ }\\\\definecolor{pgfstrokecolor}{rgb}{0,0,0}\\\\pgfsys@color@rgb@stroke{0}{0}{0}\\\\pgfsys@invoke{ }\\\\pgfsys@color@rgb@fill{0}{0}{0}\\\\pgfsys@invoke{ }\\\\pgfsys@setlinewidth{0.4pt}\\\\pgfsys@invoke{ }\\\\nullfont\\\\pgfsys@beginscope\\\\pgfsys@invoke{ }\\\\pgfsys@invoke{\\\\lxSVG@closescope }\\\\pgfsys@endscope\\\\hbox to0.0pt{\\\\pgfsys@beginscope\\\\pgfsys@invoke{ }{\\\\definecolor{orange}{RGB}{255,204,51} {{}}\\\\hbox{\\\\hbox{{\\\\pgfsys@beginscope\\\\pgfsys@invoke{ }\\\\definecolor{pgfstrokecolor}{rgb}{1,0.840625,0.359375}\\\\pgfsys@color@rgb@stroke{1}{0.840625}{0.359375}\\\\pgfsys@invoke{ }\\\\pgfsys@setlinewidth{0.2pt}\\\\pgfsys@invoke{ }\\\\definecolor{pgffillcolor}{rgb}{1,0.96015625,0.83984375}\\\\pgfsys@color@rgb@fill{1}{0.96015625}{0.83984375}\\\\pgfsys@invoke{ }{{}{}{{<br>{}{}}}{<br>{}{}}<br>{{}{{}}}{{}{}}{}{{}{}}<br>{\\\\pgfsys@beginscope\\\\pgfsys@invoke{ }\\\\definecolor{pgfstrokecolor}{rgb}{1,0.840625,0.359375}\\\\pgfsys@color@rgb@stroke{1}{0.840625}{0.359375}\\\\pgfsys@invoke{ }\\\\pgfsys@setlinewidth{0.2pt}\\\\pgfsys@invoke{ }\\\\definecolor{pgffillcolor}{rgb}{1,0.96015625,0.83984375}\\\\pgfsys@color@rgb@fill{1}{0.96015625}{0.83984375}\\\\pgfsys@invoke{ }{}\\\\pgfsys@rect{-22.98582pt}{-6.74966pt}{45.97165pt}{13.49933pt}\\\\pgfsys@fillstroke\\\\pgfsys@invoke{ }<br>\\\\pgfsys@invoke{\\\\lxSVG@closescope }\\\\pgfsys@endscope}{{{{}}\\\\pgfsys@beginscope\\\\pgfsys@invoke{ }\\\\pgfsys@transformcm{1.0}{0.0}{0.0}{1.0}{-19.65282pt}{-3.41666pt}\\\\pgfsys@invoke{ }\\\\hbox{{\\\\definecolor{pgfstrokecolor}{rgb}{0,0,0}\\\\pgfsys@color@rgb@stroke{0}{0}{0}\\\\pgfsys@invoke{ }\\\\pgfsys@color@rgb@fill{0}{0}{0}\\\\pgfsys@invoke{ }\\\\hbox{{PointNet}}<br>}}\\\\pgfsys@invoke{\\\\lxSVG@closescope }\\\\pgfsys@endscope}}}<br>\\\\pgfsys@invoke{\\\\lxSVG@closescope }\\\\pgfsys@endscope}}}<br>}<br>\\\\pgfsys@invoke{\\\\lxSVG@closescope }\\\\pgfsys@endscope{}{}{}\\\\hss}\\\\pgfsys@discardpath\\\\pgfsys@invoke{\\\\lxSVG@closescope }\\\\pgfsys@endscope\\\\hss}}\\\\lxSVG@closescope\\\\endpgfpicture}}}\\\\left(\\\\mathbf{x}\\_{i},\\\\{\\\\mathbf{x}\\_{j}\\\\}\\_{j\\\\in\\\\mathcal{N}\\_{i}}\\\\right)=\\\\mathbf{e}\\_{i}\\\\in\\\\mathbb{R}^{C}, |  | (4) |\n\nwhere C𝐶C is the embedding dimension for patches.\n\n### 3.2 Transformer\n\nFurthermore, we build a transformer to learn local latents\n{𝐳i}i∈ℳsubscriptsubscript𝐳𝑖𝑖ℳ\\\\{\\\\mathbf{z}\\_{i}\\\\}\\_{i\\\\in\\\\mathcal{M}}. The point coordinates {𝐱i}i∈ℳsubscriptsubscript𝐱𝑖𝑖ℳ\\\\{\\\\mathbf{x}\\_{i}\\\\}\\_{i\\\\in\\\\mathcal{M}} are converted to positional embeddings (PEs) \\[ [31])\\],\n𝐩i=PE​(𝐱i)∈ℝCsubscript𝐩𝑖PEsubscript𝐱𝑖superscriptℝ𝐶\\\\mathbf{p}\\_{i}=\\\\mathrm{PE}(\\\\mathbf{x}\\_{i})\\\\in\\\\mathbb{R}^{C},\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | PE​(𝐱)=\\[sin⁡(20​𝐱),cos⁡(20​𝐱),sin⁡(21​𝐱),cos⁡(21​𝐱),⋯,sin⁡(27​𝐱),cos⁡(27​𝐱)\\].PE𝐱superscript20𝐱superscript20𝐱superscript21𝐱superscript21𝐱⋯superscript27𝐱superscript27𝐱\\\\mathrm{PE}(\\\\mathbf{x})=\\[\\\\sin(2^{0}\\\\mathbf{x}),\\\\cos(2^{0}\\\\mathbf{x}),\\\\sin(2^{1}\\\\mathbf{x}),\\\\cos(2^{1}\\\\mathbf{x}),\\\\cdots,\\\\sin(2^{7}\\\\mathbf{x}),\\\\cos(2^{7}\\\\mathbf{x})\\]. |  | (5) |\n\nOur transformer takes as input the sequence of patch-PE pairs,\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | Transformer​({(𝐞i,𝐩i)}i∈ℳ)={𝐳i:𝐳i∈ℝC}i∈ℳ.Transformersubscriptsubscript𝐞𝑖subscript𝐩𝑖𝑖ℳsubscriptconditional-setsubscript𝐳𝑖subscript𝐳𝑖superscriptℝ𝐶𝑖ℳ\\\\raisebox{-4.0pt}{ \\\\leavevmode\\\\hbox to60.34pt{\\\\vbox to13.81pt{\\\\pgfpicture\\\\makeatletter\\\\hbox{\\\\hskip 30.16916pt\\\\lower-6.90521pt\\\\hbox to0.0pt{\\\\pgfsys@beginscope\\\\pgfsys@invoke{ }\\\\definecolor{pgfstrokecolor}{rgb}{0,0,0}\\\\pgfsys@color@rgb@stroke{0}{0}{0}\\\\pgfsys@invoke{ }\\\\pgfsys@color@rgb@fill{0}{0}{0}\\\\pgfsys@invoke{ }\\\\pgfsys@setlinewidth{0.4pt}\\\\pgfsys@invoke{ }\\\\nullfont\\\\pgfsys@beginscope\\\\pgfsys@invoke{ }\\\\pgfsys@invoke{\\\\lxSVG@closescope }\\\\pgfsys@endscope\\\\hbox to0.0pt{\\\\pgfsys@beginscope\\\\pgfsys@invoke{ }{\\\\definecolor{violet}{RGB}{125,125,255} {{}}\\\\hbox{\\\\hbox{{\\\\pgfsys@beginscope\\\\pgfsys@invoke{ }\\\\definecolor{pgfstrokecolor}{rgb}{0.590625,0.590625,1}\\\\pgfsys@color@rgb@stroke{0.590625}{0.590625}{1}\\\\pgfsys@invoke{ }\\\\pgfsys@setlinewidth{0.2pt}\\\\pgfsys@invoke{ }\\\\definecolor{pgffillcolor}{rgb}{0.89765625,0.89765625,1}\\\\pgfsys@color@rgb@fill{0.89765625}{0.89765625}{1}\\\\pgfsys@invoke{ }{{}{}{{<br>{}{}}}{<br>{}{}}<br>{{}{{}}}{{}{}}{}{{}{}}<br>{\\\\pgfsys@beginscope\\\\pgfsys@invoke{ }\\\\definecolor{pgfstrokecolor}{rgb}{0.590625,0.590625,1}\\\\pgfsys@color@rgb@stroke{0.590625}{0.590625}{1}\\\\pgfsys@invoke{ }\\\\pgfsys@setlinewidth{0.2pt}\\\\pgfsys@invoke{ }\\\\definecolor{pgffillcolor}{rgb}{0.89765625,0.89765625,1}\\\\pgfsys@color@rgb@fill{0.89765625}{0.89765625}{1}\\\\pgfsys@invoke{ }{}\\\\pgfsys@rect{-30.06917pt}{-6.80522pt}{60.13834pt}{13.61044pt}\\\\pgfsys@fillstroke\\\\pgfsys@invoke{ }<br>\\\\pgfsys@invoke{\\\\lxSVG@closescope }\\\\pgfsys@endscope}{{{{}}\\\\pgfsys@beginscope\\\\pgfsys@invoke{ }\\\\pgfsys@transformcm{1.0}{0.0}{0.0}{1.0}{-26.73616pt}{-3.47221pt}\\\\pgfsys@invoke{ }\\\\hbox{{\\\\definecolor{pgfstrokecolor}{rgb}{0,0,0}\\\\pgfsys@color@rgb@stroke{0}{0}{0}\\\\pgfsys@invoke{ }\\\\pgfsys@color@rgb@fill{0}{0}{0}\\\\pgfsys@invoke{ }\\\\hbox{{Transformer}}<br>}}\\\\pgfsys@invoke{\\\\lxSVG@closescope }\\\\pgfsys@endscope}}}<br>\\\\pgfsys@invoke{\\\\lxSVG@closescope }\\\\pgfsys@endscope}}}<br>}<br>\\\\pgfsys@invoke{\\\\lxSVG@closescope }\\\\pgfsys@endscope{}{}{}\\\\hss}\\\\pgfsys@discardpath\\\\pgfsys@invoke{\\\\lxSVG@closescope }\\\\pgfsys@endscope\\\\hss}}\\\\lxSVG@closescope\\\\endpgfpicture}}}\\\\left(\\\\{(\\\\mathbf{e}\\_{i},\\\\mathbf{p}\\_{i})\\\\}\\_{i\\\\in\\\\mathcal{M}}\\\\right)=\\\\{\\\\mathbf{z}\\_{i}\\\\colon\\\\mathbf{z}\\_{i}\\\\in\\\\mathbb{R}^{C}\\\\}\\_{i\\\\in\\\\mathcal{M}}. |  | (6) |\n\nThe transformer is composed of L𝐿L blocks. We denote the intermediate outputs of all blocks as\n𝐳i(0),𝐳i(1),⋯,𝐳i(l),⋯,𝐳i(L)subscriptsuperscript𝐳0𝑖subscriptsuperscript𝐳1𝑖⋯subscriptsuperscript𝐳𝑙𝑖⋯subscriptsuperscript𝐳𝐿𝑖\\\\mathbf{z}^{(0)}\\_{i},\\\\mathbf{z}^{(1)}\\_{i},\\\\cdots,\\\\mathbf{z}^{(l)}\\_{i},\\\\cdots,\\\\mathbf{z}^{(L)}\\_{i},\nwhere 𝐳i(0)subscriptsuperscript𝐳0𝑖\\\\mathbf{z}^{(0)}\\_{i} is the input 𝐞isubscript𝐞𝑖\\\\mathbf{e}\\_{i} and 𝐳i(L)subscriptsuperscript𝐳𝐿𝑖\\\\mathbf{z}^{(L)}\\_{i} is the output 𝐳isubscript𝐳𝑖\\\\mathbf{z}\\_{i}.\n\n#### Vector Quantization.\n\nThis model can be used with vector quantization \\[ [53])\\]. We simply replace the intermediate output at block l𝑙l with its closest vector in a dictionary 𝒟𝒟\\\\mathcal{D},\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | ∀i∈ℳ,arg​min𝐳^i(l)∈𝒟⁡‖𝐳^i(l)−𝐳i(l)‖.for-all𝑖ℳsubscriptargminsubscriptsuperscript^𝐳𝑙𝑖𝒟normsubscriptsuperscript^𝐳𝑙𝑖subscriptsuperscript𝐳𝑙𝑖\\\\forall i\\\\in\\\\mathcal{M},\\\\quad\\\\operatorname\\*{arg\\\\,min}\\_{\\\\mathbf{\\\\hat{z}}^{(l)}\\_{i}\\\\in\\\\mathcal{D}}\\\\left\\\\\\|\\\\mathbf{\\\\hat{z}}^{(l)}\\_{i}-\\\\mathbf{z}^{(l)}\\_{i}\\\\right\\\\\\|. |  | (7) |\n\nThe dictionary 𝒟𝒟\\\\mathcal{D} contains \\|𝒟\\|=D𝒟𝐷\\|\\\\mathcal{D}\\|=D vectors. As in VQVAE \\[ [53])\\], the gradient with respect to 𝐳i(l)subscriptsuperscript𝐳𝑙𝑖\\\\mathbf{z}^{(l)}\\_{i} is approximated with the straight-through estimator \\[ [1])\\].\n\n### 3.3 Reconstruction\n\nWe expect that each latent 𝐳isubscript𝐳𝑖\\\\mathbf{z}\\_{i} is responsible for shape reconstruction near the point 𝐱isubscript𝐱𝑖\\\\mathbf{x}\\_{i}. However, our goal is to estimate 𝒪​(⋅)𝒪⋅\\\\mathcal{O}(\\\\cdot) for an arbitrary 𝐱∈ℝ3𝐱superscriptℝ3\\\\mathbf{x}\\\\in\\\\mathbb{R}^{3}. We interpolate latent 𝐳𝐱subscript𝐳𝐱\\\\mathbf{z}\\_{\\\\mathbf{x}} for point 𝐱𝐱\\\\mathbf{x} with the Nadaraya-Watson estimator,\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | 𝐳𝐱=∑i∈ℳexp⁡(−β​‖𝐱−𝐱i‖2)​𝐳i∑i∈ℳexp⁡(−β​‖𝐱−𝐱i‖2),subscript𝐳𝐱subscript𝑖ℳ𝛽superscriptnorm𝐱subscript𝐱𝑖2subscript𝐳𝑖subscript𝑖ℳ𝛽superscriptnorm𝐱subscript𝐱𝑖2\\\\mathbf{z}\\_{\\\\mathbf{x}}=\\\\frac{\\\\sum\\_{i\\\\in\\\\mathcal{M}}\\\\exp(-\\\\beta\\\\\\|\\\\mathbf{x}-\\\\mathbf{x}\\_{i}\\\\\\|^{2})\\\\mathbf{z}\\_{i}}{\\\\sum\\_{i\\\\in\\\\mathcal{M}}\\\\exp(-\\\\beta\\\\\\|\\\\mathbf{x}-\\\\mathbf{x}\\_{i}\\\\\\|^{2})}, |  | (8) |\n\nwhere β𝛽\\\\beta controls the smoothness of interpolation and can be fixed or learned.\nThe final indicator is an MLP with a sigmoid activation,\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | 𝒪^​(𝐱)=Sigmoid​(MLP​(𝐱,𝐳𝐱)).^𝒪𝐱SigmoidMLP𝐱subscript𝐳𝐱\\\\mathcal{\\\\hat{O}}(\\\\mathbf{x})=\\\\mathrm{Sigmoid}(\\\\mathrm{MLP}(\\\\mathbf{x},\\\\mathbf{z}\\_{\\\\mathbf{x}})). |  | (9) |\n\n#### Loss Function.\n\nWe optimize the estimated 𝒪^​(⋅)^𝒪⋅\\\\mathcal{\\\\hat{O}}(\\\\cdot) by comparing to ground-truth 𝒪​(⋅)𝒪⋅\\\\mathcal{O}(\\\\cdot) via a binary cross entropy loss (BCE) and an additional commitment loss term \\[ [53])\\],\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | ℒ=ℒrecon+λ​ℒcommit=𝔼𝐱∈ℝ3​\\[BCE​(𝒪^​(𝐱),𝒪​(𝐱))\\]+λ​𝔼𝐱∈ℝ3​\\[𝔼i∈ℳ​‖sg​(𝐳^i(l))−𝐳i(l)‖2\\],ℒsubscriptℒrecon𝜆subscriptℒcommitsubscript𝔼𝐱superscriptℝ3delimited-\\[\\]BCE^𝒪𝐱𝒪𝐱𝜆subscript𝔼𝐱superscriptℝ3delimited-\\[\\]subscript𝔼𝑖ℳsuperscriptnormsgsubscriptsuperscript^𝐳𝑙𝑖subscriptsuperscript𝐳𝑙𝑖2\\\\mathcal{L}=\\\\mathcal{L}\\_{\\\\text{recon}}+\\\\lambda\\\\mathcal{L}\\_{\\\\text{commit}}=\\\\mathbb{E}\\_{\\\\mathbf{x}\\\\in\\\\mathbb{R}^{3}}\\\\left\\[\\\\mathrm{BCE}(\\\\mathcal{\\\\hat{O}}(\\\\mathbf{x}),\\\\mathcal{O}(\\\\mathbf{x}))\\\\right\\]+\\\\lambda\\\\mathbb{E}\\_{\\\\mathbf{x}\\\\in\\\\mathbb{R}^{3}}\\\\left\\[\\\\mathbb{E}\\_{i\\\\in\\\\mathcal{M}}\\\\left\\\\\\|\\\\mathrm{sg}(\\\\mathbf{\\\\hat{z}}^{(l)}\\_{i})-\\\\mathbf{z}^{(l)}\\_{i}\\\\right\\\\\\|^{2}\\\\right\\], |  | (10) |\n\nwhere sg​(⋅)sg⋅\\\\mathrm{sg}(\\\\cdot) is the stop-gradient operation. When λ=0𝜆0\\\\lambda=0, it means we train the model without vector quantization.",
            "citations": null
          },
          "4 Autoregressive Generative Modeling": {
            "content": "𝒞𝒞\\\\mathcal{C}𝐨0subscript𝐨0\\\\mathbf{o}\\_{0}𝐨1subscript𝐨1\\\\mathbf{o}\\_{1}𝐨2subscript𝐨2\\\\mathbf{o}\\_{2}\n\n⋮⋮\\\\vdots\n\nTransformer\n\n𝐨0subscript𝐨0\\\\mathbf{o}\\_{0}𝐨1subscript𝐨1\\\\mathbf{o}\\_{1}𝐨2subscript𝐨2\\\\mathbf{o}\\_{2}𝐨3subscript𝐨3\\\\mathbf{o}\\_{3}\n\n⋮⋮\\\\vdots\n\n𝒞𝒞\\\\mathcal{C}z0subscript𝑧0z\\_{0}z1subscript𝑧1z\\_{1}z2subscript𝑧2z\\_{2}⋮⋮\\\\vdotsx0,3subscript𝑥03x\\_{0,3}x1,3subscript𝑥13x\\_{1,3}x2,3subscript𝑥23x\\_{2,3}x0,2subscript𝑥02x\\_{0,2}x1,2subscript𝑥12x\\_{1,2}x2,2subscript𝑥22x\\_{2,2}x0,1subscript𝑥01x\\_{0,1}x1,1subscript𝑥11x\\_{1,1}x2,1subscript𝑥21x\\_{2,1}\n\nTransformer Blocks\n\nx0,1subscript𝑥01x\\_{0,1}x1,1subscript𝑥11x\\_{1,1}x2,1subscript𝑥21x\\_{2,1}x3,1subscript𝑥31x\\_{3,1}⋮⋮\\\\vdots\n\nTransformer Blocks\n\nx0,2subscript𝑥02x\\_{0,2}x1,2subscript𝑥12x\\_{1,2}x2,2subscript𝑥22x\\_{2,2}x3,2subscript𝑥32x\\_{3,2}⋮⋮\\\\vdots\n\nTransformer Blocks\n\nx0,3subscript𝑥03x\\_{0,3}x1,3subscript𝑥13x\\_{1,3}x2,3subscript𝑥23x\\_{2,3}x3,3subscript𝑥33x\\_{3,3}⋮⋮\\\\vdots\n\nTransformer Blocks\n\nz0subscript𝑧0z\\_{0}z1subscript𝑧1z\\_{1}z2subscript𝑧2z\\_{2}z3subscript𝑧3z\\_{3}⋮⋮\\\\vdots\n\nFigure 4: Autoregressive Generative Models with Unidirectional Transformer.Left: sequence prediction. Right: detailed visualizations with sequence element components.\\\\begin{overpic}\\[trim=0.0pt 56.9055pt 0.0pt 0.0pt,clip,width=433.62pt,grid=false\\]{images/maskgit\\_l.jpg}\n\\\\put(48.0,17.0){\\\\tiny{Steps}}\n\\\\put(10.0,16.0){\\\\vector(1,0){82.0}}\n\\\\end{overpic}Figure 5: Autoregressive Generative Models with Bidirectional Transformer.Cubes (□□\\\\Box) are predicted tokens.\nFrom left to right, we show 888 decoding steps.\n\nWith Vector Quantization (Eq. [7]In Vector Quantization. ‣ 3.2 Transformer ‣ 3 Shape Reconstruction ‣ 3DILG: Irregular Latent Grids for 3D Generative Modeling\")), we compress the bit size of intermediate latents {𝐳^i(l)}i∈ℳsubscriptsuperscriptsubscript^𝐳𝑖𝑙𝑖ℳ\\\\{\\\\mathbf{\\\\hat{z}}\\_{i}^{(l)}\\\\}\\_{i\\\\in\\\\mathcal{M}} to log2⁡Dsubscript2𝐷\\\\log\\_{2}D where D𝐷D is the size of the dictionary 𝒟𝒟\\\\mathcal{D}. We denote the compressed index as zi∈{0,1,…,D−1}subscript𝑧𝑖01…𝐷1z\\_{i}\\\\in\\\\{0,1,\\\\dots,D-1\\\\}.\n\nWe also quantize point coordinates 𝐱isubscript𝐱𝑖\\\\mathbf{x}\\_{i} to (xi,1,xi,2,xi,3)subscript𝑥𝑖1subscript𝑥𝑖2subscript𝑥𝑖3(x\\_{i,1},x\\_{i,2},x\\_{i,3}) where each entry is a 8-bit integer {0,1,…,255}01…255\\\\{0,1,\\\\dots,255\\\\},\n\nAs a result, we obtain a discrete representation of the 3D shape {(xi,1,xi,2,xi,3,zi)}i∈ℳsubscriptsubscript𝑥𝑖1subscript𝑥𝑖2subscript𝑥𝑖3subscript𝑧𝑖𝑖ℳ\\\\{(x\\_{i,1},x\\_{i,2},x\\_{i,3},z\\_{i})\\\\}\\_{i\\\\in\\\\mathcal{M}}.\n\n### 4.1 Unidirectional Transformer\n\nAutoregressive generation with unidirectional transformer is a more classical approach. We often need to sequentialize an unordered set if the order is not defined yet. Specifically, we re-order the representations in ascending order by the first component xi,1subscript𝑥𝑖1x\\_{i,1}, then by the second component xi,2subscript𝑥𝑖2x\\_{i,2}, and finally by the third component xi,3subscript𝑥𝑖3x\\_{i,3},\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | 𝒮={(x0,1,x0,2,x0,3,z0),(x1,1,x1,2,x1,3,z1),…,(xM−1,1,xM−1,2,xM−1,3,zM−1)}.𝒮subscript𝑥01subscript𝑥02subscript𝑥03subscript𝑧0subscript𝑥11subscript𝑥12subscript𝑥13subscript𝑧1…subscript𝑥𝑀11subscript𝑥𝑀12subscript𝑥𝑀13subscript𝑧𝑀1\\\\mathcal{S}=\\\\{(x\\_{0,1},x\\_{0,2},x\\_{0,3},z\\_{0}),(x\\_{1,1},x\\_{1,2},x\\_{1,3},z\\_{1}),\\\\dots,(x\\_{M-1,1},x\\_{M-1,2},x\\_{M-1,3},z\\_{M-1})\\\\}. |  | (11) |\n\nOur goal to predict sequence elements one-by-one. A common way is to flatten the sequence 𝒮𝒮\\\\mathcal{S} by concatenating the quadruplets, for examples, PointGrow \\[ [46])\\] and PolyGen \\[ [33])\\]. However, here we consider an approach generating _quadruplet-by-quadruplet_. We write 𝐨i=(xi,1,xi,2,xi,3,zi)subscript𝐨𝑖subscript𝑥𝑖1subscript𝑥𝑖2subscript𝑥𝑖3subscript𝑧𝑖\\\\mathbf{o}\\_{i}=(x\\_{i,1},x\\_{i,2},x\\_{i,3},z\\_{i}). The likelihood of generating 𝐨isubscript𝐨𝑖\\\\mathbf{o}\\_{i} autoregressively is\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | p​(𝒮∣𝒞)=∏i=0i=M−1p​(𝐨i∣𝐨<i,𝒞),𝑝conditional𝒮𝒞subscriptsuperscriptproduct𝑖𝑀1𝑖0𝑝conditionalsubscript𝐨𝑖subscript𝐨absent𝑖𝒞p(\\\\mathcal{S}\\\\mid\\\\mathcal{C})=\\\\prod^{i=M-1}\\_{i=0}p(\\\\mathbf{o}\\_{i}\\\\mid\\\\mathbf{o}\\_{<i},\\\\mathcal{C}), |  | (12) |\n\nwhere 𝒞𝒞\\\\mathcal{C} is conditioned context. Similar to ATISS \\[ [38])\\], we predict components of 𝐨i=(xi,1,xi,2,xi,3,zi)subscript𝐨𝑖subscript𝑥𝑖1subscript𝑥𝑖2subscript𝑥𝑖3subscript𝑧𝑖\\\\mathbf{o}\\_{i}=(x\\_{i,1},x\\_{i,2},x\\_{i,3},z\\_{i}) autoregressively:\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n|  |  | p​(𝐨i∣𝐨<i,𝒞)𝑝conditionalsubscript𝐨𝑖subscript𝐨absent𝑖𝒞\\\\displaystyle p(\\\\mathbf{o}\\_{i}\\\\mid\\\\mathbf{o}\\_{<i},\\\\mathcal{C}) |  | (13) |\n|  | =\\\\displaystyle= | p​(xi,1\\|𝐨<i,𝒞)⋅p​(xi,2\\|xi,1,𝐨<i,𝒞)⋅p​(xi,3\\|xi,2,xi,1,𝐨<i,𝒞)⋅p​(zi\\|xi,3,xi,2,xi,1,𝐨<i,𝒞).⋅⋅⋅𝑝conditionalsubscript𝑥𝑖1subscript𝐨absent𝑖𝒞𝑝conditionalsubscript𝑥𝑖2subscript𝑥𝑖1subscript𝐨absent𝑖𝒞𝑝conditionalsubscript𝑥𝑖3subscript𝑥𝑖2subscript𝑥𝑖1subscript𝐨absent𝑖𝒞𝑝conditionalsubscript𝑧𝑖subscript𝑥𝑖3subscript𝑥𝑖2subscript𝑥𝑖1subscript𝐨absent𝑖𝒞\\\\displaystyle p(x\\_{i,1}\\|\\\\mathbf{o}\\_{<i},\\\\mathcal{C})\\\\cdot p(x\\_{i,2}\\|x\\_{i,1},\\\\mathbf{o}\\_{<i},\\\\mathcal{C})\\\\cdot p(x\\_{i,3}\\|x\\_{i,2},x\\_{i,1},\\\\mathbf{o}\\_{<i},\\\\mathcal{C})\\\\cdot p(z\\_{i}\\|x\\_{i,3},x\\_{i,2},x\\_{i,1},\\\\mathbf{o}\\_{<i},\\\\mathcal{C}). |  |\n\nThe model is shown in Fig. [4]Figure 4 ‣ 4 Autoregressive Generative Modeling ‣ 3DILG: Irregular Latent Grids for 3D Generative Modeling\"). Different from ATISS \\[ [38])\\] which uses MLPs to decode different components, instead we continue to apply transformer blocks for component decoding.\n\n### 4.2 Bidirectional Transformer\n\nBidirectional transformer for autoregressive generation is recently proposed by MaskGIT \\[ [5])\\]. Here we show our model can also be combined with bidirectional transformer. However, here we consider a different task. We generate {zi}i∈ℳsubscriptsubscript𝑧𝑖𝑖ℳ\\\\{z\\_{i}\\\\}\\_{i\\\\in\\\\mathcal{M}} conditioned on {(xi,1,xi,2,xi,3)}i∈ℳsubscriptsubscript𝑥𝑖1subscript𝑥𝑖2subscript𝑥𝑖3𝑖ℳ\\\\{(x\\_{i,1},x\\_{i,2},x\\_{i,3})\\\\}\\_{i\\\\in\\\\mathcal{M}}. In training phase, we sample a subset {zi}i∈𝒱⊂ℳsubscriptsubscript𝑧𝑖𝑖𝒱ℳ\\\\{z\\_{i}\\\\}\\_{i\\\\in\\\\mathcal{V}\\\\subset\\\\mathcal{M}} of {zi}i∈ℳsubscriptsubscript𝑧𝑖𝑖ℳ\\\\{z\\_{i}\\\\}\\_{i\\\\in\\\\mathcal{M}} as the input of the bidirectional transformer. We aim to predict {zi}i∈ℳ∖𝒱subscriptsubscript𝑧𝑖𝑖ℳ𝒱\\\\{z\\_{i}\\\\}\\_{i\\\\in\\\\mathcal{M}\\\\setminus\\\\mathcal{V}}. The coordinates {(xi,1,xi,2,xi,3)}i∈ℳsubscriptsubscript𝑥𝑖1subscript𝑥𝑖2subscript𝑥𝑖3𝑖ℳ\\\\{(x\\_{i,1},x\\_{i,2},x\\_{i,3})\\\\}\\_{i\\\\in\\\\mathcal{M}} are converted to positional embeddings (either learned or fixed) as condition. The likelihood of generating ℳ∖𝒱ℳ𝒱\\\\mathcal{M}\\\\setminus\\\\mathcal{V} is as follows,\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | ∏𝒱⊂ℳp​({zi}i∈ℳ∖𝒱∣{zi}i∈𝒱,{(xi,1,xi,2,xi,3)}i∈ℳ).subscriptproduct𝒱ℳ𝑝conditionalsubscriptsubscript𝑧𝑖𝑖ℳ𝒱subscriptsubscript𝑧𝑖𝑖𝒱subscriptsubscript𝑥𝑖1subscript𝑥𝑖2subscript𝑥𝑖3𝑖ℳ\\\\prod\\_{\\\\mathcal{V}\\\\subset\\\\mathcal{M}}p(\\\\{z\\_{i}\\\\}\\_{i\\\\in\\\\mathcal{M}\\\\setminus\\\\mathcal{V}}\\\\mid\\\\{z\\_{i}\\\\}\\_{i\\\\in\\\\mathcal{V}},\\\\{(x\\_{i,1},x\\_{i,2},x\\_{i,3})\\\\}\\_{i\\\\in\\\\mathcal{M}}). |  | (14) |\n\nIn practice, the bidirectional transformer takes as input all tokens except that {zi}i∈ℳ∖𝒱subscriptsubscript𝑧𝑖𝑖ℳ𝒱\\\\{z\\_{i}\\\\}\\_{i\\\\in\\\\mathcal{M}\\\\setminus\\\\mathcal{V}} are replaced by a special masked token \\[m\\]delimited-\\[\\]𝑚\\[m\\].\nWhen decoding (inference), we iteratively predict multiple tokens at the same time. Tokens are sampled based on their probabilities (transformer output). See \\[ [5])\\] for a detailed explanation. We show visualization of decoding steps in Fig. [5]Figure 5 ‣ 4 Autoregressive Generative Modeling ‣ 3DILG: Irregular Latent Grids for 3D Generative Modeling\").",
            "citations": null
          },
          "5 Reconstruction Experiments": {
            "content": "We set the size of the input point cloud to N=2048𝑁2048N=2048. The number and the size of point patches are M=512𝑀512M=512 and K=32𝐾32K=32, respectively. In the case of Vector Quantization, there are D=1024𝐷1024D=1024 vectors in the dictionary 𝒟𝒟\\\\mathcal{D}. Other details of the implementation can be found in the Appendix. We use the datset ShapeNet-v2 \\[ [4])\\] for shape reconstruction. We split samples into train/val/test (48597/1283/2592485971283259248597/1283/2592) set. Following the evaluation protocol of \\[ [13]), [66])\\], we include three metrics, volumetric IoU, the Chamfer-L1 distance, and F-Score \\[ [50])\\].\nWe also show reconstruction results on another object-level dataset ABO \\[ [11])\\], a real-world dataset D-FAUST \\[ [2])\\], and a synthetic scene-level dataset in the appendix.\n\nTable 2: Shape reconstruction. We train all models on ShapeNet-v2 (55 categories). All baseline methods are trained with the corresponding officially released code. For our model, we set N=2048𝑁2048N=2048 and K=32𝐾32K=32. We select 7 categories to show. These categories have largest training set\namong 55 categories. We also show averaged metrics over all categories.\nThe numbers shown in parenthesis are results of vector quantization.\n\n|  |  | OccNet | ConvONet | IF-Net | 3DILG (Ours) |\n|  |  | M=64𝑀64M=64 | M=128𝑀128M=128 | M=256𝑀256M=256 | M=512𝑀512M=512 |\n| IoU ↑↑\\\\uparrow | mean (selected) | 0.822 | 0.881 | 0.929 | 0.922(0.904) | 0.936(0.929) | 0.945(0.943) | 0.952(0.950) |\n| mean (all) | 0.825 | 0.888 | 0.934 | 0.923(0.907) | 0.937(0.929) | 0.946(0.943) | 0.953(0.950) |\n| Chamfer ↓↓\\\\downarrow | mean (selected) | 0.058 | 0.040 | 0.034 | 0.038(0.038) | 0.035(0.036) | 0.034(0.034) | 0.032(0.030) |\n| mean (all) | 0.072 | 0.052 | 0.041 | 0.048(0.052) | 0.044(0.046) | 0.041(0.042) | 0.040(0.040) |\n| F-Score ↑↑\\\\uparrow | mean (selected) | 0.898 | 0.951 | 0.975 | 0.959(0.948) | 0.968(0.964) | 0.972(0.969) | 0.976(0.975) |\n| mean (all) | 0.858 | 0.933 | 0.967 | 0.942(0.926) | 0.955(0.948) | 0.963(0.958) | 0.966(0.965) |\n\n#### Results\n\nWe compare our method with three existing works, OccNet \\[ [29])\\], ConvONet \\[ [39])\\] and IF-Net \\[ [9])\\].\n\nThe results can be found in Table [2]Table 2 ‣ 5 Reconstruction Experiments ‣ 3DILG: Irregular Latent Grids for 3D Generative Modeling\"). We select 7 categories among 55 categories with largest training set ( _table, car, chair, airplane, sofa, rifle, lamp_). Detailed results can be found in the Appendix. We show different choices of M𝑀M. As we can see in this table, increasing M𝑀M from 646464 to 512512512 gives a performance boost. Even with the simplest model M=64𝑀64M=64, our results outperform ConvONet. The best results are achieved when setting M=512𝑀512M=512. In this case, our results lead in most categories when comparing to IF-Net. The results of IF-Net are better than ours in terms of metric F-Score in some categories. However, we argue that in this case the metric F-score is saturated (values are close to 111), which making it hard to compare. We also show results after introducing vector quantization to our model in the same table. We can see that vector quantization harms the performance slightly.\n\n#### Qualitative Comparison\n\nQualitative results are shown in Fig. [6]Figure 6 ‣ Qualitative Comparison ‣ 5 Reconstruction Experiments ‣ 3DILG: Irregular Latent Grids for 3D Generative Modeling\"). From the visualization, it can be seen that the reconstruction quality increases as M𝑀M increases, particularly for shapes with complex topology. OccNet, as a global latent method, often fails to recover complex structures. ConvONet can recover better structures than OccNet, due to its localized latents. By learning multiscale latents, IF-Net improves further upon ConvONet. Our method with M=64𝑀64M=64 outperforms ConvONet, and with M=128𝑀128M=128, the results are comparable with IF-Net.\n\n\\\\begin{overpic}\\[trim=28.45274pt 0.0pt 28.45274pt 0.0pt,clip,width=433.62pt,grid=false\\]{images/main\\_l.png}\n\\\\put(2.0,92.0){\\\\tiny{Input}}\n\\\\put(11.0,92.0){\\\\tiny{GT}}\n\\\\dashline{0.7}(18,3)(18,93)\n\\\\put(41.0,93.0){\\\\tiny{3DILG (Ours)}}\n\\\\put(22.0,91.0){\\\\tiny{$M=64$}}\n\\\\put(35.0,91.0){\\\\tiny{$M=128$}}\n\\\\put(49.0,91.0){\\\\tiny{$M=256$}}\n\\\\put(63.0,91.0){\\\\tiny{$M=512$}}\n\\\\dashline{0.7}(74,3)(74,93)\n\\\\put(76.0,92.0){\\\\tiny{OccNet}}\n\\\\put(83.0,92.0){\\\\tiny{ConvONet}}\n\\\\put(92.0,92.0){\\\\tiny{IF-Net}}\n\\\\end{overpic}Figure 6: Shape reconstruction.\nThe column Input shows input point clouds of size 204820482048. The column GT shows ground-truth meshes. We compare our results with different M𝑀M to OccNet, ConvONet and IF-Net. We also show {𝐱i}i∈ℳsubscriptsubscript𝐱𝑖𝑖ℳ\\\\{\\\\mathbf{x}\\_{i}\\\\}\\_{i\\\\in\\\\mathcal{M}} obtained via Farthest Point Sampling.",
            "citations": null
          },
          "6 Generative Experiments": {
            "content": "We introduce three experiments to show how our model can be combined with auto-regressive transformers for generative modeling. In Sec. [6.1]Probabilistic Shape Reconstruction from a Single Image ‣ 6 Generative Experiments ‣ 3DILG: Irregular Latent Grids for 3D Generative Modeling\"), we show image-conditioned generation as probabilistic shape reconstruction from single image. In Sec. [6.2]Category-Conditioned Generation ‣ 6 Generative Experiments ‣ 3DILG: Irregular Latent Grids for 3D Generative Modeling\"), we show how we generate samples given a category label (using the 555555 ShapeNet categories). In Sec. [6.3]Point Cloud Conditioned Generation ‣ 6 Generative Experiments ‣ 3DILG: Irregular Latent Grids for 3D Generative Modeling\"), we further show generation conditioned on downsampled point clouds. In contrast to the first two tasks, the point-cloud-conditioned generation is based on a bidirectional transformer described in Sec [4.2]Bidirectional Transformer ‣ 4 Autoregressive Generative Modeling ‣ 3DILG: Irregular Latent Grids for 3D Generative Modeling\"). More generative results on additional datasets ABO and D-FAUST can be found in the appendix.\n\n### 6.1 Probabilistic Shape Reconstruction from a Single Image\n\nWe train a uni-directional transformer for this task (see Sec. [4.1]Unidirectional Transformer ‣ 4 Autoregressive Generative Modeling ‣ 3DILG: Irregular Latent Grids for 3D Generative Modeling\")). The context 𝒞𝒞\\\\mathcal{C} is an image. To train this model, we render 40 images (224×224224224224\\\\times 224) of different views for each shape in ShapeNet. The implementation of the uni-directional transformer is based on GPT \\[ [42])\\]. It contains 24 blocks, where each block has an attention layer with 16 heads and 1024 embedding dimension. When sampling, nucleus sampling \\[ [22])\\] with top-p𝑝p (0.85) and top-k𝑘k (100) are applied to predicted token probabilities.\n\n#### High resolution images.\n\nWe show some generated samples when 𝒞𝒞\\\\mathcal{C} are high resolution images in Fig. [7]Figure 7 ‣ Low resolution images. ‣ 6.1 Probabilistic Shape Reconstruction from a Single Image ‣ 6 Generative Experiments ‣ 3DILG: Irregular Latent Grids for 3D Generative Modeling\"). We compare our results with a deterministic method, OccNet \\[ [29])\\]. As we can see in the results, the deterministic method (OccNet) tends to create blurred meshes. However, our probabilistic reconstruction is able to output detailed meshes.\n\n#### Low resolution images.\n\nWe also consider another more challenging task. The input images are downsampled to low resolution (16×16161616\\\\times 16). In this case, the generative model has more freedom to find multiple plausible interpretations, including variations with different topology (see Fig. [8]Figure 8 ‣ Low resolution images. ‣ 6.1 Probabilistic Shape Reconstruction from a Single Image ‣ 6 Generative Experiments ‣ 3DILG: Irregular Latent Grids for 3D Generative Modeling\")).\n\n\\\\begin{overpic}\\[trim=0.0pt 0.0pt 0.0pt 0.0pt,clip,width=433.62pt,grid=false\\]{images/image\\_cond\\_l.jpg}\n\\\\put(2.0,30.0){\\\\tiny{Input}}\n\\\\put(13.0,30.0){\\\\tiny{GT}}\n\\\\dashline{0.7}(19,3)(19,30)\n\\\\put(26.0,30.0){\\\\tiny{3DILG (Ours)}}\n\\\\dashline{0.7}(39,3)(39,30)\n\\\\put(41.5,30.0){\\\\tiny{OccNet}}\n\\\\put(50.0,2.0){\\\\line(0,1){30.0}}\n\\\\put(52.0,30.0){\\\\tiny{Input}}\n\\\\put(61.0,30.0){\\\\tiny{GT}}\n\\\\dashline{0.7}(68,3)(68,30)\n\\\\put(75.0,30.0){\\\\tiny{3DILG (Ours)}}\n\\\\dashline{0.7}(88.5,3)(88.5,30)\n\\\\put(91.0,30.0){\\\\tiny{OccNet}}\n\\\\end{overpic}Figure 7: Image-conditioned generation (224×224224224224\\\\times 224). We sample 222 shapes for each input image, and compare them with OccNet.\\\\begin{overpic}\\[trim=0.0pt 0.0pt 0.0pt 0.0pt,clip,width=433.62pt,grid=false\\]{images/lowres\\_image\\_cond\\_l.jpg}\n\\\\put(3.0,25.0){\\\\tiny{Input}}\n\\\\dashline{0.7}(20,3)(20,25)\n\\\\put(45.0,25.0){\\\\tiny{Probabilistic Reconstruction with 3DILG (Ours)}}\n\\\\put(13.0,25.0){\\\\tiny{GT}}\n\\\\end{overpic}Figure 8: Image-conditioned generation (16×16161616\\\\times 16). We sample 888 shapes for each input image.\n\n### 6.2 Category-Conditioned Generation\n\nTo generate shapes given a category label, we use the context 𝒞𝒞\\\\mathcal{C} to encode the category label. We employ the uni-directional transformer based on GPT as in Sec. [6.1]Probabilistic Shape Reconstruction from a Single Image ‣ 6 Generative Experiments ‣ 3DILG: Irregular Latent Grids for 3D Generative Modeling\"). We compare to our proposed baseline model that encodes shapes as a latent grid of resolution 83superscript838^{3}. To make a fair comparison, we also extend ViT \\[ [15])\\] to the 3D voxel domain in the first stage of training. In the second stage, we use the same uni-directional transformer for sequence prediction. Here the sequence length is 83=512superscript835128^{3}=512, which is the same as in our proposed model. The baseline model is named Grid-83superscript838^{3}.\nThe comparison to the baseline model is in Fig. [9]Figure 9 ‣ 6.2 Category-Conditioned Generation ‣ 6 Generative Experiments ‣ 3DILG: Irregular Latent Grids for 3D Generative Modeling\"). We can see that the baseline is unable to generate high quality shapes. We argue that this is because the representation is not expressive enough to capture surface details. Furthermore, we show more generated samples of our model in Fig. [10]Figure 10 ‣ 6.2 Category-Conditioned Generation ‣ 6 Generative Experiments ‣ 3DILG: Irregular Latent Grids for 3D Generative Modeling\"). The three selected categories are _bookshelf, bench_ and _chair_. For both the baseline and our model, we render 101010 images of predicted shapes, and calculate the Fréchet Inception Distance (FID) \\[ [21]), [37])\\] between predictions and test sets. The metrics can be found in Table [3]Table 3 ‣ 6.2 Category-Conditioned Generation ‣ 6 Generative Experiments ‣ 3DILG: Irregular Latent Grids for 3D Generative Modeling\"). A perceptual study on the quality of generated samples can be found in the appendix.\n\n\\\\begin{overpic}\\[trim=0.0pt 0.0pt 0.0pt 0.0pt,clip,width=433.62pt,grid=false\\]{images/class\\_cond\\_compare\\_l.jpg}\n\\\\dashline{0.7}(50,1)(50,13)\n\\\\put(21.0,13.0){\\\\tiny{3DILG (Ours)}}\n\\\\put(72.0,13.0){\\\\tiny{Grid-$8^{3}$}}\n\\\\end{overpic}Figure 9: Comparison of category-conditioned generation. We compare our results (Left) with an 83superscript838^{3} latent grid baseline (Right).Table 3: FID ↓↓\\\\downarrow for category-conditioned generation. We compare our results with the baseline Grid-83superscript838^{3}. The 777 categories are the largest categories in ShapeNet.\n\n|  | Categories | mean |\n|  | table | car | chair | airplane | sofa | rifle | lamp |\n| Grid-83superscript838^{3} | 72.396 | 95.566 | 58.649 | 42.009 | 58.092 | 59.456 | 87.319 | 67.641 |\n| 3DILG (Ours) | 68.016 | 92.597 | 45.333 | 30.957 | 53.244 | 40.500 | 72.672 | 57.617 |\n\n\\\\begin{overpic}\\[trim=0.0pt 0.0pt 0.0pt 0.0pt,clip,width=433.62pt,grid=false\\]{images/class\\_cond\\_l.jpg}\n\\\\dashline{0.7}(0,18)(100,18)\n\\\\dashline{0.7}(0,35)(100,35)\n\\\\end{overpic}Figure 10: Category-conditioned generation. We choose 3 categories to show ( _bookshelf, bench_ and _chair_). We show 100100100 samples for each category.\n\n### 6.3 Point Cloud Conditioned Generation\n\nWe train a bidirectional transformer described in Sec [4.2]Bidirectional Transformer ‣ 4 Autoregressive Generative Modeling ‣ 3DILG: Irregular Latent Grids for 3D Generative Modeling\"). The model takes as input {𝐱i}i∈ℳsubscriptsubscript𝐱𝑖𝑖ℳ\\\\{\\\\mathbf{x}\\_{i}\\\\}\\_{i\\\\in\\\\mathcal{M}}. The results can be found in Fig. [11]Figure 11 ‣ 6.3 Point Cloud Conditioned Generation ‣ 6 Generative Experiments ‣ 3DILG: Irregular Latent Grids for 3D Generative Modeling\").\n\n\\\\begin{overpic}\\[trim=56.9055pt 0.0pt 56.9055pt 0.0pt,clip,width=433.62pt,grid=false\\]{images/point\\_cond\\_l.jpg}\n\\\\par\\\\put(5.0,29.5){\\\\tiny{Context}}\n\\\\put(53.0,29.5){\\\\tiny{Steps}}\n\\\\put(16.0,29.0){\\\\vector(1,0){80.0}}\n\\\\end{overpic}Figure 11: Point cloud conditioned generation. We show 888 decoding steps.",
            "citations": null
          },
          "7 Conclusion": {
            "content": "We have studied neural fields for shapes and presented a new representation. In contrast to common approaches which define latents a on a regular grid or multiple regular grids, we position latents on an irregular grid. Comparing to existing works, the representation better scales to larger models, because the irregular grid is sparse and adapts to the underlying 3D shape of the object.\nIn our results, we demonstrated an improvement in 3D shape reconstruction from point clouds and generative modeling conditioned on images, object category, or point-clouds over alternative grid-based methods.\nIn future work, we suggest to explore other applications of our proposed representation, _e.g_., shape completion, and extensions to textured 3D shapes and 3D scenes.",
            "citations": null
          }
        },
        "abstract": "We propose a new representation for encoding 3D shapes as neural fields. The\nrepresentation is designed to be compatible with the transformer architecture\nand to benefit both shape reconstruction and shape generation. Existing works\non neural fields are grid-based representations with latents defined on a\nregular grid. In contrast, we define latents on irregular grids, enabling our\nrepresentation to be sparse and adaptive. In the context of shape\nreconstruction from point clouds, our shape representation built on irregular\ngrids improves upon grid-based methods in terms of reconstruction accuracy. For\nshape generation, our representation promotes high-quality shape generation\nusing auto-regressive probabilistic models. We show different applications that\nimprove over the current state of the art. First, we show results for\nprobabilistic shape reconstruction from a single higher resolution image.\nSecond, we train a probabilistic model conditioned on very low resolution\nimages. Third, we apply our model to category-conditioned generation. All\nprobabilistic experiments confirm that we are able to generate detailed and\nhigh quality shapes to yield the new state of the art in generative 3D shape\nmodeling."
      },
      "bib.bib114": {
        "id": "bib.bib114",
        "citation": "[114]",
        "authors": "",
        "year": "",
        "title": "3dshape2vecset: A 3d shape representation for neural fields and generative diffusion models.",
        "venue": "",
        "pages": "",
        "url": "https://arxiv.org/abs/2301.11445",
        "arxiv_id": "2301.11445",
        "doi": null,
        "sections": {},
        "abstract": "We introduce 3DShape2VecSet, a novel shape representation for neural fields\ndesigned for generative diffusion models. Our shape representation can encode\n3D shapes given as surface models or point clouds, and represents them as\nneural fields. The concept of neural fields has previously been combined with a\nglobal latent vector, a regular grid of latent vectors, or an irregular grid of\nlatent vectors. Our new representation encodes neural fields on top of a set of\nvectors. We draw from multiple concepts, such as the radial basis function\nrepresentation and the cross attention and self-attention function, to design a\nlearnable representation that is especially suitable for processing with\ntransformers. Our results show improved performance in 3D shape encoding and 3D\nshape generative modeling tasks. We demonstrate a wide variety of generative\napplications: unconditioned generation, category-conditioned generation,\ntext-conditioned generation, point-cloud completion, and image-conditioned\ngeneration."
      },
      "bib.bib115": {
        "id": "bib.bib115",
        "citation": "[115]",
        "authors": "",
        "year": "",
        "title": "Adding conditional control to text-to-image diffusion models.",
        "venue": "",
        "pages": "",
        "url": "https://arxiv.org/abs/2302.05543",
        "arxiv_id": "2302.05543",
        "doi": null,
        "sections": {
          "1 Introduction": {
            "content": "Many of us have experienced flashes of visual inspiration that\nwe wish to capture in a unique image. With the advent of\ntext-to-image diffusion\nmodels \\[ [54]), [62]), [72])\\], we\ncan now create visually stunning images by typing in a text\nprompt.\nYet, text-to-image models are limited in the control\nthey provide over the spatial composition of the image;\nprecisely expressing complex layouts, poses, shapes and forms\ncan be difficult via text prompts alone.\nGenerating an image\nthat accurately matches our mental imagery often requires numerous\ntrial-and-error cycles of editing a prompt, inspecting the\nresulting images and then re-editing the prompt.\n\nCan we enable finer grained spatial control by letting users\nprovide additional images that directly specify their desired\nimage composition?\nIn computer\nvision and machine learning, these additional images ( _e.g_.,\nedge maps, human pose skeletons, segmentation maps, depth,\nnormals, _etc_.) are often treated as conditioning on the image\ngeneration process. Image-to-image translation\nmodels \\[ [34]), [98])\\] learn the mapping\nfrom conditioning images to target images. The research\ncommunity has also taken steps to control text-to-image models\nwith spatial masks \\[ [6]), [20])\\],\nimage editing instructions \\[ [10])\\],\npersonalization via\nfinetuning \\[ [21]), [75])\\], _etc_. While\na few problems ( _e.g_., generating image variations,\ninpainting) can be resolved with training-free techniques like\nconstraining the denoising diffusion process or editing\nattention layer activations, a wider variety of problems like\ndepth-to-image, pose-to-image, _etc_., require end-to-end\nlearning and data-driven solutions.\n\nLearning conditional controls for large text-to-image\ndiffusion models in an end-to-end way is challenging. The\namount of training data for a specific condition may be\nsignificantly smaller than the data available for general\ntext-to-image training. For instance, the largest datasets\nfor various specific problems ( _e.g_., object shape/normal, human\npose extraction, _etc_.) are usually about 100K in size, which\nis 50,000 times smaller than the\nLAION-5B \\[ [79])\\] dataset that was used to\ntrain Stable Diffusion \\[ [82])\\]. The direct finetuning or\ncontinued training of a large pretrained model with limited\ndata may cause overfitting and catastrophic\nforgetting \\[ [31]), [75])\\].\nResearchers have shown that such forgetting can be alleviated by restricting the number or rank of trainable parameters \\[ [14]), [25]), [31]), [92])\\].\nFor our problem, designing deeper or more customized neural architectures might be necessary for handling in-the-wild conditioning images with complex shapes and diverse high-level semantics.\n\nThis paper presents ControlNet, an end-to-end neural\nnetwork architecture that learns conditional controls for\nlarge pretrained text-to-image diffusion models (Stable\nDiffusion in our implementation). ControlNet preserves the\nquality and capabilities of the large model by locking its\nparameters, and also making a trainable copy of its\nencoding layers. This architecture treats the large pretrained\nmodel as a strong backbone for learning diverse conditional\ncontrols. The trainable copy and the original, locked model\nare connected with zero convolution layers, with weights\ninitialized to zeros so that they progressively grow during\nthe training. This architecture ensures that harmful noise is\nnot added to the deep features of the large diffusion model at\nthe beginning of training, and protects the large-scale\npretrained backbone in the trainable copy from being damaged\nby such noise.\n\nOur experiments show that ControlNet can control Stable\nDiffusion with various conditioning inputs, including Canny\nedges, Hough lines, user scribbles, human key points,\nsegmentation maps, shape normals, depths,\n_etc_. (Figure [1]Figure 1 ‣ Adding Conditional Control to Text-to-Image Diffusion Models\")). We test our approach using a\nsingle conditioning image, with or without text prompts, and\nwe demonstrate how our approach supports the composition of\nmultiple conditions. Additionally, we report that the\ntraining of ControlNet is robust and scalable on datasets of\ndifferent sizes, and that for some tasks like depth-to-image\nconditioning, training ControlNets on a single NVIDIA RTX\n3090Ti GPU can achieve results competitive with industrial\nmodels trained on large computation clusters. Finally, we\nconduct ablative studies to investigate the contribution of\neach component of our model, and compare our models to several\nstrong conditional image generation baselines with user\nstudies.\n\nIn summary, (1) we propose ControlNet, a neural network\narchitecture that can add spatially localized input conditions\nto a pretrained text-to-image diffusion model via efficient\nfinetuning, (2) we present pretrained ControlNets to control\nStable Diffusion, conditioned on Canny edges, Hough lines,\nuser scribbles, human key points, segmentation maps, shape\nnormals, depths, and cartoon line drawings, and (3) we\nvalidate the method with ablative experiments comparing to\nseveral alternative architectures, and conduct user studies\nfocused on several previous baselines across different tasks.",
            "citations": null
          },
          "2 Related Work": {
            "content": "### 2.1 Finetuning Neural Networks\n\nOne way to finetune a neural network is to directly continue training\nit with the additional training data. But this approach can lead to\noverfitting, mode collapse, and catastrophic forgetting. Extensive\nresearch has focused on developing finetuning strategies that avoid\nsuch issues.\n\nHyperNetwork is an approach that originated in the Natural\nLanguage Processing (NLP) community \\[ [25])\\], with\nthe aim of training a small recurrent neural network to influence the\nweights of a larger one. It has been applied to image generation with\ngenerative adversarial networks (GANs) \\[ [4]), [18])\\]. Heathen _et al_.\\[ [26])\\] and Kurumuz \\[ [43])\\] implement\nHyperNetworks for Stable Diffusion \\[ [72])\\]\nto change the artistic style of its output images.\n\nAdapter methods are widely used in NLP for customizing a\npretrained transformer model to other tasks by embedding new module\nlayers into it \\[ [30]), [84])\\]. In\ncomputer vision, adapters are used for incremental\nlearning \\[ [74])\\] and domain\nadaptation \\[ [70])\\]. This technique is often used\nwith CLIP \\[ [66])\\] for transferring pretrained\nbackbone models to different\ntasks \\[ [23]), [66]), [85]), [94])\\].\nMore recently, adapters have yielded successful results in vision\ntransformers \\[ [49]), [50])\\] and\nViT-Adapter \\[ [14])\\]. In concurrent work with ours,\nT2I-Adapter \\[ [56])\\] adapts Stable Diffusion to external\nconditions.\n\nAdditive Learning circumvents forgetting by freezing the\noriginal model weights and adding a small number of new parameters using learned weight\nmasks \\[ [51]), [74])\\],\npruning \\[ [52])\\], or hard\nattention \\[ [80])\\].\nSide-Tuning \\[ [92])\\] uses a side branch model to learn\nextra functionality by linearly blending the outputs of a frozen model\nand an added network, with a predefined blending weight schedule.\n\nLow-Rank Adaptation (LoRA) prevents catastrophic\nforgetting \\[ [31])\\] by learning the offset of parameters with low-rank matrices, based on the observation that many\nover-parameterized models reside in a low intrinsic\ndimension subspace \\[ [2]), [47])\\].\n\nZero-Initialized Layers are used by ControlNet for connecting\nnetwork blocks. Research on neural networks has extensively discussed\nthe initialization and manipulation of network\nweights \\[ [36]), [37]), [44]), [45]), [46]), [76]), [83]), [95])\\].\nFor example, Gaussian initialization of weights can be less risky than\ninitializing with zeros \\[ [1])\\]. More recently,\nNichol _et al_.\\[ [59])\\] discussed how to scale the\ninitial weight of convolution layers in a diffusion model to improve\nthe training, and their implementation of “zero\\_module” is an\nextreme case to scale weights to zero. Stability’s model\ncards \\[ [83])\\] also mention the use of zero weights in neural\nlayers. Manipulating the initial convolution weights is also\ndiscussed in ProGAN \\[ [36])\\],\nStyleGAN \\[ [37])\\],\nand Noise2Noise \\[ [46])\\].\n\n### 2.2 Image Diffusion\n\nImage Diffusion Models were first introduced by\nSohl-Dickstein _et al_.\\[ [81])\\] and have been recently\napplied to image\ngeneration \\[ [17]), [42])\\].\nThe Latent Diffusion Models (LDM) \\[ [72])\\]\nperforms the diffusion steps in the latent image\nspace \\[ [19])\\], which reduces the computation cost.\nText-to-image diffusion\nmodels achieve state-of-the-art image generation results by encoding\ntext inputs into latent vectors via pretrained language models like\nCLIP \\[ [66])\\]. Glide \\[ [58])\\] is a\ntext-guided diffusion model supporting image generation and editing.\nDisco Diffusion \\[ [5])\\] processes text prompts with clip guidance.\nStable Diffusion \\[ [82])\\] is a large-scale implementation of\nlatent diffusion \\[ [72])\\].\nImagen \\[ [78])\\] directly diffuses pixels\nusing a pyramid structure without using latent images. Commercial\nproducts include DALL-E2 \\[ [62])\\] and\nMidjourney \\[ [54])\\].\n\nControlling Image Diffusion Models facilitate personalization,\ncustomization, or task-specific image generation. The image diffusion\nprocess directly provides some control over color\nvariation \\[ [53])\\] and\ninpainting \\[ [67]), [7])\\].\nText-guided control methods focus on adjusting prompts, manipulating\nCLIP features, and modifying\ncross-attention \\[ [7]), [10]), [20]), [27]), [40]), [41]), [58]), [64]), [67])\\].\nMakeAScene \\[ [20])\\] encodes segmentation masks into\ntokens to control image generation.\nSpaText \\[ [6])\\] maps segmentation masks into\nlocalized token embeddings. GLIGEN \\[ [48])\\] learns new\nparameters in attention layers of diffusion models for grounded\ngenerating. Textual Inversion \\[ [21])\\] and\nDreamBooth \\[ [75])\\] can personalize content in the\ngenerated image by finetuning the image diffusion model using a small\nset of user-provided example images. Prompt-based image\nediting \\[ [10]), [33]), [86])\\]\nprovides practical tools to manipulate images with prompts.\nVoynov _et al_.\\[ [88])\\] propose an optimization method\nthat fits the diffusion process with sketches. Concurrent works\n\\[ [8]), [9]), [32]), [56])\\]\nexamine a wide variety of ways to control diffusion models.\n\n### 2.3 Image-to-Image Translation\n\nConditional\nGANs \\[ [15]), [34]), [63]), [90]), [93]), [97]), [98]), [99])\\] and transformers \\[ [13]), [19]), [68])\\] can learn the mapping between different image domains, _e.g_., Taming\nTransformer \\[ [19])\\] is a vision transformer\napproach; Palette \\[ [77])\\] is a conditional\ndiffusion model trained from scratch; PITI \\[ [89])\\] is a pretraining-based conditional\ndiffusion model for image-to-image translation. Manipulating pretrained GANs can handle\nspecific image-to-image tasks, _e.g_., StyleGANs can be\ncontrolled by extra encoders \\[ [71])\\], with more\napplications studied in\n\\[ [3]), [22]), [38]), [39]), [55]), [60]), [65]), [71])\\].",
            "citations": null
          },
          "3 Method": {
            "content": "![Refer to caption]Figure 2: A neural block takes a feature map x𝑥x as input\nand outputs another feature map y𝑦y, as shown in (a). To add a ControlNet to\nsuch a block we lock the original block and create a trainable copy\nand connect them together using zero\nconvolution layers, _i.e_., 1×1111\\\\times 1 convolution with\nboth weight and bias initialized to zero. Here c𝑐c is a conditioning vector\nthat we wish to add to the network, as shown in (b).\n\nControlNet is a neural network architecture that can enhance large\npretrained text-to-image diffusion models with spatially localized,\ntask-specific image conditions. We first introduce the basic\nstructure of a ControlNet in Section [3.1]ControlNet ‣ 3 Method ‣ Adding Conditional Control to Text-to-Image Diffusion Models\") and then\ndescribe how we apply a ControlNet to the image diffusion model Stable\nDiffusion \\[ [72])\\] in\nSection [3.2]ControlNet for Text-to-Image Diffusion ‣ 3 Method ‣ Adding Conditional Control to Text-to-Image Diffusion Models\"). We elaborate on our training in\nSection [3.3]Training ‣ 3 Method ‣ Adding Conditional Control to Text-to-Image Diffusion Models\") and detail several extra considerations during\ninference such as composing multiple ControlNets in\nSection [3.4]Inference ‣ 3 Method ‣ Adding Conditional Control to Text-to-Image Diffusion Models\").\n\n### 3.1 ControlNet\n\nControlNet injects additional conditions into the blocks of a neural\nnetwork (Figure [2]Figure 2 ‣ 3 Method ‣ Adding Conditional Control to Text-to-Image Diffusion Models\")). Herein, we use the term network block to refer to a set of neural layers that are commonly\nput together to form a single unit of a neural network, _e.g_., resnet block,\nconv-bn-relu block, multi-head attention block, transformer\nblock, _etc_.\nSuppose ℱ​(⋅;Θ)ℱ⋅Θ\\\\mathcal{F}(\\\\cdot;\\\\Theta) is such a trained neural block, with\nparameters ΘΘ\\\\Theta, that transforms an input feature map 𝒙𝒙\\\\bm{x},\ninto another feature map 𝒚𝒚\\\\bm{y} as\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | 𝒚=ℱ​(𝒙;Θ).𝒚ℱ𝒙Θ\\\\vspace{-3pt}\\\\bm{y}=\\\\mathcal{F}(\\\\bm{x};\\\\Theta). |  | (1) |\n\nIn our setting, 𝒙𝒙\\\\bm{x} and 𝒚𝒚\\\\bm{y} are usually 2D feature maps, _i.e_., 𝒙∈ℝh×w×c𝒙superscriptℝℎ𝑤𝑐\\\\bm{x}\\\\in\\\\mathbb{R}^{h\\\\times w\\\\times c} with {h,w,c}ℎ𝑤𝑐\\\\{h,w,c\\\\}\nas the height, width, and number of channels in the map,\nrespectively (Figure [2]Figure 2 ‣ 3 Method ‣ Adding Conditional Control to Text-to-Image Diffusion Models\") a).\n\nTo add a ControlNet to such a pre-trained neural block, we lock (freeze)\nthe parameters ΘΘ\\\\Theta of the original block and simultaneously clone\nthe block to a trainable copy with parameters ΘcsubscriptΘc\\\\Theta\\_{\\\\text{c}}\n(Figure [2]Figure 2 ‣ 3 Method ‣ Adding Conditional Control to Text-to-Image Diffusion Models\") b). The trainable copy takes an external\nconditioning vector 𝒄𝒄\\\\bm{c} as input. When this structure is applied\nto large models like Stable Diffusion, the locked parameters preserve\nthe production-ready model trained with billions of images, while the\ntrainable copy reuses such large-scale pretrained model to establish a\ndeep, robust, and strong backbone for handling diverse input\nconditions.\n\nThe trainable copy is connected to the locked model with zero convolution layers, denoted\n𝒵​(⋅;⋅)𝒵⋅⋅\\\\mathcal{Z}(\\\\cdot;\\\\cdot). Specifically,\n𝒵​(⋅;⋅)𝒵⋅⋅\\\\mathcal{Z}(\\\\cdot;\\\\cdot) is a 1×1111\\\\times 1 convolution layer with\nboth weight and bias initialized to zeros.\nTo build up a ControlNet, we use two instances of zero convolutions with parameters Θz1subscriptΘz1\\\\Theta\\_{\\\\text{z1}}\nand Θz2subscriptΘz2\\\\Theta\\_{\\\\text{z2}} respectively. The complete ControlNet then\ncomputes\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | 𝒚c=ℱ​(𝒙;Θ)+𝒵​(ℱ​(𝒙+𝒵​(𝒄;Θz1);Θc);Θz2),subscript𝒚cℱ𝒙Θ𝒵ℱ𝒙𝒵𝒄subscriptΘz1subscriptΘcsubscriptΘz2\\\\vspace{-3pt}\\\\bm{y}\\_{\\\\text{c}}=\\\\mathcal{F}(\\\\bm{x};\\\\Theta)+\\\\mathcal{Z}(\\\\mathcal{F}(\\\\bm{x}+\\\\mathcal{Z}(\\\\bm{c};\\\\Theta\\_{\\\\text{z1}});\\\\Theta\\_{\\\\text{c}});\\\\Theta\\_{\\\\text{z2}}), |  | (2) |\n\nwhere 𝒚csubscript𝒚c\\\\bm{y}\\_{\\\\text{c}} is the output of the ControlNet block.\nIn the first training step, since both the weight and bias parameters of a zero convolution layer are initialized to zero, both of the 𝒵​(⋅;⋅)𝒵⋅⋅\\\\mathcal{Z}(\\\\cdot;\\\\cdot) terms in Equation ( [2]In 3.1 ControlNet ‣ 3 Method ‣ Adding Conditional Control to Text-to-Image Diffusion Models\")) evaluate to zero,\nand\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | 𝒚c=𝒚.subscript𝒚c𝒚\\\\vspace{-3pt}\\\\bm{y}\\_{\\\\text{c}}=\\\\bm{y}. |  | (3) |\n\nIn this way, harmful noise cannot influence the hidden states of\nthe neural network layers in the trainable copy when the training starts.\nMoreover,\nsince 𝒵​(𝒄;Θz1)=𝟎𝒵𝒄subscriptΘz10\\\\mathcal{Z}(\\\\bm{c};\\\\Theta\\_{\\\\text{z1}})=\\\\bm{0} and the trainable\ncopy also receives the input image 𝒙𝒙\\\\bm{x}, the\ntrainable copy is fully functional and retains the capabilities of the large, pretrained model\nallowing it to serve as a strong backbone for further\nlearning. Zero convolutions protect this backbone by\neliminating random noise as gradients in the initial\ntraining steps. We detail the gradient calculation for zero\nconvolutions in supplementary materials.\n\n![Refer to caption]Figure 3: Stable Diffusion’s U-net architecture connected with a ControlNet on the encoder blocks and middle block. The locked, gray blocks\nshow the structure of Stable Diffusion V1.5 (or V2.1, as they use the same U-net architecture). The trainable blue blocks and the white zero convolution layers are added to build a ControlNet.\n\n### 3.2 ControlNet for Text-to-Image Diffusion\n\nWe use Stable Diffusion \\[ [72])\\] as an\nexample to show how ControlNet can add conditional control to a large\npretrained diffusion model. Stable Diffusion is essentially a\nU-Net \\[ [73])\\] with an encoder, a middle block, and a\nskip-connected decoder. Both the encoder and decoder contain 12\nblocks, and the full model contains 25 blocks, including the middle\nblock. Of the 25 blocks, 8 blocks are down-sampling or up-sampling\nconvolution layers, while the other 17 blocks are main blocks that\neach contain 4 resnet layers and 2 Vision Transformers (ViTs). Each\nViT contains several cross-attention and self-attention mechanisms.\nFor example, in Figure [3]Figure 3 ‣ 3.1 ControlNet ‣ 3 Method ‣ Adding Conditional Control to Text-to-Image Diffusion Models\") a, the\n“SD Encoder Block A” contains 4 resnet layers and 2 ViTs, while the\n“×3absent3\\\\times 3” indicates that this block is repeated three times.\nText prompts are encoded using the CLIP text encoder \\[ [66])\\], and diffusion timesteps are encoded\nwith a time encoder using positional encoding.\n\nThe ControlNet structure is applied to each encoder level of the U-net\n(Figure [3]Figure 3 ‣ 3.1 ControlNet ‣ 3 Method ‣ Adding Conditional Control to Text-to-Image Diffusion Models\") b). In particular, we use ControlNet to create a\ntrainable copy of the 12 encoding blocks and 1 middle block of Stable\nDiffusion. The 12 encoding blocks are in 4 resolutions\n(64×64,32×32,16×16,8×86464323216168864\\\\times 64,32\\\\times 32,16\\\\times 16,8\\\\times 8) with each one replicated 3\ntimes. The outputs are added to the 12 skip-connections and 1 middle\nblock of the U-net. Since Stable Diffusion is a typical U-net structure, this\nControlNet architecture is likely to be applicable with other\nmodels.\n\nThe way we connect the ControlNet is computationally efficient —\nsince the locked copy parameters are frozen, no gradient computation\nis required in the originally locked encoder for the finetuning. This\napproach speeds up training and saves GPU memory. As tested on a\nsingle NVIDIA A100 PCIE 40GB, optimizing Stable Diffusion with\nControlNet requires only about 23% more GPU memory and 34% more time\nin each training iteration, compared to optimizing Stable Diffusion\nwithout ControlNet.\n\nImage diffusion models learn to progressively denoise images and\ngenerate samples from the training domain. The denoising process can\noccur in pixel space or in a latent space encoded from training\ndata. Stable Diffusion uses latent images as the training domain as\nworking in this space has been shown to stabilize the\ntraining process \\[ [72])\\].\nSpecifically, Stable Diffusion uses a pre-processing method similar to\nVQ-GAN \\[ [19])\\] to convert 512×512512512512\\\\times 512 pixel-space images into\nsmaller 64×64646464\\\\times 64latent images.\nTo add ControlNet to Stable Diffusion,\nwe first convert each input conditioning image ( _e.g_., edge, pose, depth, _etc_.) from an input size of 512×512512512512\\\\times 512 into a\n64×64646464\\\\times 64 feature space vector that matches the size of Stable Diffusion.\nIn particular, we use a tiny network\nℰ​(⋅)ℰ⋅\\\\mathcal{E}(\\\\cdot) of four convolution layers with 4×4444\\\\times 4\nkernels and 2×2222\\\\times 2 strides (activated by ReLU, using 16, 32, 64,\n128, channels respectively, initialized with Gaussian weights and\ntrained jointly with the full model) to encode an image-space\ncondition 𝒄isubscript𝒄i\\\\bm{c}\\_{\\\\text{i}} into a feature space conditioning vector\n𝒄fsubscript𝒄f\\\\bm{c}\\_{\\\\text{f}} as,\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | 𝒄f=ℰ​(𝒄i).subscript𝒄fℰsubscript𝒄i\\\\vspace{-3pt}\\\\bm{c}\\_{\\\\text{f}}=\\\\mathcal{E}(\\\\bm{c}\\_{\\\\text{i}}). |  | (4) |\n\nThe conditioning vector 𝒄fsubscript𝒄f\\\\bm{c}\\_{\\\\text{f}} is passed into the ControlNet.\n\n### 3.3 Training\n\nGiven an input image 𝒛0subscript𝒛0\\\\bm{z}\\_{0}, image diffusion algorithms\nprogressively add noise to the image and produce a noisy image\n𝒛tsubscript𝒛𝑡\\\\bm{z}\\_{t}, where t𝑡t represents the number of times noise is added. Given a\nset of conditions including time step 𝒕𝒕\\\\bm{t}, text prompts 𝒄tsubscript𝒄𝑡\\\\bm{c}\\_{t}, as\nwell as a task-specific condition 𝒄fsubscript𝒄f\\\\bm{c}\\_{\\\\text{f}}, image diffusion\nalgorithms learn a network ϵθsubscriptitalic-ϵ𝜃\\\\epsilon\\_{\\\\theta} to predict the noise\nadded to the noisy image 𝒛tsubscript𝒛𝑡\\\\bm{z}\\_{t} with\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | ℒ=𝔼𝒛0,𝒕,𝒄t,𝒄f,ϵ∼𝒩​(0,1)\\[∥ϵ−ϵθ(𝒛t,𝒕,𝒄t,𝒄f))∥22\\],\\\\vspace{-3pt}\\\\mathcal{L}=\\\\mathbb{E}\\_{\\\\bm{z}\\_{0},\\\\bm{t},\\\\bm{c}\\_{t},\\\\bm{c}\\_{\\\\text{f}},\\\\epsilon\\\\sim\\\\mathcal{N}(0,1)}\\\\Big{\\[}\\\\\\|\\\\epsilon-\\\\epsilon\\_{\\\\theta}(\\\\bm{z}\\_{t},\\\\bm{t},\\\\bm{c}\\_{t},\\\\bm{c}\\_{\\\\text{f}}))\\\\\\|\\_{2}^{2}\\\\Big{\\]}, |  | (5) |\n\nwhere ℒℒ\\\\mathcal{L} is the overall learning objective of the entire diffusion model.\nThis learning objective is directly used in finetuning diffusion models with ControlNet.\n\nIn the training process, we randomly replace 50% text prompts\n𝒄tsubscript𝒄𝑡\\\\bm{c}\\_{t} with empty strings.\nThis approach increases ControlNet’s\nability to directly recognize semantics in the input conditioning images\n( _e.g_., edges, poses, depth, _etc_.) as a replacement for the prompt.\n\n![Refer to caption]Figure 4: The sudden convergence phenomenon.\nDue to the zero convolutions, ControlNet\nalways predicts high-quality images during the\nentire training. At a certain step in the\ntraining process ( _e.g_., the 6133 steps marked\nin bold), the model suddenly learns to follow\nthe input condition.![Refer to caption]Figure 5: Effect of Classifier-Free Guidance (CFG) and the proposed CFG Resolution Weighting (CFG-RW).![Refer to caption]Figure 6: Composition of multiple conditions. We present the application to use depth and pose simultaneously.\n\nDuring the training process, since zero convolutions do not add noise to the network, the model should always be able to predict high-quality images. We observe that the model does not gradually learn the control conditions but abruptly succeeds in following the input conditioning image; usually in less than 10K optimization steps. As shown in Figure [4]Figure 4 ‣ 3.3 Training ‣ 3 Method ‣ Adding Conditional Control to Text-to-Image Diffusion Models\"), we call this the “sudden convergence phenomenon”.\n\n|     |     |     |     |     |     |     |     |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| Sketch | Normal map | Depth map | Canny\\[ [11])\\] edge | M-LSD\\[ [24])\\] line | HED\\[ [91])\\] edge | ADE20k\\[ [96])\\] seg. | Human pose |\n\n![Refer to caption]\n\nFigure 7: Controlling Stable Diffusion with various conditions without prompts. The top row is input conditions, while all other rows are outputs. We use the empty string as input prompts. All models are trained with general-domain data. The model has to recognize semantic contents in the input condition images to generate images.\n\n### 3.4 Inference\n\nWe can further control how the extra conditions of ControlNet affect the denoising diffusion process\nin several ways.\n\nClassifier-free guidance resolution weighting. Stable Diffusion\ndepends on a technique called Classifier-Free Guidance\n(CFG) \\[ [29])\\] to generate high-quality images. CFG is\nformulated as\nϵprd=ϵuc+βcfg​(ϵc−ϵuc)subscriptitalic-ϵprdsubscriptitalic-ϵucsubscript𝛽cfgsubscriptitalic-ϵcsubscriptitalic-ϵuc\\\\epsilon\\_{\\\\text{prd}}=\\\\epsilon\\_{\\\\text{uc}}+\\\\beta\\_{\\\\text{cfg}}(\\\\epsilon\\_{\\\\text{c}}-\\\\epsilon\\_{\\\\text{uc}})\nwhere\nϵprdsubscriptitalic-ϵprd\\\\epsilon\\_{\\\\text{prd}}, ϵucsubscriptitalic-ϵuc\\\\epsilon\\_{\\\\text{uc}}, ϵcsubscriptitalic-ϵc\\\\epsilon\\_{\\\\text{c}}, βcfgsubscript𝛽cfg\\\\beta\\_{\\\\text{cfg}}\nare the model’s final output, unconditional output, conditional\noutput, and a user-specified weight respectively.\nWhen a conditioning image is\nadded via ControlNet, it can be added to both ϵucsubscriptitalic-ϵuc\\\\epsilon\\_{\\\\text{uc}} and\nϵcsubscriptitalic-ϵc\\\\epsilon\\_{\\\\text{c}}, or only to the ϵcsubscriptitalic-ϵc\\\\epsilon\\_{\\\\text{c}}. In\nchallenging cases, _e.g_., when no prompts are given, adding it to both\nϵucsubscriptitalic-ϵuc\\\\epsilon\\_{\\\\text{uc}} and ϵcsubscriptitalic-ϵc\\\\epsilon\\_{\\\\text{c}} will completely remove\nCFG guidance (Figure [5]Figure 5 ‣ 3.3 Training ‣ 3 Method ‣ Adding Conditional Control to Text-to-Image Diffusion Models\") b); using only ϵcsubscriptitalic-ϵc\\\\epsilon\\_{\\\\text{c}} will make\nthe guidance very strong (Figure [5]Figure 5 ‣ 3.3 Training ‣ 3 Method ‣ Adding Conditional Control to Text-to-Image Diffusion Models\") c). Our solution is to\nfirst add the conditioning image to ϵcsubscriptitalic-ϵc\\\\epsilon\\_{\\\\text{c}} and then multiply a\nweight wisubscript𝑤𝑖w\\_{i} to each connection between Stable Diffusion and ControlNet according to\nthe resolution of each block wi=64/hisubscript𝑤𝑖64subscriptℎ𝑖w\\_{i}=64/h\\_{i}, where hisubscriptℎ𝑖h\\_{i} is the size of\nithsuperscript𝑖thi^{\\\\text{th}} block, _e.g_., h1=8,h2=16,…,h13=64formulae-sequencesubscriptℎ18formulae-sequencesubscriptℎ216…subscriptℎ1364h\\_{1}=8,h\\_{2}=16,...,h\\_{13}=64. By\nreducing the CFG guidance strength , we can achieve the result shown in\nFigure [5]Figure 5 ‣ 3.3 Training ‣ 3 Method ‣ Adding Conditional Control to Text-to-Image Diffusion Models\") d, and we call this CFG Resolution Weighting.\n\n|     |     |     |\n| --- | --- | --- |\n| Method | Result Quality ↑↑\\\\uparrow | Condition Fidelity ↑↑\\\\uparrow |\n| PITI \\[ [89])\\](sketch) | 1.10 ±plus-or-minus\\\\pm 0.05 | 1.02 ±plus-or-minus\\\\pm 0.01 |\n| Sketch-Guided \\[ [88])\\] (β=1.6𝛽1.6\\\\beta=1.6) | 3.21 ±plus-or-minus\\\\pm 0.62 | 2.31 ±plus-or-minus\\\\pm 0.57 |\n| Sketch-Guided \\[ [88])\\] (β=3.2𝛽3.2\\\\beta=3.2) | 2.52 ±plus-or-minus\\\\pm 0.44 | 3.28 ±plus-or-minus\\\\pm 0.72 |\n| ControlNet-lite | 3.93 ±plus-or-minus\\\\pm 0.59 | 4.09 ±plus-or-minus\\\\pm 0.46 |\n| ControlNet | 4.22 ±plus-or-minus\\\\pm 0.43 | 4.28 ±plus-or-minus\\\\pm 0.45 |\n\nTable 1: Average User Ranking (AUR) of result quality and condition fidelity. We report the user preference ranking (1 to 5 indicates worst to best) of different methods.\n\nComposing multiple ControlNets.\nTo apply multiple conditioning images ( _e.g_., Canny edges, and pose) to\na single instance of Stable Diffusion, we can directly add the outputs\nof the corresponding ControlNets to the Stable Diffusion model (Figure [6]Figure 6 ‣ 3.3 Training ‣ 3 Method ‣ Adding Conditional Control to Text-to-Image Diffusion Models\")). No\nextra weighting or linear interpolation is necessary for such composition.\n\n![Refer to caption]Figure 8: Ablative study of different architectures on a sketch condition and different prompt settings.\nFor each setting, we show a random batch of 6 samples without cherry-picking. Images are at 512 ×\\\\times 512 and best viewed when zoomed in. The green “conv” blocks on the left are standard convolution layers initialized with Gaussian weights.",
            "citations": null
          },
          "4 Experiments": {
            "content": "We implement ControlNets with Stable Diffusion to test various\nconditions, including Canny Edge \\[ [11])\\], Depth\nMap \\[ [69])\\], Normal Map \\[ [87])\\], M-LSD\nlines \\[ [24])\\], HED soft\nedge \\[ [91])\\], ADE20K\nsegmentation \\[ [96])\\], Openpose \\[ [12])\\],\nand user sketches. See also the supplementary material for\nexamples of each conditioning along with detailed training and inference parameters.\n\n### 4.1 Qualitative Results\n\nFigure [1]Figure 1 ‣ Adding Conditional Control to Text-to-Image Diffusion Models\") shows the generated images in several\nprompt settings. Figure [7]Figure 7 ‣ 3.3 Training ‣ 3 Method ‣ Adding Conditional Control to Text-to-Image Diffusion Models\") shows our results with\nvarious conditions without prompts, where the\nControlNet robustly interprets content semantics in\ndiverse input conditioning images.\n\n### 4.2 Ablative Study\n\n![Refer to caption]Figure 9: Comparison to previous methods.We present the qualitative comparisons to PITI \\[ [89])\\], Sketch-Guided Diffusion \\[ [88])\\], and Taming Transformers \\[ [19])\\].\n\nWe study alternative structures of ControlNets by (1) replacing the zero convolutions with standard convolution layers initialized with Gaussian weights, and (2) replacing each block’s trainable copy with one single convolution layer, which we call ControlNet-lite.\nSee also the supplementary material for the full details of these ablative structures.\n\nWe present 4 prompt settings to test with possible behaviors of real-world users:\n(1) no prompt;\n(2) insufficient prompts that do not fully cover objects in conditioning images, _e.g_., the default prompt of this paper “a high-quality, detailed, and professional image”;\n(3) conflicting prompts that change the semantics of conditioning images;\n(4) perfect prompts that describe necessary content semantics, _e.g_., “a nice house”.\nFigure [8]Figure 8 ‣ 3.4 Inference ‣ 3 Method ‣ Adding Conditional Control to Text-to-Image Diffusion Models\") a shows that ControlNet succeeds in all 4 settings.\nThe lightweight ControlNet-lite (Figure [8]Figure 8 ‣ 3.4 Inference ‣ 3 Method ‣ Adding Conditional Control to Text-to-Image Diffusion Models\") c) is not strong enough to interpret the conditioning images and fails in the insufficient and no prompt conditions.\nWhen zero convolutions are replaced, the performance of ControlNet drops to about the same as ControlNet-lite, indicating that the pretrained backbone of the trainable copy is destroyed during finetuning (Figure [8]Figure 8 ‣ 3.4 Inference ‣ 3 Method ‣ Adding Conditional Control to Text-to-Image Diffusion Models\") b).\n\n|     |     |     |     |     |     |\n| --- | --- | --- | --- | --- | --- |\n| ADE20K (GT) | VQGAN \\[ [19])\\] | LDM \\[ [72])\\] | PITI \\[ [89])\\] | ControlNet-lite | ControlNet |\n| 0.58 ±plus-or-minus\\\\pm 0.10 | 0.21 ±plus-or-minus\\\\pm 0.15 | 0.31 ±plus-or-minus\\\\pm 0.09 | 0.26 ±plus-or-minus\\\\pm 0.16 | 0.32 ±plus-or-minus\\\\pm 0.12 | 0.35 ±plus-or-minus\\\\pm 0.14 |\n\nTable 2: Evaluation of semantic segmentation label reconstruction (ADE20K) with Intersection over Union (IoU ↑↑\\\\uparrow).\n\n### 4.3 Quantitative Evaluation\n\nUser study. We sample 20 unseen hand-drawn sketches, and then assign each sketch to 5 methods:\nPITI \\[ [89])\\]’s sketch model,\nSketch-Guided Diffusion (SGD) \\[ [88])\\] with default edge-guidance scale (β=1.6𝛽1.6\\\\beta=1.6),\nSGD \\[ [88])\\] with relatively high edge-guidance scale (β=3.2𝛽3.2\\\\beta=3.2),\nthe aforementioned ControlNet-lite, and ControlNet. We invited\n12 users to rank these 20 groups of 5 results individually in terms of _“the quality of displayed images”_ and _“the fidelity to the sketch”_.\nIn this way, we obtain 100 rankings for result quality and 100 for condition fidelity.\nWe use the Average Human Ranking (AHR) as a preference metric where users rank each result on a scale of 1 to 5 (lower is worse).\nThe average rankings are shown in Table [1]Table 1 ‣ 3.4 Inference ‣ 3 Method ‣ Adding Conditional Control to Text-to-Image Diffusion Models\").\n\nComparison to industrial models. Stable Diffusion V2 Depth-to-Image (SDv2-D2I) \\[ [83])\\] is trained with a large-scale NVIDIA A100 cluster, thousands of GPU hours, and more than 12M training images. We train a ControlNet for the SD V2 with the same depth conditioning but only use 200k training samples, one single NVIDIA RTX 3090Ti, and 5 days of training. We use 100 images generated by each SDv2-D2I and ControlNet to teach 12 users to distinguish the two methods. Afterwards, we generate 200 images and ask the users to tell which model generated each image. The average precision of the users is 0.52±0.17plus-or-minus0.520.170.52\\\\pm 0.17, indicating that the two method yields almost indistinguishable results.\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n| Method | FID ↓↓\\\\downarrow | CLIP-score ↑↑\\\\uparrow | CLIP-aes. ↑↑\\\\uparrow |\n| Stable Diffusion | 6.09 | 0.26 | 6.32 |\n| VQGAN \\[ [19])\\](seg.)\\* | 26.28 | 0.17 | 5.14 |\n| LDM \\[ [72])\\](seg.)\\* | 25.35 | 0.18 | 5.15 |\n| PITI \\[ [89])\\](seg.) | 19.74 | 0.20 | 5.77 |\n| ControlNet-lite | 17.92 | 0.26 | 6.30 |\n| ControlNet | 15.27 | 0.26 | 6.31 |\n\nTable 3: Evaluation for image generation conditioned by semantic segmentation. We report FID, CLIP text-image score, and CLIP aesthetic scores for our method and other baselines. We also report the performance of Stable Diffusion without segmentation conditions. Methods marked with “\\*” are trained from scratch.\n\nCondition reconstruction and FID score.\nWe use the test set of ADE20K \\[ [96])\\] to evaluate the conditioning fidelity.\nThe state-of-the-art segmentation method OneFormer \\[ [35])\\] achieves an Intersection-over-Union (IoU) with 0.58 on the ground-truth set.\nWe use different methods to generate images with ADE20K segmentations and then apply OneFormer to detect the segmentations again to compute the reconstructed IoUs (Table [2]Table 2 ‣ 4.2 Ablative Study ‣ 4 Experiments ‣ Adding Conditional Control to Text-to-Image Diffusion Models\")).\nBesides, we use Frechet Inception Distance (FID) \\[ [28])\\] to measure the distribution distance over randomly generated 512×\\\\times512 image sets using different segmentation-conditioned methods, as well as text-image CLIP scores \\[ [66])\\] and CLIP aesthetic score \\[ [79])\\] in Table [3]Table 3 ‣ 4.3 Quantitative Evaluation ‣ 4 Experiments ‣ Adding Conditional Control to Text-to-Image Diffusion Models\"). See also the supplementary material for detailed settings.\n\n### 4.4 Comparison to Previous Methods\n\nFigure [9]Figure 9 ‣ 4.2 Ablative Study ‣ 4 Experiments ‣ Adding Conditional Control to Text-to-Image Diffusion Models\") presents a visual comparison of baselines and our method (Stable Diffusion + ControlNet). Specifically, we show the results of PITI \\[ [89])\\], Sketch-Guided Diffusion \\[ [88])\\], and Taming Transformers \\[ [19])\\]. (Note that the backbone of PITI is OpenAI GLIDE \\[ [57])\\] that have different visual quality and performance.)\nWe observe that ControlNet can robustly handle diverse conditioning images and achieves sharp and clean results.\n\n![Refer to caption]Figure 10: The influence of different training dataset sizes. See also the supplementary material for extended examples.![Refer to caption]Figure 11: Interpreting contents. If the input is ambiguous and the user does not mention object contents in prompts, the results look like the model tries to interpret input shapes.![Refer to caption]Figure 12: Transfer pretrained ControlNets to community models \\[ [16]), [61])\\] without training the neural networks again.\n\n### 4.5 Discussion\n\nInfluence of training dataset sizes.\nWe demonstrate the robustness of the ControlNet training in Figure [10]Figure 10 ‣ 4.4 Comparison to Previous Methods ‣ 4 Experiments ‣ Adding Conditional Control to Text-to-Image Diffusion Models\").\nThe training does not collapse with limited 1k images, and allows the model to generate a recognizable lion.\nThe learning is scalable when more data is provided.\n\nCapability to interpret contents.\nWe showcase ControlNet’s capability to capture the semantics from input conditioning images in Figure [11]Figure 11 ‣ 4.4 Comparison to Previous Methods ‣ 4 Experiments ‣ Adding Conditional Control to Text-to-Image Diffusion Models\").\n\nTransferring to community models.\nSince ControlNets do not change the network topology of pretrained SD models, it can be directly applied to various models in the stable diffusion community, such as Comic Diffusion \\[ [61])\\] and Protogen 3.4 \\[ [16])\\], in Figure [12]Figure 12 ‣ 4.4 Comparison to Previous Methods ‣ 4 Experiments ‣ Adding Conditional Control to Text-to-Image Diffusion Models\").",
            "citations": null
          },
          "5 Conclusion": {
            "content": "ControlNet is a neural network structure that learns\nconditional control for large pretrained text-to-image\ndiffusion models. It reuses the large-scale pretrained layers\nof source models to build a deep and strong encoder to learn\nspecific conditions. The original model and trainable copy are\nconnected via “zero convolution” layers that eliminate\nharmful noise during training. Extensive experiments verify\nthat ControlNet can effectively control Stable Diffusion with\nsingle or multiple conditions, with or without prompts.\nResults on diverse conditioning datasets show that the\nControlNet structure is likely to be applicable to a wider\nrange of conditions, and facilitate relevant applications.",
            "citations": null
          }
        },
        "abstract": "We present ControlNet, a neural network architecture to add spatial\nconditioning controls to large, pretrained text-to-image diffusion models.\nControlNet locks the production-ready large diffusion models, and reuses their\ndeep and robust encoding layers pretrained with billions of images as a strong\nbackbone to learn a diverse set of conditional controls. The neural\narchitecture is connected with \"zero convolutions\" (zero-initialized\nconvolution layers) that progressively grow the parameters from zero and ensure\nthat no harmful noise could affect the finetuning. We test various conditioning\ncontrols, eg, edges, depth, segmentation, human pose, etc, with Stable\nDiffusion, using single or multiple conditions, with or without prompts. We\nshow that the training of ControlNets is robust with small (<50k) and large\n(>1m) datasets. Extensive results show that ControlNet may facilitate wider\napplications to control image diffusion models."
      },
      "bib.bib116": {
        "id": "bib.bib116",
        "citation": "[116]",
        "authors": "",
        "year": "",
        "title": "Motiondiffuse: Text-driven human motion generation with diffusion model.",
        "venue": "",
        "pages": "",
        "url": "https://arxiv.org/abs/2208.15001",
        "arxiv_id": "2208.15001",
        "doi": null,
        "sections": {
          "1 Introduction": {
            "content": "![Refer to caption]Figure 1: MotionDiffuse is a diffusion model-based text-driven motion generation method that features _1) Probabilistic Mapping 2) Realistic Synthesis_ that results in highly diverse motions with high-fidelity shown in a)-d), and _3) Multi-Level Manipulation_ that empowers comprehensive motion generation such as that in c) where multiple body parts are involved and d) where time-varied prompts are given.\n\nHuman motion modeling is a critical component of animating virtual characters to imitate vivid and rich human movements, which has been a vital topic for many applications, such as film-making, game development, and virtual YouTuber animation.\nTo mimic human motions, virtual characters should be capable of moving around naturally, reacting to environmental stimuli, and meanwhile expressing sophisticated emotions.\nDespite decades of exciting technological breakthroughs, it requires sophisticated equipment (e.g., expensive motion capture systems) and domain experts to produce lively and authentic body movements.\nIn order to remove skill prerequisites for layman users and potentially scale to the mass audience, it is vital to create a versatile human motion generation model that could produce diverse, easily manipulable motion sequences.\n\nVarious condition signals, including pre-defined motion categories (Guo et al., [2020]); Petrovich et al., [2021]); Cervantes et al., [2022])), music pieces (Huang et al., [2020]); Li et al., [2020]), [2021]); Zhuang et al., [2020]); Siyao et al., [2022])), and natural language  (Lin et al., [2018]); Ahuja and Morency, [2019]); Ghosh et al., [2021]); Petrovich et al., [2022])), have been leveraged in previous human motion generation methods.\nAmong them, natural language is arguably the most user-friendly and convenient input format for motion sequence synthesis, and hence we focus on text-driven motion generation in this work.\nRecently, TEMOS (Petrovich et al., [2022])) utilizes KIT Motion-Language MoCap dataset (Plappert et al., [2016])) to demonstrate fine-grained trajectory synthesis.\nHowever, it does not support stylizing the generated motions and, therefore, could not achieve high diversity.\nMotionCLIP (Tevet et al., [2022])) could generate stylized motions, but it is still limited to short text inputs and fails to handle complicated motion descriptions.\nIn addition, they (Petrovich et al., [2022]); Tevet et al., [2022])) typically only accept a single text prompt, which greatly limits users’ creativity.\n\nTo tackle the aforementioned challenges, we propose MotionDiffuse, a versatile and controllable motion generation framework that could generate diverse motions with comprehensive texts.\nInspired by the recent progress of the text-conditioned image generation (Dhariwal and Nichol, [2021]); Nichol and Dhariwal, [2021]); Nichol et al., [2021]); Ramesh et al., [2022])), we propose to incorporate Denoising Diffusion Probabilistic Models (DDPM) (Ho et al., [2020])) into motion generation.\nUnlike classical DDPM which is only capable of fixed-size generation, we propose a Cross-Modality Linear Transformer to achieve motion synthesis with an arbitrary length depending on the motion duration.\nInstead of learning a direct mapping between the text space and the motion space (Tevet et al., [2022])), we propose to guide the generation pipeline with input texts softly, which could significantly increase the diversity of the generation results.\nTo maintain the uncertainties in the denoising process, we process the noise terms conditioned on the input texts by several transformer decoder layers for each denoising step.\nIn this way, the text conditions would not dominate the motion generation in a deterministic way, which facilitates generating diverse motion sequences from the driving texts.\n\nFurthermore, MotionDiffuse can achieve body part-independent control with fine-grained texts.\nSpecifically, to accommodate the human body structures, MotionDiffuse divides the whole-body motion into several near-independent parts(e.g. upper body and lower body).\nBased on the fine-grained body parts definition, we propose ‘noise interpolation’ to separately control different body parts while taking their correlations into consideration.\nMoreover, to synthesize arbitrary-length motion sequences, we propose a new sampling method to denoise several overlapped sequences simultaneously.\nSpecifically, MotionDiffuse first gets results from each sequence independently and then mixes them with correction terms.\nDifferent from auto-regressive inference schemes that often require many long motion sequences for training, MotionDiffuse is capable of modeling the correlations between continuous actions without introducing additional training costs.\n\nWe perform both extensive qualitative experiments on popular benchmarks, and quantitative evaluation on comprehensive motion generation. Firstly, we demonstrate significant improvements on text-driven motion generation over the current art on HumanML3D and KIT-ML. Secondly, to illustrate the superiority of MotionDiffuse, we directly apply it to action-conditioned motion generation tasks, and it outperforms all existing works on the HumanAct12 dataset and the UESTC datasets. Furthermore, we also demonstrate more possibilities of MotionDiffuse by conditioning the model on mixed control signals that allow body-part level manipulation and long motion generation.\n\nIn summary, our proposed MotionDiffuse has several desired properties over prior arts:\n\n- •\n\n\n_Probabilistic Mapping._ Benefiting from our new formulation of motion generation, where the DDPM is incorporated in, MotionDiffuse can be conditioned on text descriptions to generate motions in a probabilistic style, naturally leading to high diversity.\n\n- •\n\n\n_Realistic Synthesis._ The careful design of the architecture allows MotionDiffuse to synthesize high-fidelity motion sequences and achieves state-of-the-art on two conditional motion generation tasks.\n\n- •\n\n\n_Multi-Level Manipulation._ With the extended design, MotionDiffuse handles fine-grained text descriptions that mobilize the entire body (e.g. ‘a person is drinking water while walking’) and time-varied signals (e.g. ‘a person is walking and then running’).",
            "citations": null
          },
          "2 Related Work": {
            "content": "### 2.1 Motion Generative Model\n\nMotion Generation has been studied for decades. Some early works focus on unconditional motion generation (Rose et al., [1998]); Ikemoto et al., [2009]); Mukai and Kuriyama, [2005])). While some other works try to predict future motions given an initial pose or a starter motion sequence (Futrelle and Speckert, [1978]); Gavrila, [1999]); O’rourke and Badler, [1980])). Statistical models such as PCA (Ormoneit et al., [2005])), Motion Graph (Min and Chai, [2012])) are applied for these purposes.\n\nWith the rapid development of Deep Learning (DL) techniques, more generative architectures occur and flourish. Previous works can be broadly divided into four groups: 1) Variational Auto Encoder (VAE); 2) Generative Adversarial Networks (GAN); 3) Normalization Flow Network; 4) Implicit Neural Representations.\n\nVAE (Kingma and Welling, [2013])) is one of the most commonly used generative models in motion synthesis. Yan et al. ( [2018])) and Aliakbarian et al. ( [2020])) regard the motion generation task as predicting a small future motion sequence with the given small current motion sequence. They use VAE to encode the pair of current sequence and future sequence and then reconstruct the future one. ACTOR (Petrovich et al., [2021])) proposes a transformer-based encoder and decoder architecture. Transformer Encoder Layers and Transformer Decoder Layers (Vaswani et al., [2017])) are the basic blocks to build up a motion encoder and a motion decoder. This architecture is also employed in later works (Tevet et al., [2022]); Hong et al., [2022]); Petrovich et al., [2022])).\n\nGAN (Goodfellow et al., [2014])) introduces an auxiliary module, discriminator network, to justify the quality and validity of generated samples.\nSome works focus on proposing appropriate discriminator networks for motion generation to improve the synthesis quality (Barsoum et al., [2018]); Harvey et al., [2020]); Wang et al., [2020])). HP-GAN (Barsoum et al., [2018])) attempts to supervise the motion prediction results without the specific ground truth. Therefore, a data-driven discriminator is involved in learning a motion prior, which is used to justify the prediction quality. Harvey et al. ( [2020])) target solving the blurriness of the predicted motion in the Motion In-between task and propose two discriminators for both short-term critic and long-term critic. Wang et al. ( [2020])) build up a cyclic pipeline. With the help of a discriminator, the proposed pipeline can generate both class-specific and mixed-class motion sequences.\n\nNormalization Flow Network (Dinh et al., [2014])) has a long history and has been studied extensively for image synthesis (Dinh et al., [2016]); Kingma and Dhariwal, [2018])). This kind of architecture builds up a reversible neural network and will map the input data into a multi-dimensional Gaussian distribution. Hence, we can generate an initially random vector from this distribution and feed them into the reversed network to generate motion samples. Inspired by the success of GLOW (Kingma and Dhariwal, [2018])), MoGlow (Henter et al., [2020])) proposes an auto-regressive normalization network to model motion sequences. History features from an LSTM model (Hochreiter and Schmidhuber, [1997])) serve as the condition of the flow network, which predicts the next pose.\n\nRecently, another generative model has attracted much attention with the considerable success achieved by NeRF (Mildenhall et al., [2020]); Jain et al., [2021])) in rendering realistic images. Implicit Neural Representations (INR) are a series of neural networks that optimize their parameters to fit one sample instead of the whole distribution. One principal advantage is that this technique has superb generalization ability on spatial or temporal dimensions. For example, Cervantes et al. ( [2022])) propose an implicit scheme, which simultaneously models action category and timestamp. Similar to the original NeRF, the timestamp is represented by sinusoidal values. After supervised training, the proposed method can generate a variable-length motion sequence for each action category.\n\nThis paper proposes a new motion generation pipeline based on the Denoising Diffusion Probabilistic Model (DDPM) (Ho et al., [2020])). One of the principal advantages of DDPM is that the formation of the original motion sequence can be retained. It means that we can easily apply more constraints during the denoising process. In the later sections, we will explore more potential of DDPM in different types of conditions. Besides, benefiting from this nature, DDPM can generate more diverse samples.\n\n### 2.2 Conditional Motion Generation\n\nThe increasing maturity of various generative models stimulates researchers’ enthusiasm to study conditional motion generation. For example, some works (Guo et al., [2020]); Petrovich et al., [2021]); Cervantes et al., [2022])) aim at synthesizing motion sequences of several specific categories. Action2Motion (Guo et al., [2020])) builds up a recurrent conditional VAE for motion generation. Given history memory, this model predicts the next pose under the constraints of the action category. ACTOR (Petrovich et al., [2021])) also uses VAE for random sampling. Unlike Action2Motion, ACTOR embeds the whole motion sequence into the latent space. This design avoids the accumulative error in the recurrent scheme. Besides, ACTOR proposes a Transformer-based motion encoder and decoder architecture. This structure significantly outperforms recurrent methods. Cervantes et al. ( [2022])) attempt to model motion sequence with implicit functions, which can generate motion sequences with varied lengths.\n\nAnother significant conditional motion generation task is music to dance. This task requires that the generated motion has beat-wise connectivity, is a specific kind of dance, or can express similar content with the music. Many works attempt to embed the music feature and motion feature into a joint space (Lee et al., [2019]); Sun et al., [2020]); Li et al., [2020]), [2021])). Unlike direct feature embedding, Bailando (Siyao et al., [2022])) proposes a two-stage dance generator. It first learns a quantized codebook of meaningful dance pieces and then attempts to generate the whole sequence with a series of elements from a codebook.\n\nSimilar to music-to-dance, text-driven motion generation can be regarded as learning a joint embedding of text feature space and motion feature space. There are two major differences. The first one is that language commands correlate more with the human body. Therefore, we expect to control each body part accurately. The second difference is that text-driven motion generation contains a vast range of motions. Some descriptions are direct commands to a specific body part, such as “touch head”. Some describes arbitrary concepts like “playing the violin”. Such huge complexity of motions brings many difficulties to the architecture design. Recently, many works have proposed text-driven motion generation pipelines. Most of them are deterministic generation (Ahuja and Morency, [2019]); Ghosh et al., [2021]); Tevet et al., [2022])), which means they can only generate a single result from the given text. TEMOS  (Petrovich et al., [2022])) introduces the VAE architecture into this task. It can generate different motion sequences given one text description. However, these methods attempt to acquire a joint embedding space of motion and natural language. This design significantly compresses the information from text. Therefore, these works can hardly generate correct motion sequences from a detailed description. Guo et al. ( [2022])) proposes an auto-regressive pipeline. It first encodes language descriptions into features and then auto-regressively generates motion frames conditioned on the text features. However, this method is hard to capture the global relation due to the auto-regressive scheme. Moreover, the generation quality is inferior. Instead, our proposed MotionDiffuse softly fuses text features into generation and can yield the whole sequence simultaneously. The experiment results prove the superiority of our design.\n\n### 2.3 Motion Datasets\n\nHuman motion modeling has been a long-standing problem in computer vision and computer graphics. With the advent of deep learning, data has become increasingly important for training neural networks that perceive, understand, and generate human motions.\n\nA common form of datasets containing videos of human subjects are recorded with annotations such as 2D keypoints (Jhuang et al., [2013]); Andriluka et al., [2018])), 3D keypoints (Ionescu et al., [2013]); Joo et al., [2015]); Mehta et al., [2017]); Trumble et al., [2017]); Li et al., [2021])) and statistical model parameters (Yu et al., [2020]); Patel et al., [2021]); Cao et al., [2020]); Cai et al., [2021]), [2022])). Action labels are also a popular attribute of datasets for human action understanding that contains human-centric actions (Kuehne et al., [2011]); Soomro et al., [2012]); Karpathy et al., [2014]); Gu et al., [2018]); Shao et al., [2020]); Chung et al., [2021])), interaction (Carreira et al., [2019]); Monfort et al., [2019]); Zhao et al., [2019])), fine-grained action understanding (Gu et al., [2018]); Shao et al., [2020]); Chung et al., [2021])) and 3D data (Liu et al., [2019])). For the action-conditioned motion generation task, HumanAct12 (Guo et al., [2020])), UESTC (Ji et al., [2018])), and NTU RGB+D (Liu et al., [2019])) are three commonly used benchmarks. However, the above-mentioned datasets do not provide paired sophisticated semantic labels to the motion sequences.\n\nKIT (Plappert et al., [2016])) contains motion capture data annotated with detailed descriptions. Zhang et al. ( [2020])) recruit actors and actresses to record body movements expressing emotions. Recently, BABEL (Punnakkal et al., [2021])) and HumanML3D (Guo et al., [2022])) re-annotates AMASS (Mahmood et al., [2019])), a large scale motion capture dataset, with English language labels.\n\nIn this paper, we use the HumanML3D dataset and KIT dataset to evaluate the proposed methods for the text-driven motion generation task. HumanAct12 and UESTC are used to demonstrate the wide applicability of the proposed pipeline. Furthermore, we use the BABEL dataset for additional applications.",
            "citations": null
          },
          "3 Methodology": {
            "content": "We present a diffusion model-based framework, MotionDiffuse, for high-fidelity and controllable text-driven motion generation. We first give the problem definition, settings of the original text-driven motion generation in Section [3.1]Preliminaries ‣ 3 Methodology ‣ MotionDiffuse: Text-Driven Human Motion Generation with Diffusion Model\"). After that, we provide an overall illustration of the proposed MotionDiffuse in Section [3.2]Pipeline Overview ‣ 3 Methodology ‣ MotionDiffuse: Text-Driven Human Motion Generation with Diffusion Model\"), followed by introducing the diffusion model in Section [3.3]Diffusion Model for Motion Generation ‣ 3 Methodology ‣ MotionDiffuse: Text-Driven Human Motion Generation with Diffusion Model\") and the transformer-based architecture in Section [3.4]Cross-Modality Linear Transformer ‣ 3 Methodology ‣ MotionDiffuse: Text-Driven Human Motion Generation with Diffusion Model\"). Finally, the inference strategy is illustrated for the fine-grained generation scenarios in Section [3.5]Fine-grained Controlling ‣ 3 Methodology ‣ MotionDiffuse: Text-Driven Human Motion Generation with Diffusion Model\").\n\n### 3.1 Preliminaries\n\nThe motion sequence ΘΘ\\\\Theta is an array of (θi)subscript𝜃𝑖(\\\\theta\\_{i}), i∈{1,2,…,F}𝑖12…𝐹i\\\\in\\\\{1,2,\\\\dots,F\\\\}, where θi∈ℝDsubscript𝜃𝑖superscriptℝ𝐷\\\\theta\\_{i}\\\\in\\\\mathbb{R}^{D} represents the pose state in the i𝑖i-th frame, and F𝐹F is the number of frames. The representation of each pose state θisubscript𝜃𝑖\\\\theta\\_{i} is distinct in different datasets. It generally contains joint rotation, joint position, joint velocity, and foot contact conditions. Our proposed MotionDiffuse is robust to the various motion representations. Therefore, we do not specify the components of θisubscript𝜃𝑖\\\\theta\\_{i} in this section, and leave the details in Section [4]Experiments ‣ MotionDiffuse: Text-Driven Human Motion Generation with Diffusion Model\").\n\nFor standard Text-driven Motion Generation, the training datasets consist of (θi,texti)subscript𝜃𝑖subscripttext𝑖(\\\\theta\\_{i},\\\\textrm{text}\\_{i}) pairs, where textisubscripttext𝑖\\\\textrm{text}\\_{i} is the language description of motion sequence θisubscript𝜃𝑖\\\\theta\\_{i}. During inference, given a set of descriptions {texti}subscripttext𝑖\\\\{\\\\textrm{text}\\_{i}\\\\}, we are requested to generate motion sequences conditioned on the given descriptions. This task can also be regarded as a text-to-motion translation (T2M) task. We will use this abbreviation below.\n\nAn related task is Action-conditioned Motion Generation. Given a pre-defined action category set, models are supposed to fit the data distribution and synthesize motion sequences of each category. Annotated data in this task can be represented as (yi,Θi)subscript𝑦𝑖subscriptΘ𝑖{(y\\_{i},\\\\Theta\\_{i})}, where yisubscript𝑦𝑖y\\_{i} is the category index of i𝑖i-th data, ΘisubscriptΘ𝑖\\\\Theta\\_{i} is the motion sequence of i𝑖i-th data. In this paper, we replace yisubscript𝑦𝑖y\\_{i} by its semantic description textisubscripttext𝑖\\\\textrm{text}\\_{i}. Then we can use the same pipeline as in the T2M task.\n\n### 3.2 Pipeline Overview\n\n![Refer to caption]Figure 2: Overall Pipeline of the proposed MotionDiffuse. The colors of the arrows indicate different stages: blue for training, red for inference, and black for both training and inference.\n\nFollowing the literature on the diffusion model in the image synthesis field (Ho et al., [2020])), we first build up a text-conditioned motion generation pipeline using a denoising diffusion probabilistic model (DDPM). This model is the basis of our proposed MotionDiffuse. For the denoising process, we propose a Cross-Modality Linear Transformer to process input sequences conditioned on the given text prompts. Beyond the direct application of text-driven motion generation, we take one step further to explore methods that are conditioned on motion representation during denoising. Specifically, we experiment with two types of additional signals: part-aware text controlling and time-varied controlling. The former assigns different text conditions to different body parts so that we can accurately control each part of the body and generate more complicated motion sequences. The latter divides the whole sequence into several parts and assigns independent text conditions for each interval. Therefore, we can synthesize arbitrary-length motion sequences that incorporate several actions. These two kinds of conditions significantly expand the capability of MotionDiffuse. The overall pipeline is shown in Figure [2]Figure 2 ‣ 3.2 Pipeline Overview ‣ 3 Methodology ‣ MotionDiffuse: Text-Driven Human Motion Generation with Diffusion Model\"). We introduce each part of this architecture in the following subsections.\n\n### 3.3 Diffusion Model for Motion Generation\n\nGenerative Adversarial Networks (GANs) involve a discriminator to improve the generation quality in an adversarial manner. GANs are typically challenging to train, especially for conditional motion generation tasks. Implicit Functions use Multi-Layer Perceptron (MLP) to fit motion sequences. This neat architecture is easily trained on a small number of data but tends to be less generalizable when it is subjected to complicated conditions. Auto-Encoder (AE) and Variational Auto-Encoder (VAE) are the most widely used approaches in text-driven motion generation (Ghosh et al., [2021]); Petrovich et al., [2022])). Previous works learn a joint embedding of motion sequences and languages that explicitly apply the text condition in the deterministic language-motion mapping. However, high-level text features typically contain insufficient fine-grained details to guide the generation of subtly different motion. Hence, directly linking text embedding to motion embedding results in the limited diversity of the generated motions.\n\nTo tackle the problem, we build our text-driven motion generation pipeline based on diffusion models. Diffusion Models (Ho et al., [2020]); Dhariwal and Nichol, [2021]); Nichol and Dhariwal, [2021]); Nichol et al., [2021])) are a new class of generative models.\nA probabilistic model is learned to gradually denoises a Gaussian noise to generate a target output, such as a 2D image or 3D point cloud.\nFormally, diffusion models are formulated as pθ​(𝐱0):=∫pθ​(𝐱0:T)​𝑑𝐱1:Tassignsubscript𝑝𝜃subscript𝐱0subscript𝑝𝜃subscript𝐱:0𝑇differential-dsubscript𝐱:1𝑇p\\_{\\\\theta}(\\\\mathbf{x}\\_{0})\\\\,:=\\\\,\\\\int{p\\_{\\\\theta}(\\\\mathbf{x}\\_{0:T})\\\\,d{\\\\mathbf{x}\\_{1:T}}}, where 𝐱0∼q​(𝐱0)similar-tosubscript𝐱0𝑞subscript𝐱0\\\\mathbf{x}\\_{0}\\\\sim q(\\\\mathbf{x}\\_{0}) is the real data, and 𝐱1,⋯,𝐱Tsubscript𝐱1⋯subscript𝐱𝑇\\\\mathbf{x}\\_{1},\\\\cdots,\\\\mathbf{x}\\_{T} are the latent data.\nThey generally have a diffusion process and a reverse process.\nTo approximate posterior q​(𝐱1:T\\|𝐱0)𝑞conditionalsubscript𝐱:1𝑇subscript𝐱0q(\\\\mathbf{x}\\_{1:T}\\|\\\\mathbf{x}\\_{0}), the diffusion process follows a Markov chain to gradually add Gaussian noise to the data until its distribution is close to the latent distribution 𝒩​(𝟎,𝐈)𝒩0𝐈\\\\mathcal{N}(\\\\mathbf{0},\\\\mathbf{I}), according to variance schedules given by βtsubscript𝛽𝑡\\\\beta\\_{t}:\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n|  |  | q​(𝐱1:T\\|𝐱0):=∏t=1Tq​(𝐱t\\|𝐱t−1),assign𝑞conditionalsubscript𝐱:1𝑇subscript𝐱0superscriptsubscriptproduct𝑡1𝑇𝑞conditionalsubscript𝐱𝑡subscript𝐱𝑡1\\\\displaystyle q(\\\\mathbf{x}\\_{1:T}\\|\\\\mathbf{x}\\_{0})\\\\,:=\\\\,\\\\prod\\_{t=1}^{T}q(\\\\mathbf{x}\\_{t}\\|\\\\mathbf{x}\\_{t-1}), |  | (1) |\n|  |  | q​(𝐱t\\|𝐱t−1):=𝒩​(𝐱t;1−βt​𝐱t−1,βt​𝐈).assign𝑞conditionalsubscript𝐱𝑡subscript𝐱𝑡1𝒩subscript𝐱𝑡1subscript𝛽𝑡subscript𝐱𝑡1subscript𝛽𝑡𝐈\\\\displaystyle q(\\\\mathbf{x}\\_{t}\\|\\\\mathbf{x}\\_{t-1})\\\\,:=\\\\,\\\\mathcal{N}(\\\\mathbf{x}\\_{t};\\\\sqrt{1-\\\\beta\\_{t}}\\\\mathbf{x}\\_{t-1},\\\\beta\\_{t}\\\\mathbf{I}). |  |\n\nThe reverse process pθ​(𝐱0:T)subscript𝑝𝜃subscript𝐱:0𝑇p\\_{\\\\theta}(\\\\mathbf{x}\\_{0:T}) is also a Markov chain that predicts and eliminates the noise with learned Gaussian transitions starting at p​(𝐱T)=𝒩​(𝐱T;𝟎,𝐈)𝑝subscript𝐱𝑇𝒩subscript𝐱𝑇0𝐈p(\\\\mathbf{x}\\_{T})=\\\\mathcal{N}(\\\\mathbf{x}\\_{T};\\\\mathbf{0},\\\\mathbf{I}):\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n|  |  | pθ​(𝐱0:T):=p​(𝐱T)​∏t=1Tpθ​(𝐱t−1\\|𝐱t),assignsubscript𝑝𝜃subscript𝐱:0𝑇𝑝subscript𝐱𝑇superscriptsubscriptproduct𝑡1𝑇subscript𝑝𝜃conditionalsubscript𝐱𝑡1subscript𝐱𝑡\\\\displaystyle p\\_{\\\\theta}(\\\\mathbf{x}\\_{0:T})\\\\,:=\\\\,p(\\\\mathbf{x}\\_{T})\\\\prod\\_{t=1}^{T}p\\_{\\\\theta}(\\\\mathbf{x}\\_{t-1}\\|\\\\mathbf{x}\\_{t}), |  | (2) |\n|  |  | pθ​(𝐱t−1\\|𝐱t):=𝒩​(𝐱t−1;μθ​(𝐱t,t),Σθ​(𝐱t,t)).assignsubscript𝑝𝜃conditionalsubscript𝐱𝑡1subscript𝐱𝑡𝒩subscript𝐱𝑡1subscript𝜇𝜃subscript𝐱𝑡𝑡subscriptΣ𝜃subscript𝐱𝑡𝑡\\\\displaystyle p\\_{\\\\theta}(\\\\mathbf{x}\\_{t-1}\\|\\\\mathbf{x}\\_{t})\\\\,:=\\\\,\\\\mathcal{N}(\\\\mathbf{x}\\_{t-1};\\\\mu\\_{\\\\theta}(\\\\mathbf{x}\\_{t},t),\\\\Sigma\\_{\\\\theta}(\\\\mathbf{x}\\_{t},t)). |  |\n\nTo accomplish the reverse process of the diffusion model, we need to construct and optimize a neural network. During training, first we uniformly sample steps t𝑡t for each ground truth motion 𝐱0subscript𝐱0\\\\mathbf{x}\\_{0} and then generate a sample from\nq​(𝐱t\\|𝐱0)𝑞conditionalsubscript𝐱𝑡subscript𝐱0q(\\\\mathbf{x}\\_{t}\\|\\\\mathbf{x}\\_{0}). Instead of repeatedly adding noises on 𝐱0subscript𝐱0\\\\mathbf{x}\\_{0}, Ho et al. ( [2020])) formulate the diffusion process as\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | q​(𝐱t\\|𝐱0)=αt¯​𝐱0+ϵ​1−αt¯,ϵ∼𝒩​(𝟎,𝐈),formulae-sequence𝑞conditionalsubscript𝐱𝑡subscript𝐱0¯subscript𝛼𝑡subscript𝐱0italic-ϵ1¯subscript𝛼𝑡similar-toitalic-ϵ𝒩0𝐈q(\\\\mathbf{x}\\_{t}\\|\\\\mathbf{x}\\_{0})=\\\\sqrt{\\\\bar{\\\\alpha\\_{t}}}\\\\mathbf{x}\\_{0}+\\\\epsilon\\\\sqrt{1-\\\\bar{\\\\alpha\\_{t}}},\\\\epsilon\\\\sim\\\\mathcal{N}(\\\\mathbf{0},\\\\mathbf{I}), |  | (3) |\n\nwhere αt=1−βtsubscript𝛼𝑡1subscript𝛽𝑡\\\\alpha\\_{t}=1-\\\\beta\\_{t}, αt¯=∏s=0tαs¯subscript𝛼𝑡superscriptsubscriptproduct𝑠0𝑡subscript𝛼𝑠\\\\bar{\\\\alpha\\_{t}}=\\\\prod\\_{s=0}^{t}\\\\alpha\\_{s}. Hence, we can simply sample a noise ϵitalic-ϵ\\\\epsilon and then directly generate 𝐱tsubscript𝐱𝑡\\\\mathbf{x}\\_{t} by this formulation. Instead of predicting 𝐱t−1subscript𝐱𝑡1\\\\mathbf{x}\\_{t-1}, here we follow GLIDE (Nichol et al., [2021])) and predict the noise term ϵitalic-ϵ\\\\epsilon. It means that we need to construct a network to fit ϵθ​(𝐱t,t,text)subscriptitalic-ϵ𝜃subscript𝐱𝑡𝑡text\\\\epsilon\\_{\\\\theta}(\\\\mathbf{x}\\_{t},t,\\\\textrm{text}). We optimize the model parameters to decrease a mean squared error as\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | ℒ=Et∈\\[1,T\\],𝐱0∼q​(𝐱0),ϵ∼𝒩​(𝟎,𝐈)​\\[‖ϵ−ϵθ​(𝐱t,t,text)‖\\].ℒsubscriptEformulae-sequence𝑡1𝑇formulae-sequencesimilar-tosubscript𝐱0𝑞subscript𝐱0similar-toitalic-ϵ𝒩0𝐈delimited-\\[\\]normitalic-ϵsubscriptitalic-ϵ𝜃subscript𝐱𝑡𝑡text\\\\mathcal{L}=\\\\mathrm{E}\\_{t\\\\in\\[1,T\\],\\\\mathbf{x}\\_{0}\\\\sim q(\\\\mathbf{x}\\_{0}),\\\\epsilon\\\\sim\\\\mathcal{N}(\\\\mathbf{0},\\\\mathbf{I})}\\[\\\\parallel\\\\epsilon-\\\\epsilon\\_{\\\\theta}(\\\\mathbf{x}\\_{t},t,\\\\textrm{text})\\\\parallel\\]. |  | (4) |\n\nThis is the only loss we used in model training. To generate samples from the given text description, we denoise the sequence from p​(𝐱T)=𝒩​(𝐱T;𝟎,𝐈)𝑝subscript𝐱𝑇𝒩subscript𝐱𝑇0𝐈p(\\\\mathbf{x}\\_{T})=\\\\mathcal{N}(\\\\mathbf{x}\\_{T};\\\\mathbf{0},\\\\mathbf{I}). Equation  [2]In 3.3 Diffusion Model for Motion Generation ‣ 3 Methodology ‣ MotionDiffuse: Text-Driven Human Motion Generation with Diffusion Model\") shows that we need to estimate μθ​(𝐱t,t,text)subscript𝜇𝜃subscript𝐱𝑡𝑡text\\\\mu\\_{\\\\theta}(\\\\mathbf{x}\\_{t},t,\\\\textrm{text}) and Σθ​(𝐱t,t,text)subscriptΣ𝜃subscript𝐱𝑡𝑡text\\\\Sigma\\_{\\\\theta}(\\\\mathbf{x}\\_{t},t,\\\\textrm{text}). To simplify the problem, we set Σθ​(𝐱t,t,text)subscriptΣ𝜃subscript𝐱𝑡𝑡text\\\\Sigma\\_{\\\\theta}(\\\\mathbf{x}\\_{t},t,\\\\textrm{text}) as a constant number βtsubscript𝛽𝑡\\\\beta\\_{t}. μθ​(𝐱t,t,text)subscript𝜇𝜃subscript𝐱𝑡𝑡text\\\\mu\\_{\\\\theta}(\\\\mathbf{x}\\_{t},t,\\\\textrm{text}) can be estimated as\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | μθ​(𝐱t,t,text)=1𝐱t​(𝐱t−1−αt1−αt¯​ϵθ​(𝐱t,t,text)).subscript𝜇𝜃subscript𝐱𝑡𝑡text1subscript𝐱𝑡subscript𝐱𝑡1subscript𝛼𝑡1¯subscript𝛼𝑡subscriptitalic-ϵ𝜃subscript𝐱𝑡𝑡text\\\\mu\\_{\\\\theta}(\\\\mathbf{x}\\_{t},t,\\\\textrm{text})=\\\\frac{1}{\\\\sqrt{\\\\mathbf{x}\\_{t}}}(\\\\mathbf{x}\\_{t}-\\\\frac{1-\\\\alpha\\_{t}}{\\\\sqrt{1-\\\\bar{\\\\alpha\\_{t}}}}\\\\epsilon\\_{\\\\theta}(\\\\mathbf{x}\\_{t},t,\\\\textrm{text})). |  | (5) |\n\nTherefore we can denoise the motion sequence step by step and finally get a clean motion sequence, which is conditioned on the given text.\n\n### 3.4 Cross-Modality Linear Transformer\n\n![Refer to caption]Figure 3: Architecture of our Linear Self-attention.\n\nIn Section [3.3]Diffusion Model for Motion Generation ‣ 3 Methodology ‣ MotionDiffuse: Text-Driven Human Motion Generation with Diffusion Model\"), we illustrate diffusion models as motion generators and a neural network ϵθ​(𝐱t,t,text)subscriptitalic-ϵ𝜃subscript𝐱𝑡𝑡text\\\\epsilon\\_{\\\\theta}(\\\\mathbf{x}\\_{t},t,\\\\textrm{text}) is essential for denoising steps. In this section, we will introduce the design of ϵθ​(𝐱t,t,text)subscriptitalic-ϵ𝜃subscript𝐱𝑡𝑡text\\\\epsilon\\_{\\\\theta}(\\\\mathbf{x}\\_{t},t,\\\\textrm{text}) in our proposed MotionDiffuse.\n\nPrevious works (Ho et al., [2020]); Dhariwal and Nichol, [2021]); Nichol and Dhariwal, [2021]); Nichol et al., [2021])) mainly utilize UNet-like structure as the denoising model. However, the target motion sequences are variable-length in the motion generation task, making convolution-based networks unsuitable. Therefore, we propose a Cross-Modality Linear Transformer, as shown in Figure  [2]Figure 2 ‣ 3.2 Pipeline Overview ‣ 3 Methodology ‣ MotionDiffuse: Text-Driven Human Motion Generation with Diffusion Model\"). Similar to the machine translation task, our proposed model includes a text encoder and a motion decoder. To meet the requirement of the diffusion models, we further customize each layer of the motion decoder.\n\n#### Text Encoder\n\nHere we directly use classical transformer Vaswani et al. ( [2017])) to extract text features. Specifically, the input data first passes through an embedding layer to get the embedding feature from raw text and then is further processed by a series of transformer blocks. Each block contains two components: a multi-head attention module (MHA) and a feed-forward network (FFN). Suppose the input feature is 𝐗∈ℝn×d𝐗superscriptℝ𝑛𝑑\\\\mathbf{X}\\\\in\\\\mathbb{R}^{n\\\\times d} (n𝑛n denotes the number of elements and d𝑑d denotes the element feature dimension), MHA extracts query feature vectors 𝐐∈ℝn×d𝐐superscriptℝ𝑛𝑑\\\\mathbf{Q}\\\\in\\\\mathbb{R}^{n\\\\times d}, key feature vectors 𝐊∈ℝn×d𝐊superscriptℝ𝑛𝑑\\\\mathbf{K}\\\\in\\\\mathbb{R}^{n\\\\times d}, and value feature vectors 𝐕∈ℝn×d𝐕superscriptℝ𝑛𝑑\\\\mathbf{V}\\\\in\\\\mathbb{R}^{n\\\\times d} as:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | Q=Wq​X,K=Wk​X,V=Wv​X,formulae-sequenceQsubscript𝑊𝑞Xformulae-sequenceKsubscript𝑊𝑘XVsubscript𝑊𝑣X\\\\textbf{Q}=W\\_{q}\\\\,\\\\textbf{X},\\\\;\\\\;\\\\;\\\\textbf{K}=W\\_{k}\\\\,\\\\textbf{X},\\\\;\\\\;\\\\;\\\\textbf{V}=W\\_{v}\\\\,\\\\textbf{X}, |  | (6) |\n\nwhere Wqsubscript𝑊𝑞W\\_{q}, Wksubscript𝑊𝑘W\\_{k} and Wvsubscript𝑊𝑣W\\_{v} are the corresponding linear projections to generate 𝐐𝐐\\\\mathbf{Q}, 𝐊𝐊\\\\mathbf{K} and 𝐕𝐕\\\\mathbf{V}, respectively.\nThe value features are then aggregated with attention weights 𝐀∈ℝn×n𝐀superscriptℝ𝑛𝑛\\\\mathbf{A}\\\\in\\\\mathbb{R}^{n\\\\times n}:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | 𝐀=softmax⁡(𝐐⊗𝐊⊤d),𝐘=𝐀⊗𝐕,formulae-sequence𝐀softmaxtensor-product𝐐superscript𝐊top𝑑𝐘tensor-product𝐀𝐕\\\\mathbf{A}=\\\\operatorname{softmax}(\\\\frac{\\\\mathbf{Q}\\\\otimes\\\\mathbf{K}^{\\\\top}}{\\\\sqrt{d}}),\\\\;\\\\;\\\\;\\\\mathbf{Y}=\\\\mathbf{A}\\\\otimes\\\\mathbf{V}, |  | (7) |\n\nwhere 𝐘∈ℝn×d𝐘superscriptℝ𝑛𝑑\\\\mathbf{Y}\\\\in\\\\mathbb{R}^{n\\\\times d} is the output of MHA modules, d𝑑d is the dimension of each element in 𝐗𝐗\\\\mathbf{X}, and ⊗tensor-product\\\\otimes denotes the matrix multiplication. The multi-head mechanism divides the input vector into several parts, which pass through the process in Equation [6]In Text Encoder ‣ 3.4 Cross-Modality Linear Transformer ‣ 3 Methodology ‣ MotionDiffuse: Text-Driven Human Motion Generation with Diffusion Model\") and [7]In Text Encoder ‣ 3.4 Cross-Modality Linear Transformer ‣ 3 Methodology ‣ MotionDiffuse: Text-Driven Human Motion Generation with Diffusion Model\") independently. The outputs are concatenated so that the dimension remains unchanged. A residual connection is applied between input and output of the MHA modules. This feature is further processed by FFN, which contains three linear transformations and two GELU (Hendrycks and Gimpel, [2016])) layers between them.\n\nTo enhance the generalization ability, we use parameter weights in CLIP (Radford et al., [2021])) to initialize the first several layers. This part of the parameters is frozen and will not be optimized in the later training.\n\n#### Linear Self-attention.\n\nThis module aims at enhancing motion features by modeling correlations between different frames. The principal advantage of self-attention is to get an overview of the input sequence and is thus beneficial to estimating the injected noise ϵitalic-ϵ\\\\epsilon. However, the time complexity of calculating attention weight 𝐀∈ℝn×n𝐀superscriptℝ𝑛𝑛\\\\mathbf{A}\\\\in\\\\mathbb{R}^{n\\\\times n} is 𝒪​(n2​d)𝒪superscript𝑛2𝑑\\\\mathcal{O}(n^{2}d). When the target motion sequence length increases, the time cost increases quadratically. In the T2M task, the length can be several hundred, which leads to low speed. Hence, we adopt Efficient Attention (Shen et al., [2021])) to speed up the self-attention module. Instead of calculating pair-wise attention weights, efficient attention generates global feature map 𝐅g∈ℝdk×dksubscript𝐅𝑔superscriptℝsubscript𝑑𝑘subscript𝑑𝑘\\\\mathbf{F}\\_{g}\\\\in\\\\mathbb{R}^{d\\_{k}\\\\times d\\_{k}}, where dksubscript𝑑𝑘d\\_{k} is the dimension of feature after multi-head split:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | 𝐅g=softmax⁡(𝐊⊤)⊗𝐕,𝐘=softmax⁡(𝐐)⊗𝐅g.formulae-sequencesubscript𝐅𝑔tensor-productsoftmaxsuperscript𝐊top𝐕𝐘tensor-productsoftmax𝐐subscript𝐅𝑔\\\\mathbf{F}\\_{g}=\\\\operatorname{softmax}(\\\\mathbf{K}^{\\\\top})\\\\otimes\\\\mathbf{V},\\\\;\\\\;\\\\;\\\\mathbf{Y}=\\\\operatorname{softmax}(\\\\mathbf{Q})\\\\otimes\\\\mathbf{F}\\_{g}. |  | (8) |\n\nThe time complexity of these two steps is 𝒪​(dk2​n​k)=𝒪​(d​dk​n)𝒪superscriptsubscript𝑑𝑘2𝑛𝑘𝒪𝑑subscript𝑑𝑘𝑛\\\\mathcal{O}(d\\_{k}^{2}nk)=\\\\mathcal{O}(dd\\_{k}n), where n𝑛n is the number of the elements in the sequences, k𝑘k is the number of heads of self-attention.\n\nAnother advantage of efficient attention for the diffusion model is that feature map 𝐅gsubscript𝐅𝑔\\\\mathbf{F}\\_{g} explicitly aggregates global information while classical self-attention focus more on pair-wise relation. Global information gives more clues about the semantic meaning of the motion sequence than pair-wise one. The experiment results also prove this conclusion.\n\n#### Linear Cross-attention.\n\nCross-attention replaces 𝐗𝐗\\\\mathbf{X} in 𝐊𝐊\\\\mathbf{K} and 𝐕𝐕\\\\mathbf{V} calculation by the text feature. Other formulations are the same as Linear Self-attention. Text features are injected into motion sequences in this process to generate motion conditioned on the given text.\n\n#### Stylization Block.\n\nIn each denoising step, the output is conditioned on the given text and the timestamp t𝑡t. Linear Cross-attention fuses the text features into motion sequences. We need another Stylization Block component to bring timestamp t𝑡t to the generation process. This block is applied after each Linear Self-attention block, Linear Cross-attention block, and FFN block.\n\nSimilar to GLIDE (Nichol et al., [2021])), we first get a text embedding etextsubscript𝑒texte\\_{\\\\textrm{text}} by a linear transformation on the text features and a timestamp embedding 𝐞𝐭subscript𝐞𝐭\\\\mathbf{e\\_{t}} by positional embedding (Vaswani et al., [2017])). These two terms are summed together into one single vector 𝐞𝐞\\\\mathbf{e}. Given the original output 𝐘𝐘\\\\mathbf{Y} from other blocks, the Stylization block will process the feature as:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | 𝐁=ψb​(ϕ​(𝐞)),𝐖=ψw​(ϕ​(𝐞)),𝐘′=𝐘⋅𝐖+𝐁,formulae-sequence𝐁subscript𝜓𝑏italic-ϕ𝐞formulae-sequence𝐖subscript𝜓𝑤italic-ϕ𝐞superscript𝐘′⋅𝐘𝐖𝐁\\\\mathbf{B}=\\\\psi\\_{b}(\\\\phi(\\\\mathbf{e})),\\\\;\\\\;\\\\;\\\\mathbf{W}=\\\\psi\\_{w}(\\\\phi(\\\\mathbf{e})),\\\\;\\\\;\\\\;\\\\mathbf{Y}^{\\\\prime}=\\\\mathbf{Y}\\\\cdot\\\\mathbf{W}+\\\\mathbf{B}, |  | (9) |\n\nwhere (⋅)⋅(\\\\cdot) denotes Hadamard product, 𝐘′superscript𝐘′\\\\mathbf{Y}^{\\\\prime} is the output of stylization blocks. ψb,ψw,ϕsubscript𝜓𝑏subscript𝜓𝑤italic-ϕ\\\\psi\\_{b},\\\\psi\\_{w},\\\\phi denote three different linear projections. In classical transformers, the output from each block is added to the original input as a residual connection, as shown in Figure  [2]Figure 2 ‣ 3.2 Pipeline Overview ‣ 3 Methodology ‣ MotionDiffuse: Text-Driven Human Motion Generation with Diffusion Model\"). In MotionDiffuse, these outputs pass through stylization blocks and are added to the information. This modification enables our proposed method to know the timestamp t𝑡t.\n\n### 3.5 Fine-grained Controlling\n\nTo enrich the capability of MotionDiffuse, we explore the properties of both the motion representation and the denoising process of DDPM. Unlike VAE, the generated motion sequence is in its explicit form instead of being compressed in the latent space. This characteristic of DDPM-based motion generation allows more operations to be applied to this motion sequence to increase the manipulability.\n\n#### Body Part-independent Controlling.\n\nDue to the lack of diversity in text descriptions, we cannot achieve accurate motion control for each body part from text descriptions only. For example, the prompt ‘a person is running and waving left hand’ is highly challenging to the model because the expected motion sequence is significantly far from the training distribution. Even if we manually split the original description into two independent ones: ‘a person is running’ for lower limbs, and ‘a person is waving left hand’ for upper limbs, it is still difficult for the model to generate correct motions. An intuitive solution for this situation is to separately generate two motion sequences and combine the upper-limb motion of the first sequence and the lower-limb motion of the second sequence. This simple solution mitigates the problem to some extent. However, it ignores the correlation between these two parts. Specifically for ‘running and waving left hand’, the frequencies of the two motions should match. Otherwise, the motion generated by this naive method appears unnatural. To better solve this problem, we propose a body part-independent controlling scheme.\n\nRecall that, during the denoising process, our diffusion model predicts the noise term ϵθ​(𝐱t,t,text)∈ℝF×Dsubscriptitalic-ϵ𝜃subscript𝐱𝑡𝑡textsuperscriptℝ𝐹𝐷\\\\epsilon\\_{\\\\theta}(\\\\mathbf{x}\\_{t},t,\\\\textrm{text})\\\\in\\\\mathbb{R}^{F\\\\times D}, where F𝐹F represents the number of frames, D𝐷D denotes the dimension of each pose state, which includes translation and rotations of body joints. This noise term determines the denoising direction of the whole body.\n\nInspired by the application of the latent code interpolation, here we propose ‘noise interpolation’ to separately control the different parts of the human body. Suppose we have n𝑛n text descriptions {texti}subscripttext𝑖\\\\{\\\\textrm{text}\\_{i}\\\\} for different body parts {si}subscript𝑠𝑖\\\\{s\\_{i}\\\\}. We want to calculate the noise term ϵ={ϵijoint},i∈\\[1,m\\]formulae-sequenceitalic-ϵsubscriptsuperscriptitalic-ϵjoint𝑖𝑖1𝑚\\\\epsilon=\\\\{\\\\epsilon^{\\\\textrm{joint}}\\_{i}\\\\},i\\\\in\\[1,m\\], where ϵijointsubscriptsuperscriptitalic-ϵjoint𝑖\\\\epsilon^{\\\\textrm{joint}}\\_{i} represents the noise term for the i𝑖i-th body part, m𝑚m denotes the number of partition. We first estimate the noise ϵipart=ϵθ​(𝐱t,t,texti),ϵipart∈ℝF×Dformulae-sequencesubscriptsuperscriptitalic-ϵpart𝑖subscriptitalic-ϵ𝜃subscript𝐱𝑡𝑡subscripttext𝑖subscriptsuperscriptitalic-ϵpart𝑖superscriptℝ𝐹𝐷\\\\epsilon^{\\\\textrm{part}}\\_{i}=\\\\epsilon\\_{\\\\theta}(\\\\mathbf{x}\\_{t},t,\\\\textrm{text}\\_{i}),\\\\epsilon^{\\\\textrm{part}}\\_{i}\\\\in\\\\mathbb{R}^{F\\\\times D}. An intuitive method for combining these terms is ϵpart=∑i=1mϵipart⋅Misuperscriptitalic-ϵpartsuperscriptsubscript𝑖1𝑚⋅subscriptsuperscriptitalic-ϵpart𝑖subscript𝑀𝑖\\\\epsilon^{\\\\textrm{part}}=\\\\sum\\_{i=1}^{m}\\\\epsilon^{\\\\textrm{part}}\\_{i}\\\\cdot M\\_{i}, where Mi∈{0,1}Dsubscript𝑀𝑖superscript01𝐷M\\_{i}\\\\in\\\\{0,1\\\\}^{D} is a binary vector to show which body part should we focus. (⋅)⋅(\\\\cdot) denotes the Hadamard product, and here we ignore the broadcast in computation for simplicity. Although this method succeeds to some extent, the direct ignoring of some parts in ϵipartsubscriptsuperscriptitalic-ϵpart𝑖\\\\epsilon^{\\\\textrm{part}}\\_{i} will increase the combination difficulty and lead to low-quality generation results. Therefore, we add a correction item for smoothing interpolation:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | ϵ¯part=∑i=1mϵipart⋅Mi+λ1⋅∇(∑1≤i,j≤m‖ϵipart−ϵjpart‖),superscript¯italic-ϵpartsuperscriptsubscript𝑖1𝑚⋅subscriptsuperscriptitalic-ϵpart𝑖subscript𝑀𝑖⋅subscript𝜆1∇subscriptformulae-sequence1𝑖𝑗𝑚normsubscriptsuperscriptitalic-ϵpart𝑖subscriptsuperscriptitalic-ϵpart𝑗\\\\overline{\\\\epsilon}^{\\\\textrm{part}}=\\\\sum\\_{i=1}^{m}\\\\epsilon^{\\\\textrm{part}}\\_{i}\\\\cdot M\\_{i}+\\\\lambda\\_{1}\\\\cdot\\\\nabla(\\\\sum\\\\limits\\_{1\\\\leq i,j\\\\leq m}\\\\\\|\\\\epsilon^{\\\\textrm{part}}\\_{i}-\\\\epsilon^{\\\\textrm{part}}\\_{j}\\\\\\|), |  | (10) |\n\nwhere ∇∇\\\\nabla denotes gradient calculation, λ1subscript𝜆1\\\\lambda\\_{1} is a hyper-parameter to balance these two items. This correction item enforces a smoother denoising direction so that the motion of different body parts will be more natural.\n\n#### Time-varied Controlling\n\nLong-term motion generation plays a vital role in real-world applications. Previous works mainly focus on motion generation with a single type of motion. Auto-regressive methods (Henter et al., [2020]); Guo et al., [2022])) have solved this problem with satisfactory performance. However, none of them are capable of synthesizing different actions in a continuous manner. Benefiting from the nature of DDPM, here we propose another sampling method to meet this requirement.\n\nRecall that we are given an array {texti,j,\\[li,j,ri,j\\]}subscripttext𝑖𝑗subscript𝑙𝑖𝑗subscript𝑟𝑖𝑗\\\\{\\\\textrm{text}\\_{i,j},\\[l\\_{i,j},r\\_{i,j}\\]\\\\}, i∈\\[1,m\\]𝑖1𝑚i\\\\in\\[1,m\\], where m𝑚m is the number of intervals. Similar to the method we proposed in the previous paragraph, we first estimate the noise term ϵitimesubscriptsuperscriptitalic-ϵtime𝑖\\\\epsilon^{\\\\textrm{time}}\\_{i} for i𝑖i-th interval independently. Suppose the overall length of the target sequence is F′superscript𝐹′F^{\\\\prime}. By padding zeros, we extend each noise term into the same dimension F′×Dsuperscript𝐹′𝐷F^{\\\\prime}\\\\times D. Then we interpolate these noises with a correcting term:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | ϵ¯time=∑i=1mϵ¯itime+λ2⋅∇(∑1≤i,j≤m‖ϵ¯itime−ϵ¯jtime‖),superscript¯italic-ϵtimesuperscriptsubscript𝑖1𝑚subscriptsuperscript¯italic-ϵtime𝑖⋅subscript𝜆2∇subscriptformulae-sequence1𝑖𝑗𝑚normsubscriptsuperscript¯italic-ϵtime𝑖subscriptsuperscript¯italic-ϵtime𝑗\\\\overline{\\\\epsilon}^{\\\\textrm{time}}=\\\\sum\\_{i=1}^{m}\\\\overline{\\\\epsilon}^{\\\\textrm{time}}\\_{i}+\\\\lambda\\_{2}\\\\cdot\\\\nabla(\\\\sum\\\\limits\\_{1\\\\leq i,j\\\\leq m}\\\\\\|\\\\overline{\\\\epsilon}^{\\\\textrm{time}}\\_{i}-\\\\overline{\\\\epsilon}^{\\\\textrm{time}}\\_{j}\\\\\\|), |  | (11) |\n\nwhere ϵ¯jtimesubscriptsuperscript¯italic-ϵtime𝑗\\\\overline{\\\\epsilon}^{\\\\textrm{time}}\\_{j} is the padded term from ϵitimesubscriptsuperscriptitalic-ϵtime𝑖\\\\epsilon^{\\\\textrm{time}}\\_{i}, λ2subscript𝜆2\\\\lambda\\_{2} is a hyper-parameter.",
            "citations": null
          },
          "4 Experiments": {
            "content": "We evaluate MotionDiffuse with three categories of experiments:\ntext-driven motion generation (Section [4.1]Text-driven Motion Generation ‣ 4 Experiments ‣ MotionDiffuse: Text-Driven Human Motion Generation with Diffusion Model\")), action-conditioned motion generation (Section [4.2]Action-conditioned Motion Generation ‣ 4 Experiments ‣ MotionDiffuse: Text-Driven Human Motion Generation with Diffusion Model\")),\nand motion manipulation (Section [4.3]Motion Manipulation ‣ 4 Experiments ‣ MotionDiffuse: Text-Driven Human Motion Generation with Diffusion Model\")).\nIn all the evaluated benchmarks, MotionDiffuse could significantly outperform previous SoTA methods.\n\n### 4.1 Text-driven Motion Generation\n\nTable 1: Quantitative results on the HumanML3D test set. All methods use the real motion length from the ground truth. ‘→→\\\\rightarrow’ means results are better if the metric is closer to the real motions. We run all the evaluation 20 times and ±plus-or-minus\\\\pm indicates the 95% confidence interval. The best results are in bold.\n\n| Methods | R Precision↑↑\\\\uparrow | FID↓↓\\\\downarrow | MultiModal Dist↓↓\\\\downarrow | Diversity→→\\\\rightarrow | MultiModality |\n| --- | --- | --- | --- | --- | --- |\n| Top 1 | Top 2 | Top 3 |\n| --- | --- | --- |\n| Real motions | 0.511±.003superscript0.511plus-or-minus.0030.511^{\\\\pm.003} | 0.703±.003superscript0.703plus-or-minus.0030.703^{\\\\pm.003} | 0.797±.002superscript0.797plus-or-minus.0020.797^{\\\\pm.002} | 0.002±.000superscript0.002plus-or-minus.0000.002^{\\\\pm.000} | 2.974±.008superscript2.974plus-or-minus.0082.974^{\\\\pm.008} | 9.503±.065superscript9.503plus-or-minus.0659.503^{\\\\pm.065} | - |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| Language2Pose | 0.246±.002superscript0.246plus-or-minus.0020.246^{\\\\pm.002} | 0.387±.002superscript0.387plus-or-minus.0020.387^{\\\\pm.002} | 0.486±.002superscript0.486plus-or-minus.0020.486^{\\\\pm.002} | 11.02±.046superscript11.02plus-or-minus.04611.02^{\\\\pm.046} | 5.296±.008superscript5.296plus-or-minus.0085.296^{\\\\pm.008} | 7.676±.058superscript7.676plus-or-minus.0587.676^{\\\\pm.058} | - |\n| Text2Gesture | 0.165±.001superscript0.165plus-or-minus.0010.165^{\\\\pm.001} | 0.267±.002superscript0.267plus-or-minus.0020.267^{\\\\pm.002} | 0.345±.002superscript0.345plus-or-minus.0020.345^{\\\\pm.002} | 7.664±.030superscript7.664plus-or-minus.0307.664^{\\\\pm.030} | 6.030±.008superscript6.030plus-or-minus.0086.030^{\\\\pm.008} | 6.409±.071superscript6.409plus-or-minus.0716.409^{\\\\pm.071} | - |\n| MoCoGAN | 0.037±.000superscript0.037plus-or-minus.0000.037^{\\\\pm.000} | 0.072±.001superscript0.072plus-or-minus.0010.072^{\\\\pm.001} | 0.106±.001superscript0.106plus-or-minus.0010.106^{\\\\pm.001} | 94.41±.021superscript94.41plus-or-minus.02194.41^{\\\\pm.021} | 9.643±.006superscript9.643plus-or-minus.0069.643^{\\\\pm.006} | 0.462±.008superscript0.462plus-or-minus.0080.462^{\\\\pm.008} | 0.019±.000superscript0.019plus-or-minus.0000.019^{\\\\pm.000} |\n| Dance2Music | 0.033±.000superscript0.033plus-or-minus.0000.033^{\\\\pm.000} | 0.065±.001superscript0.065plus-or-minus.0010.065^{\\\\pm.001} | 0.097±.001superscript0.097plus-or-minus.0010.097^{\\\\pm.001} | 66.98±.016superscript66.98plus-or-minus.01666.98^{\\\\pm.016} | 8.116±.006superscript8.116plus-or-minus.0068.116^{\\\\pm.006} | 0.725±.011superscript0.725plus-or-minus.0110.725^{\\\\pm.011} | 0.043±.001superscript0.043plus-or-minus.0010.043^{\\\\pm.001} |\n| Guo et al. | 0.457±.002superscript0.457plus-or-minus.0020.457^{\\\\pm.002} | 0.639±.003superscript0.639plus-or-minus.0030.639^{\\\\pm.003} | 0.740±.003superscript0.740plus-or-minus.0030.740^{\\\\pm.003} | 1.067±.002superscript1.067plus-or-minus.0021.067^{\\\\pm.002} | 3.340±.008superscript3.340plus-or-minus.0083.340^{\\\\pm.008} | 9.188±.002superscript9.188plus-or-minus.0029.188^{\\\\pm.002} | 2.090±.083superscript2.090plus-or-minus.0832.090^{\\\\pm.083} |\n| Ours | 0.491±.001superscript0.491plus-or-minus.001\\\\mathbf{0.491^{\\\\pm.001}} | 0.681±.001superscript0.681plus-or-minus.001\\\\mathbf{0.681^{\\\\pm.001}} | 0.782±.001superscript0.782plus-or-minus.001\\\\mathbf{0.782^{\\\\pm.001}} | 0.630±.001superscript0.630plus-or-minus.001\\\\mathbf{0.630^{\\\\pm.001}} | 3.113±.001superscript3.113plus-or-minus.001\\\\mathbf{3.113^{\\\\pm.001}} | 9.410±.049superscript9.410plus-or-minus.049\\\\mathbf{9.410^{\\\\pm.049}} | 1.553±.042superscript1.553plus-or-minus.0421.553^{\\\\pm.042} |\n\nTable 2: Quantitative results on the KIT-ML test set. All methods use the real motion length from the ground truth.\n\n| Methods | R Precision↑↑\\\\uparrow | FID↓↓\\\\downarrow | MultiModal Dist↓↓\\\\downarrow | Diversity→→\\\\rightarrow | MultiModality |\n| --- | --- | --- | --- | --- | --- |\n| Top 1 | Top 2 | Top 3 |\n| --- | --- | --- |\n| Real motions | 0.424±.005superscript0.424plus-or-minus.0050.424^{\\\\pm.005} | 0.649±.006superscript0.649plus-or-minus.0060.649^{\\\\pm.006} | 0.779±.006superscript0.779plus-or-minus.0060.779^{\\\\pm.006} | 0.031±.004superscript0.031plus-or-minus.0040.031^{\\\\pm.004} | 2.788±.012superscript2.788plus-or-minus.0122.788^{\\\\pm.012} | 11.08±.097superscript11.08plus-or-minus.09711.08^{\\\\pm.097} | - |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| Language2Pose | 0.221±.005superscript0.221plus-or-minus.0050.221^{\\\\pm.005} | 0.373±.004superscript0.373plus-or-minus.0040.373^{\\\\pm.004} | 0.483±.005superscript0.483plus-or-minus.0050.483^{\\\\pm.005} | 6.545±.072superscript6.545plus-or-minus.0726.545^{\\\\pm.072} | 5.147±.030superscript5.147plus-or-minus.0305.147^{\\\\pm.030} | 9.073±.100superscript9.073plus-or-minus.1009.073^{\\\\pm.100} | - |\n| Text2Gesture | 0.156±.004superscript0.156plus-or-minus.0040.156^{\\\\pm.004} | 0.255±.004superscript0.255plus-or-minus.0040.255^{\\\\pm.004} | 0.338±.005superscript0.338plus-or-minus.0050.338^{\\\\pm.005} | 12.12±.183superscript12.12plus-or-minus.18312.12^{\\\\pm.183} | 6.964±.029superscript6.964plus-or-minus.0296.964^{\\\\pm.029} | 9.334±.079superscript9.334plus-or-minus.0799.334^{\\\\pm.079} | - |\n| MoCoGAN | 0.022±.002superscript0.022plus-or-minus.0020.022^{\\\\pm.002} | 0.042±.003superscript0.042plus-or-minus.0030.042^{\\\\pm.003} | 0.063±.003superscript0.063plus-or-minus.0030.063^{\\\\pm.003} | 82.69±.242superscript82.69plus-or-minus.24282.69^{\\\\pm.242} | 10.47±.012superscript10.47plus-or-minus.01210.47^{\\\\pm.012} | 3.091±.043superscript3.091plus-or-minus.0433.091^{\\\\pm.043} | 0.250±.009superscript0.250plus-or-minus.0090.250^{\\\\pm.009} |\n| Dance2Music | 0.031±.002superscript0.031plus-or-minus.0020.031^{\\\\pm.002} | 0.058±.002superscript0.058plus-or-minus.0020.058^{\\\\pm.002} | 0.086±.003superscript0.086plus-or-minus.0030.086^{\\\\pm.003} | 115.4±.240superscript115.4plus-or-minus.240115.4^{\\\\pm.240} | 10.40±.016superscript10.40plus-or-minus.01610.40^{\\\\pm.016} | 0.241±.004superscript0.241plus-or-minus.0040.241^{\\\\pm.004} | 0.062±.002superscript0.062plus-or-minus.0020.062^{\\\\pm.002} |\n| Guo et al. | 0.370±.005superscript0.370plus-or-minus.0050.370^{\\\\pm.005} | 0.569±.007superscript0.569plus-or-minus.0070.569^{\\\\pm.007} | 0.693±.007superscript0.693plus-or-minus.0070.693^{\\\\pm.007} | 2.770±.109superscript2.770plus-or-minus.1092.770^{\\\\pm.109} | 3.401±.008superscript3.401plus-or-minus.0083.401^{\\\\pm.008} | 10.91±.119superscript10.91plus-or-minus.11910.91^{\\\\pm.119} | 1.482±.065superscript1.482plus-or-minus.0651.482^{\\\\pm.065} |\n| Ours | 0.417±.004superscript0.417plus-or-minus.004\\\\mathbf{0.417^{\\\\pm.004}} | 0.621±.004superscript0.621plus-or-minus.004\\\\mathbf{0.621^{\\\\pm.004}} | 0.739±.004superscript0.739plus-or-minus.004\\\\mathbf{0.739^{\\\\pm.004}} | 1.954±.062superscript1.954plus-or-minus.062\\\\mathbf{1.954^{\\\\pm.062}} | 2.958±.005superscript2.958plus-or-minus.005\\\\mathbf{2.958^{\\\\pm.005}} | 11.10±.143superscript11.10plus-or-minus.143\\\\mathbf{11.10^{\\\\pm.143}} | 0.730±.013superscript0.730plus-or-minus.0130.730^{\\\\pm.013} |\n\n#### Datasets.\n\nKIT Motion Language datset (Plappert et al., [2016])) provides 3911 motion sequences and 6353 sequence-level natural language descriptions. HumanML3D (Guo et al., [2022])) re-annotates the AMASS dataset (Mahmood et al., [2019])) and the HumanAct12 dataset (Guo et al., [2020])). It provides 44970 annotations on 14616 motion sequences. KIT and HumanML3D are two important benchmarks for text-driven motion generation tasks. Following  Guo et al. ( [2022])), we utilize the pretrained text-motion contrastive model.\n\n#### Evaluation Metrics.\n\nWe evaluate all methods with five different metrics.\n1) Frechet Inception Distance (FID). Features are extracted from both the generated results and ground truth motion sequences by the pretrained motion encoder. FID is calculated between these two distributions to measure the similarity.\n2) R Precision. For each pair of generated sequence and description text, 31 other prompts are randomly selected from the test set. The pretrained contrastive model calculates the average top-k accuracy. This section reports the top-1, top-2, and top-3 accuracies.\n3) Diversity. The generated sequences from all test texts are randomly split into pairs. Then the average joint differences are calculated in each pair, which serves as the diversity metric.\n4) Multimodality. As for a single text description, we randomly generate 32 motion sequences. Multimodality measures the differences in joint positions between these homogeneous motion sequences.\n5) Multimodal Distance. Assisted by the pretrained contrastive model, we can calculate the difference between the text feature from the given description and the motion feature from the generated results, called multimodal distance.\n\nIn this section, R Precision and FID are the principal metrics from which we make the most conclusions. Besides, for a fair comparison, we run each evaluation 20 times and report the statistic interval with 95% confidence.\n\n#### Implementation Details.\n\nFor both HumanML3D and KIT-ML datasets, we build up an 8-layer transformer as the motion decoder. As for the text encoder, we first directly use the text encoder in the CLIP ViT-B/32 (Radford et al., [2021])), and then add four more transformer encoder layers. The latent dimension of the text encoder and the motion decoder are 256 and 512, respectively. As for the diffusion model, the number of diffusion steps is 1000, and the variances βtsubscript𝛽𝑡\\\\beta\\_{t} are linearly from 0.0001 to 0.02. We opt for Adam as the optimizer to train the model with a 0.0002 learning rate. We use 8 Tesla V100 for the training, and there are 128 samples on each GPU, so the total batch size is 1024. The total number of iterations is 40K for KIT-ML and 100K for HumanML3D.\n\nFollowing Guo et al. ( [2022])), pose states in this series of experiments mainly contain seven different parts: (rv​a,rv​x,rv​z,rh,𝐣p,𝐣v,𝐣r)superscript𝑟𝑣𝑎superscript𝑟𝑣𝑥superscript𝑟𝑣𝑧superscript𝑟ℎsuperscript𝐣𝑝superscript𝐣𝑣superscript𝐣𝑟(r^{va},r^{vx},r^{vz},r^{h},\\\\mathbf{j}^{p},\\\\mathbf{j}^{v},\\\\mathbf{j}^{r}). Here Y-axis is perpendicular to the ground. rv​a,rv​x,rv​z∈ℝsuperscript𝑟𝑣𝑎superscript𝑟𝑣𝑥superscript𝑟𝑣𝑧ℝr^{va},r^{vx},r^{vz}\\\\in\\\\mathbb{R} denotes the root joint’s angular velocity along Y-axis, linear velocity along X-axis and Z-axis, respectively. rh∈ℝsuperscript𝑟ℎℝr^{h}\\\\in\\\\mathbb{R} is the height of the root joint. 𝐣p,𝐣v∈ℝJ×3superscript𝐣𝑝superscript𝐣𝑣superscriptℝ𝐽3\\\\mathbf{j}^{p},\\\\mathbf{j}^{v}\\\\in\\\\mathbb{R}^{J\\\\times 3} are the position and linear velocity of each joint, where J𝐽J is the number of joints. 𝐣r∈ℝJ×6superscript𝐣𝑟superscriptℝ𝐽6\\\\mathbf{j}^{r}\\\\in\\\\mathbb{R}^{J\\\\times 6} is the 6D rotation (Zhou et al., [2019])) of each joint. Specifically, J𝐽J is 22 in HumanML3D and 21 in KIT-ML.\n\n#### Quantitative Results.\n\nWe compare our proposed MotionDiffuse with five baseline models: Language2Pose (Ahuja and Morency, [2019])), Text2Gesture (Bhattacharya et al., [2021])), MoCoGAN (Tulyakov et al., [2018])), Dance2Music (Lee et al., [2019])), and Guo et al. ( [2022])). All baselines’ performances are quoted from Guo et al. ( [2022])). Table [1]Table 1 ‣ 4.1 Text-driven Motion Generation ‣ 4 Experiments ‣ MotionDiffuse: Text-Driven Human Motion Generation with Diffusion Model\") and Table [2]Table 2 ‣ 4.1 Text-driven Motion Generation ‣ 4 Experiments ‣ MotionDiffuse: Text-Driven Human Motion Generation with Diffusion Model\") show the quantitative comparison on the HumanML3D dataset and the KIT-ML dataset. Our proposed MotionDiffuse outperforms all existing works with a remarkable margin in aspects of precision, FID, MultiDodal Distance, and Diversity. The precision of MotionDiffuse is even close to that of real motions, which suggests that our generated motion sequences are satisfyingly high-fidelity and realistic.\n\nGuo et al. ( [2022])) states that the results on the MultiModality metric should be larger whenever possible. However, the literature in action-conditioned motion generation task (Guo et al., [2020]); Petrovich et al., [2021]); Cervantes et al., [2022])) argue that this metric should be close to the real motion. In the T2M task, it is difficult to calculate this metric of real motions. Therefore, we only report these results without comparison.\n\nTable 3: Ablation of the pretrained CLIP and the efficient attention technique. All results are reported on the KIT-ML test set.\n\n| CLIP | EFF | R Precision↑↑\\\\uparrow |\n| --- | --- | --- |\n| Top 1 | Top 2 | Top 3 |\n| --- | --- | --- |\n| N | N | 0.288±.004superscript0.288plus-or-minus.0040.288^{\\\\pm.004} | 0.440±.004superscript0.440plus-or-minus.0040.440^{\\\\pm.004} | 0.539±.004superscript0.539plus-or-minus.0040.539^{\\\\pm.004} |\n| N | Y | 0.136±.003superscript0.136plus-or-minus.0030.136^{\\\\pm.003} | 0.233±.003superscript0.233plus-or-minus.0030.233^{\\\\pm.003} | 0.309±.003superscript0.309plus-or-minus.0030.309^{\\\\pm.003} |\n| Y | N | 0.357±.004superscript0.357plus-or-minus.0040.357^{\\\\pm.004} | 0.555±.004superscript0.555plus-or-minus.0040.555^{\\\\pm.004} | 0.679±.005superscript0.679plus-or-minus.0050.679^{\\\\pm.005} |\n| Y | Y | 0.417±.004superscript0.417plus-or-minus.004\\\\mathbf{0.417^{\\\\pm.004}} | 0.621±.004superscript0.621plus-or-minus.004\\\\mathbf{0.621^{\\\\pm.004}} | 0.739±.004superscript0.739plus-or-minus.004\\\\mathbf{0.739^{\\\\pm.004}} |\n\nTo further understand the function of CLIP initialization and efficient attention, we report ablation results in Table  [3]Table 3 ‣ Quantitative Results. ‣ 4.1 Text-driven Motion Generation ‣ 4 Experiments ‣ MotionDiffuse: Text-Driven Human Motion Generation with Diffusion Model\"). The models without pretrained CLIP suffer from severe performance drops, which indicates the necessity of a pretrained language model for the T2M task. As for efficient attention, it is significantly beneficial when we use CLIP simultaneously. However, this module also limits the model’s performance when without CLIP. A possible explanation for this phenomenon is that the global relation in efficient attention is misleading when the semantic information from given text is insufficient.\n\nTable 4: Ablation of the latent dimension and the number of transformer layers. All results are reported on the KIT-ML test set.\n\n| #layers | Dim | R Precision↑↑\\\\uparrow |\n| --- | --- | --- |\n| Top 1 | Top 2 | Top 3 |\n| --- | --- | --- |\n| 4 | 128 | 0.033±.002superscript0.033plus-or-minus.0020.033^{\\\\pm.002} | 0.066±.003superscript0.066plus-or-minus.0030.066^{\\\\pm.003} | 0.097±.003superscript0.097plus-or-minus.0030.097^{\\\\pm.003} |\n| 4 | 256 | 0.095±.002superscript0.095plus-or-minus.0020.095^{\\\\pm.002} | 0.166±.003superscript0.166plus-or-minus.0030.166^{\\\\pm.003} | 0.227±.003superscript0.227plus-or-minus.0030.227^{\\\\pm.003} |\n| 4 | 512 | 0.405±.005superscript0.405plus-or-minus.0050.405^{\\\\pm.005} | 0.620±.005superscript0.620plus-or-minus.0050.620^{\\\\pm.005} | 0.743±.004superscript0.743plus-or-minus.004\\\\mathbf{0.743^{\\\\pm.004}} |\n| 8 | 128 | 0.025±.002superscript0.025plus-or-minus.0020.025^{\\\\pm.002} | 0.053±.002superscript0.053plus-or-minus.0020.053^{\\\\pm.002} | 0.086±.002superscript0.086plus-or-minus.0020.086^{\\\\pm.002} |\n| 8 | 256 | 0.198±.003superscript0.198plus-or-minus.0030.198^{\\\\pm.003} | 0.335±.004superscript0.335plus-or-minus.0040.335^{\\\\pm.004} | 0.441±.004superscript0.441plus-or-minus.0040.441^{\\\\pm.004} |\n| 8 | 512 | 0.417±.004superscript0.417plus-or-minus.004\\\\mathbf{0.417^{\\\\pm.004}} | 0.621±.004superscript0.621plus-or-minus.004\\\\mathbf{0.621^{\\\\pm.004}} | 0.739±.004superscript0.739plus-or-minus.0040.739^{\\\\pm.004} |\n| 12 | 128 | 0.031±.002superscript0.031plus-or-minus.0020.031^{\\\\pm.002} | 0.063±.003superscript0.063plus-or-minus.0030.063^{\\\\pm.003} | 0.091±.002superscript0.091plus-or-minus.0020.091^{\\\\pm.002} |\n| 12 | 256 | 0.209±.003superscript0.209plus-or-minus.0030.209^{\\\\pm.003} | 0.348±.004superscript0.348plus-or-minus.0040.348^{\\\\pm.004} | 0.452±.003superscript0.452plus-or-minus.0030.452^{\\\\pm.003} |\n| 12 | 512 | 0.412±.006superscript0.412plus-or-minus.0060.412^{\\\\pm.006} | 0.616±.004superscript0.616plus-or-minus.0040.616^{\\\\pm.004} | 0.741±.004superscript0.741plus-or-minus.0040.741^{\\\\pm.004} |\n\nWe explore how the size of architecture influences the performance. Table  [4]Table 4 ‣ Quantitative Results. ‣ 4.1 Text-driven Motion Generation ‣ 4 Experiments ‣ MotionDiffuse: Text-Driven Human Motion Generation with Diffusion Model\") suggests that the latent dimension plays a more important role. The models with 512 latent dimension significantly outperform the models with 256 latent dimension. On the contrary, the increase of the number of layers improves the performance when the latent dimension is either 128 or 256, but has little effect when the dimension is 512.\n\n#### Qualitative Results\n\n![Refer to caption]Figure 4: Qualitative results on the HumanML3D dataset. We compare our method with Guo et al. ( [2022])) and visualize two examples for each given prompt. MotionDiffuse is able to achieve both accuracy and diversity.\n\nFigure [4]Figure 4 ‣ Qualitative Results ‣ 4.1 Text-driven Motion Generation ‣ 4 Experiments ‣ MotionDiffuse: Text-Driven Human Motion Generation with Diffusion Model\") shows a comparison between our method and Guo et al. ( [2022])) as a baseline. We highlight that MotionDiffuse achieves a balance between diversity and realness. For example, for prompt ‘A person swings a golf club and hits the ball’, our generated motions portraits the described motion more faithfully. In contrast, the baseline method has high multi-modality at the expenses of accuracy. In addition, given a complicated prompt such as ”A person is pushed hard to the left and then recovers into a standing position”, MotionDiffuse is able to generate high-quality motions that reflects the detailed description whereas the baseline method fails to produce any meaningful movement.\n\n### 4.2 Action-conditioned Motion Generation\n\nTable 5: Quantitative results for Action-conditioned Motion Generation. As for UESTC dataset, we report FID on the test split. MM: MultiModality.\n\n| Methods | HumanAct12 | UESTC |\n| FID↓↓\\\\downarrow | Accuracy↑↑\\\\uparrow | Diversity→→\\\\rightarrow | MM→→\\\\rightarrow | FID↓↓\\\\downarrow | Accuracy↑↑\\\\uparrow | Diversity→→\\\\rightarrow | MM→→\\\\rightarrow |\n| Real motions | 0.020±.010superscript0.020plus-or-minus.0100.020^{\\\\pm.010} | 0.997±.001superscript0.997plus-or-minus.0010.997^{\\\\pm.001} | 6.850±.050superscript6.850plus-or-minus.0506.850^{\\\\pm.050} | 2.450±.040superscript2.450plus-or-minus.0402.450^{\\\\pm.040} | 2.79±.29superscript2.79plus-or-minus.292.79^{\\\\pm.29} | 0.988±.001superscript0.988plus-or-minus.0010.988^{\\\\pm.001} | 33.34±.320superscript33.34plus-or-minus.32033.34^{\\\\pm.320} | 14.16±.06superscript14.16plus-or-minus.0614.16^{\\\\pm.06} |\n| Action2Motion | 0.338±.015superscript0.338plus-or-minus.0150.338^{\\\\pm.015} | 0.917±.003superscript0.917plus-or-minus.0030.917^{\\\\pm.003} | 6.879±.066superscript6.879plus-or-minus.0666.879^{\\\\pm.066} | 2.511±.023superscript2.511plus-or-minus.0232.511^{\\\\pm.023} | - | - | - | - |\n| ACTOR | 0.12±.00superscript0.12plus-or-minus.000.12^{\\\\pm.00} | 0.955±.008superscript0.955plus-or-minus.0080.955^{\\\\pm.008} | 6.84±.03superscript6.84plus-or-minus.036.84^{\\\\pm.03} | 2.53±.02superscript2.53plus-or-minus.022.53^{\\\\pm.02} | 23.43±2.20superscript23.43plus-or-minus2.2023.43^{\\\\pm 2.20} | 0.911±.003superscript0.911plus-or-minus.0030.911^{\\\\pm.003} | 31.96±.33superscript31.96plus-or-minus.3331.96^{\\\\pm.33} | 14.52±.09superscript14.52plus-or-minus.09\\\\mathbf{14.52^{\\\\pm.09}} |\n| INR | 0.088±.004superscript0.088plus-or-minus.0040.088^{\\\\pm.004} | 0.973±.001superscript0.973plus-or-minus.0010.973^{\\\\pm.001} | 6.881±.048superscript6.881plus-or-minus.0486.881^{\\\\pm.048} | 2.569±.040superscript2.569plus-or-minus.0402.569^{\\\\pm.040} | 15.00±.09superscript15.00plus-or-minus.0915.00^{\\\\pm.09} | 0.941±.001superscript0.941plus-or-minus.0010.941^{\\\\pm.001} | 31.59±.19superscript31.59plus-or-minus.1931.59^{\\\\pm.19} | 14.68±.07superscript14.68plus-or-minus.0714.68^{\\\\pm.07} |\n| Ours | 0.07±.00superscript0.07plus-or-minus.00\\\\mathbf{0.07^{\\\\pm.00}} | 0.992±.13superscript0.992plus-or-minus.13\\\\mathbf{0.992^{\\\\pm.13}} | 6.85±.02superscript6.85plus-or-minus.02\\\\mathbf{6.85^{\\\\pm.02}} | 2.46±.02superscript2.46plus-or-minus.02\\\\mathbf{2.46^{\\\\pm.02}} | 9.10±.437superscript9.10plus-or-minus.437\\\\mathbf{9.10^{\\\\pm.437}} | 0.950±.000superscript0.950plus-or-minus.000\\\\mathbf{0.950^{\\\\pm.000}} | 32.42±.214superscript32.42plus-or-minus.214\\\\mathbf{32.42^{\\\\pm.214}} | 14.74±.07superscript14.74plus-or-minus.0714.74^{\\\\pm.07} |\n\n#### Datasets.\n\nHumanAct12 dataset (Guo et al., [2020])) provides 12 kinds of motion sequences. This dataset is adapted from PHSPD dataset (Zou et al., [2020])), which contains 1191 videos. HumanAct12 further arranges these videos into trimmed motion clips. UESTC dataset (Ji et al., [2018])) is also a significant benchmark for action-conditioned motion generation tasks, which includes 25K motion sequences across 40 different action categories.  Petrovich et al. ( [2021])) further uses pre-trained VIBE (Kocabas et al., [2020])) to extract SMPL (Loper et al., [2015])) sequences from the UESTC dataset and provides pretrained action recognition model for evaluation.\n\n#### Evaluation Metrics.\n\nFour evaluation metrics are applied for this task: FID, Accuracy, Diversity, and Multimodality. The pretrained action recognition module can directly calculate the average accuracy for all action categories without arranging mini-batches. This metric has a similar function to R Precision. The other three metrics have been introduced in Section  [4.1]Text-driven Motion Generation ‣ 4 Experiments ‣ MotionDiffuse: Text-Driven Human Motion Generation with Diffusion Model\"). HumanAct12 has no official split, and we report the FID on the whole dataset. UESTC has a test split, so we report the FID on it, which is more representative than the train split. In this section, FID and Accuracy are two principal metrics. Our conclusion are mainly based on them.\n\n#### Implementation Details.\n\nAll the setting are the same to those for text-driven motion generation tasks except for the learning rate, the number of iterations and the motion representation. In this series of expreiments, we train 100K iterations for the HumanAct12 dataset and 500K for the UESTC dataset, both with a 0.0001 learning rate.\n\nMotion represention in this task is slightly different from the T2M task. As for the HumanAct12 dataset, each pose state can be representated as (𝐣x,𝐣y,𝐣z)superscript𝐣𝑥superscript𝐣𝑦superscript𝐣𝑧(\\\\mathbf{j}^{x},\\\\mathbf{j}^{y},\\\\mathbf{j}^{z}), where 𝐣x,𝐣y,𝐣z∈ℝ24×3superscript𝐣𝑥superscript𝐣𝑦superscript𝐣𝑧superscriptℝ243\\\\mathbf{j}^{x},\\\\mathbf{j}^{y},\\\\mathbf{j}^{z}\\\\in\\\\mathbb{R}^{24\\\\times 3} are the coordinates of 24 joints. We use (rx,ry,rz,𝐣r)superscript𝑟𝑥superscript𝑟𝑦superscript𝑟𝑧superscript𝐣𝑟(r^{x},r^{y},r^{z},\\\\mathbf{j}^{r}) as the pose representation for the UESTC dataset, where rx,ry,rz∈ℝsuperscript𝑟𝑥superscript𝑟𝑦superscript𝑟𝑧ℝr^{x},r^{y},r^{z}\\\\in\\\\mathbb{R} are the coordinates of the root joint, and 𝐣r∈ℝ24×6superscript𝐣𝑟superscriptℝ246\\\\mathbf{j}^{r}\\\\in\\\\mathbb{R}^{24\\\\times 6} is the rotation angle of each joint in 6D representation.\n\n#### Quantitative Results.\n\nFollowing  Cervantes et al. ( [2022])), three baseline models are selected: Action2Motion (Guo et al., [2020])), ACTOR (Petrovich et al., [2021])), INR (Cervantes et al., [2022])). Table  [5]Table 5 ‣ 4.2 Action-conditioned Motion Generation ‣ 4 Experiments ‣ MotionDiffuse: Text-Driven Human Motion Generation with Diffusion Model\") shows the quantitative results on the HumanAct12 dataset and the UESTC datasets. Our proposed MotionDiffuse achieves the best performance in aspects of FID and Accuracy when compared to other existing works. We want to highlight that our results of the HumanAct12 dataset are notably close to real motions on all four metrics.\n\nTable 6: Ablation of the latent dimension and the number of transformer layers. All results are reported on the HumanAct12 dataset.\n\n| #layers | Dim | FID↓↓\\\\downarrow | Accuracy↑↑\\\\uparrow |\n| --- | --- | --- | --- |\n| 4 | 128 | 0.29±0.00superscript0.29plus-or-minus0.000.29^{\\\\pm 0.00} | 0.892±1.97superscript0.892plus-or-minus1.970.892^{\\\\pm 1.97} |\n| 4 | 256 | 0.14±0.00superscript0.14plus-or-minus0.000.14^{\\\\pm 0.00} | 0.958±0.51superscript0.958plus-or-minus0.510.958^{\\\\pm 0.51} |\n| 4 | 512 | 0.09±0.00superscript0.09plus-or-minus0.000.09^{\\\\pm 0.00} | 0.984±0.21superscript0.984plus-or-minus0.210.984^{\\\\pm 0.21} |\n| 8 | 128 | 0.22±0.00superscript0.22plus-or-minus0.000.22^{\\\\pm 0.00} | 0.929±1.04superscript0.929plus-or-minus1.040.929^{\\\\pm 1.04} |\n| 8 | 256 | 0.09±0.00superscript0.09plus-or-minus0.000.09^{\\\\pm 0.00} | 0.983±0.23superscript0.983plus-or-minus0.230.983^{\\\\pm 0.23} |\n| 8 | 512 | 0.07±0.00superscript0.07plus-or-minus0.00\\\\mathbf{0.07^{\\\\pm 0.00}} | 0.992±0.13superscript0.992plus-or-minus0.130.992^{\\\\pm 0.13} |\n| 12 | 128 | 0.11±0.00superscript0.11plus-or-minus0.000.11^{\\\\pm 0.00} | 0.954±0.67superscript0.954plus-or-minus0.670.954^{\\\\pm 0.67} |\n| 12 | 256 | 0.10±0.00superscript0.10plus-or-minus0.000.10^{\\\\pm 0.00} | 0.988±0.21superscript0.988plus-or-minus0.210.988^{\\\\pm 0.21} |\n| 12 | 512 | 0.08±0.00superscript0.08plus-or-minus0.000.08^{\\\\pm 0.00} | 0.996±0.08superscript0.996plus-or-minus0.08\\\\mathbf{0.996^{\\\\pm 0.08}} |\n\nHere we also try different combination of latent dimension and the number of layers, as shown in Table  [6]Table 6 ‣ Quantitative Results. ‣ 4.2 Action-conditioned Motion Generation ‣ 4 Experiments ‣ MotionDiffuse: Text-Driven Human Motion Generation with Diffusion Model\"). Similar to the conclusions we found in Section [4.1]Text-driven Motion Generation ‣ 4 Experiments ‣ MotionDiffuse: Text-Driven Human Motion Generation with Diffusion Model\"), latent dimension is more important than the number of layers.\n\n### 4.3 Motion Manipulation\n\nTo better evaluate the capability of text-driven motion generation models, we design two task variants.\nFirst, Spatially-diverse T2M task (T2M-S). T2M-S requires the generated motion sequence to contain multiple actions on different body parts (e.g. ‘a person is running and drinking water simultaneously’). Specifically, i𝑖i-th test sample in T2M-S task can be represented by a set of text-mask pairs {(texti,j,Mi,j)}subscripttext𝑖𝑗subscriptM𝑖𝑗\\\\{(\\\\textrm{text}\\_{i,j},\\\\mathrm{M}\\_{i,j})\\\\}, where Mi,j∈{0,1}DsubscriptM𝑖𝑗superscript01𝐷\\\\mathrm{M}\\_{i,j}\\\\in\\\\{0,1\\\\}^{D} is a D𝐷D-dimension binary vector. It indicates which body part we should focus on when given the text description texti,jsubscripttext𝑖𝑗\\\\textrm{text}\\_{i,j}.\nSecond, Temporally-diverse T2M task (T2M-T). T2M-T expects models to generate a long motion sequence, which includes multiple actions in a specific order spanning over different time intervals (e.g. ‘a person is walking and then running’). The i𝑖i-th test sample is an array of text-duration pairs {texti,j,\\[li,j,ri,j\\]},li,j<ri,jsubscripttext𝑖𝑗subscript𝑙𝑖𝑗subscript𝑟𝑖𝑗subscript𝑙𝑖𝑗subscript𝑟𝑖𝑗\\\\{\\\\textrm{text}\\_{i,j},\\[l\\_{i,j},r\\_{i,j}\\]\\\\},l\\_{i,j}<r\\_{i,j}. It means that the motion clip from li,jsubscript𝑙𝑖𝑗l\\_{i,j}-th frame to ri,jsubscript𝑟𝑖𝑗r\\_{i,j} frame is supposed to contain the action texti,jsubscripttext𝑖𝑗\\\\textrm{text}\\_{i,j}.\n\n#### Implementation Details.\n\nWe train our proposed MotionDiffuse on the BABEL dataset (Punnakkal et al., [2021])) with 50K iterations. Each pose state is represented by (rx,ry,rz,𝐣r)superscript𝑟𝑥superscript𝑟𝑦superscript𝑟𝑧superscript𝐣𝑟(r^{x},r^{y},r^{z},\\\\mathbf{j}^{r}), which is same to the setting for the UESTC dataset. Other settings remain unchanged. λ1=λ2=0.01subscript𝜆1subscript𝜆20.01\\\\lambda\\_{1}=\\\\lambda\\_{2}=0.01 are used for the visualization.\n\n![Refer to caption]Figure 5: Qualitative results on the BABEL dataset. MotionDiffuse is able to generate dynamic sequences according to complicated prompt that involves multiple body parts or actions.\n\n#### Qualitative Results.\n\nAs shown in Fig [5]Figure 5 ‣ Implementation Details. ‣ 4.3 Motion Manipulation ‣ 4 Experiments ‣ MotionDiffuse: Text-Driven Human Motion Generation with Diffusion Model\"), MotionDiffuse has the capability to handle highly comprehensive prompts that assign motions to multiple body parts (such as “Kicking and punching” and “Jumping and raising arms” that require coordination of the upper and lower body). Moreover, MotionDiffuse is able to generate long sequences according to a complex instruction that includes multiple actions (such as “Tying the shoe, standing up and then walking forward” that includes a series of vastly different motions).",
            "citations": null
          },
          "5 Conclusion, Limitations and Future Work": {
            "content": "We propose MotionDiffuse, the first diffusion model-based method for text-driven motion generation. MotionDiffuse demonstrates three major strengths: Probabilistic Mapping that enhances diversity, Realistic Synthesis that ensures plausibility of motion sequences, and Multi-Level Manipulation that allows for per-part manipulation and long sequence generation. Both quantitative and qualitative evaluations show that MotionDiffuse outperforms existing arts on various tasks such as text-driven motion generation and action-conditioned motion generation, and demonstrates remarkable motion manipulation capabilities.\n\nAlthough MotionDiffuse has pushed forward the performance boundary of motion generation tasks, there still exist some problems. First, diffusion models require a large amount of diffusion steps during inference and it is challenging to generate motion sequences in real-time. Second, current pipeline only accepts a single form of motion representation. A more generalized pipeline that adapts concurrently to all datasets would be more versatile for various scenarios.\n\n###### Acknowledgements.\n\nThis work is supported by NTU NAP, MOE AcRF Tier 2\n(T2EP20221-0033), and under the RIE2020 Industry Alignment Fund - Industry Collaboration Projects (IAF-ICP) Funding Initiative, as well as cash and in-kind contribution from the industry partner(s).\nCorresponding author: Ziwei Liu (ziwei.liu@ntu.edu.sg).",
            "citations": null
          }
        },
        "abstract": "Human motion modeling is important for many modern graphics applications,\nwhich typically require professional skills. In order to remove the skill\nbarriers for laymen, recent motion generation methods can directly generate\nhuman motions conditioned on natural languages. However, it remains challenging\nto achieve diverse and fine-grained motion generation with various text inputs.\nTo address this problem, we propose MotionDiffuse, the first diffusion\nmodel-based text-driven motion generation framework, which demonstrates several\ndesired properties over existing methods. 1) Probabilistic Mapping. Instead of\na deterministic language-motion mapping, MotionDiffuse generates motions\nthrough a series of denoising steps in which variations are injected. 2)\nRealistic Synthesis. MotionDiffuse excels at modeling complicated data\ndistribution and generating vivid motion sequences. 3) Multi-Level\nManipulation. MotionDiffuse responds to fine-grained instructions on body\nparts, and arbitrary-length motion synthesis with time-varied text prompts. Our\nexperiments show MotionDiffuse outperforms existing SoTA methods by convincing\nmargins on text-driven motion generation and action-conditioned motion\ngeneration. A qualitative analysis further demonstrates MotionDiffuse's\ncontrollability for comprehensive motion generation. Homepage:\nhttps://mingyuan-zhang.github.io/projects/MotionDiffuse.html"
      },
      "bib.bib117": {
        "id": "bib.bib117",
        "citation": "[117]",
        "authors": "",
        "year": "",
        "title": "The unreasonable effectiveness of deep features as a perceptual metric.",
        "venue": "",
        "pages": "",
        "url": "https://arxiv.org/abs/1801.03924",
        "arxiv_id": "1801.03924",
        "doi": null,
        "sections": {
          "1 Motivation": {
            "content": "The ability to compare data items is perhaps the most fundamental operation underlying all of computing. In many areas of computer science it does not pose much difficulty: one can use Hamming distance to compare binary patterns, edit distance to compare text files, Euclidean distance to compare vectors, etc. The unique challenge of computer vision is that even this seemingly simple task of comparing visual patterns remains a wide-open problem. Not only are visual patterns very high-dimensional and highly correlated, but, the very notion of visual similarity is often subjective, aiming to mimic human visual perception. For instance, in image compression, the goal is for the compressed image to be indistinguishable from the original by a human observer, irrespective of the fact that their pixel representations might be very different.\n\nClassic per-pixel measures, such as ℓ2subscriptℓ2\\\\ell\\_{2} Euclidean distance, commonly used for regression problems, or the related Peak Signal-to-Noise Ratio (PSNR), are insufficient for assessing structured outputs such as images, as they assume pixel-wise independence. A well-known example is that blurring causes large perceptual but small ℓ2subscriptℓ2\\\\ell\\_{2} change.\n\nWhat we would really like is a “perceptual distance,” which measures how similar are two images in a way that coincides with human judgment. This problem has been a longstanding goal,\nand there have been numerous perceptually motivated distance metrics proposed, such as SSIM \\[ [58])\\], MSSIM \\[ [60])\\], FSIM \\[ [62])\\], and HDR-VDP \\[ [34])\\].\n\nHowever, constructing a perceptual metric is challenging, because human judgments of similarity (1) depend on high-order image structure \\[ [58])\\], (2) are context-dependent \\[ [19]), [36]), [35])\\], and (3) may not actually constitute a distance metric \\[ [56])\\].\nThe crux of (2) is that there are many different “senses of similarity” that we can simultaneously hold in mind: is a red circle more similar to a red square or to a blue circle? Directly fitting a function to human judgments may be intractable due the the context-dependent and pairwise nature of the judgments (which compare the similarity between two images). Indeed, we show in this paper a negative result where this approach fails to generalize, even when trained on a large-scale dataset containing many distortion types.\n\nInstead, might there be a way to learn a notion of perceptual similarity without directly training for it? The computer vision community has discovered that internal activations of deep convolutional networks, though trained on a high-level image classification task, are often surprisingly useful as a representational space for a much wider variety of tasks. For example, features from the VGG architecture \\[ [52])\\] have been used on tasks such as neural style transfer \\[ [17])\\], image superresolution \\[ [23])\\], and conditional image synthesis \\[ [14]), [8])\\].\nThese methods measure distance in VGG feature space as a “perceptual loss” for image regression problems \\[ [23]), [14])\\].\n\nBut how well do these “perceptual losses” actually correspond to human visual perception? How do they compare to traditional perceptual image evaluation metrics? Does the network architecture matter? Does it have to be trained on the ImageNet classification task, or would other tasks work just as well? Do the networks need to be trained at all?\n\n|     |     |     |     |     |     |     |     |     |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| Dataset | ##\\\\# Input Imgs/ | Input | Num | Distort. | ##\\\\# | ##\\\\# Distort. | ##\\\\# Judg- | Judgment |\n|  | Patches | Type | Distort. | Types | Levels | Imgs/Patches | ments | Type |\n| LIVE \\[ [51])\\] | 29 | images | 5 | traditional | continuous | .8k | 25k | MOS |\n| CSIQ \\[ [29])\\] | 30 | images | 6 | traditional | 5 | .8k | 25k | MOS |\n| TID2008 \\[ [46])\\] | 25 | images | 17 | traditional | 4 | 2.7k | 250k | MOS |\n| TID2013 \\[ [45])\\] | 25 | images | 24 | traditional | 5 | 3.0k | 500k | MOS |\n| BAPPS (2AFC–Distort) | 160.8k | 64×64646464\\\\times 64 patch | 425 | trad + CNN | continuous | 321.6k | 349.8k | 2AFC |\n| BAPPS (2AFC–Real alg) | 26.9k | 64×64646464\\\\times 64 patch | – | alg outputs | – | 53.8k | 134.5k | 2AFC |\n| \\\\hdashlineBAPPS (JND–Distort) | 9.6k | 64×64646464\\\\times 64 patch | 425 | trad. + CNN | continuous | 9.6k | 28.8k | Same/Not same |\n\nTable 1: Dataset comparison. A primary differentiator between our proposed Berkeley-Adobe Perceptual Patch Similarity (BAPPS) dataset and previous work is scale of distortion types. We provide human perceptual judgments on distortion set using uncompressed images from \\[ [7]), [10])\\]. Previous datasets have used a small number of distortions at discrete levels. We use a large number of distortions (created by sequentially composing atomic distortions together) and sample continuously. For each input patch, we corrupt it using two distortions and ask for a few human judgments (2 for train, 5 for test set) per pair. This enables us to obtain judgments on a large number of patches. Previous databases summarize their judgments into a mean opinion score (MOS); we simply report pairwise judgments (two alternative force choice). In addition, we provide judgments on outputs from real algorithms, as well as a same/not same Just Noticeable Difference (JND) perceptual test.\n\nIn this paper, we evaluate these questions on a new large-scale database of human judgments, and arrive at several surprising conclusions. We find that internal activations of networks trained for high-level classification tasks, even across network architectures \\[ [20]), [28]), [52])\\] and no further calibration, do indeed correspond to human perceptual judgments. In fact, they correspond far better than the commonly used metrics like SSIM and FSIM \\[ [58]), [62])\\], which were not designed to handle situations where spatial ambiguities are a factor \\[ [49])\\]. Furthermore, the best performing self-supervised networks, including BiGANs \\[ [13])\\], cross-channel prediction \\[ [64])\\], and puzzle solving \\[ [40])\\] perform just as well at this task, even without the benefit of human-labeled training data. Even a simple unsupervised network initialization with stacked k-means \\[ [26])\\] beats the classic metrics by a large margin!\nThis illustrates an emergent property shared across networks, even across architectures and training signals. Importantly, however, having some training signal appears crucial – a randomly initialized network achieves much lower performance.\n\nOur study is based on a newly collected perceptual similarity dataset, using a large set of distortions and real algorithm outputs. It contains both traditional distortions, such as contrast and saturation adjustments, noise patterns, filtering, and spatial warping operations, and CNN-based algorithm outputs, such as autoencoding, denoising, and colorization, produced by a variety of architectures and losses. Our dataset is richer and more varied than previous datasets of this kind \\[ [45])\\]. We also collect judgments on outputs from real algorithms for the tasks of superresolution, frame interpolation, and image deblurring, which is especially important as these are the real-world use cases for a perceptual metric.\nWe show that our data can be used to “calibrate” existing networks, by learning a simple linear scaling of layer activations, to better match low-level human judgments.\n\nOur results are consistent with the hypothesis that perceptual similarity is not a special function all of its own, but rather a consequence of visual representations tuned to be predictive about important structure in the world. Representations that are effective at semantic prediction tasks are also representations in which Euclidean distance is highly predictive of perceptual similarity judgments.\n\nOur contributions are as follows:\n\n- •\n\n\nWe introduce a large-scale, highly varied, perceptual similarity dataset, containing 484k human judgments. Our dataset not only includes parameterized distortions, but also real algorithm outputs. We also collect judgments on a different perceptual test, just noticeable differences (JND).\n\n- •\n\n\nWe show that deep features, trained on supervised, self-supervised, and unsupervised objectives alike, model low-level perceptual similarity surprisingly well, outperforming previous, widely-used metrics.\n\n- •\n\n\nWe demonstrate that network architecture alone does not account for the performance: untrained nets achieve much lower performance.\n\n- •\n\n\nWith our data, we can improve performance by “calibrating” feature responses from a pre-trained network.\n\n\n#### Prior work on datasets\n\nIn order to evaluate existing similarity measures, a number of datasets have been proposed. Some of the most popular are the LIVE \\[ [51])\\], TID2008 \\[ [46])\\], CSIQ \\[ [29])\\], and TID2013 \\[ [45])\\] datasets. These datasets are referred to Full-Reference Image Quality Assessment (FR-IQA) datasets and have served as the de-facto baselines for development and evaluation of similarity metrics. A related line of work is on No-Reference Image Quality Assessment (NR-IQA), such as AVA \\[ [38])\\] and LIVE In the Wild \\[ [18])\\]. These datasets investigate the “quality” of individual images by themselves, without a reference image.\nWe collect a new dataset that is complementary to these: it contains a substantially larger number of distortions, including some from newer, deep network based outputs, as well as geometric distortions. Our dataset is focused on perceptual similarity, rather than quality assessment. Additionally, it is collected on patches as opposed to full images, in the wild, with a different experimental design (more details in Sec [2]Berkeley-Adobe Perceptual Patch Similarity (BAPPS) Dataset ‣ The Unreasonable Effectiveness of Deep Features as a Perceptual Metric\")).\n\n#### Prior work on deep networks and human judgments\n\nRecently, advances in DNNs have motivated investigation of applications in the context of visual similarity and image quality assessment.\nKim and Lee \\[ [25])\\] use a CNN to predict visual similarity by training on low-level differences. Concurrent work by Talebi and Milanfar \\[ [54]), [55])\\] train a deep network in the context of NR-IQA for image aesthetics. Gao et al. \\[ [16])\\] and Amirshahi et al. \\[ [3])\\] propose techniques involving leveraging internal activations of deep networks (VGG and AlexNet, respectively) along with additional multiscale post-processing. In this work, we conduct a more in-depth study across different architectures, training signals, on a new, large scale, highly-varied dataset.\n\nRecently, Berardino et al. \\[ [6])\\] train networks on perceptual similarity, and importantly, assess the ability of deep networks to make predictions on a separate task – predicting most and least perceptually-noticeable directions of distortion. Similarly, we not only assess image patch similarity on parameterized distortions, but also test generalization to real algorithms, as well as generalization to a separate perceptual task – just noticeable differences.",
            "citations": null
          },
          "2 Berkeley-Adobe Perceptual Patch Similarity (BAPPS) Dataset": {
            "content": "To evaluate the performance of different perceptual metrics, we collect a large-scale highly diverse dataset of perceptual judgments using two approaches.\nOur main data collection employs a two alternative forced choice (2AFC) test, that asks which of two distortions is more similar to a reference.\nThis is validated by a second experiment where we perform a just noticeable difference (JND) test, which asks whether two patches – one reference and one distorted – are the same or different. These judgments are collected over a wide space of distortions and real algorithm outputs.\n\n| Sub-type | Distortion type |\n| --- | --- |\n| Photometric | lightness shift, color shift, contrast, saturation |\n|  | uniform white noise, Gaussian white, pink, |\n| Noise | & blue noise, Gaussian colored (between |\n|  | violet and brown) noise, checkerboard artifact |\n| Blur | Gaussian, bilateral filtering |\n| Spatial | shifting, affine warp, homography, |\n|  | linear warping, cubic warping, ghosting, |\n|  | chromatic aberration, |\n| Compression | jpeg |\n\n| Parameter type | Parameters |\n| --- | --- |\n| Input | null, pink noise, white noise, |\n| corruption | color removal, downsampling |\n|  | \\# layers, # skip connections, |\n| Generator | \\# layers with dropout, force skip connection |\n| network | at highest layer, upsampling method, |\n| architecture | normalization method, first layer stride |\n|  | \\# channels in 1s​tsuperscript1𝑠𝑡1^{st} layer, max # channels |\n| Discriminator | number of layers |\n| Loss/Learning | weighting on oixel-wise (ℓ1subscriptℓ1\\\\ell\\_{1}), VGG, |\n|  | discriminator losses, learning rate |\n\nTable 2: Our distortions. Our traditional distortions (left) are performed by basic low-level image editing operations. We also sequentially compose them to better explore the space. Our CNN-based distortions (right) are formed by randomly varying parameters such as task, network architecture, and learning parameters. The goal of the distortions is to mimic plausible distortions seen in real algorithm outputs.\n\n### 2.1 Distortions\n\n#### Traditional distortions\n\nWe create a set of “traditional” distortions consisting of common operations performed on the input patches, listed in Table [2]Table 2 ‣ 2 Berkeley-Adobe Perceptual Patch Similarity (BAPPS) Dataset ‣ The Unreasonable Effectiveness of Deep Features as a Perceptual Metric\") (left). In general, we use photometric distortions, random noise, blurring, spatial shifts and corruptions, and compression artifacts. We show qualitative examples of our traditional distortions in Figure [2]Figure 2 ‣ The Unreasonable Effectiveness of Deep Features as a Perceptual Metric\"). The severity of each perturbation is parameterized - for example, for Gaussian blur, the kernel width determines the amount of corruption applied to the input image. We also compose pairs of distortions sequentially to increase the overall space of possible distortions. In total, we have 20 distortions and 308 sequentially composed distortions.\n\n#### CNN-based distortions\n\nTo more closely simulate the space of artifacts that can arise from deep-learning based methods, we create a set of distortions created by neural networks. We simulate possible algorithm outputs by exploring a variety of tasks, architectures, and losses, as shown in Table [2]Table 2 ‣ 2 Berkeley-Adobe Perceptual Patch Similarity (BAPPS) Dataset ‣ The Unreasonable Effectiveness of Deep Features as a Perceptual Metric\") (right). Such tasks include autoencoding, denoising, colorization, and superresolution. All of these tasks can be achieved by applying the appropriate corruption to the input. In total, we generated 96 “denoising autoencoders” and use these as CNN-based distortion functions. We train each of these networks on the 1.3M ImageNet dataset \\[ [47])\\] for 1 epoch. The goal of each network is not to solve the task per se, but rather to explore common artifacts that plague the outputs of deep learning based methods.\n\n#### Distorted image patches from real algorithms\n\nThe true test of an image assessment algorithm is on real problems and real algorithms.\nWe gather perceptual judgments using such outputs. Data on real algorithms is more limited, as each application will have their own unique properties. For example, different colorization methods will not show much structural variation, but will be prone to effects such as color bleeding and color variation. On the other hand, superresolution will not have color ambiguity, but may see larger structural changes from algorithm to algorithm.\n\n#### Superresolution\n\nWe evaluate results from the 2017 NTIRE workshop \\[ [2])\\]. We use 3 tracks from the workshop – ×2absent2\\\\times 2, ×3absent3\\\\times 3, ×4absent4\\\\times 4 upsampling rates using “unknown” downsampling to create the input images. Each track had approximately 20 algorithm submissions. We also evaluate several additional methods, including bicubic upsampling, and four of the top performing deep superresolution methods \\[ [24]), [59]), [31]), [48])\\]. A common qualitative way of presenting superresolution results is zooming into specific patches and comparing differences. As such, we sample random 64×64646464\\\\times 64 triplets from random locations of images in the Div2K \\[ [2])\\] dataset – the ground truth high-resolution image, along with two algorithm outputs.\n\n#### Frame interpolation\n\nWe sample patches from different frame interpolation algorithms, including three variants of flow-based interpolation \\[ [33])\\], CNN-based interpolation \\[ [39])\\], and phase-based interpolation \\[ [37])\\] on the Davis Middleburry dataset \\[ [50])\\]. Because artifacts arising from frame interpolation may occur at different scales, we randomly rescale the image before sampling a patch triplet.\n\n#### Video deblurring\n\nWe sample from the video deblurring dataset \\[ [53])\\], along with deblurring outputs from Photoshop Shake Reduction, Weighted Fourier Aggregation \\[ [11])\\], and three variants of a deep video deblurring method \\[ [53])\\].\n\n#### Colorization\n\nWe sample patches using random scales on the colorization task, on images from the ImageNet dataset \\[ [47])\\]. The algorithms are from pix2pix \\[ [22])\\], Larsson et al. \\[ [30])\\], and variants from Zhang et al. \\[ [63])\\].\n\n### 2.2 Psychophysical Similarity Measurements\n\n#### 2AFC similarity judgments\n\nWe randomly select an image patch x𝑥x and apply two distortions to produce patches x0,x1subscript𝑥0subscript𝑥1x\\_{0},x\\_{1}. We then ask a human which is closer to the original patch x𝑥x, and record response h∈{0,1}ℎ01h\\\\in\\\\{0,1\\\\}. On average, people spent approximately 3 seconds per judgment. Let 𝒯𝒯\\\\mathcal{T} denote our dataset of patch triplets (x,x0,x1,h)𝑥subscript𝑥0subscript𝑥1ℎ(x,x\\_{0},x\\_{1},h).\n\nA comparison between our dataset and previous datasets is shown in Table [1]Table 1 ‣ 1 Motivation ‣ The Unreasonable Effectiveness of Deep Features as a Perceptual Metric\").\nPrevious datasets have focused on collecting large numbers of human judgments for a few images and distortion types.\nFor example, the largest dataset, TID2013 \\[ [45])\\], has 500k judgments on 3000 distortions (from 25 input images with 24 distortions types, each sampled at 5 levels).\nWe provide a complementary dataset that focuses instead on a large number of distortions types. In, addition, we collect judgments on a large number of 64×64646464\\\\times 64 patches rather than a small number of images.\nThere are three reasons for this.\nFirst, the space of full images is extremely large, which makes it much harder to cover a reasonable portion of the domain with judgments (even 64×64646464\\\\times 64 color patches represent an intractable 12k-dimensional space).\nSecond, by choosing a smaller patch size, we focus on lower-level aspects of similarity, to mitigate the effect of differing “respects of similarity” that may be influenced by high-level semantics \\[ [36])\\]. Finally, modern methods for image synthesis train deep networks with patch-based losses (implemented as convolutions) \\[ [8]), [21])\\].\nOur dataset consists of over 161k patches, derived from the MIT-Adobe 5k dataset \\[ [7])\\] (5000 uncompressed images) for training, and the RAISE1k dataset \\[ [10])\\] for validation.\n\nTo enable large-scale collection, our data is collected “in-the-wild” on Amazon Mechanical Turk, as opposed to a controlled lab setting.\nCrump et al. \\[ [9])\\] show that AMT can be reliably used to replicate many psychophysics studies, despite the inability to control all environmental factors.\nWe ask for 2 judgments per example in our “train” set and 5 judgments in our “val” sets.\nAsking for fewer judgments enables us to explore a larger set of image patches and distortions. We add sentinels which consist of pairs of patches with obvious deformations, e.g., a large amount of Gaussian noise vs a small amount of Gaussian noise. Approximately 90%percent90~{}90\\\\% of Turkers were able to correctly pass at least 93%percent9393\\\\% of the sentinels (14 of 15), indicating that they understood the task and were paying attention.\nWe choose to use a larger number of distortions than prior datasets.\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n| Dataset | Data | Train/ | ##\\\\# Ex- | ##\\\\# Judge |\n| source | Val | amples | /Example |\n| Traditional | \\[ [7])\\] | Train | 56.6k | 2 |\n| CNN-based | \\[ [7])\\] | Train | 38.1k | 2 |\n| Mixed | \\[ [7])\\] | Train | 56.6k | 2 |\n| 2AFC–Distort \\[Trn\\] | – | Train | 151.4k | 2 |\n| Traditional | \\[ [10])\\] | Train | 4.7k | 5 |\n| CNN-based | \\[ [10])\\] | Train | 4.7k | 5 |\n| 2AFC–Distort \\[Val\\] | – | Val | 9.4k | 5 |\n| Superres | \\[ [32])\\] | Val | 10.9k | 5 |\n| Frame Interp | \\[ [50])\\] | Val | 1.9 | 5 |\n| Video Deblur | \\[ [5])\\] | Val | 9.4 | 5 |\n| Colorization | \\[ [47])\\] | Val | 4.7 | 5 |\n| 2AFC–Real Alg \\[Val\\] | – | Val | 26.9k | 5 |\n| Traditional | \\[ [10])\\] | Val | 4.8k | 3 |\n| CNN-based | \\[ [10])\\] | Val | 4.8k | 3 |\n| JND–Distort | – | Val | 9.6k | 3 |\n\nTable 3: Our dataset breakdown. We split our 2AFC dataset in to three main portions (1,2) training and test sets with our distortions. Our training and test sets contain patches sampled from the MIT5k \\[ [7])\\] and RAISE1k \\[ [10])\\] datasets, respectively (3) a test set containing real algorithm outputs, containing patches from a variety of applications. Our JND data is on traditional and CNN-based distortions.\n\n#### Just noticeable differences (JND)\n\nA potential shortcoming of the 2AFC task is that it is “cognitively penetrable,” in the sense that participants can consciously choose which respects of similarity they will choose to focus on in completing the task \\[ [36])\\], which introduces subjectivity into the judgments. To validate that the judgments actually reflected something objective and meaningful, we also collected user judgments of “just noticeable differences” (JNDs). We show a reference image, followed by a randomly distorted image, and ask a human if the images are the same or different.\nThe two image patches are shown for 1 second each, with a 250 ms gap in between.\nTwo images which look similar may be easily confused, and a good perceptual metric will be able to order pairs from most to least confusable.\nJND tests like this may be considered less subjective, since there is a single correct answer for each judgment, and participants are presumed to be aware of what correct behavior entails. We gather 3 JND observations for each of the 4.8k patches in our traditional and CNN-based validation sets.\nEach subject is shown 160 pairs, along with 40 sentinels (32 identical and 8 with large Gaussian noise distortion applied).\nWe also provide a short training period of 10 pairs which contain 4 “same” pairs, 1 obviously different pair, and 5 “different” pairs generated by our distortions.\nWe chose to do this in order to prime the users towards expecting approximately 40%percent4040\\\\% of the patch pairs to be identical.\nIndeed, 36.4%percent36.436.4\\\\% of the pairs were marked “same” (70.4%percent70.470.4\\\\% of sentinels and 27.9%percent27.927.9\\\\% of test pairs).\n\n![Refer to caption]Figure 3: Computing distance from a network (Left) To compute a distance d0subscript𝑑0d\\_{0} between two patches, x𝑥x, x0subscript𝑥0x\\_{0}, given a network ℱℱ\\\\mathcal{F}, we first compute deep embeddings, normalize the activations in the channel dimension, scale each channel by vector w𝑤w, and take the ℓ2subscriptℓ2\\\\ell\\_{2} distance. We then average across spatial dimension and across all layers. (Right) A small network 𝒢𝒢\\\\mathcal{G} is trained to predict perceptual judgment hℎh from distance pair (d0,d1subscript𝑑0subscript𝑑1d\\_{0},d\\_{1}).\n\n| Distortions | Real algorithms |\n| --- | --- |\n| ![Refer to caption] | ![Refer to caption] |\n\nFigure 4: Quantitative comparison. We show a quantitative comparison across metrics on our test sets. (Left) Results averaged across our traditional and CNN-based distortions. (Right) Results averaged across our 4 real algorithm sets.",
            "citations": null
          },
          "3 Deep Feature Spaces": {
            "content": "We evaluate feature distances in different networks. For a given convolutional layer, we compute cosine distance (in the channel dimension) and average across spatial dimensions and layers of the network. We also discuss how to tune an existing network on our data.\n\n#### Network architectures\n\nWe evaluate the SqueezeNet \\[ [20])\\], AlexNet \\[ [28])\\], and VGG \\[ [52])\\] architectures. We use 5 conv layers from the VGG network, which has become the de facto standard for image generation tasks \\[ [17]), [14]), [8])\\].\nWe also compare against the shallower AlexNet network, which may more closely match the architecture of the human visual cortex \\[ [61])\\].\nWe use the conv1-conv5 layers from \\[ [27])\\]. Finally, the SqueezeNet architecture was designed to be extremely lightweight (2.82.82.8 MB) in size, with similar classification performance to AlexNet. We use the first conv layer and some subsequent “fire” modules.\n\nWe additionally evaluate self-supervised methods, including puzzle-solving \\[ [40])\\], cross-channel prediction \\[ [63]), [64])\\], learning from video \\[ [43])\\], and generative modeling \\[ [13])\\]. We use publicly available networks from these and other methods, which use variants of AlexNet \\[ [28])\\].\n\n#### Network activations to distance\n\nFigure [3]Figure 3 ‣ Just noticeable differences (JND) ‣ 2.2 Psychophysical Similarity Measurements ‣ 2 Berkeley-Adobe Perceptual Patch Similarity (BAPPS) Dataset ‣ The Unreasonable Effectiveness of Deep Features as a Perceptual Metric\") (left) and Equation [1]In Network activations to distance ‣ 3 Deep Feature Spaces ‣ The Unreasonable Effectiveness of Deep Features as a Perceptual Metric\") illustrate how we obtain the distance between reference and distorted patches x,x0𝑥subscript𝑥0{x,x\\_{0}} with network ℱℱ\\\\mathcal{F}. We extract feature stack from L𝐿L layers and unit-normalize in the channel dimension, which we designate as y^l,y^0l∈ℝHl×Wl×Clsuperscript^𝑦𝑙superscriptsubscript^𝑦0𝑙superscriptℝsubscript𝐻𝑙subscript𝑊𝑙subscript𝐶𝑙\\\\hat{y}^{l},\\\\hat{y}\\_{0}^{l}\\\\in\\\\mathds{R}^{H\\_{l}\\\\times W\\_{l}\\\\times C\\_{l}} for layer l𝑙l. We scale the activations channel-wise by vector wl∈ℝClsuperscript𝑤𝑙superscriptℝsubscript𝐶𝑙w^{l}\\\\in\\\\mathds{R}^{C\\_{l}} and compute the ℓ2subscriptℓ2\\\\ell\\_{2} distance. Finally, we average spatially and sum channel-wise. Note that using wl=1​∀lsubscript𝑤𝑙1for-all𝑙w\\_{l}=1\\\\forall l is equivalent to computing cosine distance.\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | d​(x,x0)=∑l1Hl​Wl​∑h,w‖wl⊙(y^h​wl−y^0​h​wl)‖22𝑑𝑥subscript𝑥0subscript𝑙1subscript𝐻𝑙subscript𝑊𝑙subscriptℎ𝑤superscriptsubscriptnormdirect-productsubscript𝑤𝑙superscriptsubscript^𝑦ℎ𝑤𝑙superscriptsubscript^𝑦0ℎ𝑤𝑙22d(x,x\\_{0})=\\\\sum\\_{l}\\\\dfrac{1}{H\\_{l}W\\_{l}}\\\\sum\\_{h,w}\\|\\|w\\_{l}\\\\odot(\\\\hat{y}\\_{hw}^{l}-\\\\hat{y}\\_{0hw}^{l})\\|\\|\\_{2}^{2} |  | (1) |\n\n#### Training on our data\n\nWe consider a few variants for training with our perceptual judgments: lin, tune, and scratch. For the lin configuration, we keep pre-trained network weights ℱℱ\\\\mathcal{F} fixed, and learn linear weights w𝑤w on top. This constitutes a “perceptual calibration” of a few parameters in an existing feature space.\nFor example, for the VGG network, 1472 parameters are learned. For the tune configuration, we initialize from a pre-trained classification model, and allow all the weights for network ℱℱ\\\\mathcal{F} to be fine-tuned. Finally, for scratch, we initialize the network from random Gaussian weights and train it entirely on our judgments. Overall, we refer to these as variants of our proposed Learned Perceptual Image Patch Similarity (LPIPS) metric. We illustrate the training loss function in Figure [3]Figure 3 ‣ Just noticeable differences (JND) ‣ 2.2 Psychophysical Similarity Measurements ‣ 2 Berkeley-Adobe Perceptual Patch Similarity (BAPPS) Dataset ‣ The Unreasonable Effectiveness of Deep Features as a Perceptual Metric\") (right) and describe it further in the appendix.",
            "citations": null
          },
          "4 Experiments": {
            "content": "Results on our validation sets are shown in Figure [4]Figure 4 ‣ Just noticeable differences (JND) ‣ 2.2 Psychophysical Similarity Measurements ‣ 2 Berkeley-Adobe Perceptual Patch Similarity (BAPPS) Dataset ‣ The Unreasonable Effectiveness of Deep Features as a Perceptual Metric\"). We first evaluate how well our metrics and networks work. All validation sets contain 5 pairwise judgments for each triplet. Because this is an inherently noisy process, we compute agreement of an algorithm with all of the judgments. For example, if there are 4 preferences for x0subscript𝑥0x\\_{0} and 1 for x1subscript𝑥1x\\_{1}, an algorithm which predicts the more popular choice x0subscript𝑥0x\\_{0} would receive 80%percent8080\\\\% credit. If a given example is scored with fraction p𝑝p humans in one direction and 1−p1𝑝1-p in the other, a human would achieve score p2+(1−p)2superscript𝑝2superscript1𝑝2p^{2}+(1-p)^{2} on expectation.\n\n### 4.1 Evaluations\n\n![Refer to caption]Figure 5: Correlating Perceptual Tests. We show performance across methods, including unsupervised \\[ [26])\\], self-supervised \\[ [1]), [44]), [12]), [57]), [63]), [41]), [43]), [40]), [13]), [64])\\], supervised \\[ [27]), [52]), [20])\\], and our perceptually-learned metrics (LPIPS). The scores are on our 2AFC and JND tests, averaged across traditional and CNN-based distortions.\n\n#### How well do low-level metrics and classification networks perform?\n\nFigure [4]Figure 4 ‣ Just noticeable differences (JND) ‣ 2.2 Psychophysical Similarity Measurements ‣ 2 Berkeley-Adobe Perceptual Patch Similarity (BAPPS) Dataset ‣ The Unreasonable Effectiveness of Deep Features as a Perceptual Metric\") shows the performance of various low-level metrics (in red), deep networks, and human ceiling (in black). The scores are averaged across the 2 distortion test sets (traditional+CNN-based) in Figure [4]Figure 4 ‣ Just noticeable differences (JND) ‣ 2.2 Psychophysical Similarity Measurements ‣ 2 Berkeley-Adobe Perceptual Patch Similarity (BAPPS) Dataset ‣ The Unreasonable Effectiveness of Deep Features as a Perceptual Metric\") (left), and 4 real algorithm benchmarks (superresolution, frame interpolation, video deblurring, colorization) in Figure [4]Figure 4 ‣ Just noticeable differences (JND) ‣ 2.2 Psychophysical Similarity Measurements ‣ 2 Berkeley-Adobe Perceptual Patch Similarity (BAPPS) Dataset ‣ The Unreasonable Effectiveness of Deep Features as a Perceptual Metric\") (right). All scores within each test set are shown in the appendix. Averaged across all 6 test sets, humans are 73.9%percent73.973.9\\\\% consistent. Interestingly, the supervised networks perform at about the same level to each other, at 68.6%percent68.668.6\\\\%, 68.9%percent68.968.9\\\\%, and 67.0%percent67.067.0\\\\%, even across variation in model sizes – SqueezeNet (2.82.82.8 MB), AlexNet (9.19.19.1 MB), and VGG (58.958.958.9 MB) (only convolutional layers are counted). They all perform better than traditional metrics ℓ2subscriptℓ2\\\\ell\\_{2}, SSIM, and FSIM at 63.2%percent63.263.2\\\\%, 63.1%percent63.163.1\\\\%, 63.8%percent63.863.8\\\\%, respectively. Despite its common use, SSIM was not designed for situations where geometric distortion is a large factor \\[ [49])\\].\n\n#### Does the network have to be trained on classification?\n\nIn Figure [4]Figure 4 ‣ Just noticeable differences (JND) ‣ 2.2 Psychophysical Similarity Measurements ‣ 2 Berkeley-Adobe Perceptual Patch Similarity (BAPPS) Dataset ‣ The Unreasonable Effectiveness of Deep Features as a Perceptual Metric\"), we show model performance across a variety of unsupervised and self-supervised tasks, shown in green – generative modeling with BiGANs \\[ [13])\\], solving puzzles \\[ [40])\\], cross-channel prediction \\[ [64])\\], and segmenting foreground objects from video \\[ [43])\\]. These self-supervised tasks perform on par with classification networks. This indicates that tasks across a large spectrum can induce representations which transfer well to perceptual distances. Also, the performance of the stacked k-means method \\[ [26])\\], shown in yellow, outperforms low-level metrics. Random networks, shown in orange, with weights drawn from a Gaussian, do not yield much improvement. This indicates that the combination of network structure, along with orienting filters in directions where data is more dense, can better correlate to perceptual judgments.\n\n|  |  | 2AFC | JND | Class. | Det. | Avg |\n| --- | --- | --- | --- | --- | --- | --- |\n| Perceptual | 2AFC | – | .928 | .640 | .363 | .644 |\n| Perceptual | JND | .928 | – | .612 | .232 | .591 |\n| PASCAL | Classification | .640 | .612 | – | .429 | .560 |\n| PASCAL | Detection | .363 | .232 | .429 | – | .341 |\n\nTable 4: Task correlation. We correlate scores between our low-level perceptual tests along with high-level semantic tests across methods. Perceptual scores are averaged between traditional and CNN-based distortion sets. Correlation scores are computed for AlexNet-like architectures.\n\nIn Table [5]Figure 5 ‣ 4.1 Evaluations ‣ 4 Experiments ‣ The Unreasonable Effectiveness of Deep Features as a Perceptual Metric\"), we explore how well our perceptual task correlates to semantic tasks on the PASCAL dataset \\[ [15])\\], using results summarized in \\[ [64])\\], including additional self-supervised methods \\[ [1]), [44]), [12]), [57]), [63]), [41])\\]. We compute the correlation coefficient between each task (perceptual or semantic) across different methods. The correlation from our 2AFC distortion preference task to classification and detection is .640 and .363, respectively. Interestingly, this is similar to the correlation between the classification and detection tasks (.429), even though both are considered “high-level” semantic tasks, and our perceptual task is “low-level.”\n\n![Refer to caption]Figure 6: Qualitative comparisons on distortions. We show qualitative comparison on traditional distortions, using the SSIM \\[ [58])\\] metric and BiGAN network \\[ [13])\\]. We show examples where the metrics agree and disagree. A primary difference is that deep embeddings appear to be more sensitive to blur. Please see the appendix for additional examples.\n\n#### Do metrics correlate across different perceptual tasks?\n\nWe test if training for the 2AFC distortion preference test corresponds with another perceptual task, the JND test. We order patch pairs by ascending order by a given metric, and compute precision-recall on our CNN-based distortions – for a good metric, patches which are close together are more likely to be confused for being the same. We compute area under the curve, known as mAP \\[ [15])\\]. The 2AFC distortion preference test has high correlation to JND: ρ=.928𝜌.928\\\\rho=.928 when averaging the results across distortion types. Figure [5]Figure 5 ‣ 4.1 Evaluations ‣ 4 Experiments ‣ The Unreasonable Effectiveness of Deep Features as a Perceptual Metric\") shows how different methods perform under each perceptual test. This indicates that 2AFC generalizes to another perceptual test and is giving us signal regarding human judgments.\n\n#### Can we train a metric on traditional and CNN-based distortions?\n\nIn Figure [4]Figure 4 ‣ Just noticeable differences (JND) ‣ 2.2 Psychophysical Similarity Measurements ‣ 2 Berkeley-Adobe Perceptual Patch Similarity (BAPPS) Dataset ‣ The Unreasonable Effectiveness of Deep Features as a Perceptual Metric\"), we show performance using our lin, scratch, and tune configurations, shown in purple, pink, and brown, respectively. When validating on the traditional and CNN-based distortions (Figure [4]Figure 4 ‣ Just noticeable differences (JND) ‣ 2.2 Psychophysical Similarity Measurements ‣ 2 Berkeley-Adobe Perceptual Patch Similarity (BAPPS) Dataset ‣ The Unreasonable Effectiveness of Deep Features as a Perceptual Metric\")(a)), we see improvements. Allowing the network to tune all the way through (brown) achieves higher performance than simply learning linear weights (purple) or training from scratch (pink). The higher capacity network VGG also performs better than the lower capacity SqueezeNet and AlexNet architectures. These results verify that networks can indeed learn from perceptual judgments.\n\n#### Does training on traditional and CNN-based distortions transfer to real-world scenarios?\n\nWe are more interested in how performance generalizes to real-world algorithms, shown in Figure [4]Figure 4 ‣ Just noticeable differences (JND) ‣ 2.2 Psychophysical Similarity Measurements ‣ 2 Berkeley-Adobe Perceptual Patch Similarity (BAPPS) Dataset ‣ The Unreasonable Effectiveness of Deep Features as a Perceptual Metric\")(b). The SqueezeNet, AlexNet, and VGG architectures start at 64.0%percent64.064.0\\\\%, 65.0%percent65.065.0\\\\%, and 62.6%percent62.662.6\\\\%, respectively. Learning a linear classifier (purple) improves performance for all networks. Across the 3 networks and 4 real-algorithm tasks, 11 of the 12 scores improved, indicating that “calibrating” activations on a pre-existing representation using our data is a safe way to achieve a small boost in performance (1.1%percent1.11.1\\\\%, 0.3%percent0.30.3\\\\%, and 1.5%percent1.51.5\\\\%, respectively). Training a network from scratch (pink) yields slightly lower performance for AlexNet, and slightly higher performance for VGG than linear calibration. However, these still outperform low-level metrics. This indicates that the distortions we have expressed do project onto our test-time tasks of judging real algorithms.\n\nInterestingly, starting with a pre-trained network and tuning throughout lowers transfer performance. This is an interesting negative result, as training for a low-level perceptual task directly does not necessarily perform as well as transferring a representation trained for the high-level task.\n\n#### Where do deep metrics and low-level metrics disagree?\n\nIn Figure [11]Figure 11 ‣ Appendix A Quantitative Results ‣ The Unreasonable Effectiveness of Deep Features as a Perceptual Metric\"), we show a qualitative comparison across our traditional distortions for a deep method, BiGANs \\[ [13])\\], and a representation traditional perceptual method, SSIM \\[ [58])\\]. Pairs which BiGAN perceives to be far but SSIM to be close generally contain some blur. BiGAN tends to perceive correlated noise patterns to be a smaller distortion than SSIM.",
            "citations": null
          },
          "5 Conclusions": {
            "content": "Our results indicate that networks trained to solve challenging visual prediction and modeling tasks end up learning a representation of the world that correlates well with perceptual judgments. A similar story has recently emerged in the representation learning literature: networks trained on self-supervised and unsupervised objectives end up learning a representation that is also effective at semantic tasks \\[ [12])\\]. Interestingly, recent findings in neuroscience make much the same point: representations trained on computer vision tasks also end up being effective models of neural activity in macaque visual cortex \\[ [61])\\]. Moreover (and roughly speaking), the stronger the representation is at the computer vision task, the stronger it is as a model of cortical activity. Our paper makes a similar finding: the stronger a feature set is at classification and detection, the stronger it is as a model of perceptual similarity judgments, as suggested in Table [4]Table 4 ‣ Does the network have to be trained on classification? ‣ 4.1 Evaluations ‣ 4 Experiments ‣ The Unreasonable Effectiveness of Deep Features as a Perceptual Metric\"). Together, these results suggest that a good feature is a good feature. Features that are good at semantic tasks are also good at self-supervised and unsupervised tasks, and also provide good models of both human perceptual behavior and macaque neural activity. This last point aligns with the “rational analysis” explanation of visual cognition \\[ [4])\\], suggesting that the idiosyncrasies of biological perception arise as a consequence of a rational agent attempting to solve natural tasks. Further refining the degree to which this is true is an important question for future research.\n\n#### Acknowledgements\n\nThis research was supported, in part, by grants from Berkeley Deep Drive, NSF IIS-1633310, and hardware donations by NVIDIA. We thank members of the Berkeley AI Research Lab and Adobe Research for helpful discussions. We thank Alan Bovik for his insightful comments. We also thank Radu Timofte, Zhaowen Wang, Michael Waechter, Simon Niklaus, and Sergio Guadarrama for help preparing data. RZ is partially supported by an Adobe Research Fellowship and much of this work was done while RZ was an intern at Adobe Research.",
            "citations": null
          }
        },
        "abstract": "While it is nearly effortless for humans to quickly assess the perceptual\nsimilarity between two images, the underlying processes are thought to be quite\ncomplex. Despite this, the most widely used perceptual metrics today, such as\nPSNR and SSIM, are simple, shallow functions, and fail to account for many\nnuances of human perception. Recently, the deep learning community has found\nthat features of the VGG network trained on ImageNet classification has been\nremarkably useful as a training loss for image synthesis. But how perceptual\nare these so-called \"perceptual losses\"? What elements are critical for their\nsuccess? To answer these questions, we introduce a new dataset of human\nperceptual similarity judgments. We systematically evaluate deep features\nacross different architectures and tasks and compare them with classic metrics.\nWe find that deep features outperform all previous metrics by large margins on\nour dataset. More surprisingly, this result is not restricted to\nImageNet-trained VGG features, but holds across different deep architectures\nand levels of supervision (supervised, self-supervised, or even unsupervised).\nOur results suggest that perceptual similarity is an emergent property shared\nacross deep visual representations."
      },
      "bib.bib118": {
        "id": "bib.bib118",
        "citation": "[118]",
        "authors": "",
        "year": "",
        "title": "Locally attentional sdf diffusion for controllable 3d shape generation.",
        "venue": "",
        "pages": "",
        "url": "https://arxiv.org/abs/2305.04461",
        "arxiv_id": "2305.04461",
        "doi": null,
        "sections": {},
        "abstract": "Although the recent rapid evolution of 3D generative neural networks greatly\nimproves 3D shape generation, it is still not convenient for ordinary users to\ncreate 3D shapes and control the local geometry of generated shapes. To address\nthese challenges, we propose a diffusion-based 3D generation framework --\nlocally attentional SDF diffusion, to model plausible 3D shapes, via 2D sketch\nimage input. Our method is built on a two-stage diffusion model. The first\nstage, named occupancy-diffusion, aims to generate a low-resolution occupancy\nfield to approximate the shape shell. The second stage, named SDF-diffusion,\nsynthesizes a high-resolution signed distance field within the occupied voxels\ndetermined by the first stage to extract fine geometry. Our model is empowered\nby a novel view-aware local attention mechanism for image-conditioned shape\ngeneration, which takes advantage of 2D image patch features to guide 3D voxel\nfeature learning, greatly improving local controllability and model\ngeneralizability. Through extensive experiments in sketch-conditioned and\ncategory-conditioned 3D shape generation tasks, we validate and demonstrate the\nability of our method to provide plausible and diverse 3D shapes, as well as\nits superior controllability and generalizability over existing work. Our code\nand trained models are available at\nhttps://zhengxinyang.github.io/projects/LAS-Diffusion.html"
      },
      "bib.bib119": {
        "id": "bib.bib119",
        "citation": "[119]",
        "authors": "",
        "year": "",
        "title": "Sdf-stylegan: Implicit sdf-based stylegan for 3d shape generation.",
        "venue": "",
        "pages": "",
        "url": "https://arxiv.org/abs/2206.12055",
        "arxiv_id": "2206.12055",
        "doi": null,
        "sections": {
          "1 Introduction": {
            "content": "Automatic and controllable generation of high-quality 3D shapes is one of the key tasks of computer graphics, as it is useful to enrich 3D model collections, simplify the 3D modeling and reconstruction process, and to provide a large amount of diverse 3D training data to improve shape recognition and other 3D vision tasks. Inspired by the success of generative models such as Variational AutoEncoder (VAE) \\[ [KW14])\\], Generative Adversarial Networks (GAN) \\[ [GPAM∗14])\\] in image generation and natural language generation, the 3D shape generation paradigm has been shifted to learning-based generative models in recent years.\n\nPrevious learning-based 3D generation works can be differentiated by the chosen 3D shape representations and generative models. Point cloud representation is popular in 3D generation. However, due to its discrete nature, the generative shapes do not have continuous 3D geometry, and their conversion to 3D surfaces is also non-trivial. Mesh representation overcomes this limitation by modeling 3D shapes as a piecewise-linear surface, but the modeling capability is usually restricted by the predefined mesh template and cannot allow the change of mesh topology easily. Volumetric occupancy or signed distance function treats 3D shapes as the isosurfaces of an implicit function, and the recent development of neural implicit representation such as DeepSDF \\[ [PFS∗19])\\] offers a convenient shape representation for 3D generation. Popular generative models such as VAE, GAN, flow-based generative models \\[ [RM15])\\], and autoregressive models \\[ [VOKK16])\\] have been incorporated with different 3D representations.\n\nDespite the rapid development of 3D generative models, we observed that there are clear visual and geometric differences, between generative shapes and real shape collection in existing approaches. For instance, shapes generated by many existing works often exhibit bumpy and incomplete geometry, which can be found in [Fig.5]In 4.2 Quantitative and qualitative evaluation ‣ 4 Experiments and Evaluation ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\") and [Fig.6]In 4.2 Quantitative and qualitative evaluation ‣ 4 Experiments and Evaluation ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\"). In contrast to 3D generation, the gap between real and generative data in the image generation domain becomes much smaller by using more advanced generative models such as StyleGAN \\[ [KLA19])\\] and its successors \\[ [KLA∗20]), [KAL∗21])\\]. We attribute this performance gap in 3D generation to the following three aspects. First, the design of current 3D generators is relatively weaker than the state-of-the-art image generation networks; secondly, the works based on point cloud and mesh representation have limited shape representation power; thirdly, the assessment of generated shape quality that defines the discrimination loss of GAN is not sensitive to visual appearance, which is important to human perception. To this end, in the presented work, we use the StyleGAN2 network \\[ [KLA∗20])\\] to enhance the 3D shape generator, employ grid-based implicit SDF to improve shape modeling ability, and propose novel SDF discriminators that assess the SDF values and its gradient values from global and local views to improve visual and geometric similarity between the generated shapes and the training data. In particular, the use of SDF gradients greatly enhances surface quality and visual appearance, as SDF gradients determine surface normals that contribute to visual perception via rendering.\n\nWe validate the design choice of our 3D generative network — called _SDF-StyleGAN_, through extensive ablation studies, and demonstrate the superiority of _SDF-StyleGAN_ to other state-of-the-art 3D shape generative works via qualitative and quantitative comparisons. To measure visual quality and shape distribution of the generated shapes, we propose shading-image-based Fréchet inception distance (FID) scores that complement the evaluation metrics for 3D generative models. We also present various applications enabled by _SDF-StyleGAN_, including shape reconstruction, shape completion from point clouds, single-view image-based shape generation, and shape style editing.",
            "citations": null
          },
          "2 Related Work": {
            "content": "### 2.1 3D generative models\n\nGAN-based models\nGAN models were first introduced to voxel-based 3D generation by Wu _et al_.  \\[ [WZX∗16])\\] and their training was improved by adapting the Wasserstein distance \\[ [SM17]), [HLXT19])\\]. Achlioptas _et al_.  \\[ [ADMG18])\\] brought GAN to point cloud generation and also invented l-GAN which first trains an autoencoder (AE) and then trains a GAN on the latent space of AE. Jiang and Marcus \\[ [JM∗17])\\] used both the low-frequency generator and the high-frequency generator to improve the quality of the generated discrete SDF grids. IMGAN \\[ [CZ19])\\] integrated l-GAN and neural implicit representation to achieve better performance.\nKleineberg _et al_.  \\[ [KFW20])\\] experimented with both implicit SDF and point cloud as shape representations in a GAN model, which uses a 3DCNN-based discriminator or a PointNet \\[ [QSMG17])\\]-based discriminator. Hui _et al_.  \\[ [HXX∗20])\\] proposed to generate multiresolution point clouds progressively and use adversarial losses in multiresolution to improve point cloud quality. Wen _et al_.  \\[ [WYT21])\\] also generated points progressively via a dual generator framework. Ibing _et al_.  \\[ [ILK21])\\] localized l-GAN on grid cells and used the implicit occupancy field as its shape representation. Li _et al_.  \\[ [LDPT19])\\], Wu _et al_.  \\[ [WS20])\\] and Luo _et al_.  \\[ [LLZL21])\\] used 2D differentiable rendering for training 3D GANs without any 3D supervision. The former two works used silhouette images, while Luo _et al_.  used a designed spherical map of the extracted mesh. Shu _et al_.  \\[ [MWYG20])\\] introduced a tree-structured graph convolution network as the generator to improve feature learning. For generating part-controllable shapes, Wang _et al_.  \\[ [WSH∗18])\\] introduced a global-to-local GAN in which the generator also produces segmentation labels and each local discriminator is designed for each segmented part. Shape part information was also utilized to train the network \\[ [DXA∗19]), [LNX20])\\] to generate semantically plausible shapes. To remove the requirement of part annotation, the StyleGAN-like architecture was adapted for part-level controllable point cloud generation \\[ [GBZCO21]), [LLHF21])\\]. For better controlling the generated 3D model, Chen _et al_.  \\[ [CKF∗21])\\] proposed a GAN model to refine a low-resolution coarse voxel shape into a high-resolution model with finer details. With the use of volume rendering and neural implicit 3D representations, GAN models are also used to synthesize 3D-aware images such as human faces \\[ [OELS∗22]), [CMK∗21])\\] and achieve high quality results. In our work, we also adapt the StyleGAN architecture to generate feature vectors on grids that are mapped to implicit SDFs, and use SDF gradients to guide the global and local discriminators to improve shape quality and visual appearance.\n\nAutoencoder-based models\nAtlasNet \\[ [GFK∗18])\\] encoded 3D shapes into a latent space and took a collection of parametric surface elements as shape representations for shape generation. Li _et al_.  \\[ [LXC∗17])\\] created a recursive network based on variational autoencoder (VAE) to generate 3D shapes with hierarchical tree structures. Mo _et al_.  \\[ [MGY∗19])\\] encoded more structural relations with hierarchical graphs and devised a Graph-CNN-based VAE for shape generation. Gao _et al_.  \\[ [GYW∗19])\\] proposed a two-level VAE to learn the geometry of the deformed parts and the shape structure. Jie _et al_.  \\[ [YML∗22])\\] combined the advantages of the above two approaches to learn the disentangled shape structure and geometry. Wu _et al_.  \\[ [WZX∗20])\\] used a Seq2Seq Autoencoder to generate 3D shapes via sequential part assembly. In these works, part information is needed for training. Li _et al_.  \\[ [LLW22])\\] introduced superquadric primitives in VAE learning to mimic shape parts for easy editing, without real part annotation.\n\nOther generative models\nBy transforming a complex distribution to a simple and predefined distribution, diffusion-based generative models \\[ [SE19]), [HJA20])\\] have been applied to point cloud generation via learning the reverse diffusion process that maps a noise distribution to a 3D point cloud \\[ [CYAE∗20]), [LH21]), [ZDW21])\\]. By explicitly modeling a probability distribution via normalizing flow, flow-based generative models \\[ [RM15])\\] are also popular in shape generation, especially point cloud generation \\[ [YHH∗19]), [KBV20]), [KLK∗20]), [PPMNF20]), [KMU21]), [PLS∗21])\\]. However, these works focus on point clouds and do not generate continuous shapes directly. By implicitly defining a distribution over sequences using the chain rule for conditional probability, autoregressive models achieve their success in image generation \\[ [VOKK16])\\]. They were also used in point cloud generation \\[ [SWL∗20])\\], octree generation \\[ [IKK21])\\], polygonal mesh generation \\[ [NGEB20])\\], and SDF generation \\[ [MCST22])\\]. By explicitly modeling a probability distribution in the form of the EBM \\[ [XLZW16])\\], Xie _et al_.  \\[ [XZG∗20]), [XXZ∗21])\\] used an energy-based generative model to synthesize 3D shapes via Markov chain Monte Carlo sampling.\n\n![Refer to caption]Figure 1: Overview of SDF-StyleGAN. The original StyleGAN2 generator is extended to 3D, and it outputs the feature volume in a unit box. The feature vector ϕ​(𝒙)italic-ϕ𝒙\\\\phi(\\\\bm{x}) at any point 𝒙𝒙\\\\bm{x} inside the volume is interpolated via trilinear interpolation and is mapped to SDF value via a shallow MLP. The global discriminator takes the SDF values and gradients sampled at the grid centers as input, and the local discriminator takes the SDF values and gradients at a local and random 3D box region near the surface as input. A few local box regions are illustrated on the above chair example, in different colors.\n\n### 2.2 Evaluation metrics for 3D generation\n\nTo measure the similarity between the generated point cloud data set Sgsubscript𝑆𝑔S\\_{g} and the referenced point cloud data set Srsubscript𝑆𝑟S\\_{r}, Achlioptas _et al_.  \\[ [ADMG18])\\] proposed three metrics: Coverage (COV) that is the fraction of Srsubscript𝑆𝑟S\\_{r} covered by Sgsubscript𝑆𝑔S\\_{g}; Minimum Matching Distance (MMD) that measures how well the covered shapes in Srsubscript𝑆𝑟S\\_{r} are represented by Sgsubscript𝑆𝑔S\\_{g}; and Jensen-Shannon Divergence (JSD) between two probability distributions over Sgsubscript𝑆𝑔S\\_{g} and Srsubscript𝑆𝑟S\\_{r}. The distance between two point clouds can be either the Chamfer distance (CD) or the Earth Mover’s distance (EMD). Chen _et al_.  \\[ [CZ19])\\] replaced CD and EMD with light-field-descriptor (LFD) \\[ [CTSO03])\\] for better measuring the quality of the generated meshes.\nNoticing that COV, MMD and JSD do not ensure a fair model comparison, Yang _et al_.  \\[ [YHH∗19])\\] proposed 1-Nearest Neighbor Accuracy (1-NNA) to assess whether two distributions are identical. Ibing _et al_.  \\[ [ILK21])\\] also adapted a robust statistical criterion — Edge Count Difference (ECD) \\[ [CF17])\\] to evaluate 3D generative models.\n\nTo mimic the Fréchet Inception Distance (FID) \\[ [HRU∗17])\\] that is widely used in image generation for assessing image quality, Shu _et al_.  \\[ [SPK19])\\] proposed the Fréchet Point Cloud Distance (FPD) that computes the 2-Wasserstein distance between real and fake Gaussian measures in the feature space extracted by a pretrained PointNet \\[ [QSMG17])\\]. Li _et al_.  \\[ [LLHF21])\\] replaced PointNet with a stronger pretrained backbone – DGCNN \\[ [WSL∗19])\\] for FPD computation.\n\nIn addition, some works propose task-specific metrics. Wang _et al_.  \\[ [WSH∗18])\\] proposed the 3D inception score, the symmetry score, and the distribution distance to measure the quality of the generated voxelized shapes and generated parts, Mo _et al_.  \\[ [MWYG20])\\] proposed the HierInsSeg score to measure how well the generated point clouds satisfy the part tree conditions they defined. Human preference through user studies is also used for assessing the quality of shape generation \\[ [KLK∗20]), [LLHF21])\\].\n\nOther metrics based on shading images for measuring shape reconstruction quality, such as the mean square error defined over per-pixel keypoint maps \\[ [JPXZ20])\\], have potentials to be utilized for evaluating 3D generation. In our work, we enrich the evaluation metrics by introducing Fréchet Inception Distance on shading images, to better assess the visual appearance and data distribution of 3D generative models.",
            "citations": null
          },
          "3 Design of SDF-StyleGAN": {
            "content": "### 3.1 Overview\n\nWe design a StyleGAN2-based 3D shape generation architecture, as illustrated in [Fig.1]In 2.1 3D generative models ‣ 2 Related Work ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\"). We use feature-volume-based implicit signed distance functions as shape representation to maximize implicit representation capability ( [Section3.2]Feature-volume-based implicit signed distance functions ‣ 3 Design of SDF-StyleGAN ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\")), leverage and extend the 2D StyleGAN2 generator \\[ [KLA∗20])\\] to 3D to generate 3D feature volumes ( [Section3.3]SDF-StyleGAN generator ‣ 3 Design of SDF-StyleGAN ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\")), and propose global and local discriminators to distinguish _fake_ SDF fields, including their gradients calculated from global and local regions of the generated field, from the sampled SDF field of the _real_ shapes in the training set ( [Section3.4]SDF-StyleGAN discriminator ‣ 3 Design of SDF-StyleGAN ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\")). We propose an adaptive training scheme to gradually improve the quality of the generated shapes ( [Section3.5]SDF-StyleGAN training ‣ 3 Design of SDF-StyleGAN ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\")).\n\n### 3.2 Feature-volume-based implicit signed distance functions\n\nWe represent 3D shapes as feature-volume-based implicit signed distance functions, in similar spirit to the grid-based implicit occupancy function used in \\[ [JSM∗20]), [PNM∗20]), [ILK21])\\].\n\nWe assume that a 3D shape 𝒮𝒮\\\\mathcal{S} is generated inside a box B:\\[−1,1\\]3:𝐵superscript113B:\\[-1,1\\]^{3} and the box is divided as m×m×m𝑚𝑚𝑚m\\\\times m\\\\times m grid cells with equal cell size.\n\n\\\\begin{overpic}\\[width=151.76964pt\\]{images/dual.pdf}\n\\\\put(53.0,44.0){\\\\scriptsize$\\\\Phi(\\\\bm{x})$}\n\\\\put(24.0,70.0){\\\\scriptsize$\\\\Phi\\_{1}$}\n\\\\put(68.0,70.0){\\\\scriptsize$\\\\Phi\\_{2}$}\n\\\\put(24.0,27.0){\\\\scriptsize$\\\\Phi\\_{3}$}\n\\\\put(68.0,27.0){\\\\scriptsize$\\\\Phi\\_{4}$}\n\\\\end{overpic}\n\nA dual graph is constructed on these grid cells, and on each graph node cisubscript𝑐𝑖c\\_{i}, a feature vector Φi∈ℝlsubscriptΦ𝑖superscriptℝ𝑙\\\\Phi\\_{i}\\\\in\\\\mathbb{R}^{l} is stored. All feature vectors form a feature volume.\nFor any 3D point 𝒙∈B𝒙𝐵\\\\bm{x}\\\\in B, we assign a feature vector to it, denoted as Φ​(𝒙)Φ𝒙\\\\Phi(\\\\bm{x}), via trilinear interpolation in the feature volume, _i.e_. , using the feature vectors of the eight corners of the dual cell where 𝒙𝒙\\\\bm{x} is located. Due to the construction above, Φ​(𝒙)Φ𝒙\\\\Phi(\\\\bm{x}) is a continuous function defined in B𝐵B.\nA shallow multilayer perceptron (MLP) is used to map Φ​(𝒙)Φ𝒙\\\\Phi(\\\\bm{x}) to a signed distance value to the shape. In this way, an SDF f​(𝒙):𝒙∈ℝ3⟼ℝ:𝑓𝒙𝒙superscriptℝ3⟼ℝf(\\\\bm{x}):\\\\bm{x}\\\\in\\\\mathbb{R}^{3}\\\\longmapsto\\\\mathbb{R} is determined by the feature volume and the MLP mapping.\nThe zero isosurface of the SDF defines the shape geometry. In the right inset, we illustrate the concept of feature volume in 2D. The gray grid is a portion of the primal grid cells and the dashed black grid is its dual graph. To calculate the feature at point 𝒙𝒙\\\\bm{x}, we first find the dual cell where 𝒙𝒙\\\\bm{x} is located and use the feature vectors Φ1,Φ2,Φ3,Φ4subscriptΦ1subscriptΦ2subscriptΦ3subscriptΦ4\\\\Phi\\_{1},\\\\Phi\\_{2},\\\\Phi\\_{3},\\\\Phi\\_{4} at the dual cell vertices to\nperform the interpolation.\n\nIn our implementation, m=32𝑚32m=32, l=16𝑙16l=16 and the MLP has two hidden layers. The feature volume is produced by the generator, and the MLP parameters are learned via training.\n\n### 3.3 SDF-StyleGAN generator\n\nWe adapt the StyleGAN2 architecture \\[ [KLA∗20])\\] to our feature volume generator. In the original StyleGAN2 architecture, a latent vector 𝒛𝒛\\\\bm{z} is first sampled from a high-dimensional normal distribution and mapped to an intermediate latent space 𝒲𝒲\\\\mathcal{W}. A learned affine transform and Gaussian noise are injected into a style block, and multiple stacked style locks are used to predict the pixel colors. We applied the following modifications to the original StyleGAN2’s network structure.\n\n(i).The 2D convolution in each StyleGAN2 block is changed to 3D convolution with corresponding kernel size;\n(ii).The stacked blocks are upsampled from 4×4×44444\\\\times 4\\\\times 4 to m×m×m𝑚𝑚𝑚m\\\\times m\\\\times m;\n(iii).the size of the constant tensor fed to the first style block is set to 256×4×4×4256444256\\\\times 4\\\\times 4\\\\times 4.\n\nThe detailed structure of the network and our changes are illustrated in [Fig.2]In 3.3 SDF-StyleGAN generator ‣ 3 Design of SDF-StyleGAN ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\")-(a,b). With these modifications, the generator output an m×m×m𝑚𝑚𝑚m\\\\times m\\\\times m feature volume with l𝑙l channels.\n\n![Refer to caption]Figure 2: (a): The revised StyleGAN2 generator for 3D feature volume generation. We used 3D convolution with kernel size 3 and four style blocks corresponding to four-level resolution, up to 32×32×3232323232\\\\times 32\\\\times 32. _Mod_ and _Demod_ are the modulation and demodulation modules adapted from StyleGAN2. (b): The skip input for the generator. (c) The discriminator architecture. The _tFeature_ module and the _fFeature_ module convert between the feature volume per grid cell and the high dimensional feature to/from 3D convolution. _Up_ and _Down_ denote the upsampling and downsampling modules. The first block in (c) is removed from the local discriminator as its input feature grid resolution is 16×16×1616161616\\\\times 16\\\\times 16.\n\n### 3.4 SDF-StyleGAN discriminator\n\nWe design two discriminators to evaluate the generated SDF on the coarse scale and the fine scale: global discriminator and local discriminator. Noticing that the visual appearance of the zero isosurface is affected by the surface normal, we also propose to take both SDF values and SDF gradients on a grid region as input to discriminators because the SDF gradients at the zero isosurface are exactly shape surface normals, and the use of both zero-order and first-order SDF information on a coarse grid can approximate SDF values on a much denser grid.\n\n#### 3.4.1 Global discriminator\n\nFor a generated feature volume, we calculate the SDF values and gradients in a coarse grid of \\[−1,1\\]3superscript113\\[-1,1\\]^{3} with resolution KG×KG×KGsubscript𝐾𝐺subscript𝐾𝐺subscript𝐾𝐺K\\_{G}\\\\times K\\_{G}\\\\times K\\_{G}. The SDF values are evaluated directly via the network and SDF gradients are calculated via finite differentiation. These samples form a 4×KG×KG×KG4subscript𝐾𝐺subscript𝐾𝐺subscript𝐾𝐺4\\\\times K\\_{G}\\\\times K\\_{G}\\\\times K\\_{G} feature grid that can approximate the shape roughly. For a _real_ shape in the training set, we first build a discrete SDF field with resolution 128×128×128128128128128\\\\times 128\\\\times 128, then sample the SDF values on the same coarse grid via trilinear interpolation. The corresponding SDF gradients are approximated via finite differentiation. As SDF gradient vectors should be with unit length in theory, we normalize the gradients before constructing the feature grid. In our implementation, we set KG=m=32subscript𝐾𝐺𝑚32K\\_{G}=m=32.\n\nWe adapt the discriminator architecture of StyleGAN2 to our global discriminator 𝒟Gsubscript𝒟𝐺\\\\mathcal{D}\\_{G} by replacing the 2D convolution with the corresponding 3D convolution, as illustrated in [Fig.2]In 3.3 SDF-StyleGAN generator ‣ 3 Design of SDF-StyleGAN ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\")-(c). The discriminator is used to distinguish between the synthesized shapes and the shapes from the training set.\n\n#### 3.4.2 Local discriminator\n\nThe global discriminator focuses on shape quality in a coarse level. Naively increasing KGsubscript𝐾𝐺K\\_{G} will lead to high computational and memory costs due to the use of 3D convolution, and the discrimination of _real_ or _fake_ SDF away from the zero isosurface has little impact on the quality of shape surface. Instead, we pay more attention to the local region close to the zero isosurface by introducing a local discriminator 𝒟Lsubscript𝒟𝐿\\\\mathcal{D}\\_{L}.\n\nWe choose a set of local regions as follows. We first evaluate the SDF values on the cell centers of the coarse grid used in the global discriminator and sort these cell centers in ascending order according to their absolute SDF values. The first N0subscript𝑁0N\\_{0} cell centers are selected as the centers of candidate local regions. We then randomly select s𝑠s cell centers from these candidates and construct a small box with length Lbsubscript𝐿𝑏L\\_{b} centered at every selected center. For each small box, we divide it as a KL×KL×KLsubscript𝐾𝐿subscript𝐾𝐿subscript𝐾𝐿K\\_{L}\\\\times K\\_{L}\\\\times K\\_{L} grid, sample the SDF values and calculate gradients at the cell centers of this grid to construct a 4×KL×KL×KL4subscript𝐾𝐿subscript𝐾𝐿subscript𝐾𝐿4\\\\times K\\_{L}\\\\times K\\_{L}\\\\times K\\_{L} feature grid. The local discriminator takes the feature grid as input, to distinguish whether it is _real_ or _fake_.\n\nNote that we did not choose the first s𝑠s cell centers from the sorted center list, as this greedy selection may result in clustered local regions. Our random selection from a large candidate pool helps to distribute local regions more evenly around the zero isosurface. In our implementation, the indices of N0subscript𝑁0N\\_{0} candidates are randomized directly for selection. It is possible to improve this randomization by using the furthest point sampling strategy, but it requires more computational time for training.\n\nThe network architecture of the local discriminator is similar to that of the global discriminator. During training, each _real_ or _generated_ shape provides s𝑠s local regions to the local discriminator.\nIn our implementation, we set KL=16subscript𝐾𝐿16K\\_{L}=16, Lb=0.25subscript𝐿𝑏0.25L\\_{b}=0.25, N0=2048subscript𝑁02048N\\_{0}=2048 and s=16𝑠16s=16 by default. In [Fig.1]In 2.1 3D generative models ‣ 2 Related Work ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\"), we illustrate some local region boxes in the chair examples.\n\n### 3.5 SDF-StyleGAN training\n\n#### 3.5.1 Loss functions\n\nThe loss functions of our discriminators and generator are adapted from StyleGAN2.\nThe global discriminator loss ℒ𝒟Gsubscriptsuperscriptℒ𝐺𝒟\\\\mathcal{L}^{G}\\_{\\\\mathcal{D}} has the following form:\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n|  | ℒ𝒟Gsubscriptsuperscriptℒ𝐺𝒟\\\\displaystyle\\\\mathcal{L}^{G}\\_{\\\\mathcal{D}} | =𝔼𝒛∼𝒵​\\[ζ​(𝒟G​(𝑻G​(𝒮​(𝒛))))\\]+𝔼𝒮∼pd​a​t​a​\\[ζ​(−𝒟G​(𝑻G​(𝒮)))\\]absentsubscript𝔼similar-to𝒛𝒵delimited-\\[\\]𝜁subscript𝒟𝐺subscript𝑻𝐺𝒮𝒛subscript𝔼similar-to𝒮subscript𝑝𝑑𝑎𝑡𝑎delimited-\\[\\]𝜁subscript𝒟𝐺subscript𝑻𝐺𝒮\\\\displaystyle=\\\\mathbb{E}\\_{\\\\bm{z}\\\\sim\\\\mathcal{Z}}\\[\\\\zeta(\\\\mathcal{D}\\_{G}(\\\\bm{T}\\_{G}(\\\\mathcal{S}(\\\\bm{z}))))\\]+\\\\mathbb{E}\\_{\\\\mathcal{S}\\\\sim p\\_{data}}\\[\\\\zeta(-\\\\mathcal{D}\\_{G}(\\\\bm{T}\\_{G}(\\\\mathcal{S})))\\] |  | (1) |\n|  |  | +ℛ𝒮∼pd​a​t​a​(𝒮;ΘG).subscriptℛsimilar-to𝒮subscript𝑝𝑑𝑎𝑡𝑎𝒮subscriptΘ𝐺\\\\displaystyle+\\\\mathcal{R}\\_{\\\\mathcal{S}\\\\sim p\\_{data}}(\\\\mathcal{S};\\\\Theta\\_{G}). |  |\n\nHere, 𝒮​(𝒛)𝒮𝒛\\\\mathcal{S}(\\\\bm{z}) and 𝒮𝒮\\\\mathcal{S} denote the generated SDF and the SDF of the shape sampled from the training data set respectively. 𝒟G​(⋅)subscript𝒟𝐺⋅\\\\mathcal{D}\\_{G}(\\\\cdot) is the output of the global discriminator, and 𝑻G​(⋅)subscript𝑻𝐺⋅\\\\bm{T}\\_{G}(\\\\cdot) denotes the feature grid (SDF values & gradients) calculated in the coarse grid.\nζ​(x)=log⁡(1+ex)𝜁𝑥1superscript𝑒𝑥\\\\zeta(x)=\\\\log(1+e^{x}). ℛS∼pd​a​t​a​(S;Θ)subscriptℛsimilar-to𝑆subscript𝑝𝑑𝑎𝑡𝑎𝑆Θ\\\\mathcal{R}\\_{S\\\\sim p\\_{data}}(S;\\\\Theta) is the R1subscript𝑅1R\\_{1} regularization term adapted from \\[ [MGN18])\\], where ΘGsubscriptΘ𝐺\\\\Theta\\_{G} is the network parameters of 𝒟Gsubscript𝒟𝐺\\\\mathcal{D}\\_{G}.\n\nThe local discriminator loss ℒ𝒟Lsubscriptsuperscriptℒ𝐿𝒟\\\\mathcal{L}^{L}\\_{\\\\mathcal{D}} is similar to ℒ𝒟Gsubscriptsuperscriptℒ𝐺𝒟\\\\mathcal{L}^{G}\\_{\\\\mathcal{D}}.\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n|  | ℒ𝒟Lsubscriptsuperscriptℒ𝐿𝒟\\\\displaystyle\\\\mathcal{L}^{L}\\_{\\\\mathcal{D}} | =𝔼𝒛∼𝒵​\\[ζ​(𝒟L​(𝑻L​(𝒮​(𝒛))))\\]+𝔼𝒮∼pd​a​t​a​\\[ζ​(−𝒟L​(𝑻L​(𝒮)))\\]absentsubscript𝔼similar-to𝒛𝒵delimited-\\[\\]𝜁subscript𝒟𝐿subscript𝑻𝐿𝒮𝒛subscript𝔼similar-to𝒮subscript𝑝𝑑𝑎𝑡𝑎delimited-\\[\\]𝜁subscript𝒟𝐿subscript𝑻𝐿𝒮\\\\displaystyle=\\\\mathbb{E}\\_{\\\\bm{z}\\\\sim\\\\mathcal{Z}}\\[\\\\zeta(\\\\mathcal{D}\\_{L}(\\\\bm{T}\\_{L}(\\\\mathcal{S}(\\\\bm{z}))))\\]+\\\\mathbb{E}\\_{\\\\mathcal{S}\\\\sim p\\_{data}}\\[\\\\zeta(-\\\\mathcal{D}\\_{L}(\\\\bm{T}\\_{L}(\\\\mathcal{S})))\\] |  | (2) |\n|  |  | +ℛS∼pd​a​t​a​(𝒮;ΘL).subscriptℛsimilar-to𝑆subscript𝑝𝑑𝑎𝑡𝑎𝒮subscriptΘ𝐿\\\\displaystyle+\\\\mathcal{R}\\_{S\\\\sim p\\_{data}}(\\\\mathcal{S};\\\\Theta\\_{L}). |  |\n\nHere 𝑻L​(⋅)subscript𝑻𝐿⋅\\\\bm{T}\\_{L}(\\\\cdot) is the feature grid calculated in the local region, and ΘLsubscriptΘ𝐿\\\\Theta\\_{L} is the network parameters of the local discriminator.\n\nThe loss function of the generator ℒ𝒢subscriptℒ𝒢\\\\mathcal{L}\\_{\\\\mathcal{G}} is defined as follows.\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n|  | ℒ𝒢subscriptℒ𝒢\\\\displaystyle\\\\mathcal{L}\\_{\\\\mathcal{G}} | =β​ℒpl+𝔼𝒛∼𝒵​\\[ζ​(−𝒟G​(𝑻G​(𝒮​(𝒛))))\\]absent𝛽subscriptℒplsubscript𝔼similar-to𝒛𝒵delimited-\\[\\]𝜁subscript𝒟𝐺subscript𝑻𝐺𝒮𝒛\\\\displaystyle=\\\\beta\\\\,\\\\mathcal{L}\\_{\\\\mathrm{pl}}+\\\\mathbb{E}\\_{\\\\bm{z}\\\\sim\\\\mathcal{Z}}\\[\\\\zeta(-\\\\mathcal{D}\\_{G}(\\\\bm{T}\\_{G}(\\\\mathcal{S}(\\\\bm{z}))))\\] |  | (3) |\n|  |  | +α​(t)​𝔼𝒛∼𝒵​\\[ζ​(−𝒟L​(𝑻L​(𝒮​(𝒛))))\\].𝛼𝑡subscript𝔼similar-to𝒛𝒵delimited-\\[\\]𝜁subscript𝒟𝐿subscript𝑻𝐿𝒮𝒛\\\\displaystyle+\\\\alpha(t)\\\\,\\\\mathbb{E}\\_{\\\\bm{z}\\\\sim\\\\mathcal{Z}}\\[\\\\zeta(-\\\\mathcal{D}\\_{L}(\\\\bm{T}\\_{L}(\\\\mathcal{S}(\\\\bm{z}))))\\]. |  |\n\nHere, ℒplsubscriptℒpl\\\\mathcal{L}\\_{\\\\mathrm{pl}} is the path length regularization term used by StyleGAN2, and β=2𝛽2\\\\beta=2. α​(t)𝛼𝑡\\\\alpha(t) is the weight of the local discriminator and changed during training. We also adopt the EMA scheme \\[ [YFW∗18])\\] to stabilize the generator training.\n\n#### 3.5.2 Adaptive training scheme\n\nWe propose the following adaptive scheme to train SDF-StyleGAN. We first initialize the generator and discriminators with StyleGAN2’s weight initialization, then update the global discriminator, the local discriminator, and the generator in sequential order. During the early training stage, we set a small α𝛼\\\\alpha in generator training so that the global discriminator dominates, and the network focuses on generating rough SDF fields. We gradually increase α𝛼\\\\alpha so that the local discriminator can improve the geometry details while maintaining the global shape structure. In our implementation, we set α​(t)=αmin+αmax×t/tmax𝛼𝑡subscript𝛼subscript𝛼𝑡subscript𝑡\\\\alpha(t)=\\\\alpha\\_{\\\\min}+\\\\alpha\\_{\\\\max}\\\\times t/t\\_{\\\\max}, here t𝑡t is the current epoch number and tmaxsubscript𝑡t\\_{\\\\max} is the maximum epoch number. Our default setting is αmin=0,αmax=8,tmax=200formulae-sequencesubscript𝛼0formulae-sequencesubscript𝛼8subscript𝑡200\\\\alpha\\_{\\\\min}=0,\\\\alpha\\_{\\\\max}=8,t\\_{\\\\max}=200.",
            "citations": null
          },
          "4 Experiments and Evaluation": {
            "content": "Dataset and training\nWe trained our SDF-StyleGAN with the five shape categories selected from ShapeNet Core V1 \\[ [CFG∗15])\\]: chair, table, airplane, car, and rifle, individually. We use the same data split of  \\[ [CZ19])\\]: 70%times70percent70\\\\text{\\\\,}\\\\mathrm{\\\\char 37\\\\relax} data as the training set, 20%times20percent20\\\\text{\\\\,}\\\\mathrm{\\\\char 37\\\\relax} data as the test set, and 10%times10percent10\\\\text{\\\\,}\\\\mathrm{\\\\char 37\\\\relax} data as the validation set which is not used in our approach. For each shape with triangle mesh format in the training set, we normalize it into a \\[−0.8,0.8\\]3superscript0.80.83\\[-0.8,0.8\\]^{3} box, and use the SDF computation algorithm of  \\[ [XB14])\\] to compute the discrete SDF field with resolution 1283superscript1283128^{3} in \\[−1,1\\]3superscript113\\[-1,1\\]^{3}. This algorithm can remove nested interior mesh facets, handle non-watertight meshes and meshes with inconsistently oriented normals robustly. During training, we also ensure that the centers of the selected local regions are contained in \\[−1+Lb/2,1−Lb/2\\]3superscript1subscript𝐿𝑏21subscript𝐿𝑏23\\[-1+L\\_{b}/2,1-L\\_{b}/2\\]^{3}, so that all the selected local regions are strictly within \\[−1,1\\]3superscript113\\[-1,1\\]^{3}. We conducted our experiments on a Linux server with Intel Xeon Platinum 8168 CPU (2.7GHztimes2.7GHz2.7\\\\text{\\\\,}\\\\mathrm{G}\\\\mathrm{H}\\\\mathrm{z}) and 8 Tesla V100 GPUs (16GBtimes16GB16\\\\text{\\\\,}\\\\mathrm{G}\\\\mathrm{B} memory). The default batch size is 32. The training time (200 epochs) takes about 2 days on average. SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation illustrates a few plausible shapes generated by our approach.\n\nCompetitive methods  We select the following representative works that generate continuous 3D shapes for comparison: IMGAN \\[ [CZ19])\\] and Implicit-Grid \\[ [ILK21])\\] that use implicit occupancy fields to represent 3D shapes, ShapeGAN \\[ [KFW20])\\] that uses implicit SDFs to represent 3D shapes. We reused the released checkpoints of IMGAN and Implicit-Grid for evaluation. More specifically, IMGAN \\[ [CZ19])\\]’s chair and table categories were trained on 643superscript64364^{3} resolution, while airplane, car and rifle categories were trained on 1283superscript1283128^{3} resolution. For Implicit Grid \\[ [ILK21])\\], we used the checkpoints provided by the authors, trained on 2563superscript2563256^{3} resolution. As the work of \\[ [KFW20])\\] released the pre-trained networks in three ShapeNetCore V2 shape categories only, for a fair comparison, we retrain ShapeGAN on our processed data with the same training strategy and parameters provided by the authors.\n\nIn the following subsections, we first present the evaluation metrics for 3D shape generation in [Section4.1]Evaluation metrics ‣ 4 Experiments and Evaluation ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\"), then provide a quantitative and qualitative evaluation of our method and the competitive methods in [Section4.2]Quantitative and qualitative evaluation ‣ 4 Experiments and Evaluation ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\"). Ablation studies on the design of SDF-StyleGAN are presented in [Section4.3]Ablation studies ‣ 4 Experiments and Evaluation ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\").\n\n### 4.1 Evaluation metrics\n\nAs briefly reviewed in [Section2.2]Evaluation metrics for 3D generation ‣ 2 Related Work ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\"), proper evaluation criteria for 3D generative models are still in active development. The shortcomings of commonly used COV and MMD metrics \\[ [ADMG18])\\] were verified by \\[ [YHH∗19]), [ILK21])\\], and replaced by 1-NNA \\[ [YHH∗19])\\] or ECD \\[ [ILK21])\\]. We follow their suggestions and use 1-NNA and ECD as two of our evaluation metrics and also report COV and MMD as a reference. The definitions of these metrics are at below.\n\nLet Sg∼ℙgsimilar-tosubscript𝑆𝑔subscriptℙ𝑔S\\_{g}\\\\sim\\\\mathbb{P}\\_{g} be the set of generated samples, Sr∼ℙrsimilar-tosubscript𝑆𝑟subscriptℙ𝑟S\\_{r}\\\\sim\\\\mathbb{P}\\_{r} be the set of reference data, and D​(⋅,⋅):𝒳×𝒳↦ℝ≥0:𝐷⋅⋅maps-to𝒳𝒳subscriptℝabsent0D(\\\\cdot,\\\\cdot):\\\\mathcal{X}\\\\times\\\\mathcal{X}\\\\mapsto\\\\mathbb{R}\\_{\\\\geq 0} be the distance function.\n\nCOV \\[ [ADMG18])\\]\nFor any X∈Sg𝑋subscript𝑆𝑔X\\\\in S\\_{g}, its nearest neighbor Y∈Sr𝑌subscript𝑆𝑟Y\\\\in S\\_{r} is marked as a _match_, and COV measures the fraction of Y∈Sr𝑌subscript𝑆𝑟Y\\\\in S\\_{r} matched to any element in Sgsubscript𝑆𝑔S\\_{g}:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | COV⁡(Sg,Sr)=\\|{argminY∈Sr⁡D​(X,Y)∣∀X∈Sg}\\|\\|Sr\\|.COVsubscript𝑆𝑔subscript𝑆𝑟conditional-setsubscriptargmin𝑌subscript𝑆𝑟𝐷𝑋𝑌for-all𝑋subscript𝑆𝑔subscript𝑆𝑟\\\\operatorname{COV}(S\\_{g},S\\_{r})=\\\\frac{\\|\\\\{\\\\operatorname{argmin}\\_{Y\\\\in S\\_{r}}D(X,Y)\\\\mid\\\\forall X\\\\in S\\_{g}\\\\}\\|}{\\|S\\_{r}\\|}. |  | (4) |\n\nMMD \\[ [ADMG18])\\]\nMMD measures the average distance from any Y∈Sr𝑌subscript𝑆𝑟Y\\\\in S\\_{r} to its nearest neighbor X∈Sg𝑋subscript𝑆𝑔X\\\\in S\\_{g}:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | MMD⁡(Sg,Sr)=1\\|Sr\\|​∑Y∈SrminX∈Sg⁡D​(X,Y).MMDsubscript𝑆𝑔subscript𝑆𝑟1subscript𝑆𝑟subscript𝑌subscript𝑆𝑟subscript𝑋subscript𝑆𝑔𝐷𝑋𝑌\\\\operatorname{MMD}(S\\_{g},S\\_{r})=\\\\frac{1}{\\|S\\_{r}\\|}\\\\sum\\_{Y\\\\in S\\_{r}}\\\\min\\_{X\\\\in S\\_{g}}D(X,Y). |  | (5) |\n\n1-NNA \\[ [YHH∗19])\\]\nLet S−X=Sr∪Sg−{X}subscript𝑆𝑋subscript𝑆𝑟subscript𝑆𝑔𝑋S\\_{-X}=S\\_{r}\\\\cup S\\_{g}-\\\\{X\\\\} and NXsubscript𝑁𝑋N\\_{X} be the nearest neighbor to X𝑋X in S−Xsubscript𝑆𝑋S\\_{-X}. 1-NNA is the leave-one-out accuracy of the 1-NN classifier:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | 1-NNA​(Sg,Sr)=∑X∈Sg𝕀​\\[NX∈Sg\\]+∑Y∈Sr𝕀​\\[NY∈Sr\\]\\|Sg\\|+\\|Sr\\|,1-NNAsubscript𝑆𝑔subscript𝑆𝑟subscript𝑋subscript𝑆𝑔𝕀delimited-\\[\\]subscript𝑁𝑋subscript𝑆𝑔subscript𝑌subscript𝑆𝑟𝕀delimited-\\[\\]subscript𝑁𝑌subscript𝑆𝑟subscript𝑆𝑔subscript𝑆𝑟\\\\text{1-NNA}(S\\_{g},S\\_{r})=\\\\frac{\\\\sum\\_{X\\\\in S\\_{g}}\\\\mathbb{I}\\[N\\_{X}\\\\in S\\_{g}\\]+\\\\sum\\_{Y\\\\in S\\_{r}}\\\\mathbb{I}\\[N\\_{Y}\\\\in S\\_{r}\\]}{\\|S\\_{g}\\|+\\|S\\_{r}\\|}, |  | (6) |\n\nwhere 𝕀​\\[⋅\\]𝕀delimited-\\[\\]⋅\\\\mathbb{I}\\[\\\\cdot\\] is the indicator function.\n\nECD \\[ [ILK21])\\]  A k𝑘k-minimum spanning tree of the neighborhood graph of Sr∪Sgsubscript𝑆𝑟subscript𝑆𝑔S\\_{r}\\\\cup S\\_{g} is built. Three types of tree edges are defined: connected within Srsubscript𝑆𝑟S\\_{r}, connected within Sgsubscript𝑆𝑔S\\_{g}, connected between Srsubscript𝑆𝑟S\\_{r} and Sgsubscript𝑆𝑔S\\_{g}. ECD is the weighted difference between the number of these edges and the edge count if Srsubscript𝑆𝑟S\\_{r} and Sgsubscript𝑆𝑔S\\_{g} are from the same distribution. The exact formula of ECD can be found in the Appendix of \\[ [ILK21])\\].\n\nFor COV, MMD, LFD and ECD computations, we follow \\[ [CZ19]), [ILK21])\\] to use mesh-based light-field-distance (LFD) as the distance function D𝐷D, as our method and all the compared methods can extract mesh surfaces for evaluation.\n\nDrawback of LFD  Although the above metrics based on LFD is recommended by previous 3D generation works \\[ [CZ19]), [ILK21])\\], a smaller LFD between shape A𝐴A and shape B𝐵B does not mean that their visual similarity is better than that of shape A𝐴A and another shape C𝐶C with a larger LFD, as LFD is based on silhouette images without considering the fidelity of the local shape geometry.\nWe illustrate this drawback in [Fig.3]In 4.1 Evaluation metrics ‣ 4 Experiments and Evaluation ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\") as follows. The shape in the rightmost column is sampled from ShapeNet, denoted by GT. We select the shape with the smallest LFD value to the GT shape for each method. The numbers above these shapes are the LFD values. We can see that some shapes with bumpy geometry have smaller LFDs although they have a large visual difference from their GT counterparts. This drawback indicates that the LFD-based evaluation metrics for 3D shape generative networks are not sufficient to measure the visual and geometry quality of generated shapes.\n\n![Refer to caption]Figure 3: Illustration of the drawback of LFD. The number above the shape is the LFD between the shape and its GT counterpart.\n\nShading-image-based FID  To resolve the drawback of using LFD and take human perception into consideration, we propose to adapt Fréchet inception distance (FID) \\[ [HRU∗17])\\] on the shading images of 3D shapes, as the visual quality of 3D shapes for humans is mostly perceived from rendered view images. We name this metric by shading-image-based FID. We normalize the surface mesh into a unit sphere and render shading images from 20 uniformly distributed views, here the view selection is the same as the LFD algorithm \\[ [CTSO03])\\] (see the illustration in [Fig.4]In 4.1 Evaluation metrics ‣ 4 Experiments and Evaluation ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\")). For the generated data set and the training set, we compute the Fréchet inception distance (FID) score based on their i𝑖i-th view images, and average 20 FID scores to define the shading-image-based FID:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | F​I​D=120​\\[∑i=120‖μgi−μri‖2+Tr⁡(Σgi+Σri−2​(Σri​Σgi)1/2)\\],𝐹𝐼𝐷120delimited-\\[\\]superscriptsubscript𝑖120superscriptnormsuperscriptsubscript𝜇𝑔𝑖superscriptsubscript𝜇𝑟𝑖2TrsuperscriptsubscriptΣ𝑔𝑖superscriptsubscriptΣ𝑟𝑖2superscriptsuperscriptsubscriptΣ𝑟𝑖superscriptsubscriptΣ𝑔𝑖12FID=\\\\frac{1}{20}\\\\left\\[\\\\sum\\_{i=1}^{20}\\\\\\|\\\\mu\\_{g}^{i}-\\\\mu\\_{r}^{i}\\\\\\|^{2}+\\\\operatorname{Tr}\\\\left(\\\\Sigma\\_{g}^{i}+\\\\Sigma\\_{r}^{i}-2\\\\left(\\\\Sigma\\_{r}^{i}\\\\Sigma\\_{g}^{i}\\\\right)^{1/2}\\\\right)\\\\right\\], |  | (7) |\n\nwhere g𝑔g and r𝑟r denote the features of the generated data set and the training set, μ⋅isuperscriptsubscript𝜇⋅𝑖\\\\mu\\_{\\\\cdot}^{i}, Σ⋅isuperscriptsubscriptΣ⋅𝑖\\\\Sigma\\_{\\\\cdot}^{i} denote the mean and the covariance matrix of the corresponding shading images rendered from the i𝑖i-th view.\n\n![Refer to caption]Figure 4: Left: configuration of rendering views. 20 camera positions are illustrated as red points. Right: 20 rendered images for computing FID, the image resolution is 299×299299299299\\\\times 299.\n\nHere, although the rendered images of 3D shapes are different from natural images in ImageNet \\[ [DDS∗09])\\] trained for Inception-V3 \\[ [SVI∗16])\\], we found that the shading-image-based FID is meaningful, and the generated data set with a smaller FID has more plausible and visually similar shapes to the training set.\n\nFPD \\[ [SPK19])\\]  We also adapt Fréchet point cloud distance (FPD) proposed by \\[ [SPK19])\\] for evaluation. For any shape in Sgsubscript𝑆𝑔S\\_{g} or Srsubscript𝑆𝑟S\\_{r}, we sample 2048 points on the mesh surface and pass them to a DGCNN backbone network \\[ [WSL∗19]), [LLHF21])\\] pre-trained with the shape classification task. The output feature vectors of Sgsubscript𝑆𝑔S\\_{g} and Srsubscript𝑆𝑟S\\_{r} are used to compute FPD. Small FPD values are better.\n\nEvaluation setup  For computing COV and MMD, we follow the setting of \\[ [CZ19])\\]: Srsubscript𝑆𝑟S\\_{r} is formed by the original ShapeNet meshes in the test dataset, 5​\\|Sr\\|5subscript𝑆𝑟5\\|S\\_{r}\\| shapes are generated as Sgsubscript𝑆𝑔S\\_{g}. For computing 1-NNA and ECD, Srsubscript𝑆𝑟S\\_{r} is not changed and \\|Sr\\|subscript𝑆𝑟\\|S\\_{r}\\| shapes are sub-sampled from Sgsubscript𝑆𝑔S\\_{g} as Sg′superscriptsubscript𝑆𝑔′S\\_{g}^{\\\\prime}. 1-NNA and ECD are evaluated 10 times between Sg′superscriptsubscript𝑆𝑔′S\\_{g}^{\\\\prime} and Srsubscript𝑆𝑟S\\_{r}, and their average numbers are reported. We note that taking the training set as Srsubscript𝑆𝑟S\\_{r} is more reasonable to evaluate the capability of GANs since the distribution of the test set could be very different with the training set and the number of shapes in the test set is usually small. However, here we still follow the setup of the original papers for consistency.\n\nFor computing shading-image-based FID and FPD, Srsubscript𝑆𝑟S\\_{r} is formed by the meshes in the training set and \\|Sr\\|subscript𝑆𝑟\\|S\\_{r}\\| shapes are generated as Sgsubscript𝑆𝑔S\\_{g}. We employ the clean-fid algorithm \\[ [PZZ21])\\] to calculate FID. The default iso-values of the competitive methods are employed to extract surface meshes by the Marching Cube algorithm \\[ [LC87])\\] on the 1283superscript1283128^{3} grids.\n\nTable 1: Quantitative evaluation of different methods. COV, MMD, 1-NNA and ECD use Light-field-distance and their reference set Srsubscript𝑆𝑟S\\_{r} is the test set of shape categories. FID is the abbreviation of shading-image-based FID.\n\n| Data | Method | COV(%) ↑↑\\\\uparrow | MMD ↓↓\\\\downarrow | 1-NNA↓↓\\\\downarrow | ECD↓↓\\\\downarrow | FID↓↓\\\\downarrow | FPD↓↓\\\\downarrow |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| Chair | IMGAN | 72.57 | 3326 | 0.7042 | 1998 | 63.42 | 1.093 |\n| Implicit-Grid | 82.23 | 3447 | 0.6655 | 1231 | 119.5 | 1.456 |\n| ShapeGAN | 65.19 | 3726 | 0.7896 | 4171 | 126.7 | 1.177 |\n| SDF-StyleGAN | 75.07 | 3465 | 0.6690 | 1394 | 36.48 | 1.040 |\n| Airplane | IMGAN | 76.89 | 4557 | 0.7932 | 2222 | 74.57 | 1.207 |\n| Implicit-Grid | 81.71 | 5504 | 0.8509 | 4254 | 145.4 | 2.341 |\n| ShapeGAN | 60.94 | 5306 | 0.8807 | 6769 | 162.4 | 2.235 |\n| SDF-StyleGAN | 74.17 | 4989 | 0.8430 | 3438 | 65.77 | 0.942 |\n| Car | IMGAN | 54.13 | 2543 | 0.8970 | 12675 | 141.2 | 1.391 |\n| Implicit-Grid | 75.13 | 2549 | 0.8637 | 8670 | 209.3 | 1.416 |\n| ShapeGAN | 57.40 | 2625 | 0.9168 | 14400 | 225.2 | 0.787 |\n| SDF-StyleGAN | 73.60 | 2517 | 0.8438 | 6653 | 97.99 | 0.767 |\n| Table | IMGAN | 83.43 | 3012 | 0.6236 | 907 | 51.70 | 1.022 |\n| Implicit-Grid | 85.66 | 3082 | 0.6318 | 1089 | 87.69 | 1.516 |\n| ShapeGAN | 76.26 | 3236 | 0.7069 | 1913 | 103.1 | 0.934 |\n| SDF-StyleGAN | 69.80 | 3119 | 0.6692 | 1729 | 39.03 | 1.061 |\n| Rifle | IMGAN | 71.16 | 5834 | 0.6911 | 701 | 103.3 | 2.102 |\n| Implicit-Grid | 77.89 | 5921 | 0.6648 | 357 | 125.4 | 1.904 |\n| ShapeGAN | 46.74 | 6450 | 0.8446 | 3115 | 182.3 | 1.249 |\n| SDF-StyleGAN | 80.63 | 6091 | 0.7180 | 510 | 64.86 | 0.978 |\n\n### 4.2 Quantitative and qualitative evaluation\n\nQuantitative evaluation  We evaluate SDF-StyleGAN, IMGAN, ShapeGAN and Implicit-Grid by using the metrics listed in [Section4.1]Evaluation metrics ‣ 4 Experiments and Evaluation ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\"). Quantitative results are provided in [Table1]In 4.1 Evaluation metrics ‣ 4 Experiments and Evaluation ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\"). LFD-based COV and MMD are listed for reference only as mentioned above. In the categories of airplane and table, IMGAN has better 1-NNA and ECD values. In the categories of chair and rifle, Implicit-Grid has better performance in 1-NNA and ECD. Our SDF-StyleGAN achieves the smallest 1-NNA and ECD in car shapes. However, the 1-NNA and ECD metrics do not faithfully reflect how the distribution of the generated set is similar to that of the training set, as the reference set is the test set. In terms of FID and FPD that use the training set as the reference set, our SDF-StyleGAN is significantly better than other methods, while IMGAN is the second best.\n\n![Refer to caption]Figure 5: Visual comparison of randomly generated chairs by different methods. The shapes in the last row are randomly sampled from the training dataset.![Refer to caption]Figure 6: Visual comparison of randomly generated shapes by different methods on airplane, car, table and rifle. The shapes in the last row are randomly sampled from the dataset.\n\nQualitative evaluation  The superiority of SDF-StyleGAN in terms of FID and FPD metrics can be perceived directly through visual comparison. In [Fig.5]In 4.2 Quantitative and qualitative evaluation ‣ 4 Experiments and Evaluation ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\"), a set of chairs generated by each method is illustrated for comparison. For IMGAN, their chairs have plausible structures, but with bumpy geometry, probably because IMGAN learned the voxelization artifacts in constructing the occupancy field for the training data. For Implicit-Grid, its results contain many missing regions and are also bumpy. The visual quality of its results is the worst, although it has the best 1-NNA and ECD values among all methods. The ShapeGAN results do not have voxelization-like bump geometry, but the shapes are distorted compared to the training data. Our SDF-StyleGAN generates more geometry plausible chair: the seats are flat, the local geometry is smooth, and the overall structure is more complete. This significant improvement in geometry and visual quality by our method is correctly reflected by the FID values in [Table1]In 4.1 Evaluation metrics ‣ 4 Experiments and Evaluation ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\"). In [Fig.6]In 4.2 Quantitative and qualitative evaluation ‣ 4 Experiments and Evaluation ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\"), we also show the generated shapes in other shape categories, and a similar conclusion remains. In our supplemental material, we provide more randomly generated results (240 shapes for each category) without any cherry picking. These results further validate the capability and superiority of our method.\n\n### 4.3 Ablation studies\n\nWe conducted a series of ablation studies to validate our framework design, using the chair category from the ShapeNet dataset.\n\nEfficacy of local discriminator and SDF gradients  Five alternative configurations on using the global discriminator 𝒟Gsubscript𝒟𝐺\\\\mathcal{D}\\_{G} and the local discriminator 𝒟Lsubscript𝒟𝐿\\\\mathcal{D}\\_{L} were tested:\n\n1. (1)\n\n\nuse 𝒟Gsubscript𝒟𝐺\\\\mathcal{D}\\_{G} only, and use the SDF values as input;\n\n2. (2)\n\n\nuse 𝒟Gsubscript𝒟𝐺\\\\mathcal{D}\\_{G} only, and use both SDF values and gradients as input;\n\n3. (3)\n\n\nadd 𝒟Lsubscript𝒟𝐿\\\\mathcal{D}\\_{L} to [(2)]Item (2) ‣ 4.3 Ablation studies ‣ 4 Experiments and Evaluation ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\"), and use SDF values as input to 𝒟Lsubscript𝒟𝐿\\\\mathcal{D}\\_{L};\n\n4. (4)\n\n\nadd 𝒟Lsubscript𝒟𝐿\\\\mathcal{D}\\_{L} to [(2)]Item (2) ‣ 4.3 Ablation studies ‣ 4 Experiments and Evaluation ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\"), and use SDF gradients as input to 𝒟Lsubscript𝒟𝐿\\\\mathcal{D}\\_{L};\n\n5. (5)\n\n\nour default configuration that uses both 𝒟Gsubscript𝒟𝐺\\\\mathcal{D}\\_{G} and 𝒟Lsubscript𝒟𝐿\\\\mathcal{D}\\_{L} and feeds both SDF and SDF gradients to 𝒟Gsubscript𝒟𝐺\\\\mathcal{D}\\_{G} and 𝒟Lsubscript𝒟𝐿\\\\mathcal{D}\\_{L}.\n\n\n[Table2]In 4.3 Ablation studies ‣ 4 Experiments and Evaluation ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\") shows the evaluation metrics of SDF-StyleGAN trained with these configurations. By comparing [(3)]Item (3) ‣ 4.3 Ablation studies ‣ 4 Experiments and Evaluation ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\"), [(4)]Item (4) ‣ 4.3 Ablation studies ‣ 4 Experiments and Evaluation ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\") and [(5)]Item (5) ‣ 4.3 Ablation studies ‣ 4 Experiments and Evaluation ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\") with [(1)]Item (1) ‣ 4.3 Ablation studies ‣ 4 Experiments and Evaluation ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\") and [(2)]Item (2) ‣ 4.3 Ablation studies ‣ 4 Experiments and Evaluation ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\"), we can see that the addition of 𝒟Lsubscript𝒟𝐿\\\\mathcal{D}\\_{L} increases the performance significantly; by comparing [(2)]Item (2) ‣ 4.3 Ablation studies ‣ 4 Experiments and Evaluation ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\") with [(1)]Item (1) ‣ 4.3 Ablation studies ‣ 4 Experiments and Evaluation ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\"), and [(4)]Item (4) ‣ 4.3 Ablation studies ‣ 4 Experiments and Evaluation ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\") with [(3)]Item (3) ‣ 4.3 Ablation studies ‣ 4 Experiments and Evaluation ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\"), we can find that the use of SDF gradients increases performance by a large margin. In [Fig.7]In 4.3 Ablation studies ‣ 4 Experiments and Evaluation ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\"), we visualize some shapes generated by the networks corresponding to these five configurations. We can clearly see that networks with the local discriminator produce more smooth and regular shapes, and the use of SDF gradients effectively reduces geometry distortion.\n\nTable 2: Ablation study on the use of local discriminator and SDF gradients. G𝐺G and L𝐿L denotes the global discriminator and the local discriminator, respectively. 00 and 111 denotes the use of SDF values and the use of SDF gradients, respectively. The combinations of G,L𝐺𝐿G,L and 0,1010,1 form the five configurations.\n\n| Config. | G0 | G1 | L0 | L1 | 1-NNA↓↓\\\\downarrow | ECD↓↓\\\\downarrow | FID↓↓\\\\downarrow | FPD↓↓\\\\downarrow |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| [(1)]Item (1) ‣ 4.3 Ablation studies ‣ 4 Experiments and Evaluation ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\") | ✓ |  |  |  | 0.8339 | 6280 | 173.3 | 1.335 |\n| [(2)]Item (2) ‣ 4.3 Ablation studies ‣ 4 Experiments and Evaluation ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\") | ✓ | ✓ |  |  | 0.7642 | 3387 | 85.46 | 1.198 |\n| [(3)]Item (3) ‣ 4.3 Ablation studies ‣ 4 Experiments and Evaluation ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\") | ✓ | ✓ | ✓ |  | 0.7124 | 2436 | 92.35 | 1.111 |\n| [(4)]Item (4) ‣ 4.3 Ablation studies ‣ 4 Experiments and Evaluation ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\") | ✓ | ✓ |  | ✓ | 0.6708 | 1541 | 39.17 | 1.123 |\n| [(5)]Item (5) ‣ 4.3 Ablation studies ‣ 4 Experiments and Evaluation ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\") | ✓ | ✓ | ✓ | ✓ | 0.6690 | 1394 | 36.48 | 1.040 |\n\nCandidate local region number N0subscript𝑁0N\\_{0}  Local region selection is important to our training. A smaller N0subscript𝑁0N\\_{0} does not help to distribute the selected local regions more evenly, while a much larger N0subscript𝑁0N\\_{0} cannot ensure that the selected local regions are around the zero isosurface. We tested three choices of N0subscript𝑁0N\\_{0}: 512, 2048, 8912, and found that the default value 204820482048 can lead to better performance, as shown in [Table3]In 4.3 Ablation studies ‣ 4 Experiments and Evaluation ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\").\n\nTable 3: Ablation study on the number of candidate local regions.\n\n| N0subscript𝑁0N\\_{0} | 1-NNA↓↓\\\\downarrow | ECD↓↓\\\\downarrow | FID↓↓\\\\downarrow | FPD↓↓\\\\downarrow |\n| --- | --- | --- | --- | --- |\n| 512 | 0.8875 | 4249 | 85.90 | 2.597 |\n| 2048 | 0.6690 | 1394 | 36.48 | 1.040 |\n| 8192 | 0.6881 | 1870 | 45.37 | 1.108 |\n\n\\\\begin{overpic}\\[width=411.93767pt\\]{images/ablation.pdf}\n\\\\put(7.0,0.0){\\\\ref{item:ablation\\_1}}\n\\\\put(28.0,0.0){\\\\ref{item:ablation\\_2}}\n\\\\put(49.5,0.0){\\\\ref{item:ablation\\_3}}\n\\\\put(71.0,0.0){\\\\ref{item:ablation\\_4}}\n\\\\put(92.5,0.0){\\\\ref{item:ablation\\_5}}\n\\\\end{overpic}Figure 7: Visual illustration of the generated shapes by SDF-StyleGAN trained with different configurations listed in [Table2]In 4.3 Ablation studies ‣ 4 Experiments and Evaluation ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\"). In the first row we intentionally pick a four-leg chair from each configuration for visual comparison. The shapes in the other rows are randomly selected.\n\nFeature-volume-based implicit SDF  Our method benefits from feature-volume-based implicit SDF. We did an ablation study by replacing it with discrete SDFs, _i.e_. , letting the generator directly output an N×N×N𝑁𝑁𝑁N\\\\times N\\\\times N SDF grid. We use the global discriminator only for this test. We tested two kinds of resolutions: N=32𝑁32N=32 and N=64𝑁64N=64, and we also tested whether the additional SDF gradient input can help improve these networks. [Table4]In 4.3 Ablation studies ‣ 4 Experiments and Evaluation ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\") shows the performance of these alternative networks, where the mesh extraction by the Marching Cube algorithm uses the same resolution of the SDF grid. We found that the use of SDF gradients can significantly improve the performance of these alternate networks, but there is still a large performance gap between them and our default design. [Fig.8]In 4.3 Ablation studies ‣ 4 Experiments and Evaluation ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\") illustrates the shapes generated by these alternative networks.\n\nTable 4: Performance of an alternative network design that generates discrete SDF grids directly.\n\n| resolution | SDF gradient | FID↓↓\\\\downarrow | FPD↓↓\\\\downarrow |\n| --- | --- | --- | --- |\n| 323superscript32332^{3} | ✗ | 156.0 | 2.097 |\n| 323superscript32332^{3} | ✓ | 104.6 | 1.532 |\n| 643superscript64364^{3} | ✗ | 154.2 | 1.323 |\n| 643superscript64364^{3} | ✓ | 80.26 | 1.792 |\n\n\\\\begin{overpic}\\[width=346.89731pt\\]{images/nomlp.pdf}\n\\\\put(7.0,0.0){\\\\tiny$N=32$}\n\\\\put(27.0,0.0){\\\\tiny$N=32$ / with grad.}\n\\\\put(59.0,0.0){\\\\tiny$N=64$}\n\\\\put(81.0,0.0){\\\\tiny$N=64$ / with grad.}\n\\\\end{overpic}Figure 8: Illustration of the randomly generated shapes by the alternative design of SDF-StyleGAN that generates discrete SDF grids directly. \"with grad.\" means the SDF gradients also be fed into the discriminator.",
            "citations": null
          },
          "5 Applications": {
            "content": "Based on the GAN inversion technique, we employed the trained SDF-StyleGAN generator for a series of applications.\n\n3D GAN inversion\nThe goal of 3D GAN inversion is to embed a shape into the latent space of GAN. To this end, we first use an encoder network ℰφsubscriptℰ𝜑\\\\mathcal{E}\\_{\\\\varphi} to encode the input sample 𝒙𝒙\\\\bm{x} to a latent code 𝒛∈𝒵𝒛𝒵\\\\bm{z}\\\\in\\\\mathcal{Z} or 𝒘∈𝒲𝒘𝒲\\\\bm{w}\\\\in\\\\mathcal{W}, then feed the resulting code to our trained SDF-StyleGAN model ℱϑsubscriptℱitalic-ϑ\\\\mathcal{F}\\_{\\\\vartheta}, and optimize the parameters φ𝜑\\\\varphi with the following loss function:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | ℒφ=1\\|𝒱\\|​∑𝒑∈𝒱\\|ℱϑ​(ℰφ​(𝒙);𝒑)−SDFg​t​(𝒑)\\|,subscriptℒ𝜑1𝒱subscript𝒑𝒱subscriptℱitalic-ϑsubscriptℰ𝜑𝒙𝒑subscriptSDF𝑔𝑡𝒑\\\\mathcal{L\\_{\\\\varphi}}=\\\\frac{1}{\\|\\\\mathcal{V}\\|}\\\\sum\\_{\\\\bm{p}\\\\in\\\\mathcal{V}}\\\\left\\|\\\\mathcal{F}\\_{\\\\vartheta}\\\\left(\\\\mathcal{E}\\_{\\\\varphi}\\\\left(\\\\bm{x}\\\\right);\\\\bm{p}\\\\right)-\\\\texttt{SDF}\\_{gt}\\\\left(\\\\bm{p}\\\\right)\\\\right\\|, |  | (8) |\n\nwhere 𝒱𝒱\\\\mathcal{V} is a set of points sampled inside a volumetric space that contains 𝒙𝒙\\\\bm{x}, SDFg​tsubscriptSDF𝑔𝑡\\\\texttt{SDF}\\_{gt} queries the ground-truth SDF values of any point with respect to 𝒙𝒙\\\\bm{x}, and ℱϑ​(𝒚;𝒑)subscriptℱitalic-ϑ𝒚𝒑\\\\mathcal{F}\\_{\\\\vartheta}\\\\left(\\\\bm{y};\\\\bm{p}\\\\right) returns the predicted SDF value at point 𝒑𝒑\\\\bm{p} for a given latent code 𝒚𝒚\\\\bm{y}.\nAfter training, we can directly map 𝒙𝒙\\\\bm{x} to a latent code 𝒚𝒚\\\\bm{y} via network forwarding.\nThe choice of encoders is flexible and depends on the input type of 𝒙𝒙\\\\bm{x}.\n\nShape reconstruction from point clouds\nWe use SDF-StyleGAN to reconstruct category-wise shapes from point clouds. We first train the encoder of 3D GAN inversion on a shape category. We choose a light version of octree-based CNN \\[ [WLG∗17])\\], which is composed of 3 sparse convolution layers and 2 fully connected layers. We optimize φ𝜑\\\\varphi with an AdamW optimizer \\[ [LH19])\\] for 200 epochs on a shape collection while keeping ϑitalic-ϑ\\\\vartheta fixed.\nWe use the 3D GAN inversion to map an input point cloud to an SDF-StyleGAN latent code via the trained encoder.\nThe latent code can be further optimized by minimizing the following loss function which forces the SDF values at 𝒑𝒑\\\\bm{p} to be zero:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | ℒ𝔂=1\\|𝒫\\|∑𝒑∈𝒫\\|ℱϑ(𝒚;𝒑))\\|,\\\\mathcal{L\\_{\\\\bm{y}}}=\\\\frac{1}{\\|\\\\mathcal{P}\\|}\\\\sum\\_{\\\\bm{p}\\\\in\\\\mathcal{P}}\\\\left\\|\\\\mathcal{F}\\_{\\\\vartheta}\\\\left(\\\\bm{y};\\\\bm{p}\\\\right))\\\\right\\|, |  | (9) |\n\nwhere 𝒫𝒫\\\\mathcal{P} is a set of points sampled on the surface of 𝒙𝒙\\\\bm{x}.\nIn our experiment, we optimize the code obtained from the encoder with 1000 iterations for each input point cloud 𝒙𝒙\\\\bm{x}.\n\n[Fig.9]In 5 Applications ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\") shows some reconstructed shapes using our method, as well as other state-of-the-art methods designed for surface reconstruction, including Screen Poisson reconstruction (SPR) \\[ [KH13])\\], and three learning-based methods: ConvOcc \\[ [PNM∗20])\\], DeepMLS \\[ [LGP∗21])\\], and DualOGNN \\[ [WLT22])\\]). Each input noisy point cloud contains 3000 points, where the noisy level is the same as the noisy data used in ConvOcc, DeepMLS and DualOGNN. As our latent code is constrained by the SDF-StyleGAN space, the geometry of the reconstructed shapes respects the data distribution of the training set of SDF-StyleGAN. We can find that our approach is robust to noise, but has limitations in fitting unusual shape details, such as the bumpy surface of the backrest ( [Fig.9]In 5 Applications ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\")-(d)), the additional backrest ( [Fig.9]In 5 Applications ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\")-(e)), and the cabin of the fighter plane ( [Fig.9]In 5 Applications ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\")-(f)).\n\n\\\\begin{overpic}\\[width=433.62pt\\]{images/reconstruction\\_comparison.pdf}\n\\\\put(12.5,0.0){(a)}\n\\\\put(23.5,0.0){(b)}\n\\\\put(36.5,0.0){(c)}\n\\\\put(48.5,0.0){(d)}\n\\\\put(61.0,0.0){(e)}\n\\\\put(73.0,0.0){(f)}\n\\\\end{overpic}Figure 9: Shape reconstruction. Inversion and Recons. denote the reconstructed shapes via our GAN inversion and our reconstruction, respectively. The shapes in GT row are the ground-truth shapes. Here the point normals requested by SPR \\[ [KH13])\\] are estimated from 10 nearest points.\n\nShape completion\nIt is easy to adapt the 3D GAN inversion for the shape completion task.\nIn this experiment, we randomly drop 75% of the input point cloud 𝒙𝒙\\\\bm{x} to train the encoder while keeping the loss functions unchanged. The trained encoder maps the incomplete input to a latent code that always corresponds to a plausible shape due to the GAN training. We can further optimize the latent code via minimizing [Eq.9]In 5 Applications ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\"). In [Fig.10]In 5 Applications ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\"), we test our method on the categories of chairs and airplanes and compare it with a state-of-the-art point completion cloud approach PoinTr \\[ [YRW∗21])\\], which is based on a transformer architecture. We can see that within the shape space constrained by SDF-StyleGAN, our method has a better ability to reconstruct plausible shapes, even from a partial chair back (see [Fig.10]In 5 Applications ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\")-(a)). However, similar to the behavior on shape reconstruction, our method has worse capability in fitting fine details, such as the round joint of chair legs (see [Fig.10]In 5 Applications ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\")-(c)) and the wingtip of the airplane (see [Fig.10]In 5 Applications ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\")-(f)); while PoinTr keeps the original points to maintain the input geometry.\n\n\\\\begin{overpic}\\[width=433.62pt\\]{images/completion.pdf}\n\\\\put(15.0,0.0){(a)}\n\\\\put(29.0,0.0){(b)}\n\\\\put(43.0,0.0){(c)}\n\\\\put(58.0,0.0){(d)}\n\\\\put(74.5,0.0){(e)}\n\\\\put(91.0,0.0){(f)}\n\\\\end{overpic}Figure 10: Shape completion. The shapes in GT row are the ground-truth shapes of the input point clouds. Our method can recover plausible shapes from incomplete inputs.\n\nShape generation from single images  It is also easy to adapt the GAN inversion to predict a 3D shape from a single image input. In this experiment, the input sample 𝒙𝒙\\\\bm{x} is an image, and we use a ResNet-18 network \\[ [HZRS16])\\] to encode the input. We trained the encoder network on the airplane category, where the low-resolution training images are from\n\\[ [CXG∗16])\\]. [Fig.11]In 5 Applications ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\") shows some results generated by our method, as well as some state-of-the-art methods including IMSVR \\[ [CZ19])\\], Pixel2Mesh \\[ [WZL∗18])\\], Occ-Net \\[ [MON∗19])\\]. Our method is able to predict plausible shapes from low-resolution images. The result in the last row shows a failure case that our method does not generate the airplane engine, as the encoder does not map the input to a good latent code.\n\n![Refer to caption]Figure 11: Shape generation from single images. The shapes in GT column are the ground-truth shapes.\n\nShape style editing\nTo edit the attributes of facial images via GAN model, Shen _et al_.  \\[ [SYTZ20])\\] assumed that for any binary semantics, there may exist a hyperplane in the latent space serving as the separation boundary. This hyperplane in the latent space can be used for editing the image style. We adapted their approach to our SDF-StyleGAN space for 3D shape style editing. We use the shape labels provided in  \\[ [MKC18])\\] to divide the chair category into two groups: chairs with and without arms. A DGCNN network \\[ [WSL∗19])\\] was trained to infer whether an input chair contains arms or not. We then randomly generated 10000 chairs using SDF-StyleGAN and divided them into two groups using the trained classification network. As the latent codes of these generate shapes are known, the hyperplane 𝒏⋅𝒙+d=0⋅𝒏𝒙𝑑0\\\\bm{n}\\\\cdot\\\\bm{x}+d=0 that separates these two groups can easily be computed. For any generated shape or a shape obtained by GAN inversion, we can change its latent code 𝒚𝒚\\\\bm{y} to 𝒚−η​(𝒏⋅𝒚+d)​𝒏𝒚𝜂⋅𝒏𝒚𝑑𝒏\\\\bm{y}-\\\\eta(\\\\bm{n}\\\\cdot\\\\bm{y}+d)\\\\bm{n}, η≥0𝜂0\\\\eta\\\\geq 0, to modify the shape style from “without arms” to “with arms”, or vice versa. Similarly on the car category, we use the label “with roof” and “without roof” to find the separation plane and edit the shape style. In [Fig.12]In 5 Applications ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\"), we demonstrate this kind of shape style editing, and we find that the original geometry of the input shapes is also well-preserved.\n\n![Refer to caption]Figure 12: Shape style editing based on the algorithm of \\[ [SYTZ20])\\]. The style editing on chairs is to add arms, and the style editing on cars is to add car roofs.\n\nShape interpolation  A straightforward application is to perform shape interpolation in the 𝒵𝒵\\\\mathcal{Z} space, or the 𝒲𝒲\\\\mathcal{W} space. [Fig.13]In 5 Applications ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\") shows the intermediate results of the interpolation between two chairs, in the 𝒵𝒵\\\\mathcal{Z} space. Due to the use of GAN model, each intermediate result is plausible, and the transition of shape geometry between adjacent frames is also smooth.\n\n![Refer to caption]Figure 13: An example of shape interpolation in the 𝒵𝒵\\\\mathcal{Z} space.",
            "citations": null
          },
          "6 Conclusion": {
            "content": "In the presented work, we offer a high-quality 3D generative model — SDF-StyleGAN for shape generation, which is capable of producing diverse and visually plausible 3D models superior to the state-of-the-art. These significant improvements are ascribed to the design of our global and local SDF discriminators, the choice of implicit SDF representation, the use of SDF gradients, and the StyleGAN2 network structure. We evaluated the learned generative model using suitable 3D GAN metrics, including our proposed FID on rendered images, and demonstrated the capability of SDF-StyleGAN on a series of applications.\n\n\\\\begin{overpic}\\[width=433.62pt\\]{images/failure\\_case.pdf}\n\\\\end{overpic}Figure 14: Incomplete shapes generated by our method. The thin structures are not captured by the zero isosurfaces.\n\nLimitations  A few limitations exist in our work. As there is no explicit shape part structure utilized in our framework design, we notice that a small portion of the generated shapes is not complete: tiny and thin parts could be missing, as shown in [Fig.14]In 6 Conclusion ‣ SDF-StyleGAN: Implicit SDF-Based StyleGAN for 3D Shape Generation\"). Increasing the iso-value in extracting mesh surfaces can mitigate this issue, but there is no guarantee. We also found that complex geometry patterns such as various supporting beam layouts of chair backs, are not learned by our network, possibly due to unbalanced data distribution.\n\nFuture work\nSome research directions are left for future exploration.\nFirst, using truncated SDF would help leverage higher resolution ground-truth SDF during training to improve shape quality while reducing memory footprint and computational time. Second, our preliminary test on style mixing \\[ [KLA19])\\] reveals that there is some relation between the styles learned from the network and the semantic structures of the shapes, but it is still difficult to make a semantically meaningful disentanglement. Furthermore, it would be very useful to extend our model to 3D scene generation.",
            "citations": null
          }
        },
        "abstract": "We present a StyleGAN2-based deep learning approach for 3D shape generation,\ncalled SDF-StyleGAN, with the aim of reducing visual and geometric\ndissimilarity between generated shapes and a shape collection. We extend\nStyleGAN2 to 3D generation and utilize the implicit signed distance function\n(SDF) as the 3D shape representation, and introduce two novel global and local\nshape discriminators that distinguish real and fake SDF values and gradients to\nsignificantly improve shape geometry and visual quality. We further complement\nthe evaluation metrics of 3D generative models with the shading-image-based\nFr\\'echet inception distance (FID) scores to better assess visual quality and\nshape distribution of the generated shapes. Experiments on shape generation\ndemonstrate the superior performance of SDF-StyleGAN over the state-of-the-art.\nWe further demonstrate the efficacy of SDF-StyleGAN in various tasks based on\nGAN inversion, including shape reconstruction, shape completion from partial\npoint clouds, single-view image-based shape generation, and shape style\nediting. Extensive ablation studies justify the efficacy of our framework\ndesign. Our code and trained models are available at\nhttps://github.com/Zhengxinyang/SDF-StyleGAN."
      },
      "bib.bib120": {
        "id": "bib.bib120",
        "citation": "[120]",
        "authors": "",
        "year": "",
        "title": "3d shape generation and completion through point-voxel diffusion.",
        "venue": "",
        "pages": "",
        "url": "https://arxiv.org/abs/2104.03670",
        "arxiv_id": "2104.03670",
        "doi": null,
        "sections": {
          "1 Introduction": {
            "content": "Generative modeling of 3D shapes has extensive applications across vision, graphics, and robotics. To perform well in these downstream applications, a good 3D generative models should be _faithful_ and _probabilistic_. A faithful model generates shapes that are realistic to humans and, in cases where conditional inputs such as depth maps are available, respects such partial observations. A probabilistic model captures the under-determined, multi-modal nature of the generation and completion problem: it may sample and produce diverse shapes from scratch or from partial observations. As shown in Figure 3D Shape Generation and Completion through Point-Voxel Diffusion, when only the back of a chair is visible, good generative models should be able to produce multiple possible completed chairs, including those with arms and those without.\n\nExisting shape generation models can be roughly divided into two categories. The first operates on 3D voxels \\[ [43]), [14]), [45]), [2])\\], a natural extension of 2D pixels. While being straightforward to use, voxels demand prohibitively large memory when scaled to high dimensions, and are thus unlikely to produce results with high fidelity. The second class of models studies point cloud generation \\[ [1]), [11]), [48]), [46]), [16]), [17])\\] and has produced promising results. While being more faithful, these approaches typically view point cloud generation as a point generation process conditioned on shape encoding, which is obtained by deterministic encoders. When performing shape completion, these approaches are therefore unable to capture the multi-modal nature of the completion problem.\n\nRecently, a new class of generative models, named probabilistic diffusion models, have achieved impressive performance on 2D image generation \\[ [35]), [13]), [36])\\]. These approaches learn a probabilistic model over a denoising process. Diffusion is supervised to gradually denoise a Gaussian noise to a target output, such as an image. Methods along this line, such as DDPM \\[ [13])\\], are inherently probabilistic and produce highly realistic 2D images.\n\nExtending diffusion models to 3D is, however, technically highly nontrivial: a direct application of diffusion models on either voxel and point representation results in poor generation quality. This is because, first, pure voxels are binary and therefore not suitable for the probabilistic nature of diffusion models; second, point clouds demand permutation-invariance, which imposes infeasible constraints on the model. Experiments in Section [4.1]Shape Generation ‣ 4 Experiments ‣ 3D Shape Generation and Completion through Point-Voxel Diffusion\") also verifies that a straightforward extension does not lead to reasonable results.\n\nWe propose Point-Voxel Diffusion (PVD), a probabilistic and flexible shape generation model that tackles the above challenges by marrying denoising diffusion models with the hybrid, point-voxel representation of 3D shapes \\[ [24])\\]. A point-voxel representation builds structured locality into point cloud processing; integrated with denoising diffusion models, PVD suggests a novel, probabilistic way to generate high-quality shapes by denoising a Gaussian noise and to produce multiple completion results from a partial observation, as shown in Figure 3D Shape Generation and Completion through Point-Voxel Diffusion.\n\nA unique strength of PVD is that it is a unified, probabilistic formulation for unconditional shape generation and conditional, multi-modal shape completion. While multi-modal shape completion is a highly desirable feature in applications such as digital design or robotics, past works on shape generation primarily use deterministic shape encoders and decoders to output a single possible completion in voxels or a point cloud. In contrast, PVD can perform both unconditional shape generation and conditional shape completion in an integrated framework, requiring only minimal modifications to the training objective. It is thus capable of sampling multiple completion results depending on diffusion initialization.\n\nExperiments demonstrate that PVD is capable of synthesizing high-fidelity shapes, outperforming multiple state-of-the-art methods. PVD also delivers high-quality results on multi-modal shape completion from partial observations such as a partial point cloud or a depth map. In particular, we show that PVD does well on multi-modal completion on multiple synthetic and real datasets, including ShapeNet \\[ [4])\\], PartNet \\[ [27])\\], and single-view depth scans of real objects in the Redwood dataset \\[ [5])\\].",
            "citations": null
          },
          "2 Related Works": {
            "content": "#### Point cloud generative models.\n\nMany prior works have explored point cloud generation in terms of auto-encoding \\[ [1]), [11]), [47])\\], single-view reconstruction \\[ [12]), [10]), [18]), [17])\\], and adversarial generation \\[ [34]), [48]), [40])\\]. Many of them rely on directly optimizing heuristic loss functions such as Chamfer Distance (CD) and Earth Mover’s Distance (EMD), which are also used to evaluate generative quality.\n\nSome recent works take a different approach, viewing the 3D point clouds in light of probabilistic distributions. For example, Sun _et al_.\\[ [37])\\] view the point clouds from a probabilistic perspective and introduce autoregressive generation, but doing so requires ordering of the point clouds. GAN-based models and flow-based models \\[ [21]), [1]), [46]), [16]), [17])\\] also adopt a probabilistic view but separate shape-level distribution from point-level distribution. Among these models, PointFlow applies normalizing flow \\[ [29])\\] to 3D point clouds, and Discrete PointFlow follows up using discrete normalizing flow with affine coupling layers \\[ [8])\\]. Shape Gradient Fields \\[ [3])\\], unlike flow-based works, directly learn a gradient field that samples point clouds using Langevin dynamics. Our model is different from these models in that we do not distinguish point and shape distributions, and that we directly generate entire shapes starting from random noise.\n\n#### Point-voxel representation.\n\n3D shapes were conventionally rasterized into voxel grids and processed using 3D convolution \\[ [6]), [42])\\]. Due to the correspondence between voxels and 2D pixels, many works have explored voxel-based classification and segmentation using volumetric convolution \\[ [26]), [31]), [19]), [39]), [42]), [7])\\]. Voxel-based generative models have similarly proven successful \\[ [43]), [14]), [45])\\]. However, voxel grids are memory-intensive and they grow cubically with increase in dimension, so they cannot be scaled to a high resolution.\n\nPoint clouds, on the other hand, are detailed samples from smooth surfaces and do not suffer from the grid effect of usually low-resolution voxels and do not require as much memory for processing. Researchers have explored point cloud classification and segmentation \\[ [30]), [30]), [41])\\] and most assume point cloud processing networks are permutation-invariant. Permutation-invariance is a strong condition to be imposed on the architecture and we empirically find that direct extension of 2D methods to either permutation-invariant point clouds or voxels do not work well. We therefore explore a separate point-voxel representation \\[ [22]), [33])\\], and our work is most related to point-voxel CNN \\[ [24])\\], which proposes to voxelize the point clouds for 3D convolution. We use it as the backbone of our generative model due to its exploitation of the strong spacial correlation inherent in point cloud data.\n\n#### Energy-based models and denoising diffusion models.\n\nEnergy-based models (EBMs) and denoising diffusion models are two classes of generative models that formulate generation as an iterative refinement procedure. Energy based models \\[ [20]), [9]), [28])\\] learn an energy landscape over input data, where local minima correspond to high-fidelity samples, which are obtained by Langevin dynamics \\[ [9]), [28])\\]. In contrast, denoising diffusion models \\[ [35]), [13]), [36])\\] learn a probabilistic model over a denoising process on inputs. Diffusion is supervised to gradually denoise a Gaussian noise to a target output. This form of supervision can be seen as supervision of the gradient of a log probability distribution \\[ [36])\\] as in score matching EBM \\[ [15]), [38])\\]. Our work builds on these related existing approaches and we explore the 3D domain, which is challenging and fundamentally different from 2D images. A concurrent work on point cloud diffusion model \\[ [25])\\] views point cloud generation as a conditional generation problem and uses an additional encoder for shape latents. Ours, however, adopts an unconditional approach, ridding the need for additional shape encoders, and uses a different hybrid, point-voxel representation for processing shapes. In addition to generating high-quality 3D shapes, we also show that our model can be modified with no architectural change to perform on conditional generation tasks such as shape completion. We also demonstrate its effectiveness on real-world scans.\n\n![Refer to caption]Figure 2: Visualization of the diffusion and generative process. To generate, Gaussian noise is sampled from p​(𝐱T)𝑝subscript𝐱𝑇p({\\\\bf x}\\_{T}) and noise is progressively removed by pθ​(𝐱t\\|𝐱t+1)subscript𝑝𝜃conditionalsubscript𝐱𝑡subscript𝐱𝑡1p\\_{\\\\theta}({\\\\bf x}\\_{t}\\|{\\\\bf x}\\_{t+1}). Symmetrically, the diffusion process gradually adds noise by q​(𝐱t+1\\|𝐱t)𝑞conditionalsubscript𝐱𝑡1subscript𝐱𝑡q({\\\\bf x}\\_{t+1}\\|{\\\\bf x}\\_{t}). We utilize a closed-form expression for each q​(𝐱t+1\\|𝐱t)𝑞conditionalsubscript𝐱𝑡1subscript𝐱𝑡q({\\\\bf x}\\_{t+1}\\|{\\\\bf x}\\_{t}), allowing pθ​(𝐱t\\|𝐱t+1)subscript𝑝𝜃conditionalsubscript𝐱𝑡subscript𝐱𝑡1p\\_{\\\\theta}({\\\\bf x}\\_{t}\\|{\\\\bf x}\\_{t+1}) to be learned by simply matching the posterior q​(𝐱t\\|𝐱t+1,𝐱0)𝑞conditionalsubscript𝐱𝑡subscript𝐱𝑡1subscript𝐱0q({\\\\bf x}\\_{t}\\|{\\\\bf x}\\_{t+1},{\\\\bf x}\\_{0}) of the corresponding forward transition probability.",
            "citations": null
          },
          "3 Point-Voxel Diffusion": {
            "content": "In this section we introduce Point-Voxel Diffusion (PVD), a denoising diffusion probabilistic model for 3D point clouds. We start by describing our formulation, followed by the training objective for shape generation, and end with the modified objective we proposed for shape completion from partial observation. For all our discussions below, we assume each of our data points are a set of N𝑁N points with x​y​z𝑥𝑦𝑧xyz-coordinates and is denoted as 𝐱∈ℝN×3𝐱superscriptℝ𝑁3{\\\\bf x}\\\\in\\\\mathbb{R}^{N\\\\times 3}. Our model is parameterized as a single point-voxel CNN \\[ [24])\\].\n\n### 3.1 Formulation\n\nThe denoising diffusion probabilistic model is a generative model where generation is modeled as a denoising process. Starting from Gaussian noise, denoising is performed until a sharp shape is formed. In particular, the denoising process produces a series of shape variables with decreasing levels of noise, denoted as 𝐱T,𝐱T−1,…,𝐱0subscript𝐱𝑇subscript𝐱𝑇1…subscript𝐱0{\\\\bf x}\\_{T},{\\\\bf x}\\_{T-1},...,{\\\\bf x}\\_{0}, where 𝐱Tsubscript𝐱𝑇{\\\\bf x}\\_{T} is sampled from a Gaussian prior and 𝐱0subscript𝐱0{\\\\bf x}\\_{0} is the final output.\n\nTo learn our generative model, we define a ground truth diffusion distribution q​(𝐱0:T)𝑞subscript𝐱:0𝑇q({\\\\bf x}\\_{0:T}) (defined by gradually adding Gaussian noise to the ground truth shape), and learn a diffusion model pθ​(𝐱0:T)subscript𝑝𝜃subscript𝐱:0𝑇p\\_{\\\\theta}({\\\\bf x}\\_{0:T}), which aims to invert the noise corruption process. We factor both probability distributions into products of Markov transition probabilities:\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n|  | q​(𝐱0:T)𝑞subscript𝐱:0𝑇\\\\displaystyle q({\\\\bf x}\\_{0:T}) | =q​(𝐱0)​∏t=1Tq​(𝐱t\\|𝐱t−1),absent𝑞subscript𝐱0superscriptsubscriptproduct𝑡1𝑇𝑞conditionalsubscript𝐱𝑡subscript𝐱𝑡1\\\\displaystyle=q({\\\\bf x}\\_{0})\\\\prod\\_{t=1}^{T}q({\\\\bf x}\\_{t}\\|{\\\\bf x}\\_{t-1}), |  | (1) |\n|  | pθ​(𝐱0:T)subscript𝑝𝜃subscript𝐱:0𝑇\\\\displaystyle p\\_{\\\\theta}({\\\\bf x}\\_{0:T}) | =p​(𝐱T)​∏t=1Tpθ​(𝐱t−1\\|𝐱t),absent𝑝subscript𝐱𝑇superscriptsubscriptproduct𝑡1𝑇subscript𝑝𝜃conditionalsubscript𝐱𝑡1subscript𝐱𝑡\\\\displaystyle=p({\\\\bf x}\\_{T})\\\\prod\\_{t=1}^{T}p\\_{\\\\theta}({\\\\bf x}\\_{t-1}\\|{\\\\bf x}\\_{t}), |  |\n\nwhere q​(𝐱0)𝑞subscript𝐱0q({\\\\bf x}\\_{0}) is the data distribution and p​(𝐱T)𝑝subscript𝐱𝑇p({\\\\bf x}\\_{T}) is a standard Gaussian prior. Here, q​(𝐱t\\|𝐱t−1)𝑞conditionalsubscript𝐱𝑡subscript𝐱𝑡1q({\\\\bf x}\\_{t}\\|{\\\\bf x}\\_{t-1}) is named the forward process, diffusing data into noise; accordingly, q​(𝐱t−1\\|𝐱t)𝑞conditionalsubscript𝐱𝑡1subscript𝐱𝑡q({\\\\bf x}\\_{t-1}\\|{\\\\bf x}\\_{t}) is named the reverse process. pθ​(𝐱t−1\\|𝐱t)subscript𝑝𝜃conditionalsubscript𝐱𝑡1subscript𝐱𝑡p\\_{\\\\theta}({\\\\bf x}\\_{t-1}\\|{\\\\bf x}\\_{t}) is named the generative process, which we learn, that generates realistic samples by approximates the reverse process. To enable closed-form evaluation, the transition probabilities are also parameterized as Gaussian distributions. We illustrate the processes in Figure [2]Figure 2 ‣ Energy-based models and denoising diffusion models. ‣ 2 Related Works ‣ 3D Shape Generation and Completion through Point-Voxel Diffusion\"). Given a pre-determined increasing sequence of Gaussian noise values β1,…,βTsubscript𝛽1…subscript𝛽𝑇\\\\beta\\_{1},...,\\\\beta\\_{T},111We leave derivation and implementation details to Appendix. each transition probability can be defined as\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n|  | q​(𝐱t\\|𝐱t−1)𝑞conditionalsubscript𝐱𝑡subscript𝐱𝑡1\\\\displaystyle q({\\\\bf x}\\_{t}\\|{\\\\bf x}\\_{t-1}) | :=𝒩​(1−βt​𝐱t−1,βt​𝐈),assignabsent𝒩1subscript𝛽𝑡subscript𝐱𝑡1subscript𝛽𝑡𝐈\\\\displaystyle:={\\\\mathcal{N}}(\\\\sqrt{1-\\\\beta\\_{t}}{\\\\bf x}\\_{t-1},\\\\beta\\_{t}{\\\\bf I}), |  | (2) |\n|  | pθ​(𝐱t−1\\|𝐱t)subscript𝑝𝜃conditionalsubscript𝐱𝑡1subscript𝐱𝑡\\\\displaystyle p\\_{\\\\theta}({\\\\bf x}\\_{t-1}\\|{\\\\bf x}\\_{t}) | :=𝒩​(μθ​(𝐱t,t),σt2​𝐈).assignabsent𝒩subscript𝜇𝜃subscript𝐱𝑡𝑡superscriptsubscript𝜎𝑡2𝐈\\\\displaystyle:={\\\\mathcal{N}}(\\\\mu\\_{\\\\theta}({\\\\bf x}\\_{t},t),\\\\sigma\\_{t}^{2}{\\\\bf I}). |  |\n\n,\nwhere μθ​(𝐱t,t)subscript𝜇𝜃subscript𝐱𝑡𝑡\\\\mu\\_{\\\\theta}({\\\\bf x}\\_{t},t) represents the predicted shape from our generative model at timestep t−1𝑡1t-1.\nEmpirically, we found that setting σt2=βtsuperscriptsubscript𝜎𝑡2subscript𝛽𝑡\\\\sigma\\_{t}^{2}=\\\\beta\\_{t} works well. Intuitively, the forward process can be seen as gradually injecting more random noise to the data, with the generative process learning to progressively remove noise to obtain realistic samples by mimicking the reverse process.\n\n#### Training objective.\n\nTo learn the marginal likelihood pθ​(𝐱)subscript𝑝𝜃𝐱p\\_{\\\\theta}({\\\\bf x}), we maximize a variational lower bound of log data likelihood that involves all of 𝐱0,…,𝐱Tsubscript𝐱0…subscript𝐱𝑇{\\\\bf x}\\_{0},...,{\\\\bf x}\\_{T}:\\\\@footnotemark\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | Eq​(𝐱0)​\\[log⁡pθ​(𝐱0)\\]≥Eq​(𝐱0:T)​\\[log⁡pθ​(𝐱0:T)q​(𝐱1:T\\|𝐱0)\\].subscriptE𝑞subscript𝐱0delimited-\\[\\]subscript𝑝𝜃subscript𝐱0subscriptE𝑞subscript𝐱:0𝑇delimited-\\[\\]subscript𝑝𝜃subscript𝐱:0𝑇𝑞conditionalsubscript𝐱:1𝑇subscript𝐱0{\\\\rm E}\\_{q({\\\\bf x}\\_{0})}\\[\\\\log p\\_{\\\\theta}({\\\\bf x}\\_{0})\\]\\\\geq{\\\\rm E}\\_{q({\\\\bf x}\\_{0:T})}\\\\Big{\\[}\\\\log\\\\frac{p\\_{\\\\theta}({\\\\bf x}\\_{0:T})}{q({\\\\bf x}\\_{1:T}\\|{\\\\bf x}\\_{0})}\\\\Big{\\]}. |  | (3) |\n\nIn the above objective, the forward process q​(𝐱t\\|𝐱t−1)𝑞conditionalsubscript𝐱𝑡subscript𝐱𝑡1q({\\\\bf x}\\_{t}\\|{\\\\bf x}\\_{t-1}) is fixed and p​(𝐱T)𝑝subscript𝐱𝑇p({\\\\bf x}\\_{T}) is defined as a Gaussian prior, so they do not affect the learning of θ𝜃\\\\theta. Therefore, the final objective can be reduced to maximum likelihood given the complete data likelihood with joint posterior q​(𝐱1:T\\|𝐱0)𝑞conditionalsubscript𝐱:1𝑇subscript𝐱0q({\\\\bf x}\\_{1:T}\\|{\\\\bf x}\\_{0}):\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | maxθ⁡E𝐱0∼q​(𝐱0),𝐱1:T∼q​(𝐱1:T\\|𝐱0)​\\[∑t=1Tlog⁡pθ​(𝐱t−1\\|𝐱t)\\].subscript𝜃subscriptEformulae-sequencesimilar-tosubscript𝐱0𝑞subscript𝐱0similar-tosubscript𝐱:1𝑇𝑞conditionalsubscript𝐱:1𝑇subscript𝐱0delimited-\\[\\]superscriptsubscript𝑡1𝑇subscript𝑝𝜃conditionalsubscript𝐱𝑡1subscript𝐱𝑡\\\\max\\_{\\\\theta}{\\\\rm E}\\_{{\\\\bf x}\\_{0}\\\\sim q({\\\\bf x}\\_{0}),{\\\\bf x}\\_{1:T}\\\\sim q({\\\\bf x}\\_{1:T}\\|{\\\\bf x}\\_{0})}\\\\left\\[\\\\sum\\_{t=1}^{T}\\\\log p\\_{\\\\theta}({\\\\bf x}\\_{t-1}\\|{\\\\bf x}\\_{t})\\\\right\\]. |  | (4) |\n\nJoint posterior q​(𝐱1:T\\|𝐱0)𝑞conditionalsubscript𝐱:1𝑇subscript𝐱0q({\\\\bf x}\\_{1:T}\\|{\\\\bf x}\\_{0}) can be factorized into ∏t=1Tq​(𝐱t−1\\|𝐱t,𝐱0)superscriptsubscriptproduct𝑡1𝑇𝑞conditionalsubscript𝐱𝑡1subscript𝐱𝑡subscript𝐱0\\\\prod\\_{t=1}^{T}{q({\\\\bf x}\\_{t-1}\\|{\\\\bf x}\\_{t},{\\\\bf x}\\_{0})}. Each factored ground-truth posterior is denoted as q​(𝐱t−1\\|𝐱t,𝐱0)𝑞conditionalsubscript𝐱𝑡1subscript𝐱𝑡subscript𝐱0q({\\\\bf x}\\_{t-1}\\|{\\\\bf x}\\_{t},{\\\\bf x}\\_{0}) and is analytically tractable. It can be shown that it is also parameterized by Gaussian distributions:\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n|  |  | q​(𝐱t−1\\|𝐱t,𝐱0)=𝑞conditionalsubscript𝐱𝑡1subscript𝐱𝑡subscript𝐱0absent\\\\displaystyle q({\\\\bf x}\\_{t-1}\\|{\\\\bf x}\\_{t},{\\\\bf x}\\_{0})= |  | (5) |\n|  |  | 𝒩​(α~t−1​βt1−α~t​𝐱0+αt​(1−α~t−1)1−α~t​𝐱t,(1−α~t−1)1−α~t​βt​𝐈).𝒩subscript~𝛼𝑡1subscript𝛽𝑡1subscript~𝛼𝑡subscript𝐱0subscript𝛼𝑡1subscript~𝛼𝑡11subscript~𝛼𝑡subscript𝐱𝑡1subscript~𝛼𝑡11subscript~𝛼𝑡subscript𝛽𝑡𝐈\\\\displaystyle{\\\\mathcal{N}}\\\\left(\\\\frac{\\\\sqrt{\\\\tilde{\\\\alpha}\\_{t-1}}\\\\beta\\_{t}}{1-\\\\tilde{\\\\alpha}\\_{t}}{\\\\bf x}\\_{0}+\\\\frac{\\\\sqrt{\\\\alpha\\_{t}}(1-\\\\tilde{\\\\alpha}\\_{t-1})}{1-\\\\tilde{\\\\alpha}\\_{t}}{\\\\bf x}\\_{t},\\\\frac{(1-\\\\tilde{\\\\alpha}\\_{t-1})}{1-\\\\tilde{\\\\alpha}\\_{t}}\\\\beta\\_{t}{\\\\bf I}\\\\right). |  |\n\nwhere αt=1−βtsubscript𝛼𝑡1subscript𝛽𝑡\\\\alpha\\_{t}=1-\\\\beta\\_{t} and α~t=∏s=1tαssubscript~𝛼𝑡superscriptsubscriptproduct𝑠1𝑡subscript𝛼𝑠\\\\tilde{\\\\alpha}\\_{t}=\\\\prod\\_{s=1}^{t}\\\\alpha\\_{s}.\\\\@footnotemark This property allows each timestep to learn independently, _i.e_., each pθ​(𝐱t−1\\|𝐱t)subscript𝑝𝜃conditionalsubscript𝐱𝑡1subscript𝐱𝑡p\\_{\\\\theta}({\\\\bf x}\\_{t-1}\\|{\\\\bf x}\\_{t}) only needs to match q​(𝐱t−1\\|𝐱t,𝐱0)𝑞conditionalsubscript𝐱𝑡1subscript𝐱𝑡subscript𝐱0q({\\\\bf x}\\_{t-1}\\|{\\\\bf x}\\_{t},{\\\\bf x}\\_{0}).\n\nSince both pθ​(𝐱t−1\\|𝐱t)subscript𝑝𝜃conditionalsubscript𝐱𝑡1subscript𝐱𝑡p\\_{\\\\theta}({\\\\bf x}\\_{t-1}\\|{\\\\bf x}\\_{t}) and q​(𝐱t−1\\|𝐱t,𝐱0)𝑞conditionalsubscript𝐱𝑡1subscript𝐱𝑡subscript𝐱0q({\\\\bf x}\\_{t-1}\\|{\\\\bf x}\\_{t},{\\\\bf x}\\_{0}) are Gaussian, we can reparameterize the model to output noise and the final loss can be reduced to an ℒ2subscriptℒ2\\\\mathcal{L}\\_{2} loss between the model output ϵθ​(𝐱t,t)subscriptbold-italic-ϵ𝜃subscript𝐱𝑡𝑡\\\\bm{\\\\epsilon}\\_{\\\\theta}({\\\\bf x}\\_{t},t) and noise ϵbold-italic-ϵ\\\\bm{\\\\epsilon}:\\\\@footnotemark\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | ∥ϵ−ϵθ​(𝐱t,t)∥2,ϵ∼𝒩​(0,𝐈),similar-tosuperscriptdelimited-∥∥bold-italic-ϵsubscriptbold-italic-ϵ𝜃subscript𝐱𝑡𝑡2bold-italic-ϵ𝒩0𝐈\\\\left\\\\lVert\\\\bm{\\\\epsilon}-\\\\bm{\\\\epsilon}\\_{\\\\theta}({\\\\bf x}\\_{t},t)\\\\right\\\\rVert^{2},\\\\;\\\\;\\\\bm{\\\\epsilon}\\\\sim{\\\\mathcal{N}}(0,{\\\\bf I}), |  | (6) |\n\nIntuitively, the model seeks to predict the noise vector necessary to decorrupt the 3D shape.\n\nPoint clouds can then be generated by progressively sampling from pθ​(𝐱t−1\\|𝐱t)subscript𝑝𝜃conditionalsubscript𝐱𝑡1subscript𝐱𝑡p\\_{\\\\theta}({\\\\bf x}\\_{t-1}\\|{\\\\bf x}\\_{t}) as t=T,…,1𝑡𝑇…1t=T,...,1 using the following equation:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | 𝐱t−1=1αt​(𝐱t−1−αt1−α~t​ϵθ​(𝐱t,t))+βt​𝐳,subscript𝐱𝑡11subscript𝛼𝑡subscript𝐱𝑡1subscript𝛼𝑡1subscript~𝛼𝑡subscriptbold-italic-ϵ𝜃subscript𝐱𝑡𝑡subscript𝛽𝑡𝐳{\\\\bf x}\\_{t-1}=\\\\frac{1}{\\\\sqrt{\\\\alpha\\_{t}}}\\\\left({\\\\bf x}\\_{t}-\\\\frac{1-\\\\alpha\\_{t}}{\\\\sqrt{1-\\\\tilde{\\\\alpha}\\_{t}}}\\\\bm{\\\\epsilon}\\_{\\\\theta}({\\\\bf x}\\_{t},t)\\\\right)+\\\\sqrt{\\\\beta\\_{t}}\\\\mathbf{z}, |  | (7) |\n\nwhere 𝐳∼𝒩​(0,𝐈)similar-to𝐳𝒩0𝐈\\\\mathbf{z}\\\\sim{\\\\mathcal{N}}(0,{\\\\bf I}), corresponding to the gradual denoising of a shape from noise.\\\\@footnotemark\n\n### 3.2 Shape Completion\n\nOur objective can be simply modified to learn a conditional generative model given partial shapes, which we introduce in this section.\n\nDenote a point cloud sample as 𝐱0=(𝐳0,𝐱~0)subscript𝐱0subscript𝐳0subscript~𝐱0{\\\\bf x}\\_{0}=({\\\\bf z}\\_{0},\\\\tilde{{\\\\bf x}}\\_{0}), where 𝐳0∈ℝM×3subscript𝐳0superscriptℝ𝑀3{\\\\bf z}\\_{0}\\\\in\\\\mathbb{R}^{M\\\\times 3} is the fixed partial shape, and any intermediate shapes as free points 𝐱t=(𝐳0,𝐱~t)subscript𝐱𝑡subscript𝐳0subscript~𝐱𝑡{\\\\bf x}\\_{t}=({\\\\bf z}\\_{0},\\\\tilde{{\\\\bf x}}\\_{t}). We can then define a conditional forward process, where the partial shape is fixed at 𝐳0subscript𝐳0{\\\\bf z}\\_{0} for all time. Our conditional forward and generative processes, as well as each transition probability, can then be parametrized as\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n|  | q​(𝐱~t\\|𝐱~t−1,𝐳0)𝑞conditionalsubscript~𝐱𝑡subscript~𝐱𝑡1subscript𝐳0\\\\displaystyle q(\\\\tilde{{\\\\bf x}}\\_{t}\\|\\\\tilde{{\\\\bf x}}\\_{t-1},{\\\\bf z}\\_{0}) | :=𝒩​(1−βt​𝐱~t−1,βt​𝐈),assignabsent𝒩1subscript𝛽𝑡subscript~𝐱𝑡1subscript𝛽𝑡𝐈\\\\displaystyle:={\\\\mathcal{N}}(\\\\sqrt{1-\\\\beta\\_{t}}\\\\tilde{{\\\\bf x}}\\_{t-1},\\\\beta\\_{t}{\\\\bf I}), |  | (8) |\n|  | pθ​(𝐱~t−1\\|𝐱~t,𝐳0)subscript𝑝𝜃conditionalsubscript~𝐱𝑡1subscript~𝐱𝑡subscript𝐳0\\\\displaystyle p\\_{\\\\theta}(\\\\tilde{{\\\\bf x}}\\_{t-1}\\|\\\\tilde{{\\\\bf x}}\\_{t},{\\\\bf z}\\_{0}) | :=𝒩​(μθ​(𝐱t,𝐳0,t),σt2​𝐈).assignabsent𝒩subscript𝜇𝜃subscript𝐱𝑡subscript𝐳0𝑡superscriptsubscript𝜎𝑡2𝐈\\\\displaystyle:={\\\\mathcal{N}}(\\\\mu\\_{\\\\theta}({\\\\bf x}\\_{t},{\\\\bf z}\\_{0},t),\\\\sigma\\_{t}^{2}{\\\\bf I}). |  |\n\nNote that the above equations now give the forward/generative transition probabilities for the free points 𝐱~tsubscript~𝐱𝑡\\\\tilde{{\\\\bf x}}\\_{t}, while 𝐳0subscript𝐳0{\\\\bf z}\\_{0} stays unchanged for all timesteps. Intuitively, this process is the same as unconditional generation, while we hold the partial shape 𝐳0subscript𝐳0{\\\\bf z}\\_{0} fixed and diffuse only the missing parts.\n\nThe modified training objective also maximizes the likelihood conditioned on partial shapes 𝐳0subscript𝐳0{\\\\bf z}\\_{0}:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | E(𝐱~0,𝐳0)∼q​(x0),𝐱1:T∼q​(𝐱1:T\\|𝐱~0,𝐳0)​\\[∑t=1Tlog⁡pθ​(𝐱~t−1\\|𝐱~t,𝐳0)\\],subscriptEformulae-sequencesimilar-tosubscript~𝐱0subscript𝐳0𝑞subscript𝑥0similar-tosubscript𝐱:1𝑇𝑞conditionalsubscript𝐱:1𝑇subscript~𝐱0subscript𝐳0delimited-\\[\\]superscriptsubscript𝑡1𝑇subscript𝑝𝜃conditionalsubscript~𝐱𝑡1subscript~𝐱𝑡subscript𝐳0{\\\\rm E}\\_{(\\\\tilde{{\\\\bf x}}\\_{0},{\\\\bf z}\\_{0})\\\\sim q(x\\_{0}),{\\\\bf x}\\_{1:T}\\\\sim q({\\\\bf x}\\_{1:T}\\|\\\\tilde{{\\\\bf x}}\\_{0},{\\\\bf z}\\_{0})}\\\\left\\[\\\\sum\\_{t=1}^{T}\\\\log p\\_{\\\\theta}(\\\\tilde{{\\\\bf x}}\\_{t-1}\\|\\\\tilde{{\\\\bf x}}\\_{t},{\\\\bf z}\\_{0})\\\\right\\], |  | (9) |\n\nwhere each posterior q​(𝐱~t−1\\|𝐱~t,𝐱~0,𝐳0)𝑞conditionalsubscript~𝐱𝑡1subscript~𝐱𝑡subscript~𝐱0subscript𝐳0q(\\\\tilde{{\\\\bf x}}\\_{t-1}\\|\\\\tilde{{\\\\bf x}}\\_{t},\\\\tilde{{\\\\bf x}}\\_{0},{\\\\bf z}\\_{0}) is known and its derivation is similar to the unconditional generative model. Using the same reasoning as before, we can arrive at a similar ℒ2subscriptℒ2\\\\mathcal{L}\\_{2} loss:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | ℒt=∥ϵ−ϵθ​(𝐱~t,𝐳0,t)∥2,subscriptℒ𝑡superscriptdelimited-∥∥bold-italic-ϵsubscriptbold-italic-ϵ𝜃subscript~𝐱𝑡subscript𝐳0𝑡2\\\\mathcal{L}\\_{t}=\\\\left\\\\lVert\\\\bm{\\\\epsilon}-\\\\bm{\\\\epsilon}\\_{\\\\theta}(\\\\tilde{{\\\\bf x}}\\_{t},{\\\\bf z}\\_{0},t)\\\\right\\\\rVert^{2}, |  | (10) |\n\nwhere ϵ∼𝒩​(0,𝐈)similar-tobold-italic-ϵ𝒩0𝐈\\\\bm{\\\\epsilon}\\\\sim{\\\\mathcal{N}}(0,{\\\\bf I}). Additionally, since the partial shape is always fixed during both forward and generative processes, we can mask away the subset of model output that affects 𝐳0subscript𝐳0{\\\\bf z}\\_{0} and minimize ℒ2subscriptℒ2\\\\mathcal{L}\\_{2} distance between ϵ~​(𝐱~t,𝐳0,t)~bold-italic-ϵsubscript~𝐱𝑡subscript𝐳0𝑡\\\\tilde{\\\\bm{\\\\epsilon}}(\\\\tilde{{\\\\bf x}}\\_{t},{\\\\bf z}\\_{0},t) and random noise, which only affects 𝐱~tsubscript~𝐱𝑡\\\\tilde{{\\\\bf x}}\\_{t}. In practice, we input 𝐳0subscript𝐳0{\\\\bf z}\\_{0} and 𝐱tsubscript𝐱𝑡{\\\\bf x}\\_{t} into the model and obtain 𝐱t−1subscript𝐱𝑡1{\\\\bf x}\\_{t-1}, where only the subset 𝐱~t−1subscript~𝐱𝑡1\\\\tilde{{\\\\bf x}}\\_{t-1} is used for ℒ2subscriptℒ2\\\\mathcal{L}\\_{2} loss. In shape completion, 𝐱~t−1subscript~𝐱𝑡1\\\\tilde{{\\\\bf x}}\\_{t-1} is concatenated with 𝐳0subscript𝐳0{\\\\bf z}\\_{0} to be the input into the model again. This allows the exact same training architecture to do both generation and shape completion by simply changing the training objective.\n\n|     |     |     |     |     |     |     |     |     |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- |\n|  |  |  |  |  |  |  |  |  |\n|  |  |  |  |  |  |  |  |  |\n|  |  |  |  |  |  |  |  |  |\n| l-GAN | PointFlow | SoftFlow | DPF-Net | Shape-GF | Vox-Diff | PVD (ours) |\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\nFigure 3: Results on unconditional shape generation with 2,048 points. The l-GAN results are from the EMD variant.",
            "citations": null
          },
          "4 Experiments": {
            "content": "We demonstrate here that our model outperforms previous point generative models in Section [4.1]Shape Generation ‣ 4 Experiments ‣ 3D Shape Generation and Completion through Point-Voxel Diffusion\"), is capable of completing partial shapes sampled from single views in Section [4.2]Shape Completion ‣ 4 Experiments ‣ 3D Shape Generation and Completion through Point-Voxel Diffusion\"), and can generate diverse shapes given partial shape constraints in Section [4.3]Multi-Modal Completion ‣ 4 Experiments ‣ 3D Shape Generation and Completion through Point-Voxel Diffusion\"). Architecture and hyper-parameter details are provided in Appendix.\n\n### 4.1 Shape Generation\n\n|  | Airplane | Chair | Car |\n| --- | --- | --- | --- |\n|  | CD | EMD | CD | EMD | CD | EMD |\n| --- | --- | --- | --- | --- | --- | --- |\n| r-GAN \\[ [1])\\] | 98.40 | 96.79 | 83.69 | 99.70 | 94.46 | 99.01 |\n| l-GAN (CD) \\[ [1])\\] | 87.30 | 93.95 | 68.58 | 83.84 | 66.49 | 88.78 |\n| l-GAN (EMD) \\[ [1])\\] | 89.49 | 76.91 | 71.90 | 64.65 | 71.16 | 66.19 |\n| PointFLow \\[ [46])\\] | 75.68 | 70.74 | 62.84 | 60.57 | 58.10 | 56.25 |\n| SoftFlow \\[ [16])\\] | 76.05 | 65.80 | 59.21 | 60.05 | 64.77 | 60.09 |\n| DPF-Net \\[ [17])\\] | 75.18 | 65.55 | 62.00 | 58.53 | 62.35 | 54.48 |\n| Shape-GF \\[ [3])\\] | 80.00 | 76.17 | 68.96 | 65.48 | 63.20 | 56.53 |\n| PVD (ours) | 73.82 | 64.81 | 56.26 | 53.32 | 54.55 | 53.83 |\n\nTable 1: Generation results on Airplane, Chair, Car compared with baselines using 1-NN as the metric. Both CD and EMD as the distance measure are calculated. Lower scores indicate better quality and diversity.\n\n#### Data.\n\nWe choose ShapeNet \\[ [4])\\] Airplane, Chair, and Car to be our main datasets for generation, following most previous works \\[ [46]), [17]), [3]), [16])\\]. We use the provided datasets in \\[ [46])\\], which contain 15,000 sampled points for each shape. We sample 2,048 points for training and testing, respectively, and process our data following procedures provided in PointFlow \\[ [46])\\].\n\n#### Evaluation metrics.\n\nPrevious works such as \\[ [46]), [17]), [3]), [16])\\] have used Chamfer Distance (CD) and Earth Mover’s Distance (EMD) as their distance metrics in calculating Jensen-Shannon Divergence (JSD), Coverage (COV), Minimum Matching Distance (MMD), and 1-Nearest Neighbor (1-NN), which are four main metrics to measure generative quality. However, as discussed by \\[ [46])\\], JSD, COV, and MMD each has limitations and does not necessarily indicate better quality. Some generation results achieve even better scores than ground-truth datasets.\n1-NN is robust and correlates with generation quality, as supported by \\[ [46])\\], which also proposes 1-NN as the better metric. Therefore, we use 1-NN directly for evaluating generation quality and we provide comparison of remaining metrics in Appendix. As we also discover that EMD score can vary widely depending on its implementation, We evaluate all baselines using our implementation of the metrics.\n\n#### Baselines and results.\n\nWe quantitatively compare our results with r-GAN \\[ [1])\\], l-GAN \\[ [1])\\], PointFlow \\[ [46])\\], DPF-Net \\[ [17])\\], SoftFlow \\[ [16])\\], and Shape-GF \\[ [3])\\] on generating 2048 points. In evaluating the baselines, we follow the same data processing and evaluation procedure as PointFlow, and follow the provided baseline implementations to evaluate their models. Our comparisons are shown in Table [1]Table 1 ‣ 4.1 Shape Generation ‣ 4 Experiments ‣ 3D Shape Generation and Completion through Point-Voxel Diffusion\"). Our model noticeably achieves the best generation quality.\n\nWe also investigated pure voxel and point representations for shape generation. We noticed that simply extending diffusion models to pure point representation using conventional permutation-invariant architectures such as PointNet++ \\[ [32])\\] fails to generate any visible shapes. Extending diffusion models to pure voxel representation generates noisy results due to the binary nature of voxels which is different from our Gaussian assumption. We visually compare with baselines including a voxel diffusion model (Vox-Diff) in Figure [3]Figure 3 ‣ 3.2 Shape Completion ‣ 3 Point-Voxel Diffusion ‣ 3D Shape Generation and Completion through Point-Voxel Diffusion\"). For Vox-Diff, 2048 points are sampled from voxel surfaces. We provide additional quantitative comparison in Appendix.\n\n|  |  |  |  |  |  |  |\n|  |  |  |  |  |  |  |\n|  |  |  |  |  |  |  |\n| Depths | Ground-truths | Partial | PointFlow | SoftFlow | DPF-Net | PVD (ours) |\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\nFigure 4: Our shape completion visualization (right) compared to baseline models (left). From left to right: depth images, ground-truth shapes, partial shapes sampled from depth images, completion from baselines, and our results.\n\n### 4.2 Shape Completion\n\nIn various graphics applications users usually do not have access to all viewpoints of an object. A shape often needs to be completed knowing a partial shape from a single depth map. Therefore, the ability to complete partial shapes become practically useful. In this section, we use the same model architecture (see Appendix) from Section [4.1]Shape Generation ‣ 4 Experiments ‣ 3D Shape Generation and Completion through Point-Voxel Diffusion\") and test our shape completion models.\n\n#### Data.\n\nFor shape completion, we use the benchmark provided by GenRe \\[ [49])\\], which contains renderings of each shape in ShapeNet from 20 random views. We sample 200 points as our partial point clouds obtained from the provided depth images, and we evaluate shape completion on all 20 partial shapes per ground-truth sample.\n\n#### Metrics.\n\nFor shape completion, as the ground-truth data are involved, Chamfer Distance and Earth Mover’s Distance suffice to evaluate the reconstruction results.\n\n#### Baselines.\n\nSince our approach is probabilistic, we selected major distribution-fitting models such as PointFlow \\[ [46])\\], DPF-Net \\[ [17])\\], and SoftFlow \\[ [16])\\] for comparison. We directly evaluate pre-trained models, if provided, otherwise we re-train them using baselines’ provided implementation on our benchmark. We also compared with Shape-GF as its encoder can similarly receive an arbitrary number of points. However, it is experimentally found that the model is sensitive to the input partial shapes and completion is not realistic after Langevin sampling. Therefore, we leave them out of the comparison.\n\n| Category | Model | CD | EMD |\n| --- | --- | --- | --- |\n| Airplane | SoftFlow \\[ [16])\\] | 0.4042 | 1.198 |\n| PointFlow \\[ [46])\\] | 0.4030 | 1.180 |\n| DPF-Net \\[ [17])\\] | 0.5279 | 1.105 |\n| PVD (ours) | 0.4415 | 1.030 |\n| Chair | SoftFlow \\[ [16])\\] | 2.786 | 3.295 |\n| PointFlow \\[ [46])\\] | 2.707 | 3.649 |\n| DPF-Net \\[ [17])\\] | 2.763 | 3.320 |\n| PVD (ours) | 3.211 | 2.939 |\n| Car | SoftFlow \\[ [16])\\] | 1.850 | 2.789 |\n| PointFlow \\[ [46])\\] | 1.803 | 2.851 |\n| DPF-Net \\[ [17])\\] | 1.396 | 2.318 |\n| PVD (ours) | 1.774 | 2.146 |\n\nTable 2: Quantitative comparison against baselines. CD is multiplied by 103superscript10310^{3} and EMD is multiplied by 102superscript10210^{2}.\n\n![Refer to caption]\n\n| GT | PointFlow | SoftFlow | DPF-Net | PVD (ours) |\n| --- | --- | --- | --- | --- |\n| CD | 8.633 | 1.501 | 1.197 | 1.921 |\n| EMD | 1.124 | 1.856 | 1.109 | 0.919 |\n\nFigure 5: Typical case when CD is higher than baseline models. Column 1 shows input depth image and ground-truth point clouds. The next columns show completion from the input viewpoint (top) and from the canonical viewpoint (bottom). CD is multiplied by 103superscript10310^{3} and EMD is multiplied by 102superscript10210^{2} scores.\n\n#### Results.\n\nQuantitative results are presented in Table [2]Table 2 ‣ Baselines. ‣ 4.2 Shape Completion ‣ 4 Experiments ‣ 3D Shape Generation and Completion through Point-Voxel Diffusion\") and a visual comparison is shown in Figure [4]Figure 4 ‣ Baselines and results. ‣ 4.1 Shape Generation ‣ 4 Experiments ‣ 3D Shape Generation and Completion through Point-Voxel Diffusion\"). From Table [2]Table 2 ‣ Baselines. ‣ 4.2 Shape Completion ‣ 4 Experiments ‣ 3D Shape Generation and Completion through Point-Voxel Diffusion\"), we observe that our model achieves best on EMD scores while worse on CD compared to some baselines. First, we note EMD is a better metric for measuring completion quality because by solving the linear assignment problem it forces model outputs to have the same density as the ground-truths \\[ [23])\\] and it is known that CD is blind to visual inferiority \\[ [1])\\]. Our better EMD score is more indicative of higher visual quality.\n\n|     |     |     |     |     |     |     |     |     |     |     |     |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] |\n| ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] |\n| ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] |\n| ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] |\n| ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] | ![Refer to caption] |\n| Partial | KNN-latent | cGAN | PVD (Ours) | Partial | KNN-latent | cGAN | PVD (Ours) | Partial | KNN-latent | cGAN | PVD (Ours) |\n\nFigure 6: Multi-modal completion visualization on PartNet. Each column presents five completion modes from a model.\n\nNext, we investigate the reason our CD is inferior to our baselines. We discover that a typical case when our CD is higher is as shown in Figure [5]Figure 5 ‣ Baselines. ‣ 4.2 Shape Completion ‣ 4 Experiments ‣ 3D Shape Generation and Completion through Point-Voxel Diffusion\"), where from the input view the ground-truth shape is largely unknown. The baseline models tend to output a mean shape when encountered with such an unconventional angle. Naturally, mean shapes are more frequently closer to the ground-truths than other shapes, as exemplified by the figure. However, with each noise initialization, our model seeks a possible completion that matches well with the partial shape and may be further away from the ground-truth than the mean shape. In the case shown, our completion is a van instead of a sedan but is equally realistic.\n\nOur model also enables controlled completion given multiple partial shapes, and we leave details to Appendix.\n\n|  | TMD ×102absentsuperscript102\\\\times 10^{2} | MMD ×103absentsuperscript103\\\\times 10^{3} |\n| --- | --- | --- |\n|  | Chair | Table | Lamp | Avg. | Chair | Table | Lamp | Avg. |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| KNN-latent \\[ [44])\\] | 0.96 | 1.37 | 1.95 | 1.43 | 1.42 | 1.42 | 1.88 | 1.57 |\n| cGAN \\[ [44])\\] | 1.75 | 1.99 | 1.94 | 1.89 | 1.61 | 1.56 | 2.13 | 1.77 |\n| PVD (ours) | 1.91 | 1.70 | 5.92 | 3.18 | 1.27 | 1.03 | 1.98 | 1.43 |\n\nTable 3: Quantitative comparison for multi-modal completion on PartNet. TMD (higher the better) measures completion diversity, and MMD (lower the better) measures completion quality. Chamfer Distance (CD) is used as the distance measure.\n\n### 4.3 Multi-Modal Completion\n\nOur baselines for shape completion adopt an encoder-decoder structure that takes in a partial shape and outputs a single completion. While some offer impressive results, their completion ability is deterministic, much different from humans who can often imagine different completion possibilities given single views. Our PVD, however, adopts a probabilistic approach to shape completion, where each noise initialization can result in a different completion.\n\n#### Data.\n\nWe follow experiment setups from cGAN \\[ [44])\\] and train our model on Chair, Table, and Lamp from PartNet \\[ [27])\\]. 1024 points are given and 2048 points are generated as completion. In addition, we show diversity of our completion on ShapeNet. Different from PartNet, ShapeNet’s partial shapes are sampled from custom-rendered depth images.\n\n#### Metrics.\n\nWe follow cGAN \\[ [44])\\] and use Total Mutual Difference (TMD) to measure diversity and Minimal Matching Distance (MMD) to measure quality with Chamfer Distance (CD) as distance measure. Since our model is different from cGAN and only completes the 1024 free points, TMD is calculated only on the free points for our model and on a subsampled set of 1024 points for our baselines. MMD is calculated using the completed 2048 points and re-sampled 2048 ground-truth points.\n\n#### Results on PartNet.\n\nOur model is compared with cGAN \\[ [44])\\] and KNN-latent \\[ [44])\\]. Results are shown in Table [3]Table 3 ‣ Results. ‣ 4.2 Shape Completion ‣ 4 Experiments ‣ 3D Shape Generation and Completion through Point-Voxel Diffusion\") and visual comparisons are shown in Figure [6]Figure 6 ‣ Results. ‣ 4.2 Shape Completion ‣ 4 Experiments ‣ 3D Shape Generation and Completion through Point-Voxel Diffusion\"). Our model outperforms both baselines in terms of average diversity and quality.\n\n![Refer to caption]Figure 7: Multi-modal completion results on ShapeNet. Left: ground-truth bottom view depth image of a chair. Right: six different possible shape completion results. Top: completion from the depth image viewpoint. Bottom: completion from the canonical viewpoint.\n\n|     |     |     |     |     |     |     |     |     |     |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n|  |  |  |  |  |  |  |  |  |  |\n|  |  |  |  |  |  |  |  |\n|  |  |  |  |  |  |  |  |  |  |\n|  |  |  |  |  |  |  |  |\n| RGB-D | GT | Completion Results | RGB-D | GT | Completion Results |\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\n![Refer to caption]\n\nFigure 8: Application of our model on scans from the Redwood 3DScans dataset. PVD takes partial point clouds induced from the depth maps, not the RGB image as input. Left: from a more complete view, the model outputs stable, similar completions. Right: from an uncertain viewpoint, the model outputs multiple completions with a larger variation.\n\n#### Results on ShapeNet.\n\nThe shape completion model trained in Section [4.2]Shape Completion ‣ 4 Experiments ‣ 3D Shape Generation and Completion through Point-Voxel Diffusion\") is directly used to demonstrate completion diversity on ShapeNet, as shown in Figure [7]Figure 7 ‣ Results on PartNet. ‣ 4.3 Multi-Modal Completion ‣ 4 Experiments ‣ 3D Shape Generation and Completion through Point-Voxel Diffusion\"). We choose a bottom view of a chair and show that, in the top row, all of our completion results match well with the constrained viewpoint, and in the bottom row, our completion results are noticeably diverse from the canonical viewpoint.\n\n#### Results on real scans.\n\nWe further investigate how our model pre-trained on ShapeNet can perform on scans of real objects. We use the Redwood 3DScans dataset \\[ [5])\\] and test our model on partial shapes of chairs and tables, sampled from its depth images. Since the GenRe benchmark \\[ [49])\\] does not provide table data, the training data for the table category are generated by randomly sampling 20 views from ShapeNet meshes, following GenRe’s procedure. Within each example, we present the real RGB-D scans and ground-truths from the input views.\n\nFigure [8]Figure 8 ‣ Results on PartNet. ‣ 4.3 Multi-Modal Completion ‣ 4 Experiments ‣ 3D Shape Generation and Completion through Point-Voxel Diffusion\") shows results on two views of two different chairs and tables. For chair scans, the left example shows the front view, and the completion results only vary slightly across different runs. The right chair example shows a back view, and the uncertainty allows more varied completion. Similarly, the left table scan shows a large part of the table, so the completion varies less than the right example, which only shows the top of the table.",
            "citations": null
          },
          "5 Conclusion": {
            "content": "We have introduced PVD, a unified framework for both shape generation and shape completion. Our model, trained on a simple ℒ2subscriptℒ2\\\\mathcal{L}\\_{2} loss, is based on diffusion probabilistic models and learns to reverse a diffusion process by progressively removing noise from noise-initialized samples. A minor modification on the objective also results in a shape completion model without the need for any architectural change. Experimentally, we show the failure with straight-forward extension of diffusion models to either pure voxel or point representations. With the point-voxel representation, our model demonstrates superior generative power and impressive shape completion quality. Unlike most baseline models which use deterministic encoder-decoder structures, PVD can output multiple possible completion results given a partial shape. Additionally, it can complete real 3D scans, thus offering practical usage in various downstream applications.\n\n#### Acknowledgements:\n\nYilun Du is funded by an NSF graduate fellowship. This work is in part supported by ARMY MURI grant W911NF-15-1-0479, Samsung Global Research Outreach (GRO) program, Amazon Research Award (ARA), IBM, Stanford HAI, and Autodesk.",
            "citations": null
          }
        },
        "abstract": "We propose a novel approach for probabilistic generative modeling of 3D\nshapes. Unlike most existing models that learn to deterministically translate a\nlatent vector to a shape, our model, Point-Voxel Diffusion (PVD), is a unified,\nprobabilistic formulation for unconditional shape generation and conditional,\nmulti-modal shape completion. PVD marries denoising diffusion models with the\nhybrid, point-voxel representation of 3D shapes. It can be viewed as a series\nof denoising steps, reversing the diffusion process from observed point cloud\ndata to Gaussian noise, and is trained by optimizing a variational lower bound\nto the (conditional) likelihood function. Experiments demonstrate that PVD is\ncapable of synthesizing high-fidelity shapes, completing partial point clouds,\nand generating multiple completion results from single-view depth scans of real\nobjects."
      },
      "bib.bib121": {
        "id": "bib.bib121",
        "citation": "[121]",
        "authors": "",
        "year": "",
        "title": "Triplane meets gaussian splatting: Fast and generalizable single-view 3d reconstruction with transformers.",
        "venue": "",
        "pages": "",
        "url": "https://arxiv.org/abs/2312.09147",
        "arxiv_id": "2312.09147",
        "doi": null,
        "sections": {
          "1 Introduction": {
            "content": "Digitizing 3D objects from single 2D images represents a crucial and longstanding challenge in both computer vision and graphics. The significance of this problem stems from its broad applications, notably in augmented reality (AR) and virtual reality (VR). However, the inherent ambiguity and lack of information in single images pose a substantial challenge in accurately recovering the complete, high-quality shape and texture of an object from such a constrained perspective.\n\nThe recent surge in image generation using diffusion models \\[ [49]), [51])\\] enabled approaches to “imagine” images from novel viewpoints by leveraging these models with pose transformation conditions \\[ [31])\\] or novel view rendering feature maps \\[ [5]), [73])\\].\nDespite these advancements, achieving consistent novel view synthesis remains a complex task, largely due to the lack of 3D structural constraints.\nRecent efforts incorporating multi-view attention or 3D-aware feature attention for simultaneous multi-view generation \\[ [54]), [32])\\] have not fully mitigated this challenge.\nFurthermore, these methods require a time-intensive, object-specific optimization process to distill diffusion priors \\[ [45]), [28]), [36]), [55]), [7])\\], combined with monocular cues (depth or normals \\[ [14]), [33])\\]), into neural 3D representations such as NeRF \\[ [39])\\] and DMTet \\[ [53])\\].\nThis optimization procedure is often too slow for practical applications requiring rapid 3D creation.\n\nInstead of optimizing a 3D representation, alternative approaches utilize category-specific shape priors to regress 3D representations (e.g., point clouds \\[ [15]), [64])\\], voxels \\[ [19]), [63])\\], meshes \\[ [61]), [58])\\], and NeRF \\[ [68])\\]) from single images.\nAmong various 3D representations, the triplane representation is notable for its compactness and efficient expressiveness, with its implicit nature facilitating the learning of 3D structures via volume rendering \\[ [39])\\].\nNevertheless, the inherent complexity of volume rendering imposes significant runtime and memory costs, adversely impacting training efficiency and real-time rendering capabilities.\nRecently, Gaussian Splatting \\[ [25])\\] has made strides by using anisotropic 3D Gaussians for high-quality radiance field representation, enhancing both novel view synthesis quality and rendering speed through adaptive density control and efficient, differentiable rendering.\nYet, the direct learning of 3D Gaussian representations from images presents a substantial challenge due to their discrete, non-structural, and higher-dimensional nature compared to implicit representations that only require decoding RGB and density. Additionally, the non-structural and explicit characteristics of 3D Gaussians further complicate the learning process. (see the first image of Figure [5]Figure 5 ‣ 3D representation. ‣ 4.6 Ablation Study ‣ 4 Experiments ‣ Triplane Meets Gaussian Splatting: Fast and Generalizable Single-View 3D Reconstruction with Transformers\")).\nConsequently, developing an effective method to unleash the potential of Gaussian Splatting for generalizable 3D learning remains a significant area for exploration.\n\nIn this work, we introduce _TGS_, a novel 3D reconstruction approach from single-view images, leveraging the strengths of Triplane and Gaussian Splatting.\nOur method employs a hybrid explicit-and-implicit 3D representation, facilitating fast and high-quality 3D reconstruction and novel view synthesis.\nWe diverge from traditional 3D representation methods by proposing a hybrid Triplane-Gaussian model, which marries an explicit point cloud with an implicit triplane field.\nThe explicit point cloud outlines the object’s rough geometry, while the implicit triplane field refines the geometry while encoding 3D Gaussian properties such as opacity and spherical harmonics.\nThis separation of position (explicit) and Gaussian properties (implicit) significantly enhances the quality of 3D reconstruction, while maintaining the efficiency of Gaussian Splatting.\nBased on such representation, our approach includes two networks for reconstructing the point cloud and triplane from the input image, respectively.\nWe employ a fully transformer-based architecture for both the point cloud and triplane networks, enabling the interaction of latent features with input image features through cross-attention.\nThis transformer design ensures scalability and supports large-scale, category-agnostic training, thereby enhancing the model’s generalizability to real-world objects.\nMoreover, we augment each 3D Gaussian with local image features by projecting explicit geometry onto the input image plane.\nOverall, the proposed approach allows for fast, high-resolution rendering and facilitates efficient end-to-end training of the entire pipeline.\n\nTo the best of our knowledge, this is the first study to achieve generalizable 3D reconstruction from single-view images using Gaussian Splatting, opening new possibilities in fast 3D content creation and rendering.\nOur extensive experiments on the Google Scanned Object (GSO) dataset \\[ [13])\\] demonstrate that our method surpasses existing baselines in both geometry reconstruction and novel-view synthesis. Owing to its feed-forward model and the hybrid representation, our approach achieves object reconstruction in a matter of seconds, significantly faster than prior methods.\nWe summarize our main contributions as follows:\n\n- •\n\n\nWe propose Triplane-Gaussian, a new hybrid representation that leverages both explicit and implicit representation for fast and high-quality single-view reconstruction.\n\n- •\n\n\nBy leveraging local image features for projection-aware conditioning in the transformer networks, we achieve greater consistency with the input observation.\n\n- •\n\n\nExperiments show that our approach outperforms state-of-the-art baselines in terms of reconstruction quality and speed.",
            "citations": null
          },
          "2 Related Works": {
            "content": "![Refer to caption]Figure 2: The overview of our framework. Given an image with its camera parameters, we first encode them into a set of latent feature tokens by leveraging a pre-trained ViT model. Our two transformer-based networks, point cloud decoder and triplane decoder, take initial positional embedding as input and project image tokens onto latent feature tokens of respective 3D representation via cross-attention.\nSubsequently, a point cloud and a triplane can be de-tokenized from the output of decoders, respectively.\nAfter the point cloud decoder, we adapt a point upsampling module \\[ [66]), [65])\\] with condition-aware projection to densify the point cloud.\nAdditionally, we utilize a geometry-aware encoding to project point cloud features into the initial positional embedding of triplane latent.\nFinally, 3D Gaussians are decoded by the point cloud, the triplane features and image features for novel view rendering.\n\n#### Single View 3D Reconstruction.\n\n3D reconstruction from single view image is an ill-posed problem that garnered substantial attention from many researchers, due to the lack of geometry cues from single view.\nMost studies learn strong 3D priors from 3D synthetic models \\[ [6])\\] or real scans \\[ [9])\\].\nPrevious works have constructed priors based on collections of 3D primitives using an encoder-decoder approach \\[ [67]), [38])\\].\nFor example, they utilize image encoder to encode visual information into compact latent features (e.g., vectors and volumes), and the 3D model can be decoded from the features for specific representation.\nHowever, these methods often are limited to specific category.\nAnd most of them focus on geometry reconstruction and have poor performance on texture.\nRecently, transformer architecture \\[ [56])\\] has shown its capacity and scalability in the field of computer vision \\[ [12]), [4]), [47]), [50])\\] and other areas \\[ [11]), [3])\\].\nGINA-3D \\[ [52])\\] and LRM \\[ [20])\\] propose a full transformer-based pipeline to decode a NeRF representation from triplane features.\nMCC \\[ [62])\\] also trains a transformer decoder to predict occupancy and color from RGB-D inputs.\nIn this work, we adopt the scalable transformer-based architecture to learn generalizable 3D representation from single image.\n\n#### 3D Generation conditioned on image.\n\nContrary to learning 3D geometry prior and reconstructing an object from image in a feed-forward manner, some recent works treat this task as a conditional generation. They aim to exploit techniques such as GAN \\[ [16])\\], diffusion model \\[ [72]), [37]), [24]), [8]), [69])\\] to sample a high 3D content from pre-trained distribution.\nPoint-E \\[ [41])\\] and Shap-E \\[ [23])\\] are trained on several million 3D models to generate point clouds and parameters of implicit function (e.g. neural radiance field).\nHowever, these 3D native generative models are limited due to lack of a substantial mount of high-quality 3D model datasets.\n\nInspired from success of 2D generative models (e.g. DALL-E \\[ [49])\\] and Stable Diffusion \\[ [51])\\]) with impressive and high-quality image generation, a large number of studies \\[ [45]), [28]), [7]), [36])\\] incorporate 2D diffusion and CLIP priors into per-shape optimization via various score distillation sampling strategy \\[ [45]), [57]), [60])\\], or with other monocular prior losses.\nMost off-the-shelf high-quality text-to-image diffusion models cannot perfect generate images at given novel view that plausibly constitute other views of the given object.\nAlternatively, some works explore view-conditioned diffusion to learn control mechanisms that manipulate the camera viewpoint in large-scale diffusion models \\[ [31])\\].\nHowever, these methods necessitate a time-consuming per-shape optimization for different 3D representations (i.e., NeRF, mesh, 3D Gaussian, SMPL human model) via differentiable rendering.\nSome other works improves the multi-view consistency across different novel views \\[ [54]), [32])\\], which directly enables NeRF optimization with pixel-wise loss with distillation, achieving impressive performance in few minutes.\nOne-2-3-45 \\[ [30])\\] proposes to combine the 2D generative models and mutli-view 3D reconstruction, leading to superiority on both quality and efficiency.\n\n#### Neural 3D Representation and Rendering.\n\nWith the recent advancement of neural networks, neural implicit representations \\[ [43]), [38]), [22])\\], especially neural radiance field (NeRF) \\[ [39])\\] with its variants \\[ [2]), [29]), [17]), [71])\\], have shown its promising performance in novel-view synthesis and 3D reconstruction, only using dense images via differentiable volume rendering.\nDespite many efforts dedicated to enhancing the rendering speed of neural implicit representations \\[ [40]), [18])\\], their efficiency still falls short when compared with point-based rendering \\[ [27]), [26])\\].\nCertain works enhance points with neural features and employ a UNet \\[ [1]), [48])\\] for fast or even real-time rendering, leveraging its advantages of fast GPU/CUDA-based rasterization.\nThese methods, relying on 2D CNN thus lacking 3D awareness, often occur over- or under-reconstruction in hard cases (e.g. featureless areas or thin structures).\nThe 3DGS \\[ [25])\\], as a special point-based rendering, stands out for its distinctive utilization of explicit representation and differential point-based splatting techniques, thereby facilitating real-time rendering at novel views.\nHowever, it’s difficult to directly regress 3D Gaussians from image for high-quality novel view synthesis.\nIn this paper, we leverage a hybrid 3D representation, facilitating fast and generalizable reconstruction and rendering.",
            "citations": null
          },
          "3 Method": {
            "content": "In the subsequent sections, we present our approach for 3D object reconstruction from single-view images.\nWe introduce a new hybrid 3D representation that combines explicit point cloud geometry and implicit triplane features,\nallowing for efficient rendering without compromising on quality (Section [3.1]Hybrid Triplane-Gaussian ‣ 3 Method ‣ Triplane Meets Gaussian Splatting: Fast and Generalizable Single-View 3D Reconstruction with Transformers\")).\nIn order to optimize the hybrid representation from a singe-view input, we first employ a transformer-based point cloud decoder to predict coarse points from image features\nand upsample the coarse points to a dense point cloud.\nSubsequently, a triplane decoder takes these points along with the image features and outputs the triplane features.\nFinally, the hybrid Triplane-Gaussian will encompass point clouds, triplane features, and image features to generate representative hybrid features for 3D Gaussian attributes decoding (Section [3.2]Reconstruction from Single-View Images ‣ 3 Method ‣ Triplane Meets Gaussian Splatting: Fast and Generalizable Single-View 3D Reconstruction with Transformers\")).\nBenefiting from differentiable splatting, we can train the full framework end-to-end on large-scale category-agnostic datasets efficiently (Section [3.3]Training ‣ 3 Method ‣ Triplane Meets Gaussian Splatting: Fast and Generalizable Single-View 3D Reconstruction with Transformers\")).\n\n### 3.1 Hybrid Triplane-Gaussian\n\nGaussian Splatting, while offering advantages such as high-quality rendering and speed, remains unexplored in its application to generalizable reconstruction settings.\nA preliminary approach might consider treating 3D Gaussians as an explicit point cloud enriched with specific attributes. One possibility involves adapting existing point cloud reconstruction or generation models \\[ [41]), [37])\\] to include additional 3D Gaussian attributes besides point positions.\nPursuing this concept, we initially developed a 3D Gaussian reconstruction model based on a transformer architecture aimed at directly predicting 3D Gaussians.\nHowever, as shown in the experiment in Section [4.6]Ablation Study ‣ 4 Experiments ‣ Triplane Meets Gaussian Splatting: Fast and Generalizable Single-View 3D Reconstruction with Transformers\"), it fails to generate satisfied 3D objects from a single image.\nThis shortfall might be attributed to the discrete, non-structural, and high-dimensional nature of 3D Gaussians, which complicates the learning process.\nIn response, we introduce _Triplane-Gaussian_, a new hybrid 3D representation that merges the benefits of both triplane and point cloud approaches for 3D Gaussian representation.\nThis hybrid model offers fast rendering, high quality, and generalizability, as depicted in Figure [5]Figure 5 ‣ 3D representation. ‣ 4.6 Ablation Study ‣ 4 Experiments ‣ Triplane Meets Gaussian Splatting: Fast and Generalizable Single-View 3D Reconstruction with Transformers\").\n\nThe hybrid representation includes a point cloud P∈RN×3𝑃superscript𝑅𝑁3P\\\\in R^{N\\\\times 3} which provides explicit geometry, and a triplane T∈R3×C×H×W𝑇superscript𝑅3𝐶𝐻𝑊T\\\\in R^{3\\\\times C\\\\times H\\\\times W} which encodes an implicit feature field, where 3D Gaussian attributes can be decoded.\nThe triplane T𝑇T comprises three axis-aligned orthogonal feature planes {Txy,Txz,Tyz}subscript𝑇xysubscript𝑇xzsubscript𝑇yz\\\\{T\\_{\\\\mathrm{xy}},T\\_{\\\\mathrm{xz}},T\\_{\\\\mathrm{yz}}\\\\}.\nFor any position 𝐱𝐱\\\\mathbf{x}, we can query the corresponding feature vector from triplane by projecting it onto axis-aligned feature planes, and concatenate three trilinear interpolated features as the final feature ft=i​n​t​e​r​p​(Txy,pxy)⊕i​n​t​e​r​p​(Txz,pxz)⊕i​n​t​e​r​p​(Tyz,pyz)subscript𝑓𝑡direct-sum𝑖𝑛𝑡𝑒𝑟𝑝subscript𝑇xysubscript𝑝xy𝑖𝑛𝑡𝑒𝑟𝑝subscript𝑇xzsubscript𝑝xz𝑖𝑛𝑡𝑒𝑟𝑝subscript𝑇yzsubscript𝑝yzf\\_{t}=interp(T\\_{\\\\mathrm{xy}},p\\_{\\\\mathrm{xy}})\\\\oplus interp(T\\_{\\\\mathrm{xz}},p\\_{\\\\mathrm{xz}})\\\\oplus interp(T\\_{\\\\mathrm{yz}},p\\_{\\\\mathrm{yz}}), where i​n​t​e​r​p𝑖𝑛𝑡𝑒𝑟𝑝interp and ⊕direct-sum\\\\oplus denote the trilinear interpolation and concatenation operation, and p𝑝p denotes the projected position on each plane.\n\n#### 3D Gaussian Decoder.\n\nFor a given position 𝐱∈R3𝐱superscript𝑅3\\\\mathbf{x}\\\\in R^{3} from point cloud P𝑃P, we query feature f𝑓f from the triplane and adopt an MLP ϕgsubscriptitalic-ϕ𝑔\\\\phi\\_{g} to decode the attributes of the 3D Gaussians derived from the point cloud.\nThe 3D Gaussians’ attributes include opacity α𝛼\\\\alpha, anisotropic covariance (represented by a scale s𝑠s and rotation q𝑞q) and spherical harmonics (SH) coefficients s​h𝑠ℎsh\\[ [25])\\]:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n|  | (Δ​𝐱′,α,s,q,s​h)=ϕg​(𝐱,f)Δsuperscript𝐱′𝛼𝑠𝑞𝑠ℎsubscriptitalic-ϕ𝑔𝐱𝑓\\\\displaystyle(\\\\Delta\\\\mathbf{x}^{\\\\prime},\\\\alpha,s,q,sh)=\\\\phi\\_{g}(\\\\mathbf{x},f) |  | (1) |\n\nSince surface points are not always the best choice for the 3D Gaussian representation, we additionally predict a small offset Δ​𝐱Δ𝐱\\\\Delta\\\\mathbf{x} for the position, and the final position is computed by 𝐱=𝐱+Δ​𝐱𝐱𝐱Δ𝐱\\\\mathbf{x}=\\\\mathbf{x}+\\\\Delta\\\\mathbf{x}.\n\nRegarding the single-view 3D reconstruction task we focus on in this paper, we additionally augmented the queried triplane features with projected image features as in PC2\\[ [37])\\] to fully utilize the local features from the input image.\nSpecifically, we concatenate the triplane feature ftsubscript𝑓𝑡f\\_{t} with projected local features flsubscript𝑓𝑙f\\_{l} from explicit geometry as f𝑓f in Equation [1]Equation 1 ‣ 3D Gaussian Decoder. ‣ 3.1 Hybrid Triplane-Gaussian ‣ 3 Method ‣ Triplane Meets Gaussian Splatting: Fast and Generalizable Single-View 3D Reconstruction with Transformers\").\nGiven an input camera pose π𝜋\\\\pi and a point cloud P𝑃P, the local projection feature can be calculated by the projection function 𝒫𝒫\\\\mathcal{P}, where fl=𝒫​(π,P)subscript𝑓𝑙𝒫𝜋𝑃f\\_{l}=\\\\mathcal{P}(\\\\pi,P).\nFollowing \\[ [37])\\], we consider the self-occlusion problem of the point cloud and implement the projection by point rasterization.\nThe local features include the RGB color, DINOv2 \\[ [42])\\] feature, mask, and 2-dimensional distance transform corresponding to the mask region.\nIn this way, the projection-aware condition can improve the texture quality under the input viewing angle.\n\n#### Rendering.\n\nBased on such representation, we can perform image rendering by utilizing the efficient Gaussian Splatting rendering approach \\[ [25])\\] at any novel viewpoint. It’s a differentiable tile-based rasterization that allows fast α𝛼\\\\alpha-blending of anisotropic splats and fast backward pass by tracking accumulated α𝛼\\\\alpha values, ensuring that our pipeline can be trained end-to-end more efficiently with higher resolution images and less GPU memory cost.\n\n### 3.2 Reconstruction from Single-View Images\n\nIn this section, we detail the process of learning the Triplane-Gaussian representation from a single image. Drawing inspiration from recent breakthroughs in 3D reconstruction using transformers \\[ [20])\\], our approach employs two transformer-based decoders, each tailored for reconstructing a point cloud P𝑃P and a triplane F𝐹F from input images.\nThe adoption of a scalable transformer architecture substantially enhances the model’s capability and generalization potential.\nFeatures from the input image, along with camera features, are integrated into the transformer blocks of both the point and triplane decoders via cross-attention\nMoreover, we harness local features projected from the input image to enhance both the point cloud up-sampling process and the 3D Gaussian decoder. This strategy significantly improves initial point cloud reconstruction and facilitates more accurate novel-view synthesis.\n\n#### Image Encoder.\n\nWe first leverage a pre-trained ViT-based model \\[ [12])\\] (e.g., DINOv2 \\[ [42])\\]) to obtain patch-wise feature tokens from the input image.\nIn order to better utilize camera information in our pipeline, we implement an adaptive layer norm (adaLN) to modulate the DINOv2 features with the camera features, which is similar to \\[ [20]), [62])\\].\nSpecifically, we project the camera parameters, which are the concatenation of flattened camera extrinsic matrix T∈R4×4𝑇superscript𝑅44T\\\\in R^{4\\\\times 4} and normalized intrinsic matrix K∈R3×3𝐾superscript𝑅33K\\\\in R^{3\\\\times 3}, to high dimensional camera features fc∈R25subscript𝑓𝑐superscript𝑅25f\\_{c}\\\\in R^{25} aligned with the DINOv2 feature dimension.\nFinally, we implement an MLP to predict the scale and shift based on the camera features after each normalization layer.\nThese camera modulation layers are trained to make image features aware of the observation viewpoint, thereby better guiding both the point cloud network and the triplane network.\n\n#### Transformer Backbone.\n\nIn our framework, we use a set of feature tokens {fi}psubscriptsubscript𝑓𝑖𝑝\\\\{f\\_{i}\\\\}\\_{p} and {fi}tsubscriptsubscript𝑓𝑖𝑡\\\\{f\\_{i}\\\\}\\_{t} for the latent features of two different 3D representations, i.e., points and triplane, respectively.\nThe latent tokens are initialized from learnable positional embeddings, and fed to the transformer blocks.\nSimilar to other transformer architecture designs \\[ [21])\\], each transformer block comprises a self-attention layer, a cross-attention layer, and a feed-forward layer.\nThe viewpoint-augmented image tokens guide the two decoders via cross-attention, respectively.\n\n#### Point Cloud Decoder.\n\nThe point cloud decoder provides the coarse geometry of the object,\nwhere 3D Gaussians can be produced based on the coordinates of the points.\nWe employ a 6-layer transformer backbone to decode a point cloud using image conditions\nfrom a fixed number of learnable positional embeddings,\ni.e., point cloud tokens.\nWe treat each latent token as a point, which is similar to Point-E \\[ [41])\\].\nHowever, our approach operates in a feed-forward manner, where the point cloud can be predicted directly from the final token,\nas opposed to the diffusion process employed in Point-E \\[ [41])\\].\nDue to limited computation and memory resources,\nwe only decode a coarse point cloud with 2048 points in this step.\n\n#### Point Upsampling with Projection-Aware Conditioning.\n\nSince the quality of novel view synthesis from Gaussian Splatting is highly influenced by the number of Gaussians,\nit’s not enough to generate 3D Gaussians from such a low-resolution point cloud.\nTherefore, we adopt\na lifting module with two-step Snowflake point deconvolution (SPD) \\[ [66]), [65])\\] to\ndensify the point clouds from 2048 points to 16384 points.\nSnowflake utilizes a global shape code extracted from\nthe input point cloud along with point features, to predict\nthe point displacements for the upsampled point cloud.\nIn order to reconstruct the detailed geometry guided by the input image,\nwe integrate local image features into the shape code of SPD from the given camera pose\nby Projection-Aware Conditioning \\[ [37])\\].\nSuch projection enables the generation of high-resolution point clouds that are well-aligned with the input image.\n\n#### Triplane Decoder with Geometry-Aware Encoding.\n\nThe triplane decoder outputs the implicit feature field based on the image and initial point cloud, from which 3D Gaussian properties will be decoded by position queries.\nIt shares a similar transformer architecture to decode the features from learnable positional embedding by image tokens but with deeper layers (we employ 10 layers for the triplane decoder).\nWe also encode the point cloud into the initial learnable positional embeddings,\nresulting in better geometry awareness.\nMore specifically, the points are also augmented with projection features from the input image as in point cloud upsampling.\nThe feature-rich points are then fed into a shallow PointNet \\[ [46])\\] with local pooling \\[ [44])\\], and then we perform an orthographic projection onto the three axis-aligned planes.\nThe features projected to the same token are average-pooled and added with the learnable positional embedding.\n\n![Refer to caption]Figure 3: Qualitative comparisons of novel view synthesis from reconstructed object between our method and other baselines on the GSO dataset. Our approach achieves both quality and consistency across different novel views.\n\n### 3.3 Training\n\nWe train the full pipeline by using 2D rendering loss along with 3D point cloud supervision:\n\n|     |     |     |     |     |\n| --- | --- | --- | --- | --- |\n|  | ℒℒ\\\\displaystyle\\\\mathcal{L} | =λc​ℒCD+λe​ℒEMD+absentsubscript𝜆𝑐subscriptℒCDlimit-fromsubscript𝜆𝑒subscriptℒEMD\\\\displaystyle=\\\\lambda\\_{c}\\\\mathcal{L}\\_{\\\\text{CD}}+\\\\lambda\\_{e}\\\\mathcal{L}\\_{\\\\text{EMD}}+ |  | (2) |\n|  |  | 1N​∑i=1N(ℒMSE+λm​ℒMASK+λs​ℒSSIM+λl​ℒLPIPS)1𝑁superscriptsubscript𝑖1𝑁subscriptℒMSEsubscript𝜆𝑚subscriptℒMASKsubscript𝜆𝑠subscriptℒSSIMsubscript𝜆𝑙subscriptℒLPIPS\\\\displaystyle\\\\frac{1}{N}\\\\sum\\_{i=1}^{N}(\\\\mathcal{L}\\_{\\\\text{MSE}}+\\\\lambda\\_{m}\\\\mathcal{L}\\_{\\\\text{MASK}}+\\\\lambda\\_{s}\\\\mathcal{L}\\_{\\\\text{SSIM}}+\\\\lambda\\_{l}\\\\mathcal{L}\\_{\\\\text{LPIPS}}) |  | (3) |\n\nwhere ℒCDsubscriptℒCD\\\\mathcal{L}\\_{\\\\mathrm{CD}} is the Chamfer Distance (CD) and ℒEMDsubscriptℒEMD\\\\mathcal{L}\\_{\\\\mathrm{EMD}} is the Earth Mover’s Distance (EMD).\nFor training the triplane decoder and 3D Gaussian decoder, we apply the rendering losses, including a pixel-wise MSE loss ℒMSE=‖I−I^‖22subscriptℒMSEsubscriptsuperscriptnorm𝐼^𝐼22\\\\mathcal{L}\\_{\\\\text{MSE}}=\\|\\|I-\\\\hat{I}\\|\\|^{2}\\_{2}, a mask loss ℒMASK=‖M−M^‖22subscriptℒMASKsubscriptsuperscriptnorm𝑀^𝑀22\\\\mathcal{L}\\_{\\\\text{MASK}}=\\|\\|M-\\\\hat{M}\\|\\|^{2}\\_{2}, a SSIM loss ℒSSIMsubscriptℒSSIM\\\\mathcal{L}\\_{\\\\text{SSIM}}\\[ [59])\\] and a perceptual loss ℒLPIPSsubscriptℒLPIPS\\\\mathcal{L}\\_{\\\\text{LPIPS}}\\[ [70])\\].",
            "citations": null
          },
          "4 Experiments": {
            "content": "In this section, we first give the implementation details, comparison baselines, and evaluation protocols.\nThen we conduct two types of experiments to evaluate our method and other baseline methods for both quantitative and qualitative performance on geometry reconstruction and novel view synthesis.\n\n### 4.1 Implementation Details\n\nWe utilize a pre-trained DINOv2 \\[ [42])\\] as our image encoder, which generates 768-dimension feature tokens with a patch size of 14.\nThe point decoder is a 6-layer transformer with hidden dimension 512 and the triplane is a 10-layer transformer with hidden dimension 512.\nThe positional embeddings of the point decoder consist of 2048 tokens, each with 512 dimensions, corresponding to 2048 points.\nThe positional embeddings of the triplane decoder comprise three 32×32323232\\\\times 32 tokens, each with 512 dimensions, representing three axis-aligned planes.\nTo ensure better convergence during training, we divide the training process into two stages.\nInitially, we train the point decoder using λc=10subscript𝜆𝑐10\\\\lambda\\_{c}=10 and λe=10subscript𝜆𝑒10\\\\lambda\\_{e}=10 only with CD loss and EMD loss, enabling the network to deliver high-quality geometry.\nSubsequently, we train the triplane decoder and the Gaussian decoder based on the input image and initial points, with the point decoder frozen.\nWe set the weights of the losses with λm=1,λs=1,λl=2,λc=10,λe=0formulae-sequencesubscript𝜆𝑚1formulae-sequencesubscript𝜆𝑠1formulae-sequencesubscript𝜆𝑙2formulae-sequencesubscript𝜆𝑐10subscript𝜆𝑒0\\\\lambda\\_{m}=1,\\\\lambda\\_{s}=1,\\\\lambda\\_{l}=2,\\\\lambda\\_{c}=10,\\\\lambda\\_{e}=0 in this stage.\n\n![Refer to caption]Figure 4: Qualitative comparisons of geometry reconstruction from a single image between our method and other baselines on the GSO dataset. The mesh of Shap-E and One-2-3-45 are extracted from implicit fields by Marching Cubes \\[ [35])\\], while the mesh of Point-E and ours are reconstructed from point cloud using a pre-trained regression-based model provided by \\[ [41])\\].\n\n### 4.2 Baselines, Dataset, and Metrics\n\n#### Baselines.\n\nWe compare our method with the previous state-of-the-art single-image reconstruction and generation methods.\nThere are three kinds of them: (1) native 3D generative models, including Point-E \\[ [41])\\] and Shap-E \\[ [23])\\]; (2) 2D diffusion model, i.e., Zero-1-2-3 \\[ [31])\\] and (3) feed-forward model based on 2D diffusion model output, i.e., One-2-3-45 \\[ [30])\\].\nPoint-E \\[ [41])\\] and Shap-E \\[ [23])\\] are trained on a large-scale internal 3D dataset to produce point cloud and implicit representation (NeRF) from single images. Zero-1-2-3 \\[ [31])\\] is a 2D generative model to utilize view-conditioned diffusion for novel view synthesis.\nOne-2-3-45 \\[ [30])\\] trains a robust multi-view reconstruction model which takes multi-view images generated from a 2D diffusion model (e.g., Zero-1-2-3). It directly builds an SDF field by SparseNeuS \\[ [34])\\], achieving state-of-the-art performance.\n\n#### Dataset.\n\nFollowing One-2-3-45 \\[ [30])\\], we train our model on the Objaverse-LVIS dataset \\[ [10])\\], which contains 46K 3D models in 1,156 categories.\nWe use Blender to render ground-truth RGB and depth with a circle path for an object.\nFor Evaluation, we adopt the Google Scanned Objects (GSO) dataset \\[ [13])\\], which includes a wide variety of high-quality scanned household items, to evaluate the performance of our method and other baselines.\nWe randomly choose 100 shapes and render a single image per shape for evaluation.\n\n#### Metrics.\n\nFollowing prior works, we adopt commonly used reconstruction metrics, including Chamfer Distance (CD) and Volume IoU, between ground truth and reconstruction, to evaluate the quality of geometry reconstruction from single-view images.\nFurthermore, we also adopt PSNR, SSIM, and LPIPS metrics, which cover different aspects of image similarity, to evaluate the novel view synthesis performance.\n\n### 4.3 Single View Reconstruction\n\nWe conduct the evaluation quality of geometry reconstruction from single-view images with other baselines, including Point-E \\[ [41])\\], Shap-E \\[ [23])\\] and One-2-3-45 \\[ [30])\\].\nTable [1]Table 1 ‣ 4.3 Single View Reconstruction ‣ 4 Experiments ‣ Triplane Meets Gaussian Splatting: Fast and Generalizable Single-View 3D Reconstruction with Transformers\") demonstrates the quantitative results on CD and Volume IoU, and Figure [4]Figure 4 ‣ 4.1 Implementation Details ‣ 4 Experiments ‣ Triplane Meets Gaussian Splatting: Fast and Generalizable Single-View 3D Reconstruction with Transformers\") illustrates some visual comparisons.\nPoint-E tends to produce holes in the reconstructed meshes due to the sparsity of the generated point cloud.\nMeanwhile, Shap-E is susceptible to collapsing during the generation process, resulting in an unpredictable outcome.\nThe geometric output generated by One-2-3-4-5 \\[ [30])\\] is characterized by a coarse representation, lacking intricate details.\nIn contrast, our method reconstructs geometry based on the explicit point clouds,\nwhich can preserve finer details and maintain consistency with the ground truth.\n\n|  | CD ↓↓\\\\downarrow | IoU ↑↑\\\\uparrow | Time (s) ↓↓\\\\downarrow |\n| --- | --- | --- | --- |\n| Point-E | 68.56 | 0.181 | 78 |\n| Shape-E | 79.84 | 0.218 | 27 |\n| One-2-3-45 | 75.56 | 0.338 | 40 |\n| Ours | 21.04 | 0.401 | 0.14 |\n\nTable 1: Quantitative Comparison for single view 3D reconstruction on the GSO dataset,\nin terms of Chamfer Distance ×10−3absentsuperscript103\\\\times 10^{-3}, Volume IoU and runtime efficiency.\n\n|  | PSNR ↑↑\\\\uparrow | SSIM ↑↑\\\\uparrow | LPIPS ↓↓\\\\downarrow | Time ↓↓\\\\downarrow |\n| --- | --- | --- | --- | --- |\n| One-2-3-45 | 15.55 | 0.76 | 0.25 | 14 |\n| Zero-1-2-3 | 17.57 | 0.78 | 0.19 | 1.70 |\n| Ours | 23.15 | 0.87 | 0.13 | 0.003 |\n\nTable 2: Quantitative comparison on novel-view synthesis from single images on the GSO dataset, in terms of PSNR, SSIM, LPIPS, and runtime efficiency.\n\n### 4.4 Novel View Synthesis\n\nIn this subsection, we evaluate the quality of novel view synthesis in comparison with baselines, including One-2345 and Zero-1-2-3. The quantitative and qualitative results are shown in Table [2]Table 2 ‣ 4.3 Single View Reconstruction ‣ 4 Experiments ‣ Triplane Meets Gaussian Splatting: Fast and Generalizable Single-View 3D Reconstruction with Transformers\") and Figure [3]Figure 3 ‣ Triplane Decoder with Geometry-Aware Encoding. ‣ 3.2 Reconstruction from Single-View Images ‣ 3 Method ‣ Triplane Meets Gaussian Splatting: Fast and Generalizable Single-View 3D Reconstruction with Transformers\"), respectively.\nWhile Zero-1-2-3 can generate plausible results from a novel viewpoint, it doesn’t ensure consistency between different views, and can even yield completely unreasonable results.\nFor example, it may generate two different instances of Spider-Man and shoes when the input only contains one of each.\nAlthough One-2-3-45 is primarily designed for geometry reconstruction, we utilize it to render the novel view image from its generated feature volume.\nDue to its inherent geometry constraint in 3D volume, the rendering images are consistent across different views.\nHowever, its reliance on images generated by Zero-1-2-3 limits its ability to produce high-quality novel view synthesis.\nIn contrast, Our method delivers both high quality and consistency, thereby attaining superior performance.\nAdditionally, by leveraging the transformer architecture and local feature projection, our model exhibits robust generalization to unseen objects while preserving intricate textures.\n\n|  | PSNR ↑↑\\\\uparrow | SSIM ↑↑\\\\uparrow | LPIPS ↓↓\\\\downarrow |\n| --- | --- | --- | --- |\n| 3DG | 18.56 | 0.80 | 0.20 |\n| Triplane-NeRF | 21.85 | 0.84 | 0.15 |\n| Triplane-Gaussian | 23.15 | 0.87 | 0.13 |\n\nTable 3: Quantitative comparison between different representations for novel view synthesis on GSO.\n\n|  | CD ↓↓\\\\downarrow | IoU ↑↑\\\\uparrow |\n| --- | --- | --- |\n| PCL tokens | 22.16 | 0.385 |\n| Global image feature | 22.22 | 0.401 |\n| Projection-aware condition | 21.04 | 0.401 |\n\nTable 4: Quantitative Comparison of different conditions for point cloud up-sampling in geometry reconstruction, in terms of Chamfer Distance ×10−3absentsuperscript103\\\\times 10^{-3} and Volume IoU.\n\n### 4.5 Runtime Efficiency\n\nWe also evaluate the runtime efficiency of our method in comparison with other baseline approaches.\nTable [1]Table 1 ‣ 4.3 Single View Reconstruction ‣ 4 Experiments ‣ Triplane Meets Gaussian Splatting: Fast and Generalizable Single-View 3D Reconstruction with Transformers\") and Table [2]Table 2 ‣ 4.3 Single View Reconstruction ‣ 4 Experiments ‣ Triplane Meets Gaussian Splatting: Fast and Generalizable Single-View 3D Reconstruction with Transformers\") demonstrate the runtime of reconstruction and rendering of each baseline, respectively.\nWe evaluate the runtime of Zero-1-2-3’s diffusion sampling process due to its lack of rendering process from 3D representation.\nWe evaluate the volume rendering of One-2-3-45 from its generated implicit feature volume rather than the generated mesh.\nWe can find that our method has achieved significant improvements in speed for both reconstruction and rendering processes compared to other baselines, benefiting from feed-forward fashion and efficient rasterization.\n\n### 4.6 Ablation Study\n\n#### 3D representation.\n\nTo evaluate the effectiveness of the design of our Triplane-Gaussian design, we conducted an experiment that compared it with two ablation settings, including (1) native generalizable 3D Gaussians (3DG) and (2) Triplane-NeRF.\nTable [3]Table 3 ‣ 4.4 Novel View Synthesis ‣ 4 Experiments ‣ Triplane Meets Gaussian Splatting: Fast and Generalizable Single-View 3D Reconstruction with Transformers\") and Figure [5]Figure 5 ‣ 3D representation. ‣ 4.6 Ablation Study ‣ 4 Experiments ‣ Triplane Meets Gaussian Splatting: Fast and Generalizable Single-View 3D Reconstruction with Transformers\") present the quantitative and qualitative comparisons among these methods.\nThe native generalizable 3D Gaussians, which are directly decoded from latent tokens like points, exhibit the poorest performance according to all metrics.\nOur Triplane-Gaussian, leveraging the projection-aware condition with explicit geometry, excels in producing more detailed texture compared to Triplane-NeRF, as illustrated in the red box of Figure [5]Figure 5 ‣ 3D representation. ‣ 4.6 Ablation Study ‣ 4 Experiments ‣ Triplane Meets Gaussian Splatting: Fast and Generalizable Single-View 3D Reconstruction with Transformers\"), and achieves the best quantitative results.\nFurthermore, once the 3D Gaussians are decoded, our rendering process proves to be faster than that of Triplane-NeRF.\nThis efficiency arises because our method doesn’t require decoding features from the triplane for each sampling point along the ray marching path.\nAs the rendering resolution increases, the superiority of Triplane-Gaussian becomes increasingly evident.\n\n|  | P.C. | G.E. | PSNR ↑↑\\\\uparrow | SSIM ↑↑\\\\uparrow | LPIPS ↓↓\\\\downarrow |\n| --- | --- | --- | --- | --- | --- |\n| a | ✗ | ✗ | 22.04 | 0.85 | 0.16 |\n| b | ✓ | ✗ | 22.47 | 0.86 | 0.15 |\n| c | ✗ | ✓ | 22.76 | 0.86 | 0.14 |\n| d | ✓ | ✓ | 23.15 | 0.87 | 0.13 |\n\nTable 5: Quantitative effect of projection-aware condition and geometry-aware encoding to novel view synthesis.![Refer to caption]Figure 5: Qualitative comparison with 3DG and Triplane-NeRF. More accurate recovery of detailed textures by our hybrid representation is highlighted within the red box. ![Refer to caption]Figure 6: Qualitative effect of projection-aware condition and geometry-aware encoding. The (a-d) are corresponding with (a-d) in Table [5]Table 5 ‣ 3D representation. ‣ 4.6 Ablation Study ‣ 4 Experiments ‣ Triplane Meets Gaussian Splatting: Fast and Generalizable Single-View 3D Reconstruction with Transformers\").\n\n—\n\n#### Projection-aware condition.\n\nWe evaluate the effect of projection-aware condition on both point cloud reconstruction and novel view synthesis.\nFirstly, to investigate the impact of different shape codes\nwithin the point upsampling module, we conduct experiments with two ablation shape code settings, including (1) the Point CLoud (PCL) tokens from the point cloud decoder and (2) global image features from DINOv2.\nAs shown in Table [4]Table 4 ‣ 4.4 Novel View Synthesis ‣ 4 Experiments ‣ Triplane Meets Gaussian Splatting: Fast and Generalizable Single-View 3D Reconstruction with Transformers\"), image-based shape codes achieve higher IoU compared to merely PCL tokens,\nwhich demonstrates the importance of incorporating structural information from the visual modality. Moreover, the projection-aware condition outperforms the other two code methods in terms of CD, suggesting that the local patterns of the image are effectively transferred to the structure of the point cloud.\n\nWe also assess the impact of the projection-aware condition on the 3D Gaussian Decoder for novel view synthesis. Table [5]Table 5 ‣ 3D representation. ‣ 4.6 Ablation Study ‣ 4 Experiments ‣ Triplane Meets Gaussian Splatting: Fast and Generalizable Single-View 3D Reconstruction with Transformers\") demonstrates that using projection-aware condition (P.C.) improves the quality of novel view synthesis across all metrics.\nIn figure [6]Figure 6 ‣ 3D representation. ‣ 4.6 Ablation Study ‣ 4 Experiments ‣ Triplane Meets Gaussian Splatting: Fast and Generalizable Single-View 3D Reconstruction with Transformers\"), two examples illustrate its visual effects.\nThe use of P.C. (Figure [6]Figure 6 ‣ 3D representation. ‣ 4.6 Ablation Study ‣ 4 Experiments ‣ Triplane Meets Gaussian Splatting: Fast and Generalizable Single-View 3D Reconstruction with Transformers\") (b) and (d)) significantly enhances the rendering image with sharper and more detailed texture on the same side as the input view. For example, in the first row, the left image of the shoe, and in the second row, the complex checkered texture of the coverlet.\n\n#### Geometry-aware encoding.\n\nWhile the projection-aware condition improves rendering quality on the same side as the input view, achieving good texture on the backside remains challenging (see the first row of Figure [6]Figure 6 ‣ 3D representation. ‣ 4.6 Ablation Study ‣ 4 Experiments ‣ Triplane Meets Gaussian Splatting: Fast and Generalizable Single-View 3D Reconstruction with Transformers\") (b)).\nIntroducing geometry-aware encoding (G.E.) enhances texture results, as evident in Figure [6]Figure 6 ‣ 3D representation. ‣ 4.6 Ablation Study ‣ 4 Experiments ‣ Triplane Meets Gaussian Splatting: Fast and Generalizable Single-View 3D Reconstruction with Transformers\") (c) and (d), particularly on the backside (right image of the shoe).\nGeometry-aware encoding enables the triplane decoder to predict backside texture with a shape prior, considering that shoes often have a similar texture on both sides.\nSince our point cloud decoder and triplane decoder are trained separately, the implicit field is sometimes not well-aligned with the explicit point cloud for complex geometry in the absence of geometry-aware encoding. This leads to blurry and non-sharp rendering results, as observed in the last row of Figure [6]Figure 6 ‣ 3D representation. ‣ 4.6 Ablation Study ‣ 4 Experiments ‣ Triplane Meets Gaussian Splatting: Fast and Generalizable Single-View 3D Reconstruction with Transformers\") (a) and (b). The geometry-aware encoding enhances the alignment between them, resulting in high-quality novel view synthesis.\nTable [5]Table 5 ‣ 3D representation. ‣ 4.6 Ablation Study ‣ 4 Experiments ‣ Triplane Meets Gaussian Splatting: Fast and Generalizable Single-View 3D Reconstruction with Transformers\") also demonstrates the quantitative improvement achieved by geometry-aware encoding in novel view synthesis results.\n\n### 4.7 Limitations\n\nThe rendering quality of the 3D Gaussians largely depends on the initial geometry. If the predicted point cloud deviates severely from the ground truth, it becomes challenging for the 3D Gaussians to recover the missing regions.\nAdditionally, since our model is not a probabilistic model, the backside tends to be blurry.\nOur model also relies on the camera parameters, which will restrict its applications.",
            "citations": null
          },
          "5 Conclusion": {
            "content": "In this paper, we present _TGS_, a new framework for 3D reconstruction from a single image with only a feed-forward inference.\nWhen presented with an image of an object, our approach constructs a hybrid Triplane-Gaussian representation using two transformer decoders - a point cloud decoder and a triplane decoder.\nThis is followed by a 3D Gaussian decoder to generate Gaussian properties, e.g. opacity and spherical harmonics.\nTo improve the consistency with the input observation, we further augment the generation process of these two representations by the application of projection-aware conditioning and geometry-aware encoding.\nExperiment results demonstrate that our method not only achieves high-quality geometry reconstruction and novel view synthesis, but also maintains a fast reconstruction and rendering speed.",
            "citations": null
          }
        },
        "abstract": "Recent advancements in 3D reconstruction from single images have been driven\nby the evolution of generative models. Prominent among these are methods based\non Score Distillation Sampling (SDS) and the adaptation of diffusion models in\nthe 3D domain. Despite their progress, these techniques often face limitations\ndue to slow optimization or rendering processes, leading to extensive training\nand optimization times. In this paper, we introduce a novel approach for\nsingle-view reconstruction that efficiently generates a 3D model from a single\nimage via feed-forward inference. Our method utilizes two transformer-based\nnetworks, namely a point decoder and a triplane decoder, to reconstruct 3D\nobjects using a hybrid Triplane-Gaussian intermediate representation. This\nhybrid representation strikes a balance, achieving a faster rendering speed\ncompared to implicit representations while simultaneously delivering superior\nrendering quality than explicit representations. The point decoder is designed\nfor generating point clouds from single images, offering an explicit\nrepresentation which is then utilized by the triplane decoder to query Gaussian\nfeatures for each point. This design choice addresses the challenges associated\nwith directly regressing explicit 3D Gaussian attributes characterized by their\nnon-structural nature. Subsequently, the 3D Gaussians are decoded by an MLP to\nenable rapid rendering through splatting. Both decoders are built upon a\nscalable, transformer-based architecture and have been efficiently trained on\nlarge-scale 3D datasets. The evaluations conducted on both synthetic datasets\nand real-world images demonstrate that our method not only achieves higher\nquality but also ensures a faster runtime in comparison to previous\nstate-of-the-art techniques. Please see our project page at\nhttps://zouzx.github.io/TriplaneGaussian/."
      }
    },
    "key_map": {
      "2303.13873": "bib.bib9",
      "1812.02822": "bib.bib11",
      "2403.06738": "bib.bib12",
      "2212.08051": "bib.bib15",
      "2210.04628": "bib.bib102",
      "1610.07584": "bib.bib103",
      "2401.04099": "bib.bib105",
      "2404.07191": "bib.bib106",
      "2201.10326": "bib.bib107",
      "1906.12320": "bib.bib108",
      "2403.14621": "bib.bib109",
      "2404.10772": "bib.bib110",
      "2212.02500": "bib.bib111",
      "2210.06978": "bib.bib112",
      "2205.13914": "bib.bib113",
      "2301.11445": "bib.bib114",
      "2302.05543": "bib.bib115",
      "2208.15001": "bib.bib116",
      "1801.03924": "bib.bib117",
      "2305.04461": "bib.bib118",
      "2206.12055": "bib.bib119",
      "2104.03670": "bib.bib120",
      "2312.09147": "bib.bib121"
    }
  }
}